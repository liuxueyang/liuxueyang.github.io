<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>NFA2DFA &middot; liuxueyang</title>

  
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/highlight/sunburst.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://liuxueyang.github.io/touch-icon-144-precomposed.png">
  <link href="http://liuxueyang.github.io/favicon.png" rel="icon">

  
  
  
  

  <meta name="description" content="This is my Notes">
  <meta name="keywords" content="Notes,Diary">
  
</head>
<body class="theme-base-08">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
        <img src="https://www.gravatar.com/avatar/8c0cbc14aa80dd620f186fcb50bbcab1?s=200"
             alt="gravatar" title="liuxueyang">
      
      <h1>liuxueyang</h1>
      <p class="lead">THE LAST ONE.</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="http://liuxueyang.github.io/">Blog</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="http://github.com/liuxueyang"><i class="fa fa-github-square fa-3x"></i></a>
      
      
      
      
      
      
      
      
      </li>
    </ul>

    

    <p>Copyright &copy; 2017 <a href="http://liuxueyang.github.io/license/">License</a><br/>
       Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>
  </div>
</div>


<div class="content container">
  <div class="post">
    <h1 class="post-title">NFA2DFA</h1>
    <span class="post-date">May 28, 2014 &middot; 8 minute read &middot; <a href="http://liuxueyang.github.io/blog/2014/05/28/nfa2dfa/#disqus_thread">Comments</a>
    </span>
    <p>input:
number of symbols
symbol set(each space between two symbol)
number of states(state number starts from 1 to n by default)
start state number
number of accept states
accept states set
state transfer table (epsilon transfer is at column one and if there are several epsilon transfers, seperate them with a comma without spaces)
The following file is the input file.</p>

<pre><code class="language-text">	NFA2DFA.txt

	2
	a b
	4
	1
	1
	3
	3 2 1
	-1 1 -1
	-1 3 4
	-1 -1 3

</code></pre>

<p>we input a integer N by str.txt file. then we generate accepted strings by DFA and NFA whose length is no more than N. Then compare those strings generated by NFA and DFA are all the same. The output is in str_out.txt</p>

<p>The following program is the main program.</p>

<pre><code class="language-c++">
/*
 * =====================================================================================
 *       Filename : NFA2DFA.cpp
 *    Description : 
 *    Version     : 0.1
 *        Created : 05/13/14 20:43
 *         Author : Liu Xue Yang (LXY), liuxueyang457@163.com
 *         Motto  : How about today?
 * =====================================================================================
 */
#include &lt;cstdio&gt;
#include &lt;map&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;cctype&gt;
#include &lt;string&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;

using namespace std;

int trans[1000][1000];
int n;                                          /* number of symbols */
char ch[1000];                                  /* symbol set */
int start_state;                                /* start state */
int n_state;                                    /* number of states */
int nac_state;                                  /* number of accept states */
int ac[1000];                                   /* accept states */
char input[1000];                               /* input string */
int start = 1;                                  /* start state */
bool flag = true;                               /* whether the string is legal */
bool mark_ac;                                   /* whether the string is accepted */
int N;
vector&lt;int&gt; dfa_ac;
vector&lt;vector&lt;int&gt; &gt; e_s;
void dfs_nfa(string, int);
void dfs_dfa(string, int);
bool ac_check(int);
bool ac_check_dfa(int);
bool all_check(int);
vector&lt;vector&lt;int&gt; &gt; Newtrans;
vector&lt;string&gt; dfa_generate, nfa_generate;

/* 
 * ===  FUNCTION  ======================================================================
 *         Name: main
 * =====================================================================================
 */

	int
main ( int argc, char *argv[] )
{

	freopen(&quot;NFA2DFA.txt&quot;, &quot;r&quot;, stdin);

	dfa_ac.clear();
	scanf ( &quot;%d&quot;, &amp;n);
	getchar();
	for ( int i = 0; i &lt; n; ++i ) {
		scanf ( &quot;%c&quot;, &amp;ch[i] );
		getchar();
	}
	scanf ( &quot;%d%d%d&quot;, &amp;n_state, &amp;start_state, &amp;nac_state );
	for ( int i = 0; i &lt; nac_state; ++i ) {
		scanf ( &quot;%d&quot;, &amp;ac[i] );
	}
	string str;
	e_s.clear();
	char buffer[1111];
	for ( int i = 0; i &lt; n_state; ++i ) {
		cin &gt;&gt; str;
		memset(buffer, 0, sizeof(buffer));
		strcpy(buffer, str.c_str());
		char *pch = strtok(buffer, &quot;,&quot;);
		char suffer[1000];
		vector&lt;int&gt; t_a;
		t_a.clear();
		while ( NULL != pch ) {
			memset(suffer, 0, sizeof(suffer));
			strcpy(suffer, pch);
			int su_n = atoi(suffer);
			t_a.push_back(su_n);
			pch = strtok(NULL, &quot;,&quot;);
		}
		e_s.push_back(t_a);
		for ( int j = 1; j &lt; n + 1; ++j ) {
			scanf ( &quot;%d&quot;, &amp;trans[i][j] );
		}
	}
	vector&lt;int&gt;::iterator i_t;
	vector&lt;int&gt; v;

	map&lt;vector&lt;int&gt;, int &gt; mystate;
	mystate.clear();

	Newtrans.clear();

	int ii;
	ii = 0;
	set&lt;int&gt; s_in;
	s_in.clear();
	v.push_back(start_state);
	s_in.insert(start_state);
	// start_state enclosure
	for ( i_t = e_s[start_state-1].begin(); i_t != e_s[start_state-1].end(); ++i_t ) {
		if ( -1 != *i_t &amp;&amp; s_in.count(*i_t) == 0) {
			v.push_back(*i_t);
			s_in.insert(*i_t);
		}
	}
	vector&lt;int&gt;::iterator it;
	bool in_ac = false;
	for ( it = v.begin(); it != v.end(); ++it ) {
		for ( int jk = 0; jk &lt; nac_state; ++jk ) {
			if ( ac[jk] == (*it) ) {
				in_ac = true;
				dfa_ac.push_back(0);
				break;
			}
		}
		if ( in_ac ) {
			break;
		}
	}
	sort(v.begin(), v.end());

	vector&lt;int&gt; add;
	add.clear();

	mystate.insert(pair&lt;vector&lt;int&gt;, int&gt;(v, ii));
	++ii;
	Newtrans.push_back(add);                      /* push_back a empty vector */

	stack&lt;vector&lt;int&gt; &gt; stac;
	stac.push(v);
	while ( !stac.empty() ) {                     /*if stack if not empty we will search new state */
		vector&lt;int&gt; tmp;
		v = stac.top();
		stac.pop();
		int jj;
		jj = mystate[v];
		for ( int i = 1; i &lt; n + 1; ++i ) {         /* for every symbol */
			tmp.clear();
			s_in.clear();
			// move(v, i) = tmp
			for ( it = v.begin(); it != v.end(); ++it ) { /* for every symbol in this set (this symbol as input) */
				if (-1 != trans[(*it)-1][i] &amp;&amp; s_in.count(trans[(*it)-1][i]) == 0) { /* we can not push_back -1!!!f**k!!! */
					tmp.push_back(trans[(*it)-1][i]);     /* =_= T_T I wasted so much time to debug here!!!!!! T^T */
					s_in.insert(trans[(*it)-1][i]);
				}
			}
			// get enclosure tmp-enclosure
			vector&lt;int&gt; tmp_i;
			tmp_i = tmp;
			for ( it = tmp.begin(); it != tmp.end(); ++it ) { /* get stuck!!! command terminated */
				for ( i_t = e_s[(*it)-1].begin(); i_t != e_s[(*it)-1].end(); ++i_t ) {
					if ( -1 != *i_t &amp;&amp; s_in.count(*i_t) == 0 ) {
						tmp_i.push_back(*i_t);              /* we cannot modify tmp */
						s_in.insert(*i_t);
					}
				}
			}
			tmp = tmp_i;
			sort(tmp.begin(), tmp.end());
			if ( (tmp.size() != 0) &amp;&amp; !mystate.count(tmp)) {                  /* do not have it */
				mystate.insert(pair&lt;vector&lt;int&gt;, int&gt;(tmp, ii));
				in_ac = false;
				for ( it = tmp.begin(); it != tmp.end(); ++it ) {
					for ( int jk = 0; jk &lt; nac_state; ++jk ) {
						if ( ac[jk] == (*it) ) {
							in_ac = true;
							dfa_ac.push_back(ii);
							break;
						}
					}
					if ( in_ac ) {
						break;
					}
				}
				add.clear();
				Newtrans.push_back(add);
				ii++;
				stac.push(tmp);
			}
			if (tmp.size() != 0) {
				Newtrans[jj].push_back(mystate[tmp]);
			}
			else {
				Newtrans[jj].push_back(-1);
			}
		}
	}
//	vector&lt;vector&lt;int&gt; &gt;::iterator j_t;
//	for ( j_t = Newtrans.begin(); j_t != Newtrans.end(); ++j_t ) {
//		for ( it = (*j_t).begin(); it != (*j_t).end(); ++it ) {
//			cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
//		}
//		cout &lt;&lt; endl;
//	}
	// succeed!
	// Out put DFA!
	for (int i = 0; i &lt; ii; ++i) {
		for ( it = Newtrans[i].begin(); it != Newtrans[i].end(); ++it ) {
			cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
		}
		cout &lt;&lt; endl;
	}
	// output accepted state
	cout &lt;&lt; &quot;accepted state: &quot;; 
	for ( it = dfa_ac.begin(); it != dfa_ac.end() ; ++it ) {
		cout &lt;&lt; *it &lt;&lt; &quot; &quot;; 
	}
	N = 3;
	dfa_generate.clear();
	nfa_generate.clear();
//	printf ( &quot;\n&quot; );
	freopen(&quot;str.txt&quot;, &quot;r&quot;, stdin);
	freopen(&quot;str_out.txt&quot;, &quot;w&quot;, stdout);
	while ( ~scanf(&quot;%d&quot;, &amp;N) ) {
		string sad = &quot;&quot;;
		dfs_dfa(sad, 0);
		sort(dfa_generate.begin(), dfa_generate.end());
		vector&lt;string&gt;::iterator end_u, sadbu;
		end_u = unique(dfa_generate.begin(), dfa_generate.end());
		dfa_generate.erase(end_u, dfa_generate.end());
		cout &lt;&lt; &quot;********************&quot; &lt;&lt; endl; 
		cout &lt;&lt; &quot;size = &quot; &lt;&lt; dfa_generate.size() &lt;&lt; endl; 
		for ( sadbu = dfa_generate.begin(); sadbu != dfa_generate.end(); ++sadbu ) {
			cout &lt;&lt; *sadbu &lt;&lt; endl;
		}
		sad = &quot;&quot;;
		dfs_nfa(sad, 1);
		sort(nfa_generate.begin(), nfa_generate.end());
		end_u = unique(nfa_generate.begin(), nfa_generate.end());
		nfa_generate.erase(end_u, nfa_generate.end());
		cout &lt;&lt; &quot;********************&quot; &lt;&lt; endl; 
		cout &lt;&lt; &quot;size = &quot; &lt;&lt; nfa_generate.size() &lt;&lt; endl; 
		for ( sadbu = nfa_generate.begin(); sadbu != nfa_generate.end(); ++sadbu ) {
			cout &lt;&lt; *sadbu &lt;&lt; endl;
		}
		bool mark = true;
		if ( dfa_generate.size() != nfa_generate.size() ) {
			mark = false;
			printf ( &quot;size is Different!\n&quot; );
		} else {
			for ( int js = 0; js &lt; dfa_generate.size(); ++js ) {
				if ( dfa_generate[js] != nfa_generate[js] ) {
					mark = false;
					break;
				}
			}
		}
		if ( mark ) {
			cout &lt;&lt; &quot;Same!&quot; &lt;&lt; endl; 
		} 
		else {
			cout &lt;&lt; &quot;Different!&quot; &lt;&lt; endl;
		}
	}

		return EXIT_SUCCESS;
}				/* ----------  end of function main  ---------- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  dfs_dfa
 *  Description:  dfs to generate string
 * =====================================================================================
 */
	void
dfs_dfa ( string str, int now )
{
	int len = str.length();
	if ( len &gt; N ) {
		return;
	}
	if ( len &gt; 0 &amp;&amp; len &lt;= N &amp;&amp; ac_check_dfa(now) ) {
		dfa_generate.push_back(str);
//		cout &lt;&lt; str &lt;&lt; endl;
	}
	vector&lt;int&gt;::iterator jk;
	for ( jk = Newtrans[now].begin(); jk != Newtrans[now].end(); ++jk ) {
		if ( -1 != *jk ) {
			dfs_dfa(str + ch[jk-Newtrans[now].begin()], *jk);
		}
	}
	return ;
}		/* -----  end of function dfs_dfa  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  dfs_nfa
 *  Description:  dfs to generate string
 * =====================================================================================
 */
	void
dfs_nfa ( string str, int now )
{
	int len = str.length();
	if ( len &gt; N ) {
		return;
	}
	if ( len &gt; 0 &amp;&amp; len &lt;= N &amp;&amp; all_check(now) ) {
		nfa_generate.push_back(str);
//		cout &lt;&lt; str &lt;&lt; endl;
	}
	for ( int i = 1; i &lt; n + 1; ++i ) {
		if ( -1 != trans[now-1][i] ) {
			dfs_nfa(str+ch[i-1], trans[now-1][i]);
		}
	}
	vector&lt;int&gt;::iterator i_t;
	for ( i_t = e_s[now-1].begin(); i_t != e_s[now-1].end(); ++i_t ) {
		if ( -1 != *i_t ) {
			dfs_nfa(str, *i_t);
		}
		else break;
	}
	return ;
}		/* -----  end of function dfs_nfa  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  all_check
 *  Description:  enclosure check
 * =====================================================================================
 */
	bool
all_check ( int sta )
{
	bool mark = false;
	mark = ac_check(sta);
	if ( mark ) {
		return mark;
	}
//	vector&lt;int&gt;::iterator i_t;
//	for ( i_t = e_s[sta-1].begin(); i_t != e_s[sta-1].end(); ++i_t ) {
//		if ( -1 != *i_t ) {
//			mark = ac_check(*i_t);
//			if ( mark ) {
//				break;
//			}
//		}
//		else break;
//	}
	return mark;
}		/* -----  end of function all_check  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  ac_check
 *  Description:  check whether a state is accepted
 * =====================================================================================
 */
	bool
ac_check ( int sta )
{
	bool mark = false;
	for ( int i = 0; i &lt; nac_state; ++i ) {
		if ( sta == ac[i] ) {
			mark = true;
			break;
		}
	}
	return mark;
}		/* -----  end of function ac_check  ----- */

/* 
 * ===  FUNCTION  ======================================================================
 *         Name:  ac_check_dfa
 *  Description:  check whether it is legal
 * =====================================================================================
 */
	bool
ac_check_dfa ( int sta )
{
	bool mark = false;
	vector&lt;int&gt;::iterator it;
	for ( it = dfa_ac.begin(); it != dfa_ac.end(); ++it ) {
		if ( (*it) == sta ) {
			mark = true;
			return mark;
		}
	}
	return mark;
}		/* -----  end of function ac_check_dfa  ----- */
</code></pre>

<p>Nice.</p>

<hr />

<p>Maybe I made a mistake! I forget a case:
when I get epsilon of a node, it may have some consistent epsilon transfers! So I should use dfs to get the whole epsilon!</p>

<p>I find this problem when I read this blog: <a href="www.cnblgos.com/cyjb/archive/LexerDfa.html">cyjb</a>
Thank You!
I will fix the problem later.</p>

  </div>
  <div id="disqus_thread"></div>
</div>


<script type="text/javascript">
var disqus_shortname = "abeliu";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>



<script type="text/javascript">
    var disqus_shortname = "abeliu";
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<script src="http://liuxueyang.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

