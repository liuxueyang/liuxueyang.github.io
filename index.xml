<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LXY Site</title>
    <link>http://liuxueyang.github.io/</link>
    <description>Recent content on LXY Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>your@email.com (Aos Dabbagh)</managingEditor>
    <webMaster>your@email.com (Aos Dabbagh)</webMaster>
    <copyright>(c) 2008 - 2014</copyright>
    <lastBuildDate>Sat, 23 Dec 2017 16:15:50 +0800</lastBuildDate>
    
	<atom:link href="http://liuxueyang.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>2017 年结束了</title>
      <link>http://liuxueyang.github.io/posts/2017-12-23-summary-for-2017/</link>
      <pubDate>Sat, 23 Dec 2017 16:15:50 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2017-12-23-summary-for-2017/</guid>
      <description>2017 年这么快就过完了！实在是不知道怎么总结这一年。但还是记录一下吧！
 一月到五月，每天都在玩儿…… 每天是吃了睡，睡了玩，玩了睡。生活很规律。不过好像学了一点儿东西来着。 六、七月，生活还是挺平静，发现还是北方城市适合我，和在南方相比，舒服很多。 八、九月，噩梦。 十月到十二月，除去个人事情比较多，需要到处跑来跑去以外，过得还算平静。  总的来说，这一年真是大起大落，经历了一些之前想都没有想过的事情。。不过还是有很多开心的事情，比如补了好多番什么的。至于技术方面嘛，没有什么长进。。
好像也开始需要注意个人身体健康了，以前身体从来没有出过问题，也从来不把健康当回事儿，今年才慢慢发现身体显然不如以前了，说实话这让我很意外。。可能是年纪大了得过…… 去年有段时间还天天跑几公里，今年一整年也没运动过一次。。
虽然技术没什么长进，也没学会什么东西，不过倒是玩儿了很多之前就想玩的东西，从中得到了很多乐趣。
另外我好像变得越来越宅了（周五回家，下周一才出门。。。这和几年前作息规律饮食规律的我完全不一样啊。。。真是造化弄人。
列举一下今年玩过的东西吧：
 重完了一遍 Limbo 重玩了一遍 Braid 玩了几个月的 Ingress，认识了一些人 玩了大概一个多月的 Steam 里面的游戏（名字好像叫做战矛 重玩了「孢子」 年初、年中、年底都玩了一段时间的 Wesnoth 折腾 FVWM 折腾 Emacs 折腾 i3 折腾 Slackware 刷过 CM13、H2OS、LineageOS  最近唯一的乐趣也就是看书、补番、听歌什么的。。间歇性踌躇满志，持续性混吃等死。。我也不知道从什么时候开始早上起床越来越晚，早上看运气八九点才起床…… 也是厉害。。。很难想象以前是怎么保持每天七点以前起床的？？我竟然完全不记得了……
人的变化真是大。。。自己加油吧！
诶，不管怎么说，今年总算是过完了！希望明年能够回归正常吧。</description>
    </item>
    
    <item>
      <title>Clustering</title>
      <link>http://liuxueyang.github.io/posts/clustering/</link>
      <pubDate>Wed, 17 May 2017 15:33:49 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/clustering/</guid>
      <description>题目链接：pdf
题目给出一个些点的坐标，要求把这些点分成k组，求这k组中，组和组之间的点 的最小距离d。
这道题，好像可以用Kruskal？比如：按照边长度从小到大扫描， 同时记录当前有多少个连通分量（比如：每次Union之后连通分量 的个数减一），一直到只剩k个连通分量的时候，找到下一个可用 边（这个边的两个点在不同的连通分量中）的时候退出循环。这个 可用边就是答案。
因为要求最小的d嘛，所以就是贪心吧。
所以相对难实现的就是这些了：
 处理输入数据 带路径压缩的并查集  这些也挺好写的。
// Tue May 16 21:01:58 2017 // Tue May 16 22:06:44 2017 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; struct edge { int from, to; double cost; }; inline double p_distance(int x1, int y1, int x2, int y2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); } int p_find(int x, vector&amp;lt;int&amp;gt; &amp;amp;parent) { int p = x; while (p !</description>
    </item>
    
    <item>
      <title>Building Roads to Connect Cities</title>
      <link>http://liuxueyang.github.io/posts/building-roads-to-connect-cities/</link>
      <pubDate>Wed, 17 May 2017 15:24:43 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/building-roads-to-connect-cities/</guid>
      <description>题目链接：pdf
给出平面上的一些点，任意两点之间可以相连，求最小生成树的总权值。
用Kruskal：把所有边按照边长度升序排序，循环所有边，每次加入一个边之前要判断这个边的两个点是不是在一个集合中，如果是那么跳过，如果不是那么把这个边的两个点合并到一个集合中。集合操作用带路径压缩的并查集。循环边的过程中累加边的权值。
// Tue May 16 17:02:04 2017 // Tue May 16 20:42:10 2017 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; struct edge { int from, to; double cost; }; inline double p_distance(int x1, int y1, int x2, int y2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); } int p_find(int x, vector&amp;lt;int&amp;gt; &amp;amp;parent) { int p = x; while (p != parent[p]) { p = parent[p]; } return parent[x] = p; } void p_union(int x, int y, vector&amp;lt;int&amp;gt; &amp;amp;parent, vector&amp;lt;int&amp;gt; &amp;amp;p_size) { int p_x = p_find(x, parent), p_y = p_find(y, parent), ps_x = p_size[p_x], ps_y = p_size[p_y]; if (ps_x &amp;gt; ps_y) { parent[p_y] = p_x; p_size[p_x] += ps_y; } else { parent[p_x] = p_y; p_size[p_y] += ps_x; } }	double minimum_distance(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y) { double result = 0.</description>
    </item>
    
    <item>
      <title>Detecting Anomalies in Currency Exchange Rates</title>
      <link>http://liuxueyang.github.io/posts/detecting-anomalies-in-currency-exchange-rates/</link>
      <pubDate>Wed, 17 May 2017 15:01:28 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/detecting-anomalies-in-currency-exchange-rates/</guid>
      <description>题目链接：pdf
题目给一个有向图，判定这个有向图是不是存在负环。
思路：
对这个图进行Bellman-Ford算法：不断对所有边进行松弛操作，循环进行V次，如果第V次仍然有边被松弛，那么说明存在负环。
相反，如果第V次没有边被松弛，那么说明没有负环。
在讨论Dijkstra算法的时候，最开始的V*E的算法其实就是Bellman-Ford算法。
初始化的时候把dist数组初始化为0。为什么呢？因为我们找的是负环，所以我们可以假设所有点到对源点的距离都是0。如果有负环，那么一定有负边，在第V次松弛所有边的时候，这个环中一定有一个点的最短路为负值。
// Mon May 15 14:13:09 CST 2017 // Mon May 15 15:09:41 CST 2017 // 一个有向图是不是存在负环 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; using namespace std; typedef pair&amp;lt;int, int&amp;gt; PII;	// from, to struct edge { int from; int to; int w; }; int negative_cycle(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;cost) { vector&amp;lt;int&amp;gt; dist(adj.size(), 0); vector&amp;lt;edge&amp;gt; edges; for (size_t i = 0; i &amp;lt; adj.size(); ++i) { for (size_t j = 0; j &amp;lt; adj[i].</description>
    </item>
    
    <item>
      <title>Computing the Minimum Cost of a Flight</title>
      <link>http://liuxueyang.github.io/posts/computing-minimum-cost-of-a-flight/</link>
      <pubDate>Wed, 17 May 2017 08:37:01 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/computing-minimum-cost-of-a-flight/</guid>
      <description>题目链接：pdf
题目给出一个有向图，边的权值非负，求起点到终点的最短路。
用Dijkstra，基本思想是这样的：如果一个有向图权值非负，那么两点之间的最 短路有最优子结构的性质。两点之间的最短路上的任意两点之间的路径也是最优 的。
设S -&amp;gt; ... -&amp;gt; u -&amp;gt; ... -&amp;gt; v -&amp;gt; ... -&amp;gt; t是从S到t的一条最短路，那么这条路径 上从u到v的部分也是u到v的最短路。反证：假设从u到v存在一条更短的路径L， 那么用L替换S到t中从u到v的部分，就可以得到一条从S到v的更短的路径，由于 我们假设原来的路径是从S对v的最短路，得出矛盾。
这样，设d(S, t)是S -&amp;gt; ... -&amp;gt; u -&amp;gt; t是S到t的最短路。则：
d(S, t) = d(S, u) + w(u, t)  所以我们可以不断地对所有边的进行松弛操作，直到没有边可以松弛。这个时候就可以得到单源最短路。这样的循环最多进行V次，每次最多进行E次松弛操作，因此复杂度是V*E。
显然我们不必每次都对所有边进行松弛。我们可以记录下以后不需要松弛的点，也就是最短路已经确定的点，所以我们可以把所有点分成两个集合，一个集合表示这些点到源点的最短路已经确定，另一个集合表示最短路还不确定。
也就是说每次松弛的循环中，我们可以把松弛过的点放到一个优先队列中，然后从中选择到源点距离最小的出队，它就是最短距离已经确定的点。继续从这个开始松弛操作，一直循环到队列为空。每个点入队一次，出队一次。总共循环V次，每次循环中要出队最小元素（VlogV），对这个点相连的所有边进行松弛并且入队(ElogV)。总共是(E+V)logV。
// Mon May 15 10:45:45 CST 2017 // Mon May 15 11:29:58 CST 2017 /* 最简单的Dijkstra */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;climits&amp;gt; using namespace std; typedef pair&amp;lt;int, int&amp;gt; PII; class Comp { public: bool operator() (const PII &amp;amp;a, const PII &amp;amp;b) { return a.</description>
    </item>
    
    <item>
      <title>Checking whether a Graph is Bipartite</title>
      <link>http://liuxueyang.github.io/posts/checking-whether-a-graph-is-bipartite/</link>
      <pubDate>Wed, 17 May 2017 00:06:00 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/checking-whether-a-graph-is-bipartite/</guid>
      <description>题目链接：pdf
题目给一个无向图，判定这个图是否是二分图。
所谓二分图就是，用可以两种颜色给这个图的所有节点染色，并且满足相邻两个点颜色不同。
思路：
模拟染色过程，遍历所有点，如果这个点没有被染色，那么用BFS从这个点开始染色，当出现两个点颜色相同，说明这个图不是二分图。如果这个点已经被染色过，那么判断一下和这个点直接相连的点和它的颜色是否相同。
// Sun May 14 21:24:26 CST 2017 // Sun May 14 21:43:44 CST 2017 /* 二分图判定 */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; using std::vector; using std::queue; int bipartite(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj) { int result = 1; vector&amp;lt;int&amp;gt; color(adj.size(), -1); queue&amp;lt;int&amp;gt; que; for (size_t i = 0; i &amp;lt; adj.size(); ++i) { if (-1 == color[i]) { color[i] =1; que.push(i); while (!que.empty()) { int cur = que.</description>
    </item>
    
    <item>
      <title>Computing the Minimum Number of Flight Segments</title>
      <link>http://liuxueyang.github.io/posts/computing-minimum-number-of-flight-segments/</link>
      <pubDate>Tue, 16 May 2017 23:57:39 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/computing-minimum-number-of-flight-segments/</guid>
      <description>题目链接：pdf
给一个无向图，一个起点，一个终点，求从起点到终点的路径的边数的最小值。
就是一遍BFS。
// Sun May 14 21:01:40 CST 2017 // Sun May 14 21:20:34 CST 2017 /* 最简单的BFS */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; using std::vector; using std::queue; int distance(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, int s, int t) { vector&amp;lt;int&amp;gt; dist(adj.size(), -1); queue&amp;lt;int&amp;gt; que; dist[s] = 0; que.push(s); while (!que.empty()) { int cur = que.front(); que.pop(); for (auto v : adj[cur]) { if (-1 == dist[v]) { dist[v] = dist[cur] + 1; que.</description>
    </item>
    
    <item>
      <title>Checking Whether Any Intersection in a City is Reachable from Any Other</title>
      <link>http://liuxueyang.github.io/posts/checking-whether-any-intersection-in-a-city-is-reachable-any-other/</link>
      <pubDate>Tue, 16 May 2017 23:24:52 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/checking-whether-any-intersection-in-a-city-is-reachable-any-other/</guid>
      <description>题目链接：pdf
题目给出一个有向图，要求输出图中强连通分量的个数。
我把这样的强连通分量叫做一个sink：不存在一个边从这个强连通分量中的任意 一个点连接到其它连通分量。也就是说如果把这个强连通分量缩成一个点的话， 它的出度为0。
我把和一个图的所有边都反向的图叫做反向图。貌似没有这样的术语。不知道 reverse graph应该怎么翻译。
思路大概是这样的：
 如果我们知道一个有向图的sink中的一个点，那么我们就可以求出这个强连 通分量的所有点，因为强连通分量中的任意两个点都相互可达。 如何求有相同的sink？我们知道反向图的强连通分量的个数和原图的强连通 分量一定是一样的，只是方向不同。并且，原图的sink对应于反向图的 source strong connected component，所以我们可以通过求反向图的source SCC，来求原图的sink。 求一个图的source SCC的思路和用DFS求拓扑排序的思路是一样的，我们可以 按照所有点的DFS回退的时刻降序排序，这样DFS最晚回退的点就是反向图的 source SCC，也就是原图的sink，我们可以第二次DFS得到这个sink中的所有 点并且从原图中去掉，继续求下一个sink，同时计数。  实现的过程中出现了非常难以发现的bug：一个vector，我在dfs里面加入元素， 然后在调用dfs的外层循环中循环这个vector。所以对于小数据并没有显现出错 误，对于10000的数据就出现段错误了。调试了很久，不过xhe也教了我好多调试 的方法，比如gdb，valgrind，libsigseg库，strace等。不过gdb调试的时候查 看STL数据结构里面的数据的时候还是有点小麻烦，这个时候IDE的调试工具就好 用很多了。
另外，gdb设置端点竟然支持条件表达式，这个功能非常有用。
// Sat May 13 09:28:34 CST 2017 // Sat May 13 10:46:30 CST 2017 // 求一个有向图的强连通分量的个数。。。 /* 1. 建reverse graph 2. 降序排序post 3. 在原图中依次求强连通分量，并且从图中去掉 */ #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; using namespace std; typedef vector&amp;lt;int&amp;gt; VI; typedef pair&amp;lt;int, int&amp;gt; PII; int cnt; vector&amp;lt;PII&amp;gt; post;	// index, post void dfs(vector&amp;lt;VI&amp;gt; &amp;amp;adj, vector&amp;lt;bool&amp;gt; &amp;amp;used, int x, bool get_post) { used[x] = true; for (auto &amp;amp;v1 : adj[x]) { if (!</description>
    </item>
    
    <item>
      <title>Determining an Order of Courses</title>
      <link>http://liuxueyang.github.io/posts/determining-an-order-of-courses/</link>
      <pubDate>Tue, 16 May 2017 23:11:46 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/determining-an-order-of-courses/</guid>
      <description>题目链接：pdf
题目给出一个有向图，保证没有环，求这个有向图所有点的拓扑排序之后的序列， 只输出一种即可。
同样用DFS，求拓扑排序的过程一般是先求所有出度为0的点，然后删除这些点， 如此循环。DFS的过程中，回退过程最早的那个点一定是出度为0，所以就可以记 录下DFS的过程中每个点回退的时刻，然后按照时刻大小逆序排序就是拓扑顺序 了。
// Sat May 13 00:14:15 CST 2017 // Sat May 13 09:27:41 CST 2017 // 拓扑排序 #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; using namespace std; typedef pair&amp;lt;int, int&amp;gt; PII; vector&amp;lt;PII &amp;gt; post;	// index, clock_cnt int clock_cnt; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, vector&amp;lt;int&amp;gt; &amp;amp;used, int x) { used[x] = true; for (auto v : adj[x]) { if (!used[v]) { dfs(adj, used, v); } } clock_cnt++; post.</description>
    </item>
    
    <item>
      <title>Checking Consistency of CS Curriculum</title>
      <link>http://liuxueyang.github.io/posts/checking-consistency-curriculum/</link>
      <pubDate>Tue, 16 May 2017 23:00:54 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/checking-consistency-curriculum/</guid>
      <description>题目链接：pdf
题目给一个有向图，判断是不是有环。我的方法是DFS，对于一个点，访问的过程中存在这三种情况：
 访问v的过程中，再次访问到了v这个点，说明存在环。 完成访问v后（DFS已经回退到v之后），以后再次访问到了v，这是没有问题 的，这种情况不能说明存在环。 v还没有访问过。  因此用三个不同的值来标记这三种情况就可以了。
// Fri May 12 22:50:22 CST 2017 // Fri May 12 23:50:02 CST 2017 // 判断一个有向图是不是有环。。。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; /* visit[i]的值有三种情况： 0:这个点没有访问过 1:这个点正在访问 2:这个点以及和它相连的点都已经访问过了 所以DFS的过程中，下一个点遇到了visit[e] == 1说明有环。 */ void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, vector&amp;lt;int&amp;gt; &amp;amp;visit, int x, bool &amp;amp;mark) { // cout &amp;lt;&amp;lt; &amp;quot;(&amp;quot; &amp;lt;&amp;lt; x + 1 &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;quot;)&amp;quot; &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;; visit[x] = 1; if (mark) return; for (auto e : adj[x]) { if (mark) return; else if (visit[e] == 1) { mark = true; return; } else if (!</description>
    </item>
    
    <item>
      <title>Adding Exits to a Maze</title>
      <link>http://liuxueyang.github.io/posts/adding-exits-to-maze/</link>
      <pubDate>Tue, 16 May 2017 22:52:55 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/adding-exits-to-maze/</guid>
      <description>题目链接：pdf
给出一个无向图，求连通分量的个数。对这个图做一遍DFS同时计数就好了。因 为我用邻接表表示图，所以还要记得孤点的情况，这个后来才发现。
// Begin: Fri May 12 19:52:46 CST 2017 // Finish: Fri May 12 20:16:44 CST 2017 // 求有几个连通块。。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, vector&amp;lt;bool&amp;gt; &amp;amp;visit, int x) { visit[x] = true; for (size_t i = 0; i &amp;lt; adj[x].size(); ++i) { if (!visit[adj[x][i]]) { dfs(adj, visit, adj[x][i]); } } } int number_of_components(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, int n) { int res = 0; vector&amp;lt;bool&amp;gt; visit(n, false); // 所以我忘了孤点。。。。T_T for (size_t i = 0; i &amp;lt; adj.</description>
    </item>
    
    <item>
      <title>Finding an Exit from a Maze</title>
      <link>http://liuxueyang.github.io/posts/finding-an-exit-from-maze/</link>
      <pubDate>Tue, 16 May 2017 22:28:46 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/finding-an-exit-from-maze/</guid>
      <description>题目链接：pdf
这道题目给出一个无向图，一个起点，一个终点，判断从起点是否能够到达终点。 显然就是从起点开始做一次DFS就可以了。
// 2017/05/12 19:35:19 // 判断两个点是否连通。。。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, int x, int y, vector&amp;lt;bool&amp;gt; &amp;amp;visit) { visit[x] = true; if (visit[y]) return; for (size_t i = 0; i &amp;lt; adj[x].size(); ++i) { if (!visit[adj[x][i]]) { dfs(adj, adj[x][i], y, visit); } } } int reach(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, int x, int y, int n) { vector&amp;lt;bool&amp;gt; visit(n, false); dfs(adj, x, y, visit); return (visit[y] ?</description>
    </item>
    
    <item>
      <title>Typeclass in Haskell筆記</title>
      <link>http://liuxueyang.github.io/posts/typeclass-in-haskell%E7%AD%86%E8%A8%98/</link>
      <pubDate>Wed, 19 Apr 2017 09:29:24 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/typeclass-in-haskell%E7%AD%86%E8%A8%98/</guid>
      <description>代數數據類型 這樣定義一個類型：
data Name = Name String String  Name既是類型名，也是一個Value Constructor，一個類型通常有多個Value Constructor，不過按照習慣，如果一個類型僅僅有一個Value Constructor，那麼它的名字通常和類型名同名。
Value Constructor事實上只是一個函數，這也就決定了，不同的類型不能夠擁有相同名字的Value Constructor。
創建一個對象：
λ&amp;gt; Name &amp;quot;aries&amp;quot; &amp;quot;abel&amp;quot; Name &amp;quot;aries&amp;quot; &amp;quot;abel&amp;quot; :: Name  有多個Value Constructor的例子：
data Shape = Rectangle Point Point | Circle Point Float data Point = Point Float Float  創建一個Circle對象：
λ&amp;gt; Point 3 4 Point 3 4 :: Point λ&amp;gt; Circle (Point 3 4) 3 Circle (Point 3 4) 3 :: Shape  Record 在代數類型裏面每個field所代表的意義不明確，並且如果需要得到某個field的值只能用模式匹配，非常繁瑣，所以這個時候Record就有用了：</description>
    </item>
    
    <item>
      <title>foldl和foldr的不同點</title>
      <link>http://liuxueyang.github.io/posts/foldr%E5%92%8Cfoldl%E5%87%BD%E6%95%B8%E8%BE%A8%E6%9E%90/</link>
      <pubDate>Tue, 18 Apr 2017 16:37:32 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/foldr%E5%92%8Cfoldl%E5%87%BD%E6%95%B8%E8%BE%A8%E6%9E%90/</guid>
      <description>foldl foldl這個函數的類型是：
(a -&amp;gt; b -&amp;gt; a) -&amp;gt; a -&amp;gt; [b] -&amp;gt; b  它接收一個函數、一個起始值、一個列表。它的作用相當于：
foldl f z [x_1, x_2, ..., x_n] == (... ((z `f` x_1) `f` x_2) `f` ...) `f` x_n  也就是它把起始值作爲f的*左參數*，從左邊迭代列表。
可以這樣實現這個函數：
mfoldl&#39; :: (a -&amp;gt; b -&amp;gt; a) -&amp;gt; a -&amp;gt; [b] -&amp;gt; a mfoldl&#39; f accu [] = accu mfoldl&#39; f accu (x : xs) = mfoldl&#39; f (accu `f` x) xs  λ&amp;gt; mfoldl&#39; (-) 0 [1.</description>
    </item>
    
    <item>
      <title>Haskel筆記 10</title>
      <link>http://liuxueyang.github.io/posts/haskell-%E7%AC%94%E8%AE%B010/</link>
      <pubDate>Tue, 18 Apr 2017 15:03:07 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/haskell-%E7%AC%94%E8%AE%B010/</guid>
      <description>這是Functionally Solving Problems一章的筆記。
Reverse Polish notation calculator polish :: (Num a, Read a) =&amp;gt; String -&amp;gt; a polish = head . foldl folder [] . words where folder (x : y : xs) &amp;quot;+&amp;quot; = (y + x) : xs folder (x : y : xs) &amp;quot;*&amp;quot; = (y * x) : xs folder (x : y : xs) &amp;quot;-&amp;quot; = (y - x) : xs folder accu x = read x : accu  求解逆波蘭算數表達式。</description>
    </item>
    
    <item>
      <title>Haskell 笔记9</title>
      <link>http://liuxueyang.github.io/posts/haskell-%E7%AC%94%E8%AE%B09/</link>
      <pubDate>Thu, 13 Apr 2017 08:01:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/haskell-%E7%AC%94%E8%AE%B09/</guid>
      <description>这是第九章的笔记
Hello, world! Files and streams getContents：从标准输入读数据，返回IO Action，一直到文件末尾。
-- print lines whose length is less than 10 main = do lines &amp;lt;- getContents putStr . shortLines $ lines shortLines :: String -&amp;gt; String shortLines = unlines . filter ((&amp;lt; 10) . length) . lines -- Function composition简直好用  interact：接收一个类型为String -&amp;gt; String的函数作为参数，返回一个IO Action，这个IO Action接收一个输入，用之前的String -&amp;gt; String函数处理之后，然后返回一个IO Action，这个IO Action执行的时候会输出处理之后的字符串。
main = interact shortLines shortLines = unlines . filter ((&amp;lt;5) . length) .</description>
    </item>
    
    <item>
      <title>几种个人文档同步方案</title>
      <link>http://liuxueyang.github.io/posts/%E5%87%A0%E7%A7%8D%E4%B8%AA%E4%BA%BA%E6%96%87%E6%A1%A3%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/</link>
      <pubDate>Wed, 12 Apr 2017 15:16:05 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%87%A0%E7%A7%8D%E4%B8%AA%E4%BA%BA%E6%96%87%E6%A1%A3%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/</guid>
      <description>因为前几天（4月7日晚上）我的笔记本硬盘突然坏了，不能读盘了，造成了一些损失，之前做得Coursera上的三部分PL课的作业什么的都没有了，当初也没有多想就没有放到网盘里面同步，万万没想到硬盘会出问题。另外损失了大概两天的工作量，因为两天之前同步过一次Dropbox，因为需要频繁修改一些文件，Dropbox也就会频繁同步，我的电脑比较老了，一直开着Dropbox比较占内存和CPU，所以只是偶尔打开Dropbox。这也算是一个教训吧，所以在这里纪录一下。
最简单的就是用网盘了，比如Dropbox之类的。Slackware里面我用Dropbox和OneDrive。另外一种方法就是Gitlab或者Bitbucket的私有仓储，如果可以公开的话，可以直接放到Github的公开仓库，缺点就是需要频繁git add，git push什么的，这个时候Emacs的插件magit就很有用了。
以后尤其是手写的文档，一定要注意经常同步。不管是移动硬盘还是笔记本硬盘都不如网盘靠谱，至于数据的安全性嘛，都是一些笔记啊，程序啊之类的，好像也没有什么特别需要保护的。当然也可以把文件加密再上传到网盘。</description>
    </item>
    
    <item>
      <title>Haskell 笔记7</title>
      <link>http://liuxueyang.github.io/posts/haskell-%E7%AC%94%E8%AE%B07/</link>
      <pubDate>Wed, 12 Apr 2017 11:16:43 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/haskell-%E7%AC%94%E8%AE%B07/</guid>
      <description>这是一些阅读Learn You a Haskell for Great Good!的时候的笔记，之前用Latex写的，放在Dropbox里面，现在想把它们整理一下，放在博客里。这是第七章 Modules的笔记。
Loading modules 之前用TeXmacs虽然挺方便，但还是感觉有点不舒服。所以还是换回来吧。
在默认的Prelude模块里面，已经默认引入了一些Data.List中的函数。另外，引入Data.List模块的时候不需要使用带限定符的方法，因为Prelude里面的函数除了默认引入的Data.List的部分函数以外，不会和Data.List里面的其它函数命名冲突。然而，如果再引用其它模块的时候就不一定了。一般情况下只需要用一般的引入模块的方法就够了：import Data.List
Data.List group这个函数，它接收一个列表，把列表中相邻并且相等的元素合成一个子列表，对于相等但是不相邻的元素，它会分别合成独立的子列表，也就是说，它并不会排序。比如：
λ&amp;gt; group [1, 2, 2, 2, 3, 4, 2, 2, 2, 5, 6] [[1],[2,2,2],[3],[4],[2,2,2],[5],[6]]  如果想要一个列表中的某个元素的个数，可以这样做：
λ&amp;gt; map (\ xs@(x : xs&#39;) -&amp;gt; (x, length xs)) $ group . sort $ [1, 2, 2, 2, 3, 4, 2, 2, 2, 5, 6] [(1,1),(2,6),(3,1),(4,1),(5,1),(6,1)]  这里我用到了function composition(.)、function application($)、lambda表达式、lambda表达式中的模式匹配、用@符号来捕获整个模式（注意它的用法，用@符号来把整个模式和部分模式分隔开）。
init函数的意思是得到列表的前n - 1个元素，inits的意思是依次得到列表的前0, 1, 2 ... n个元素组成一个嵌套列表。</description>
    </item>
    
    <item>
      <title>Haskell 笔记1</title>
      <link>http://liuxueyang.github.io/posts/haskell-%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Wed, 12 Apr 2017 10:35:34 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/haskell-%E7%AC%94%E8%AE%B01/</guid>
      <description>这是一些阅读Learn You a Haskell for Great Good!的时候的笔记，之前用Latex写的，放在Dropbox里面，现在想把它们整理一下，放在博客里。这是第二章 Starting Out的笔记。
Baby&amp;rsquo;s first functions 2017/03/15 10:32:18
function call的优先级最高。
定义函数这样：
doubleMe x = x * 2  和SML基本一样。
doubleUs x y = doubleMe x + doubleMe y doubleUs1(x, y) = doubleMe x + doubleMe y  这两个的区别？
第一个是curried function，第二个函数接收一个参数，这个参数是一个含有两个元素的tuple，也叫做pair。
函数调用格式：
doubleUs 3 4 doubleUs1(3, 4)  if else格式：
if x &amp;gt; 50 then x else x * 3  和SML基本一样。同样，else部分不能省略。因为这是一个「表达式」，表达式必须有一个值，所以，不管条件是否满足，一定要有一部分被求值，并且当作这个表达式的值。并且，这两部分的表达式的返回值的类型必须一样。
不能在ghci里面像在文件里面那样定义函数。有几种解决方法：defun function in ghci</description>
    </item>
    
    <item>
      <title>重新整理博客</title>
      <link>http://liuxueyang.github.io/posts/%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Mon, 10 Apr 2017 21:11:11 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E5%8D%9A%E5%AE%A2/</guid>
      <description>这么长时间过去了，好像很久不管这个博客了，差不多10个月过去了。是时候 把这些零散的东西整理一下了。争取把之前在别的地方写的东西都整理到这里 来。这样以后查看会方便很多吧！
主要是2014年的「博客园」上面的东西。找了一下现有的工具hexo-migrator-cnblogs发现早已经不维护了，现在也不能用了。所以写了一个简单的脚本来爬取我的博客：
# 2017/04/11 00:45:15 AM # Author: liuxueyang from bs4 import BeautifulSoup import requests import re import os.path url = &#39;http://www.cnblogs.com/liuxueyang/default.html?page=&#39; page_nums = range(1, 11) cnt = 0 already_urls = [] if os.path.exists(&#39;already.txt&#39;): with open(&#39;already.txt&#39;, &#39;r&#39;) as already_f: already_urls = already_urls + already_f.readlines() for page_num in page_nums: url1 = url + str(page_num) r = requests.get(url1) soup = BeautifulSoup(r.content, &#39;html5lib&#39;) titles = soup.find_all(&#39;a&#39;, class_=&#39;posttitle&#39;) for title in titles: print &#39;==&#39; * 20, &#39;\n\n&#39; cnt += 1 blog_url = title.</description>
    </item>
    
    <item>
      <title>整理Bilibili安卓客户端缓存的视频</title>
      <link>http://liuxueyang.github.io/posts/%E6%95%B4%E7%90%86bilibili%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E7%9A%84%E8%A7%86%E9%A2%91/</link>
      <pubDate>Thu, 16 Mar 2017 22:30:48 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E6%95%B4%E7%90%86bilibili%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E7%9A%84%E8%A7%86%E9%A2%91/</guid>
      <description>昨天晚上无意中看到了B站竟然有TOUCH。。完全没想到。所以我决定这次要把这部动画片全部下载下来，B站的视频质量看起来还不错。所以最简单的方法就是用安卓客户端缓存，然后在电脑上处理了。
其实之前我做过这件事情。当初是为了整理「暖暖日记」这部番，因为它每集仅仅有5分钟左右。每个视频只有一个文件，所以只需要找到所有视频然后读json文件找到视频名称，重命名就好了。
不过这次好像有点不同：每集一般有25分钟，缓存的是高清的。奇怪的是：即使是同一集，最开始我缓存的时候某一集是仅仅有一个mp4文件，然后我又实验了一次，发现它就变成了多个flv文件。。真是迷。。
处理也不难，如果是单个mp4文件直接重命名就好了。如果是多个flv文件，那么就需要先合并，然后再命名。
然后看了一下之前写的Perl程序，竟然，看不太懂了。。。T_T，然而还好，最后还是搞定了：
#!/usr/bin/perl # Date : 2017/03/16 19:14:35 # Finish: 2017/03/16 22:04:07 # NOTE: There MUST NOT be any non-ascii character in the path!!!!!!!!!! use strict; use warnings; use 5.014; use Cwd; use JSON qw(); use open &#39;:std&#39;, &#39;:encoding(UTF-8)&#39;; use File::Copy; my $cur_dir = &#39;/home/repl/Videos/Bilibili/Fanju/TOUCH/s_2425&#39;; opendir(DIR, $cur_dir) or dir $!; while (my $file = readdir(DIR)) { next if ($file =~ /^\./); # get index_title my $json_file = $cur_dir .</description>
    </item>
    
    <item>
      <title>复习C&#43;&#43;</title>
      <link>http://liuxueyang.github.io/posts/%E5%A4%8D%E4%B9%A0c/</link>
      <pubDate>Mon, 06 Mar 2017 23:24:07 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%A4%8D%E4%B9%A0c/</guid>
      <description>今天复习了一下C++。很久很久不碰这门语言，早上看到一段代码竟然感觉十分陌生。this，const pointer，引用之类的，有点忘了。其实也不是忘，就是感觉很陌生。比如this别的语言里面也有，只是不是指针，比较容易混淆。所以就大概查了一下C++ Primer，然后做了几道题目。放在这里。
题目一 给CMyString类写一个方法，使它能够支持赋值=操作。CMyString类已经给出。
#include &amp;lt;bits/stdc++.h&amp;gt; // implement a operator `=` on class CMyString using namespace std; class CMyString { public: CMyString(char * pData = NULL); CMyString(const CMyString &amp;amp; str); CMyString &amp;amp; operator =(const CMyString &amp;amp;); void print(); ~CMyString(void); private: char * m_pData; }; CMyString &amp;amp; CMyString::operator =(const CMyString &amp;amp; str) { // if (this == &amp;amp;str) return *this; // delete [] m_pData; // m_pData = NULL; // m_pData = new char[strlen(str.</description>
    </item>
    
    <item>
      <title>const member function in cpp</title>
      <link>http://liuxueyang.github.io/posts/const-member-function-in-cpp/</link>
      <pubDate>Mon, 06 Mar 2017 11:25:18 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/const-member-function-in-cpp/</guid>
      <description>默认情况下，this是一个const pointer to the nonconst version of the class type。比如有一个类A，那么在类里面，this的类型是A * const。因为不能把一个const对象的地址赋值给一个指向nonconst对象的指针，因此不能把this绑定到一个const对象上。这就导致，不能在const对象上调用一个nonconst member function。
解决方法就是，把this声明为const。可是this是隐性的变量，所以C++的解决方法就是在参数列表后面指定const。这样的函数就是const member function。它的语义是：this是一个const pointer to a const object of the class type。这样，const对象和nonconst对象都可以调用这个函数。</description>
    </item>
    
    <item>
      <title>const pointer and pointer to const in Cpp</title>
      <link>http://liuxueyang.github.io/posts/const-pointer-and-pointer-to-const-in-cpp/</link>
      <pubDate>Mon, 06 Mar 2017 10:03:28 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/const-pointer-and-pointer-to-const-in-cpp/</guid>
      <description>中文翻译好像有常量指针和指针常量这两种说法。然而翻译过来让我更加费解。还是英文更加直白。
pointer to const const int b = 30; const int * bptr = &amp;amp;b;  bptr是一个指针，它指向的是一个类型为const int的对象。可以对bptr本身的内容（保存的地址）进行修改，但是不能对它指向的对象进行修改：
const int c = 31; bptr = &amp;amp;c;  这样，bptr就指向了另外一个const对象。
有个例外：可以让pointer to const指向一个nonconst对象。
int d = 32; bptr = &amp;amp;d;  需要注意的是，即使d变量是nonconst，仍然不能通过bptr这个指针对b进行修改：
// *bptr = 33; // error!  总之，
 我可以指向const对象，也可以指向nonconst对象，你也可以修改我。但是，你不能修改我指向的*对象*。 &amp;mdash; pointer to const
 const pointer int a = 3; int * const aptr = &amp;amp;a;  aptr是一个常量，同时是一个指针。不能对aptr里面保存的地址进行修改。但是可以对aptr所指向的对象进行修改：</description>
    </item>
    
    <item>
      <title>Learn C&#43;&#43;</title>
      <link>http://liuxueyang.github.io/posts/learn-c/</link>
      <pubDate>Mon, 06 Mar 2017 09:56:32 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/learn-c/</guid>
      <description>我已经很久没有碰过C++这门语言了。重新看到C++程序的时候竟然有些陌生，很多语法都模糊了。所以我打算复习一下。</description>
    </item>
    
    <item>
      <title>学习org-mode</title>
      <link>http://liuxueyang.github.io/posts/%E5%AD%A6%E4%B9%A0org-mode/</link>
      <pubDate>Fri, 17 Feb 2017 14:09:39 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%AD%A6%E4%B9%A0org-mode/</guid>
      <description>今天我花了非常多的时间来学习org-mode，以前主要用它来记录每天的工作和学习日志，仅仅记录学习时间，几乎只用到了Clock in, Clock out之类的功能。这两天我发现我非常有必要对学过的东西做一个总结或者笔记，供以后查看，不然每次捡起很久之前看的东西还是有点困难。比如前几周学的PL课程，分三部分，学完第一部分觉得还可以，第二部分就比较难了，有些比较新的概念虽然没有完全理解，但是照葫芦画瓢做作业还是可以的。然后到了第三部分，也能够顺利把作业完成。然而到了最后的考试的时候考到第二部分的知识和概念，我竟然几乎完全记不起来了！说实话我还是挺惊讶的。所以我决定以后要经常作笔记，没有完全理解的概念和原理应该经常回顾，反复消化。所以我决定认真学习一下org-mode，用它来管理我的笔记。
本来我把笔记放在了 Dropbox 里面同步，后来想了想，我可能还是会拷贝一份在这里。以后查阅可能会方便很多。随后我会陆续把关于org-mode的笔记贴到下面。</description>
    </item>
    
    <item>
      <title>解决Konsole下Emacs org-mode快捷键不能使用的问题</title>
      <link>http://liuxueyang.github.io/posts/%E8%A7%A3%E5%86%B3kconsole%E4%B8%8Bemacs-org-mode%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 16 Feb 2017 20:11:10 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E8%A7%A3%E5%86%B3kconsole%E4%B8%8Bemacs-org-mode%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>如果想在终端里面使用Emacs的话，org-mode的有些快捷键可能会失效，比如M-LEFT，这个问题在这里有一个解决方案：Stack Overflow。然而我还是觉得挺麻烦的。
今天瞎玩的时候，一个非常偶然的机会，发现这个问题在KDE 4里面的原生的Konsole里面可以非常容易地被解决，只需要在Profile的设置里面的Keyboard标签里面的Key Bindings设置成Default (Xfree 4)，如图：
然后在org-mode里面就可以使用类似于M-LEFT之类的快捷键了。虽然GUI版本的Emacs可能会比较好看，不过还是终端下用Emacs更方便一点。另外，说到终端，以前经常用Terminator，不过在KDE 4里面其实原生的Konsole体验更好。顺便说一句：Slackware是我用过的最好用的发行版。KDE 4非常好用，当作主力机使用了两个多月了，没有出现过问题。</description>
    </item>
    
    <item>
      <title>对折腾编辑器配置的想法</title>
      <link>http://liuxueyang.github.io/posts/%E5%AF%B9%E6%8A%98%E8%85%BE%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%83%B3%E6%B3%95/</link>
      <pubDate>Tue, 14 Feb 2017 17:42:28 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%AF%B9%E6%8A%98%E8%85%BE%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%83%B3%E6%B3%95/</guid>
      <description>我是先接触的Vim，用了很长一段时间，去年才开始使用Emacs。两种编辑器我觉得都挺不错，有的时候使用Emacs，有的时候使用Vim。当然，我也喜欢使用各种IDE。对于我来说，使用Vim和Emacs最大的乐趣就是可以定制各种各样奇怪的东西，虽然只是找别人开发分享的插件，但还是充满了乐趣。有的时候发现了某个非常厉害的插件会特别特别兴奋，这种情况遇到过两次：一次是abo-abo这个俄罗斯人开发的Emacs插件，一次是junegunn这个韩国人开发的Vim插件。
有机会也学着写写怎么写插件吧。配置编辑器其实挺花时间并且会上瘾，看来也没有什么意义，因为使用再好的编辑器，也没法阻止你写出丑陋的程序，也没法提高工作和学习效率。所以听过一句话，大意大概是这样：如果世界上的程序员能够把折腾编辑器的一般精力花在「更有价值」的事情上面的话，工作效率也许会提升不止一倍。
我配置过很多次Vim和Emacs，也因为这样或者那样的原因推翻过很多次。也使用过一些类似于Spacemacs的这种称为「世界级配置」的Emacs。然而我还是喜欢自己从头开始配置，因为别人的需求和我个人的需求不可能完全一致，使用别人的非常全面的配置反而会给我引来更多没法预料的问题，太臃肿的配置也让可移植性变差，比如版本问题，比如想要引入一个插件的时候，和原来的配置的冲突问题等等。
慢慢的我还是比较喜欢非常轻量级的、能够恰好满足我的个人需求的配置。我可以根据需要来手动加载当前需要的配置和插件，而不是当启动的时候一次性一次性全部加载进来。还有，如果不是特别需要，就不要加入新的插件，尽量保持配置文件的清晰和简洁，能够轻易移植。所以我打算慢慢地开始重新配置我的编辑器，要遵守的原则是：尽量保持简洁、轻量。不要强行解决「次要」问题，不适合使用编辑器做的事情就不要强行来实现。
其实，Emacs本身的初始配置对于一些场景来说，就已经够用了。
另外，这两种编辑器，如果非要做一个比较的话，我更喜欢Emacs，但是类似于临时修改个系统配置文件之类的事情，使用Vim快速解决。对于日常工作：写程序、记笔记等，我全部在Emacs里面做。
 唉……如果老是依赖某种东西的话，毕竟不算是真正的勇气。——风间彻
 2016/02/17 01:16:57AM 更新 昨晚又折腾了很久的Emacs，该完成的任务又没有完成。其实仔细想想，折腾编辑器确实耽误了我非常非常多的时间，带来的回报却很少。所以决定不再自己折腾和配置编辑器了。刚才又适用了一下 Spacemacs，其实感觉还不错。至于到底是不是完全适合自己，倒不是最重要的，重要的是能用，能够比较方便地实现日常的编辑工作，如果有些小的瑕疵或者违反我个人的习惯的话，那就慢慢适应吧。我不得不承认，我自己再怎么配置也不可能有 Spacemacs 的配置全面可靠。所以我决定以后就用 Spacemacs 了。花很多时间折腾编辑器甚至舍本逐末对目前的我来说是一件非常不明智的事情。
如果要使用 Spacemacs 的话唯一需要做的事情就是，找时间认真看一下它的文档：http://spacemacs.org/doc/DOCUMENTATION.html。遇到问题最先应该找的就是官方文档，可能你遇到的问题官方文档里面没有特别拿一节或者一章来说明，但是很可能在其它某个小结里面做了说明，这个时候就体现出浏览一遍文档的重要性了。
目前，我在 Spacemacs 里面只做了很少的配置：
 加了lispy插件 更换了插件源 如果状态栏里面的Unicode符号显示乱码的话，把dotspacemacs-mode-line-unicode-symbols这个变量设置成nil  另外特别需要注意的是：不要强行解决不重要的问题。有些问题其实并没有那么重要，花很多时间去解决无关紧要的问题就是浪费时间。要做到这一点还是需要有自制力，克服所谓的「洁癖」或者「强迫症」。
[2017-02-17 Fri 09:59] 更新 在使用 Spacemacs 的过程中，还是应该保持一个.org文件，来专门记录遇到的快捷键，以便以后需要的时候能够方便查阅。这么多快捷键肯定是一下记不住的。今天一整天都在使用 Spacemacs，说实话，体验非常好。对我来说简直完美：有一些美化，能够实现我需要的功能。虽然可能有些解决方案不如abo-abo的插件体验那么好，或者好像也没有加入 multicursors 的功能，但还是让我满意的。</description>
    </item>
    
    <item>
      <title>开始使用Raspbian</title>
      <link>http://liuxueyang.github.io/posts/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8raspbian/</link>
      <pubDate>Tue, 14 Feb 2017 15:30:46 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8raspbian/</guid>
      <description>这两天折腾了一下树莓派，因为我的树莓派里面的Arch Linux不能启动了。开机的时候，ACT LED并没有闪烁，查了一下wiki才知道这表示pi没有读取SD卡。试了很多次，开始以为接触问题，擦了擦卡然后开机的时候用力按着，还是不行。在IRC里问了一下，后来猜测可能是/boot分区出问题了，或者firmware在系统更新的时候出问题了，或者是pi的硬件的问题，或者是SD卡的问题。
之前的手机里还有一个SD卡，只有2GB。然后备份数据之后，刷了Raspbian Lite，插入树莓派顺利进入系统了。能正常用。所以只能是SD卡里的系统问题了。
花了点时间把树莓派里面的数据备份了一下，然后刷了Raspbian jessie，稍微配置了一下。意外地好用。我还是挺满意这个系统的。如果只是在树莓派里写写程序的话，用起来还是挺舒服的。本机用VNC连接到树莓派的桌面，然后就可以像另外一台配置比较低的电脑一样使用了。以前我以为VNC什么的速度可能很慢，画面也不清晰，这两天一直在用，发现其实体验非常好。可以根据主机屏幕的大小来设置树莓派的分辨率，我记得好像是设置一下/boot/config.txt文件里面的framebuffer_width和framebuffer_height这两个变量就好了。然后在VNC的设置里面再设置成同样的分辨率。完美。
在树莓派里写程序的时候，好像除了一些非常轻量级的IDE能用之外，别的只能用Emacs或者Vim了。JetBrains家的IDE估计是没法用。:P</description>
    </item>
    
    <item>
      <title>Use Hexo</title>
      <link>http://liuxueyang.github.io/posts/use-hexo/</link>
      <pubDate>Tue, 14 Feb 2017 00:00:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/use-hexo/</guid>
      <description>Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick Start Create a new post $ hexo new &amp;quot;My New Post&amp;quot;  More info: Writing
Run server $ hexo server  More info: Server
Generate static files $ hexo generate  More info: Generating</description>
    </item>
    
    <item>
      <title>折腾Emacs和Fcitx的兼容问题</title>
      <link>http://liuxueyang.github.io/posts/2017-01-02-emacs-fcitx-thought/</link>
      <pubDate>Mon, 02 Jan 2017 11:21:37 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2017-01-02-emacs-fcitx-thought/</guid>
      <description>在Emacs时而不能使用Fcitx中文输入法。
我只是把这件事记录在这里，我并没有搞定这个问题。
 把下面的程序放到~/.xprofile文件里。未果。  export LANG=zh_CN.UTF8 export LC_CTYPE=en_US.UTF-8 export XMODIFIERS=&#39;@im=fcitx&#39; export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export GTK3_IM_MODULE=fcitx   放到~/.bashrc或者~/.zshrc、~/.profile里。未果。 试试XEmacs。未果。 卸载Fcitx之后重新安装，未果。 卸载Fcitx这后安装ibus输入法，也不能在Emacs里面使用ibus。 把上面的设置改成ibus，未果。 重新手动编译ibus，未果。 元旦结束，放弃。 元旦第二天，继续。 编译安装ibus-wubi，未果。 一天加半天过去，觉悟。放弃解决这个问题。  </description>
    </item>
    
    <item>
      <title>Slackware Dolphin中文文件夹显示乱码</title>
      <link>http://liuxueyang.github.io/posts/2016-12-30-slackware-dolphin-chinese/</link>
      <pubDate>Fri, 30 Dec 2016 07:33:01 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2016-12-30-slackware-dolphin-chinese/</guid>
      <description>在Slackware里面的KDE 4的默认文件夹管理器Dolphin里面，中文文件夹的名称显示是一堆问号。这个问题是我前两天遇到的，还是记在这里吧。问题描述如下。
Dolphin的侧边栏可以显示中文，如图：
如果我想要建立一个中文名称的文件夹的话：
就会成为这样：
我的locale是这样的：
我的解决方法是这样的：
在/etc/profile.d/lang.sh这个文件里面，有这样一句话：
# en_US is the Slackware default locale: export LANG=en_US  把它改成这样就可以了：
export LANG=zh_CN.utf-8  重新登录如果不行，那就重启，问题应该就解决了。比如：
顺便说一句，在这两天我整理文件的过程中发现，最好用最方便的文件管理器是：KDE的Dolphin，因为我可以这样：
其次是macOS的Finder，它也有类似的文件夹显示方式。其它的比如Xfce里面的默认文件夹管理器，删除文件夹的时候没有提示，我严重怀疑有一次整理文件夹的时候误删了一些东西，因为我只发现了一次，并且从回收站里找到了，八成还有别的，我没发现……所以那些简洁的文件管理器也就日常用用还可以。</description>
    </item>
    
    <item>
      <title>开始使用Slackware</title>
      <link>http://liuxueyang.github.io/posts/2016-12-29-start-to-use-slackware/</link>
      <pubDate>Thu, 29 Dec 2016 22:33:15 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2016-12-29-start-to-use-slackware/</guid>
      <description>前两天，我在整理我的硬盘，顺便整理了一下我的openSUSE Leap里面的资料，同样也是十分的混乱。花了很长时间整理，全部移动到移动硬盘里。过程中发现openSUSE Leap的官方源连不上了，正常情况下官方源应该会选择国内速度最快的镜像的，然而有的时候就是蜜汁连不上……去年我也遇到过这种情况，然后我就放弃这个发行版了（后来又回来了……）。这次我决定替换掉openSUSE Leap 42.2，理由：
 官方源有的时候连不上； 早上开机，一直使用到晚上，有的时候即使使用Xfce4也会变得卡； Plasma 5的BUG太多，出问题的次数太多； 跨版本升级的时候有点麻烦； 其实忍它很久了。  好吧，其实都是借口，我只是想试一试Slackware了。看了一下官方的文档，地址在这里：Document，这个文档挺不错的。粗略看完了。安装过程原来挺简单的，我还以为有多复杂。其中有一点挺人性化：安装过程中会提示你要不要制作一个启动盘，这样在系统出现问题无法启动的时候，利用启动盘就可以直接启动系统，然后我就制作了一个。没想到，很快我就用上了。Slackware使用的是LILO，而不是GRUB，Slackware不是那么激进，开发过程比较慢也比较保守，这一点我还是比较喜欢的，不用经常更新。是这样的：安装完之后，我发现LILO的第一个启动项是Windows而不是Slackware，我想把第一个换成Linux。然后在LILO的高级设置里面只选择了Windows，然后保存重启，发现启动项里只有Windows了……原来高级设置里的启动项目需要自己一个一个添加。没法进Slackware了，所以之前的启动盘就有用了，顺利进入Slackware，重新设置LILO，顺利解决。
桌面环境我选择的KDE，安装完毕之后，干净清爽，KDE 4竟然非常流畅，完全不想Plasma 5在我的老电脑上面会经常卡顿。KDE 4一点也不卡，这点让我还是有点惊喜的。然后是中文一系列的配置：
 KeepassX fcitx中文双拼输入法 zsh, fish修改默认shell，oh-my-zsh, fisherman Terminator安装了，不过我现在还是用的默认的Konsole，干净好用，分割其实我也用到少，不如Tab方便 Shadowsocks的GUI版本我遇到点问题，但是命令行版本能用 Dropbox同步Emacs配置，个人文档 Jetbrains全家桶，顺利安装 Android Studio，顺利安装  哦，值得一提的是，系统默认提供了clisp。哈哈。这两天使用的过程中，我还是非常满意的。这么好的发行版，不知道为什么用户那么少。可能是因为安装软件比较麻烦？没有好用的软件包管理器？这个对于我来说不是什么问题。反而是好事，我可不想用zypper install, pacman -S或者apt install安装一堆我可能永远用不到的软件。有的软件需要自己编译，自己解决依赖，有的可以找到二进制包，总的来说还是挺方便的。比如，我要安装VLC这个播放器，过程是这样的：
 在slackbuilds里面下载VLC的SlackBuild包：vlc.tar.gz到$HOME/Downloads，并解压缩：  {% highlight bash %} wget https://slackbuilds.org/slackbuilds/14.2/multimedia/vlc.tar.gz ~/Downloads tar -xvzf vlc.tar.gz {% endhighlight %}
 看一下vlc.info  {% highlight bash %} cd vlc cat ./vlc.info {% endhighlight %}
可以看到它有很多依赖，然后它的源代码的包在DOWNLOAD这个变量里面（一般情况下都是这个变量，只不过有的时候64位和32位是分开的，变量名字可能会不同，所以要注意一下。）
 下载源代码  {% highlight bash %} source .</description>
    </item>
    
    <item>
      <title>使用Time Machine备份系统时磁盘空间不足的问题</title>
      <link>http://liuxueyang.github.io/posts/2016-12-05-timemachine-macos/</link>
      <pubDate>Mon, 26 Dec 2016 17:41:06 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2016-12-05-timemachine-macos/</guid>
      <description>Time Machine这个功能我只在当初刚买了MacBook Air之后不久才用过一次。后来就再也没有管它。当初在移动硬盘里面分出125GB的空间作为Time Machine的分区。那次备份的时间是2014年8月24日。距离现在已经两年多了。
之前我用这个Time Machine把电脑恢复到了2014年8月24日的状态。挺好用的。没有遇到问题。方法如下：
1. 关机，插入移动硬盘 2. 在电脑开机的时候，按住cmd + R键 3. 选择`Restore From Time Machine Backup`  等一段时间就好了。还原完毕之后，记得在系统设置的Security &amp;amp; Privacy里面打开FileVault，然后把recovery key备份到一个安全的地方。然后我找回了我要的比较重要的文件。更新、升级系统。还是比较顺利的。
我的SSD大小是120GB。然后我想在把更新后的系统备份到Time Machine里面。系统提示磁盘空间不足，也就是我的移动硬盘里面的Time Machine里面空间不足了，这就比较麻烦了，手上也没有足够空间的移动硬盘了。事实上，合适的Time Machine的空间应该是电脑硬盘空间的两倍，当初我并不知道，所以只分配了一倍。玩手机的时候无意中在国外的一个论坛的不知名的角落里发现一个人七八年之前的回复，说可以在备份的时候剔除某些目录，比如/Users/这个目录。备份完之后，再把被剔除的目录加进来，再备份一次。因为的的Time Machine的剩余空间只有30GB，所以我剔除了/Users/和/Applications这两个目录。成功备份。然后再加入/Users/目录，再备份一次。最后再加入/Applications/目录。继续备份。这个时候即使/Applications/目录的大小大于我的Time Machine的剩余空间，它也没有提示磁盘空间不足，而是会自动删除最老的备份，然后正常备份。挺神奇。为什么最开始的时候它不会自动删除最老的备份呢？
另外，我发现它把2014年的整个备份删除了。没关系，反正我已经把所有的文件分类导出来了。</description>
    </item>
    
    <item>
      <title>做事情分清主次</title>
      <link>http://liuxueyang.github.io/posts/2016-12-25-stop-organize/</link>
      <pubDate>Sun, 25 Dec 2016 19:58:52 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2016-12-25-stop-organize/</guid>
      <description>我花了很长时间在整理移动硬盘里面的文件上面，并且发现工作量十分巨大。一直到晚上，好像还有很多，没办法估计。因为太乱了。在这件优先级不是特别高的事情上，我似乎花了太多的时间，这是不值得的。
所以我打算目前先放弃着手这件事情，我打算平时每天拿出二十分钟来整理硬盘，这样应该会让我觉得工作量小一点，因为这件事情并不是特别紧急，所以可以慢慢来。只是需要坚持下去就是了。
我本来还想折腾一下Slackware这个Linux发行版，不知道为什么，每隔一段时间，总想折腾一点什么，似乎有一点强迫症。刚才我的老电脑上面的Windows 10又出现了奇怪的问题：不能关机。命名按下了关机的按钮，屏幕也黑了。过了一会儿还没有完全关闭，再按一下回车键，就有回到了登录界面。在登录界面直接关机，也是一样的效果。只能强制关机。这种情况对于我这种有点「强迫症」的人来说有点难受啊。不过，还是凑合一下吧，不能完全取代掉Windows，不得不承认，有时候它还是会给我帮上一些忙的。
所以目前最重要的事情就是：学习Android开发，上架一个APP。至于这个APP是什么，我已经有了几个想法，写在了笔记里面，就不在这里写了，随后可能会写一些博客来纪录我遇到的问题或者解决方法等。
说来有点惭愧，我以前，是非常地讨厌Java和Android，要说原因，我也说不上来，反正就是不想看一行的Java程序。现在想想，当初为什么会那样呢？可能还是因为见得少吧，实践得少，经验少，所以才会像个井底之蛙。类似的情况还有，以前特别讨厌Windows、特别喜欢Linux、特别喜欢使用Vim编辑器、特别讨厌使用Emacs编辑器、特别讨厌使用IDE等等。这些都是我以前有过的想法。而现在，我使用Vim也使用Emacs，同时也会使用IDE。对于开发工作，如果有条件能够方便地使用IDE的话，我就会使用IDE；对于日常学习的时候写的小程序或者做日常的笔记，我会使用Emacs；如果要在终端里面临时修改配置文件的话，我会使用Vim；虽然Windows有的时候会出现一些小问题，但是我平时还是会使用它，我甚至还尝试着学过一些C#语言。虽然以前经常性地忍不住折腾不同发行版的Linux，现在也会理性地克制住，稳定下来。所以，人啊，还是要保持一种比较开放的心态，活得也舒服一点。逛一些技术向的论坛的时候，经常看到一些和我以前的想法类似的人，搞得气氛有点奇怪，所以慢慢我也不喜欢逛论坛或者不喜欢看类似类型的帖子了。
好像跑题了。做事情还是应该至少有一个计划，先完成每天的重要的目标，次要或者不重要的等到最后做或者不做。这样工作效率会高一点。而不是忙了很久，却收效甚微。所以还是要克制住自己「跑题」的欲望，把大多数时间投入到重要的事情上面。
「写这篇博客用时36分钟。」</description>
    </item>
    
    <item>
      <title>养成整理的习惯</title>
      <link>http://liuxueyang.github.io/posts/2016-12-23-organize-computer/</link>
      <pubDate>Fri, 23 Dec 2016 20:24:14 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2016-12-23-organize-computer/</guid>
      <description>我的电脑空间不够用了。整理的时候我才发现，我的目录是多么混乱。很多可能用到的、再也用不到的、以前用过的、很久都没有用的各种各样的文档，塞在各种各样的目录下面。有一些照片，很久没有看过，也没有想过要备份一下。很多软件，即使一年也没有用过，也还是在那里。不知道何年何月才有机会打开。很多截图，用过了即使知道以后再也不用了也没想过要删除。网络上下载的图片，没有收藏价值的也从来没有想过要删除。网络上下载的各种文档，没有想过要按照主题分类管理一下。写过的测试程序，有的时候懒得同步到Gitlab、Github或者各种网盘上，就临时放在了本地，从来没有整理过。
当然，移动硬盘里的情况更是惨不忍睹。很多备份，没有分类，还有很多奇怪的重复。
在电脑里面，之前因为想要一个新的环境，就新建了几个用户。现在看来是错误的选择。这更加重了电脑的混乱。我的几个旧电脑都是这样的情况，尤其是Linux系统，更是混乱。
是时候花一些时间来开始整理了。我的想法是这样的：
 把一些不大的文档，全部分类，保存到DropBox里面。最好建立一个索引。  按照使用频率把文档分类，分别放到多个帐号里面，好处是，如果更换平台或者系统的话，我只需要同步最常用的那个帐号里面的文件就好了，同步速度会快一些。其实，DropBox有选择性同步的功能，可是我还是想要保持目录结构的尽量清晰和简洁，这就需要分类，目录尽量少。  把所有的程序相关的东西（别人的程序、自己写的程序），同步到Github、GitLab里面。 多个系统里面的目录结构尽量相同，如果有同步的必要就要同步。并且如果有更新的话，要及时检查更改是不是更新到了网盘里。尽量少出现同步冲突的情况。比如这两天我发现macOS里的DropBox很奇怪地没有同步一个文件，导致出现了冲突，合并两个文件并不是特别好合并（它是特定格式的）。 每个电脑或者系统，可以建立多个用户，但是只有一个主用户，其它用户仅仅在极特殊的情况下使用。  事实上，我每天使用的东西，或者我这一生能够使用的东西是非常有限的。只是我太贪婪，占有了很多根本用不到的东西，除了心理安慰，别的没有什么用。所以，养成每天都整理的习惯，更有条理一点。其实对于我来说啊，还是不要太贪心，能够做好一些事情就已经很不错了。
比如，使用浏览器，不要同时打开五个标签。一个桌面，不要同时打开三个窗口。如果必要的话，使用多个桌面，每个桌面做不同的事情。闲下来或者休息的时候不要顺手就开始刷论坛或者社交网络，休息就好好休息，或者可以出去散散步，因为坐在电脑前面的生活并不是全部，还是要平衡一点。做到有条理其实不困难，可是我从来没有想过去做。
我打算把我之前写过的博客也整理一下，尽量全部迁移到这里来。我发现我还是很喜欢使用这个简单的主题的。很久以前使用过Hexo，尝试过各种各样的主题，反而忘记了最重要的事情。所以我以后也不尝试别的主题了，就长期使用这个默认的主题。经常性地写一些东西，给自己回顾。算起来，我也尝试过很多博客平台了。总是一段时间就放弃了，可能是因为各种各样的原因。这次，希望，不会像以前那样了。
2016年12月26日更新 费了很大力气找到了之前的博客备份。发现以前写的东西真是，看不下去啊。所以咧，就不迁移到这里了。在这个博客里面好好写就是了。</description>
    </item>
    
    <item>
      <title>个人努力</title>
      <link>http://liuxueyang.github.io/posts/2016-12-23-life-labixiaoxin/</link>
      <pubDate>Fri, 23 Dec 2016 17:59:39 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2016-12-23-life-labixiaoxin/</guid>
      <description>人啊，还是依靠个人努力。至于是不是要考虑到历史的进程，对于我来说，倒不是那么重要，毕竟，「我」只有一个，在另外的历史进程里的「我」是什么样子，我不知道。所以我还是过好自己的生活就可以了。
最近，「蜡笔小新」的视频在哔哩哔哩上因为版权原因全部被删除了，唯一的乐趣没有了。不过还好，有良心UP主在直播间里24小时播放蜡笔小新。缺点是不能自己选集看了，优点是至少还有的看。</description>
    </item>
    
    <item>
      <title>第一次使用Jekyll来搭建博客</title>
      <link>http://liuxueyang.github.io/posts/2016-12-23-first-jekyll/</link>
      <pubDate>Fri, 23 Dec 2016 17:39:27 +0800</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2016-12-23-first-jekyll/</guid>
      <description>第一次使用Jekyll来搭建静态博客。这里有一份关于Markdown语法的文档：Markdown，挺不错的。
如果想要在Jekyll的Markdown里面使用Github图标的形式插入Github的项目地址，可以这样：
{% highlight markdown %} {\% include icon-github.html username=&amp;ldquo;username&amp;rdquo; %} / repository-name {% endhighlight %}
注意：需要把上面开头的两个\去掉。
这个博客的源地址在这里：{% include icon-github.html username=&amp;ldquo;replper&amp;rdquo; %} / replper.github.io</description>
    </item>
    
    <item>
      <title>2016</title>
      <link>http://liuxueyang.github.io/posts/2016/</link>
      <pubDate>Fri, 07 Oct 2016 22:12:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2016/</guid>
      <description>玩过 游戏 i wanna 之前看散人优瓦夏玩i wanna游戏挺欢乐。可惜我手残，玩不了这种游戏。最近发现，也许这种游戏是一种比较好的培养耐心的方式吧？今天下午玩了一个多小时，最后手指酸疼。比较神奇的是，我竟然还感觉挺有意思的。过程中完全没想过一定要通关怎么怎么样，只是沉浸在其中，明显感觉到一次比一次好。从开始玩到某一关，总共死了500+次。后来又从开始玩了一遍，到同样的关卡只死了80+次。进步这么明显，我还是蛮惊讶的。当我开始怀疑人生的时候，不妨玩玩i wanna吧。;-)
Besiege 这个游戏在Steam上买了，可惜没怎么玩，看到B站上的大神们玩出各种花样，看着比较过瘾，然而自己还是算了吧。
孢子 很久以前玩过。一开始玩的时候，总是走军事路线，当然是选的简单。今年年初又玩了一次，改成经济路线了，同样也能称霸星球啊哈哈。宇宙阶段没有怎么深入玩。
编辑器 Vim 大学的时候入的Vim坑，给我带来了很多方便，同时，也花费了我极多的时间。我也很难衡量到底值不值得花那么多时间在它上面。不过，确实挺好玩的。它也成了我各种平台的通用编辑器，ssh到树莓派上编辑个什么系统文件啊什么的，首选Vim，我的配置在GitHub上同步。
Emacs 算是今年入的坑。打开了新世界的大门。同样，花费了我极多的时间，我觉得，还是得不偿失的。不过，当配置好之后，还是很方便的。它现在是我日常用的编辑器。只要电脑开着，Emacs就处于打开状态。用LaTeX写日记，写LISP、C/CPP、ML程序之类，还是非常方便的。有些大牛说，一开始学习Emacs就要用大牛们的配置，我倒是不以为然。这个还是因人而异吧。我愿意花时间弄一套自己的配置，优点是，编辑器的插件的每个方面、快捷键之类的自己最清楚，出错了也知道哪里错了。缺点是比较花时间。用别人的配置就不同了，比如Spacemacs它集成了太多东西，有些我根本不需要，绑定的快捷键可能和我的习惯冲突等等。现在我的配置对于我自己来说处于一个比较好的状态，我把它同步到GitLab的私人仓库里面。
RIME 好用的输入法。我用小鹤双拼语句流。打字行云流水。我在Linux，macOS上面都用它。我还把词库和配置文件放到了GitLab的私人仓库里面同步。我没有在Windows 10上面用，因为它和UWP类的应用不兼容，会出现问题，比如让Windows的开始菜单不可用。
操作系统 Windows 10 把家里的旧台式机和新台式机都装上了Windows 10，先安装的盗版Windows 7，然后洗白。使用Windows面向残障人士的升级软件来洗白的。微软官方网站可以下载。Windows 10还是挺好用的。
macOS 把MacBook Air升级到了macOS Sierra，多了Siri的功能，还有别的，比如类似于移动端的画中画的功能。直接升级的，没备份，升级成功。不过Homebrew和MacPorts还需要迁移一下，挺麻烦的。还有一些软件和新版系统不兼容了。。
Linux Arch Linux 我的树莓派上面用的系统，一年多了，没挂过。很稳定。
openSUSE 一台旧电脑用的系统，很稳定，当时也感觉有点臃肿。
Manjaro 挺漂亮的系统，Arch Linux的衍生版，今年第一次尝试它，还是被它给惊艳到了。
Linux Mint 18 Ubuntu的衍生版，优点是，易用。
所有的Linux的桌面环境我都用Xfce，稳如狗哈哈。
路由器 家里的路由器距离我卧室比较远，还隔着墙。所以我用我以前的两个路由器和家里的路由器WPS桥接。效果还不错。需要注意的一点是：只有主路由器需要打开DHCP服务，两个副路由器都不用。我是让一个副路由器B桥接主路由器A，然后让另一个副路由器C桥接到副路由器B。为什么使用C呢，因为我的USB无线网卡的驱动不支持最新版本的Windows 10（某次更新系统之后就连不上网了），所以我把C放到主机旁边，用网线连接电脑。
这大概就是我今年玩过的东西吧。时间过得很快。
很久不来博客园，增加了markdown的功能？不过怎么没有预览功能啊哈哈。</description>
    </item>
    
    <item>
      <title>Spoj, math: CPCRC1C - Sum of Digits</title>
      <link>http://liuxueyang.github.io/posts/spoj-math-cpcrc1c-sum-of-digits/</link>
      <pubDate>Sun, 14 Aug 2016 21:11:34 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/spoj-math-cpcrc1c-sum-of-digits/</guid>
      <description>Primary Problem 题目大意：
给两个数字a和b，求从a到b所有数字的每一位的和。比如1到3就是：1+2+3=6, 10到12 就是：1+0 + 1+1 + 1+2=6，范围是10^9  为了表示方便，用[n]表示从1到n的所有数字的每一位的和。要求从a到b，只需要计算[b] - [a]就可以。
[9] = 45; [19] = [9] + [9] + 10 * 1 = [9] * 2 + 10 * 1 [99] = [9] + ([9] + 10 * 1) + ([9] + 10 * 2) + ... + ([9] + 10 * 9) = = [9] * 10 + 10 * [9] [999] = [99] + ([99] + 100 * 1) + ([99] + 100 * 2) + ([99] + 100 * 3) + .</description>
    </item>
    
    <item>
      <title>Spoj: ANARC09A - Seinfeld</title>
      <link>http://liuxueyang.github.io/posts/spoj-anarc09a-seinfeld/</link>
      <pubDate>Sun, 14 Aug 2016 15:59:14 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/spoj-anarc09a-seinfeld/</guid>
      <description>题目意思：
一个字符串由`{`和`}`组成，长度最多位2000，求最少修改多少次可以使得这个字符串合法。  如果把合法的字符串都消去的话，那么最后留下不合法的括号，一定是这样的}*{*其中 *代表0个或者多个。题目规定字符串长度是偶数，所以不合法的括号的长度也一定是偶数， 假设它是len。
1. 如果只有左括号或者右括号，那么答案是`len/2`； 2. 如果左右括号都有，那么答案是左括号的个数/2 + 右括号的个数 / 2，如果左括号 或者右括号的个数是奇数，那么答案增加一。比如这个例子：`}}}{{{`  所以复杂度是O(n)。
/* * ===================================================================================== * * Filename: main.cpp * * Description: http://www.spoj.com/problems/ANARC09A/ * * Version: 1.0 * Created: 2016年08月14日 14时01分45秒 * Compiler: g++ * * Author: Sabastian (liuxueyang.github.io), read3valprintloop@gmail.com * * ===================================================================================== */ #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; #define _ ios_base::sync_with_stdio(0);cin.tie(0); #define rep(i, a, n) for (int i = a; i &amp;lt; n; ++i) #define per(i, a, n) for (int i = n-1; i &amp;gt;= a; --i) #define pb push_back #define mp make_pair #define all(x) (x).</description>
    </item>
    
    <item>
      <title>Spoj, dynamic-programming: ASSIGN - Assignments</title>
      <link>http://liuxueyang.github.io/posts/spoj-dynamic-programming-assign-assignments/</link>
      <pubDate>Sun, 14 Aug 2016 15:08:27 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/spoj-dynamic-programming-assign-assignments/</guid>
      <description>题目意思：
有n个学生和n个任务，每个学生有喜欢的任务，输入一个矩阵，第i行第j列表示第i个 学生喜欢第j个任务。把任务分配给所有学生，使得每个学生得到的任务都是他喜欢的。 输出有多少种分配方法。n的最大值是20。  用一个数字的一个位表示这个任务是否已经被分配，如果任务全部被分配，那么这个数字就 是(1&amp;lt;&amp;lt;n)-1。可以想到这样的递归方法：solve(i,mask) 表示对i..n这些人分配任务的 方法的数目，mask代表此时对1..i-1这些人已经分配了任务，也就是说mask的二进制表示里 面有i-1个1。对当前的人，如果他喜欢第j个任务，并且mask的第j位是0，那么就可以把这 个任务分配给他，继续考虑下一个人。
/* * ===================================================================================== * * Filename: main1.cpp * * Description: http://www.spoj.com/problems/ASSIGN/ * * Version: 2.0 * Created: 08/13/2016 14:13:42 * Compiler: g++ * * Author: Sabastian (liuxueyang.github.io), read3valprintloop@gmail.com * * ===================================================================================== */ #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; #define _ ios_base::sync_with_stdio(0);cin.tie(0); #define rep(i, a, n) for (int i = a; i &amp;lt; n; ++i) #define per(i, a, n) for (int i = n-1; i &amp;gt;= a; --i) #define pb push_back #define mp make_pair #define all(x) (x).</description>
    </item>
    
    <item>
      <title>Spoj, dynamic-programming: AIBOHP - Aibohphobia</title>
      <link>http://liuxueyang.github.io/posts/spoj-dynamic-programming-aibohp-aibohphobia/</link>
      <pubDate>Fri, 12 Aug 2016 21:36:32 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/spoj-dynamic-programming-aibohp-aibohphobia/</guid>
      <description>给一个字符串，求最少插入多少个字符，可以使得这个字符串是回文的。
可以这样想：我们假设它已经是回文的，那么把这个字符串逆序，如果它是回文的，那么对 应的每个字符应该相等。可以它不是回文的，那么就需要尽量少地加一些字符，加多少呢？ 那么需要知道当前的最长连续公共子序列的长度len，把不相等的那些字符串加进去就成为 了回文的。加进去的字符的最少个数 = 字符串长度 - 原先的字符串和它的逆序字符串的最 长连续公共子序列的长度。
问题就转化为求两个序列的最长公共子序列。这个就简单了。
因为懒并且想省时间，所以就用了一些宏，这让程序变得不易读，还好程序比较简单，不太 影响吧。反正以后也不会再读。。了解思路就可以了。
/* * ===================================================================================== * * Filename: main.cpp * * Description: http://www.spoj.com/problems/AIBOHP/ * * Version: 1.0 * Created: 08/12/2016 18:27:30 * Compiler: g++ * * Author: Sabastian (liuxueyang.github.io), liuxueyang457@gmail.com * * ===================================================================================== */ #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; #define _ ios_base::sync_with_stdio(0);cin.tie(0); #define rep(i, a, n) for (int i = a; i &amp;lt; n; ++i) #define per(i, a, n) for (int i = n-1; i &amp;gt; a; --i) #define pb push_back #define mp make_pair #define all(x) (x).</description>
    </item>
    
    <item>
      <title>Spoj, dynamic-programming: BYTESM2 - Philosophers Stone</title>
      <link>http://liuxueyang.github.io/posts/spoj-dynamic-programming-bytesm2-philosophers-stone/</link>
      <pubDate>Fri, 12 Aug 2016 21:32:26 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/spoj-dynamic-programming-bytesm2-philosophers-stone/</guid>
      <description>在矩阵里面捡石头，求最大值。和常见的直角三角形那样的问题是一样的。
/* * ===================================================================================== * * Filename: main.cpp * * Description: http://www.spoj.com/problems/BYTESM2/ * * Version: 1.0 * Created: 08/12/2016 18:49:12 * Compiler: g++ * * Author: Sabastian (liuxueyang.github.io), liuxueyang457@gmail.com * * ===================================================================================== */ #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; #define _ ios_base::sync_with_stdio(0);cin.tie(0); #define rep(i, a, n) for (int i = a; i &amp;lt; n; ++i) #define per(i, a, n) for (int i = n-1; i &amp;gt;= a; --i) #define pb push_back #define mp make_pair #define all(x) (x).</description>
    </item>
    
    <item>
      <title>Dynamic-programming: Spoj DIEHARD - DIE HARD</title>
      <link>http://liuxueyang.github.io/posts/dynamic-programming-spoj-diehard-die-hard/</link>
      <pubDate>Fri, 12 Aug 2016 21:14:23 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/dynamic-programming-spoj-diehard-die-hard/</guid>
      <description>题目很好理解：
有三个区域，你在每个区域里面只能停留一秒，每个区域会对你的两个指标h和a增加或者减少： 区域A：h += 3, a += 2 区域B：h -= 5, a -= 10 区域C：h -= 20, a+= 5 你在任意区域最多只能停留1秒，下一秒必须移动到其它两个区域中的一个，也就是说 你不能一直呆在一个区域。在任意时刻，如果你的两个指标其中的任意一个&amp;lt;=0，那么 游戏结束，输出你一共在游戏里面停留了多长时间。  如果不加什么思考，那么容易想到，直接递归就可以了，递归函数有三个参数：当前的h值， 当前的a值，当前的位置。为了不重复求解，用一个三位数组存储这一步的结果。
程序如下：
/* * ===================================================================================== * * Filename: main.cpp * * Description: http://www.spoj.com/problems/DIEHARD/ * * Version: 1.0 * Created: 08/12/2016 20:04:27 * Compiler: g++ * * Author: Sabastian (liuxueyang.github.io), liuxueyang457@gmail.com * * ===================================================================================== */ #include &amp;lt;bits/stdc++.h&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; #define _ ios_base::sync_with_stdio(0);cin.tie(0); #define rep(i, a, n) for (int i = a; i &amp;lt; n; ++i) #define per(i, a, n) for (int i = n-1; i &amp;gt;= a; --i) #define pb push_back #define mp make_pair #define all(x) (x).</description>
    </item>
    
    <item>
      <title>show and hide dot files in Finder of OS X El Capitan</title>
      <link>http://liuxueyang.github.io/posts/show-and-hide-dot-files-in-finder-of-os-x-el-capitan/</link>
      <pubDate>Thu, 04 Aug 2016 10:39:01 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/show-and-hide-dot-files-in-finder-of-os-x-el-capitan/</guid>
      <description>Fish Run the following code in fish shell. Then it works as a charm. :-)
function showFiles defaults write com.apple.finder AppleShowAllFiles YES killall Finder /System/Library/CoreServices/Finder.app end funcsave showFiles function hideFiles defaults write com.apple.finder AppleShowAllFiles NO killall Finder /System/Library/CoreServices/Finder.app end funcsave hideFiles  :joy:
zsh Add the following code to ~/.zshrc
alias showFiles=&#39;defaults write com.apple.finder AppleShowAllFiles YES; killall Finder /System/Library/CoreServices/Finder.app&#39; alias hideFiles=&#39;defaults write com.apple.finder AppleShowAllFiles NO; killall Finder /System/Library/CoreServices/Finder.app&#39;  then run source ~/.</description>
    </item>
    
    <item>
      <title>Text Adventure Game in Land of Lisp</title>
      <link>http://liuxueyang.github.io/posts/text-adventure-game-in-land-of-lisp/</link>
      <pubDate>Mon, 01 Aug 2016 23:19:46 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/text-adventure-game-in-land-of-lisp/</guid>
      <description>Land of LiSP 这本书里面的第五章和第六章构建了一个字符冒险游戏，游戏截图如下：
;; 2016.07.30 23:22:41 PM ;; Sabastian ;; building a text adventure game engine ;; ==================== ;; location (defparameter *nodes* &#39;((living-room (you are in the living-room. a wizard is snoring loudly on the couch.)) (garden (you are in a beautiful garden. there is a well in front of you.)) (attic (you are in the attic. there is a giant welding torch in the corner.)))) (defun describe-location (location nodes) &amp;quot;location is a symbol.</description>
    </item>
    
    <item>
      <title>2016/07/31 17:43:50 PM 杂事</title>
      <link>http://liuxueyang.github.io/posts/2016-07-31-17-43-50-pm-%E6%9D%82%E4%BA%8B/</link>
      <pubDate>Sun, 31 Jul 2016 17:44:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2016-07-31-17-43-50-pm-%E6%9D%82%E4%BA%8B/</guid>
      <description>这两天开始重新读 Land of LISP 这本书，之前只读到了第六章，这次重头开始复习一遍， 发现这本书写的挺有意思，循序渐进，并且也特别有趣。目前的节奏是每天读一章到两章的 样子。我买的是原版的英文书，读书的过程中体会到，纸质书的质量对阅读心情特别重要！ 好的书就让人有阅读欲望，甚至愿意经常抱着它读，看完也会收藏起来，国外的书那么贵其 实也有道理，书的质量好啊……然而国内的很多引进的计算机的书虽然卖的便宜，然而质量并 不能和人家比。。
写LISP的时候一直都用Spacemacs，然后我现在变得也日常用Emacs了……除非临时在终端配置 个文件什么的懒得打开Emacs还得忍受它缓慢的启动速度，这种时候我依然是用Vim愉快地解 决问题。其它时候，用Emacs的org-mode写文档、写博客、写程序之类的，全在Emacs里面完 成。生活变得轻松了许多 :joy:
夏天来了，下午经常犯困，睡好久……下午战斗力骤减，不过也好，睡醒了精神了之后，看书 也变得更愉快 :joy:
TeXmacs其实对于英文文档的书写来说，蛮不错的，写公式、创建表格什么的都很方便，然 而对与中文来说，就是个坑了……并且，在Mac里面，经！常！闪！退！真是醉了。看来关键 时候，还是不能偷懒，中文还是老老实实LaTeX加ctex之类的宏包吧 :joy:
之前学会了双拼之后，日常就用双拼输入法，越来越觉得，这货真是好东西，希望用全拼的 每个人都能有机会尝试一下，我用的是Rime的小鹤双拼。Spacemacs对像我这种的Emacs小白 用户来说真是福音啊！对我来说，这就是完美的配置，避免了自己配置、然后推翻自己的配 置、然后重新配置、插件之间有冲突之类的这些坑。如果早早用上Spacemacs可能会省下不 少时间吧。
哦，最近，把哈利波特系列电影除了最后一部混血王子全部看了一遍，唉，挺遗憾的吧，我 记得小学的时候只买了哈利波特与混血王子那本书，如果当时看的是第一部的话，可能就不 一样了吧。。
说出来可能有点残酷，你是什么样的人，你有过什么样的经历，你做过什么样的事情，你就 会产生什么样的偏见，你就会成会什么样的人。。。这一点，我似乎有了进一步体会。。
为了节省时间，还是少刷B站。。
做事情，还是要善始善终，靠谱一点。惭愧。 :cry:
七月的最后一天，随意写写。说起七月，突然想起 七月上这首歌</description>
    </item>
    
    <item>
      <title>spoj, segment tree: KGSS - Maximum Sum</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-kgss-maximum-sum/</link>
      <pubDate>Tue, 26 Jul 2016 08:58:52 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-kgss-maximum-sum/</guid>
      <description>Problem Link
每个节点保存三个值：区间的最大值，区间的第二大值，区间的最大的两个数的和
平常的区间的点更新和区间查询
// 2016/07/25 19:29:33 PM // Sabastian #include &amp;lt;iostream&amp;gt; #include &amp;lt;math.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; using namespace std; typedef long long ll; typedef struct TreeNode { int start, end; int Max, SecMax, sum; TreeNode() : SecMax(-1) {} void merge(TreeNode &amp;amp; left, TreeNode &amp;amp; right) { sum = max(left.sum, max(right.sum, left.Max + right.Max)); Max = max(left.Max, right.Max); SecMax = min(left.Max, right.Max); } } TreeNode; TreeNode tree[4 * 100000 + 10]; ll a[4 * 100000 + 10]; void update(int stIndex, int start, int end); void printNode(int stIndex) { TreeNode &amp;amp;t = tree[stIndex]; printf(&amp;quot;%d (%d, %d), total=%d\n&amp;quot;, stIndex, t.</description>
    </item>
    
    <item>
      <title>spoj, segment tree: HORRIBLE - Horrible Queries</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-horrible-horrible-queries/</link>
      <pubDate>Mon, 25 Jul 2016 23:25:39 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-horrible-horrible-queries/</guid>
      <description>Problem Link
平常的线段树区间更新和区间查询
// 2016/07/22 14:38:03 PM // Sabastian #include &amp;lt;iostream&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; using namespace std; typedef long long ll; typedef struct TreeNode { int start, end; ll total; ll lazy; } TreeNode; TreeNode tree[4 * 100000 + 10]; void printNode(int stIndex) { TreeNode &amp;amp;t = tree[stIndex]; printf(&amp;quot;(%d, %d), lazy=%lld, total=%lld\n&amp;quot;, t.start, t.end, t.lazy, t.total); } void build(int stIndex, int start, int end) { tree[stIndex].start = start; tree[stIndex].end = end; tree[stIndex].</description>
    </item>
    
    <item>
      <title>spoj, segment tree: GSS4 - Can you answer these queries IV</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-gss4-can-you-answer-these-queries-iv/</link>
      <pubDate>Mon, 25 Jul 2016 23:19:05 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-gss4-can-you-answer-these-queries-iv/</guid>
      <description>Problem Link
这道题目并没有用到懒惰更新，只是有一个优化：当一个区间的和等于区间长度的时候，那么他就没有必要更新了。
平常的线段树区间更新和区间查询
另外注意，题目中并没有说X和Y的大小关系。。
// 2016/07/22 19:58:12 PM // Sabastian #include &amp;lt;iostream&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;math.h&amp;gt; using namespace std; typedef long long ll; typedef struct TreeNode { int start, end; ll total; } TreeNode; TreeNode tree[4 * 100000 + 10]; ll a[4 * 100000 + 10]; void update(int stIndex, int start, int end); void printNode(int stIndex) { TreeNode &amp;amp;t = tree[stIndex]; printf(&amp;quot;%d (%d, %d), total=%lld\n&amp;quot;, stIndex, t.start, t.</description>
    </item>
    
    <item>
      <title>spoj, segment tree: GSS3 - Can you answer these queries III</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-gss3-can-you-answer-these-queries-iii/</link>
      <pubDate>Mon, 25 Jul 2016 23:16:44 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-gss3-can-you-answer-these-queries-iii/</guid>
      <description>Problem Link
similar to GSS1 in addition to point update in segment tree.
#include &amp;lt;iostream&amp;gt; using namespace std; struct SegmentTreeNode { int pre, suf, sub, total; void assignLeaf(int value) { pre = suf = sub = total = value; } void merge(SegmentTreeNode &amp;amp;left, SegmentTreeNode &amp;amp;right) { pre = max(left.pre, left.total + right.pre); suf = max(left.suf + right.total, right.suf); sub = max(left.sub, max(right.sub, left.suf + right.pre)); total = left.total + right.total; return; } int getValue() { return sub; } }; template &amp;lt;class T, class V&amp;gt; class SegmentTree { SegmentTreeNode *nodes; int N; public: SegmentTree(T arr[], int N) { this-&amp;gt;N = N; nodes = new SegmentTreeNode[getSegmentTreeSize(N)]; buildTree(arr, 1, 0, N - 1); } ~SegmentTree() { delete[] nodes; } V getValue(int lo, int hi) { SegmentTreeNode result = getValue(1, 0, N - 1, lo, hi); return result.</description>
    </item>
    
    <item>
      <title>spoj, segment tree: GSS1 - Can you answer these queries I</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-gss1-can-you-answer-these-queries-i/</link>
      <pubDate>Mon, 25 Jul 2016 23:07:09 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-gss1-can-you-answer-these-queries-i/</guid>
      <description>Problem Link
max sum of a sequence can be from one of the three:
1. left half of the sequence 2. right half of the sequence 3. left half + right half  segment tree range query
#include &amp;lt;iostream&amp;gt; using namespace std; struct SegmentTreeNode { int pre, suf, sub, total; void assignLeaf(int value) { pre = suf = sub = total = value; } void merge(SegmentTreeNode &amp;amp;left, SegmentTreeNode &amp;amp;right) { pre = max(left.</description>
    </item>
    
    <item>
      <title>spoj, segment tree: BRCKTS - Brackets</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-brckts-brackets/</link>
      <pubDate>Mon, 25 Jul 2016 22:56:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-brckts-brackets/</guid>
      <description>Problem Link
开始没有读懂题目，合法括号的意思其实就是常识情况下的括号合法：整个序列的左括号数目和右括号的数目相同，但是也不能出现这样的：)))(((，所以还要保证在任意一点，左括号的数目大于等于右括号的数目。
这就需要，在序列里面任意一点，左边的不匹配的左括号的数目一定等于右边的不匹配右括号的数目。
平常的线段树的点更新和区间查询
#include &amp;lt;iostream&amp;gt; using namespace std; struct SegmentTreeNode { int unmatchedLeft, unmatchedRight; void assignLeaf(char value) { if (value == &#39;(&#39;) { unmatchedLeft = 1; unmatchedRight = 0; } else { unmatchedLeft = 0; unmatchedRight = 1; } } void merge(SegmentTreeNode &amp;amp;left, SegmentTreeNode &amp;amp;right) { int L_unl = left.unmatchedLeft, L_unr = left.unmatchedRight, R_unl = right.unmatchedLeft, R_unr = right.unmatchedRight; int matched = min(L_unl, R_unr); unmatchedLeft = L_unl + R_unl - matched; unmatchedRight = L_unr + R_unr - matched; return; } bool getValue() { return unmatchedRight == 0 &amp;amp;&amp;amp; unmatchedLeft == 0; } }; template &amp;lt;class T, class V&amp;gt; class SegmentTree { SegmentTreeNode *nodes; int N; public: SegmentTree(T arr[], int N) { this-&amp;gt;N = N; nodes = new SegmentTreeNode[getSegmentTreeSize(N)]; buildTree(arr, 1, 0, N - 1); } ~SegmentTree() { delete[] nodes; } V getValue(int lo, int hi) { SegmentTreeNode result = getValue(1, 0, N - 1, lo, hi); return result.</description>
    </item>
    
    <item>
      <title>spoj, segment tree: AKVQLD03 - How to Handle the Fans</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-akvqld03-how-to-handle-the-fans/</link>
      <pubDate>Mon, 25 Jul 2016 22:49:37 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-akvqld03-how-to-handle-the-fans/</guid>
      <description>Problem Link
平常的线段树点更新和区间查询
#include &amp;lt;iostream&amp;gt; #include &amp;lt;string.h&amp;gt; using namespace std; struct SegmentTreeNode { // fields on the node long long sum; void assignLeaf(int value) { sum = value; } void merge(SegmentTreeNode &amp;amp;left, SegmentTreeNode &amp;amp;right) { sum = left.sum + right.sum; } long long getValue() { return sum; } }; template &amp;lt;class T, class V&amp;gt; class SegmentTree { SegmentTreeNode *nodes; int N; public: SegmentTree(T arr[], int N) { this-&amp;gt;N = N; nodes = new SegmentTreeNode[getSegmentTreeSize(N)]; buildTree(arr, 1, 0, N - 1); } ~SegmentTree() { delete[] nodes; } V getValue(int lo, int hi) { SegmentTreeNode result = getValue(1, 0, N - 1, lo, hi); return result.</description>
    </item>
    
    <item>
      <title>segment tree, lazy propagation, codechef: Flipping Coins</title>
      <link>http://liuxueyang.github.io/posts/codechef-flipping-coins/</link>
      <pubDate>Mon, 25 Jul 2016 22:40:35 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codechef-flipping-coins/</guid>
      <description>Problem Link
平常的线段树区间更新、区间查询加上懒惰更新
// 2016/07/24 22:01:19 PM // Sabastian #include &amp;lt;iostream&amp;gt; #include &amp;lt;math.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; using namespace std; typedef long long ll; typedef struct TreeNode { int start, end; ll total; bool lazy; TreeNode() : total(0), lazy(false) {} void merge(TreeNode &amp;amp; left, TreeNode &amp;amp; right) { total = (left.lazy ? left.end - left.start + 1 - left.total : left.total) + (right.lazy ? right.end - right.start + 1 - right.</description>
    </item>
    
    <item>
      <title>iTerm2 查看图片</title>
      <link>http://liuxueyang.github.io/posts/iterm2-%E6%9F%A5%E7%9C%8B%E5%9B%BE%E7%89%87/</link>
      <pubDate>Mon, 11 Jul 2016 18:14:26 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/iterm2-%E6%9F%A5%E7%9C%8B%E5%9B%BE%E7%89%87/</guid>
      <description>首先是，OS X El Capitan的几个截图技巧：
 ⌘ + ⇪ + 3 ：全屏截图，并且把截图保存在桌面。 ⌘ + ⇪ + 4 ：区域截图，可以自由拖动大小，松开触摸板自动保存截图到桌面。 ⌘ + ⇪ + 4 ，然后，单击空格键，可以选定窗口截图。（这么好用的快捷键我很长时间都不知道……） ⌘ + ⇪ + 4，然后用触摸板选定一个矩形区域，然后，按住空格键，再拖动鼠标，就可以发现，矩形区域跟随鼠标移动，但是大小不变。 ⌘ + ⇪ + 4，选定一个矩形区域，然后，按住 ⇪ 键，然后鼠标如果在左右方向移动，那么你可以发现矩形区域高度被锁定；如果在按住 ⇪ 键的同时，鼠标在上下方向移动，那么左右方向被锁定。 ⌘ + ⇪ + 4，选定一个矩形区域，按住 ⇪ 和 ⌥ 键，再拖动鼠标，可以发现，矩形区域在锁定一个方向的基础上，在水平或者数值方向上呈对称性变化。  在终端里面的时候，有时需要查看一下图片到底是不是想要的那一张，然而并不想在打开finder看，所以，这个功能就比较有用了，如图：
更多用法，看这里</description>
    </item>
    
    <item>
      <title>POJ3320 Jessica&#39;s Reading Problem</title>
      <link>http://liuxueyang.github.io/posts/poj3320-jessica-s-reading-problem/</link>
      <pubDate>Sun, 03 Jul 2016 19:00:24 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj3320-jessica-s-reading-problem/</guid>
      <description>Problem Jessica&amp;rsquo;s Reading Problem
Solution 方法和Subsequence一样，只是增加一个计数的步骤。
Code C++ #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; using namespace std; const int MAX_N = 100 * 10000 + 1; int a[MAX_N], n; set&amp;lt;int&amp;gt; idea; map&amp;lt;int, int&amp;gt; num_idea; void solve() { idea.clear(); num_idea.clear(); for (int i = 0; i &amp;lt; n; ++i) { idea.insert(a[i]); } int all_ideas = (int)idea.size(); int s = 0, t = 0, cnt = 0, ans = n + 1; while (true) { while (t &amp;lt; n &amp;amp;&amp;amp; cnt &amp;lt; all_ideas) { if (num_idea[a[t]] == 0) { cnt++; } num_idea[a[t]]++; ++t; } if (cnt &amp;lt; all_ideas) { break; } ans = min(ans, t - s); num_idea[a[s]]--; if (num_idea[a[s]] == 0) { num_idea.</description>
    </item>
    
    <item>
      <title>Poj3061 Subsequence</title>
      <link>http://liuxueyang.github.io/posts/poj3061-subsequence/</link>
      <pubDate>Sat, 02 Jul 2016 16:58:15 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj3061-subsequence/</guid>
      <description>Problem Subsequence
Solution 方法一：O(nlogn)
1. 计算前序和 2. 定起点，二分找不小于S的最小的连续区间和  方法二：O(n)
1. 定起点，线性找不小于S的最小的连续区间和，得到一个终点 2. 把起点向右移动一个单位，把终点在原来的基础上递增，线性找不小于S的最小的连 续区间和。如此反复。  Code 方法一：
C++ #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; int N, S; vector&amp;lt;int&amp;gt; a, presum; void solve() { cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; S; presum.clear(); a.clear(); a.reserve(N); presum.reserve(N + 1); for (int i = 0; i &amp;lt; N; ++i) { int tmp; cin &amp;gt;&amp;gt; tmp; a.push_back(tmp); } // presum[i] means sum of [0, i) elements // j &amp;gt; i, presum[j] - presum[i] means sum of [i, j) elements presum.</description>
    </item>
    
    <item>
      <title>Educational Codeforces Round 10. D. Nested Segments: c&#43;&#43;, perl and common lisp implementation, Segment Tree</title>
      <link>http://liuxueyang.github.io/posts/educational-codeforces-round-10-d-nested-segments-c-perl-and-common-lisp-implementation/</link>
      <pubDate>Fri, 01 Jul 2016 07:53:06 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/educational-codeforces-round-10-d-nested-segments-c-perl-and-common-lisp-implementation/</guid>
      <description>Problem Link
Fenwick Tree，它的本质就是把一个序列的和划分成一个个子序列的和。比如一个序列的长 度是10，那么10的二进制是1010，也就是2^1 + 2^3，所以结果就是树里面2和8两个节点的 和。在树里面，节点（n）表示数列里从1到n的元素的和，那么：
 (1) = (1) (2) = (2) (3) = (1) + (2) (4) = (4) (5) = (1) + (4) (6) = (2) + (4)   按照右端点排序，然后把它离散化； 按照左端点倒序排列，从大到小循环，计算右端点在Fenwick Tree里面的presum（也就 是之前插入的比当前右端点小的数量），这个presum就是当前的segment包含的segment 的个数； 把当前右端点插入Fewnwick Tree；  题目要求计算每个端点包含的segment的数量，因为后面要用到排序和离散化，所以可以在 结构体或者类中增加一个域表示它原来在数组中的初始位置。每计算一个presum就可以根据 这个域放到结果数组里面的对应位置。
C++ #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; struct segment { int x, y, position; }; const int N = 2e5 + 1; int n, fenwick[N]; long long ans[N]; segment S[N]; int cmpx_r(segment a, segment b) { return a.</description>
    </item>
    
    <item>
      <title>Binary Search Tree: Perl and Common Lisp implementation</title>
      <link>http://liuxueyang.github.io/posts/binary-search-tree-perl-and-common-lisp-implementation/</link>
      <pubDate>Thu, 30 Jun 2016 08:33:38 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/binary-search-tree-perl-and-common-lisp-implementation/</guid>
      <description>Perl #!perl use strict; use warnings; use utf8; use 5.014; # insert given value into the proper position. If no tree provided, # use implicit pass by reference aspect of @_ to fill one. sub insert { my($tree, $value) = @_; unless ($tree) { $tree = {}; $tree-&amp;gt;{VALUE} = $value; $tree-&amp;gt;{LEFT} = undef; $tree-&amp;gt;{RIGHT} = undef; $_[0] = $tree; # $_[0] is reference param return; } if ($tree-&amp;gt;{VALUE} &amp;gt; $value) { insert($tree-&amp;gt;{LEFT}, $value) } elsif ($tree-&amp;gt;{VALUE} &amp;lt; $value) { insert($tree-&amp;gt;{RIGHT}, $value) } else { warn &amp;quot;duplicate insert of $value\n&amp;quot; } } sub in_order { my($tree) = @_; return unless $tree; in_order($tree-&amp;gt;{LEFT}); print $tree-&amp;gt;{VALUE}, &amp;quot; &amp;quot;; in_order($tree-&amp;gt;{RIGHT}); } sub pre_order { my($tree) = @_; return unless $tree; print $tree-&amp;gt;{VALUE}, &amp;quot; &amp;quot;; pre_order($tree-&amp;gt;{LEFT}); pre_order($tree-&amp;gt;{RIGHT}); } sub post_order { my($tree) = @_; return unless $tree; post_order($tree-&amp;gt;{LEFT}); post_order($tree-&amp;gt;{RIGHT}); print $tree-&amp;gt;{VALUE}, &amp;quot; &amp;quot;; } sub search { my($tree, $value) = @_; return unless $tree; return $tree if ($tree-&amp;gt;{VALUE} == $value); search ($tree-&amp;gt;{ ($value &amp;lt; $tree-&amp;gt;{VALUE}) ?</description>
    </item>
    
    <item>
      <title>Lowest common ancestor in binary tree: perl, c and common lisp implementation</title>
      <link>http://liuxueyang.github.io/posts/lowest-common-ancestor-in-binary-tree-perl-c-and-common-lisp-implementation/</link>
      <pubDate>Mon, 27 Jun 2016 17:32:47 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/lowest-common-ancestor-in-binary-tree-perl-c-and-common-lisp-implementation/</guid>
      <description>Find lowest common ancestor in binary tree. We assume the values in the tree are unique and the two values are always in the tree.
Time complexity O(n), Space complexity O(n)
C: #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; // Find lowest common ancestor in binary tree. We assume the // values in the tree are unique and the two values are always in // the tree. // Time complexity O(n) // Space complexity O(n) typedef struct Node { int key; struct Node *left, *right; } Node; Node* createNode(int key) { Node * tmp = (Node*)malloc(sizeof(Node)); tmp-&amp;gt;key = key; tmp-&amp;gt;left = tmp-&amp;gt;right = NULL; return tmp; } Node* findLCA(Node* root, int n1, int n2) { if (root == NULL) { return NULL; } if (n1 == root-&amp;gt;key || n2 == root-&amp;gt;key) { return root; } Node* left = findLCA(root-&amp;gt;left, n1, n2); Node* right = findLCA(root-&amp;gt;right, n1, n2); if (left &amp;amp;&amp;amp; right) { return root; } return left ?</description>
    </item>
    
    <item>
      <title>Fenwick Tree</title>
      <link>http://liuxueyang.github.io/posts/fenwick-tree/</link>
      <pubDate>Mon, 27 Jun 2016 00:54:39 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/fenwick-tree/</guid>
      <description>Fenwick Tree的原理是，把一个前缀和划分成多个子序列的和，子序列的个数是当前前缀和元素个数的数字二进制表示中的1的个数。
Perl实现：
#!/usr/bin/env perl -n #=============================================================================== # FILE: fenwick_tree.pl # AUTHOR: Sabastian (liuxueyang.github.io), liuxueyang457@gmail.com # ORGANIZATION: Hunan University # CREATED: 2016/06/26 23时27分06秒 #=============================================================================== use strict; use warnings; use utf8; use 5.014; chomp; my @fenwick; my @array = split; unshift @array, 0; unshift @fenwick, 0; sub lowbit { $_[0] &amp;amp; -$_[0]; } sub build_fenwick_tree { for (1..$#array) { for my $j ($_-lowbit($_)+1..$_) { $fenwick[$_] += $array[$j] } } } sub modify_fenwick_tree { # two arguments # 1.</description>
    </item>
    
    <item>
      <title>推荐Rime小鹤双拼输入法</title>
      <link>http://liuxueyang.github.io/posts/%E6%8E%A8%E8%8D%90rime%E5%B0%8F%E9%B9%A4%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95/</link>
      <pubDate>Fri, 17 Jun 2016 08:02:11 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E6%8E%A8%E8%8D%90rime%E5%B0%8F%E9%B9%A4%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95/</guid>
      <description>之前一直没有时间配置我的OS X上的Rime输入法。所以我最近认真配置了一下。首先，推荐 一篇博客： 安装及配置 Mac 上的 Rime 输入法——鼠鬚管 (Squirrel) 这是一篇好博客。然而复制配置文件的时候，还是不能直接复制到编辑器里面，一定要注意 格式！因为这篇博客，我发现了小鹤双拼输入法，然后随便找了一篇关于小鹤双拼的文章： 做少数派中的少数派：双拼输入快速入门 看了一下里面的键位映射图，大概理解了一下，就马上开始用了。也没怎么刻意记忆，不知 道哪个键就看一下那个图，和朋友聊了几句，就可以打字了，虽然很慢，但是可以接受。前 天晚上开始接触，昨天上午就可以愉快地打字了。到现在大概用了一天半的时间，我就可以 用双拼愉快地写这篇博客了。
愚笨如我也能够这么快地接受这个输入法，所以它的学习成本还真的是挺低的。然而打字效 率比原来的全拼却好很多。每个汉字拼音分成声母和韵母，每个声母和韵母只需要一次按键， 不得不说，很适合用汉语拼音打汉字。哈哈，用词根输入英语可能就没这么方便了？:joy: :joy:
另外，我也可以同步Rime的用户资料了。然后再同步到Gitlab的私人仓库里面，完美！另外， 那篇博客也介绍了如何配置小鹤双拼・语句流输入法，这样就可以中英混输并且还带emoji 了！简直Perfect流畅。
时间好快，麦子熟了。</description>
    </item>
    
    <item>
      <title>Karabiner —— 自定义MacBook Air键盘</title>
      <link>http://liuxueyang.github.io/posts/karabiner--%E8%87%AA%E5%AE%9A%E4%B9%89macbook-air%E9%94%AE%E7%9B%98/</link>
      <pubDate>Wed, 15 Jun 2016 11:25:11 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/karabiner--%E8%87%AA%E5%AE%9A%E4%B9%89macbook-air%E9%94%AE%E7%9B%98/</guid>
      <description>一直以来，我的MacBook Air的键盘有几个键总是莫名其妙不灵。。换了一次键盘，然而问 题依旧，并且，问题不好重现，仿佛它不高兴了就不灵了。。这给打字带来了极大的不爽。。 所以我的解决办法是外接键盘。。或者外接USB键盘，或者外接蓝牙键盘。然而，这便携性 就没有了。。还要经常担心我那个蓝牙键盘的支脚是不是压倒了原装键盘的某个功能键什么 的。。。所以就很蛋疼。。
所以为了解决蓝牙键盘经常压到Air的原装键盘的问题，我就在原装键盘上面垫上一本小书， 一定程度上解决了这个问题。。然后我就去淘宝搜有没有买专用的板子的啊。。:joy: :joy: 原来我的思路也蛮开阔的。。并没有，随手在Bing搜了一下，看到了V2EX的一个帖子 说如何关闭MacBook Air自带的键盘，诶？这倒是一个办法。然后我就开始折腾了：
下载了Karabiner这个软件。然后就开 始找怎么把某个组合键映射到经常失灵的U键。打开Karabiner的Preferences，看了一下 Change Key那个标签并没有什么头绪。然后看到Misc &amp;amp; Uninstall这个标签里面有一个 Custom Setting：
绝壁八成是这个了。。然后在Karabiner的官网里面的Documents里面找到了这个文档： private.xml Reference Manual照着加 了下面的配置：
 &amp;lt;item&amp;gt; &amp;lt;name&amp;gt;Change &#39;u&#39; key to fn+v&amp;lt;/name&amp;gt; &amp;lt;identifier&amp;gt;private.make_u_work&amp;lt;/identifier&amp;gt; &amp;lt;autogen&amp;gt;__KeyToKey__ KeyCode::V, ModifierFlag::FN, KeyCode::U &amp;lt;/autogen&amp;gt; &amp;lt;/item&amp;gt;  然后在Karabiner Preferences的Change Key里面就就可以看到我刚才加的选项了，选择 它，点Reload XML，然后就可以用fn+v的组合键代替u这个键了。（因为V和 U长得比较像。。。 :joy: :joy: ) 完美！
另外一个经常不灵的键就是(这个键，它的位置就是9所在的键。因为6和9比较像……所以 我就把fn+6映射成了9。。同样的做法。:smile: :smiley:
 &amp;lt;item&amp;gt; &amp;lt;name&amp;gt;Change &#39;9&#39; key to fn+6&amp;lt;/name&amp;gt; &amp;lt;identifier&amp;gt;private.make_9_work&amp;lt;/identifier&amp;gt; &amp;lt;autogen&amp;gt;__KeyToKey__ KeyCode::6, ModifierFlag::FN, KeyCode::9 &amp;lt;/autogen&amp;gt; &amp;lt;/item&amp;gt;  哦，对了，上面的配置里面的autogen里面的KeyCode可以在这里 KeyCode 找到。</description>
    </item>
    
    <item>
      <title>Codeforces Round #356 (Div. 2) C. Bear and Prime 100</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-356-div-2-c-bear-and-prime-100/</link>
      <pubDate>Sat, 11 Jun 2016 08:05:05 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-round-356-div-2-c-bear-and-prime-100/</guid>
      <description>C. Bear and Prime 100 This is an interactive problem. In the output section below you will see the information about flushing the output.
Bear Limak thinks of some hidden number — an integer from interval [2, 100]. Your task is to say if the hidden number is prime or composite.
Integer x &amp;gt; 1 is called prime if it has exactly two distinct divisors, 1 and x. If integer x &amp;gt; 1 is not prime, it&amp;rsquo;s called composite.</description>
    </item>
    
    <item>
      <title>problem when configuring vim taglist plugin</title>
      <link>http://liuxueyang.github.io/posts/problem-when-configuring-vim-taglist-plugin/</link>
      <pubDate>Fri, 10 Jun 2016 22:44:32 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/problem-when-configuring-vim-taglist-plugin/</guid>
      <description>最开始，用这个插件的时候出现了类似
ctags unrecognized option &#39;--format=2&#39;^@^itry
这样的问题。
然后我看了一下ctags的man page，发现，确实没有这个选项。这……是为啥。
然后去看taglist插件的manual和它的首页，发现，它里面说的是exuberant ctags，然后 我看了一下这个对比了一下Linux里面的系 统的ctags的man page，发现确实不一样。然后我在常用的PATH里面找了一下exuberant， 很快就找到了/usr/bin/ctags-exuberant，然后根据taglist的文档，设置一个变量就好 了。
在openSUSE Linux上面，需要在vimrc里面加一句这个：
let Tlist_Ctags_Cmd = &amp;quot;/usr/bin/ctags-exuberant&amp;quot;  系统自带的ctags，
❯ which ctags /usr/bin/ctags  并非是taglist这个插件所指的ctags，这个问题，我也是，醉了。 :joy: 搞了51min才 搞定…… :smile: 这个插件里面的ctags指的是ctags-exuberant
貌似在Mac OS X上面，也需要设置一下，比如这 里不过我记得貌似我的以前在Mac OS X里面 可以用。不知道是不是也像这样设置了。
这是效果截图：
taglist的窗口通过C-a快捷键打开，再次按C-a快捷键，taglist窗口关闭。这个插件尤其是 在读程序的时候比较有用。或者写程序的时候也会用到。</description>
    </item>
    
    <item>
      <title>fish shell tutorial</title>
      <link>http://liuxueyang.github.io/posts/fish-shell-tutorial/</link>
      <pubDate>Sat, 04 Jun 2016 10:12:04 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/fish-shell-tutorial/</guid>
      <description>在fish里面，相邻的列表或者字符串会按照笛卡尔积来展开。比如：
liu@lisp /p/tmp&amp;gt; echo {good,bad}&amp;quot; apples&amp;quot; good apples bad apples liu@lisp /p/tmp&amp;gt; set -l a x y z liu@lisp /p/tmp&amp;gt; echo $a x y z liu@lisp /p/tmp&amp;gt; set -l b 1 2 3 liu@lisp /p/tmp&amp;gt; echo $a$b x1 y1 z1 x2 y2 z2 x3 y3 z3 liu@lisp /p/tmp&amp;gt; echo $a&amp;quot;-&amp;quot;$b x-1 y-1 z-1 x-2 y-2 z-2 x-3 y-3 z-3 liu@lisp /p/tmp&amp;gt; echo {x,y,z}$b x1 y1 z1 x2 y2 z2 x3 y3 z3 liu@lisp /p/tmp&amp;gt; echo {$b}word 1word 2word 3word liu@lisp /p/tmp&amp;gt; echo &amp;quot;$b&amp;quot;word 1 2 3word  上面用到了括号扩展的功能：在一个大括号里面以逗号分隔的几个字符串会被扩展成列表里 面的每个元素被当作一个新的变量。比如：</description>
    </item>
    
    <item>
      <title>Codeforces Round #353 (Div. 2) C. Money Transfers</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-353-div-2-c-money-transfers/</link>
      <pubDate>Tue, 31 May 2016 13:57:13 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-round-353-div-2-c-money-transfers/</guid>
      <description>There are n banks in the city where Vasya lives, they are located in a circle, such that any two banks are neighbouring if their indices differ by no more than 1. Also, bank 1 and bank n are neighbours if n &amp;gt; 1. No bank is a neighbour of itself.
Vasya has an account in each bank. Its balance may be negative, meaning Vasya owes some money to this bank.</description>
    </item>
    
    <item>
      <title>Codeforces Round #354 (Div. 2) C. Vasya and String</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-354-div-2-c-vasya-and-string/</link>
      <pubDate>Mon, 30 May 2016 23:21:39 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-round-354-div-2-c-vasya-and-string/</guid>
      <description>High school student Vasya got a string of length n as a birthday present. This string consists of letters &amp;lsquo;a&amp;rsquo; and &amp;lsquo;b&amp;rsquo; only. Vasya denotes beauty of the string as the maximum length of a substring (consecutive subsequence) consisting of equal letters.
Vasya can change no more than k characters of the original string. What is the maximum beauty of the string he can achieve?
Input The first line of the input contains two integers n and k (1 ≤ n ≤ 100 000, 0 ≤ k ≤ n) — the length of the string and the maximum number of characters to change.</description>
    </item>
    
    <item>
      <title>2016年5月29日</title>
      <link>http://liuxueyang.github.io/posts/2016%E5%B9%B45%E6%9C%8829%E6%97%A5/</link>
      <pubDate>Sun, 29 May 2016 19:14:43 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2016%E5%B9%B45%E6%9C%8829%E6%97%A5/</guid>
      <description>前几天花了大量的时间整理我的各个平台的浏览器书签，最后终于不得不承认，要想一次性 把那么杂乱的书签整理好、去重然后找一个好的插件保持各个浏览器同步是一件很困难的 事情……
所以我想把杂乱的旧书签备份一下，然后重新开始。:joy:我还发现，其实我之前保存书签 的方法一点都不科学。。有的东西其实更适合保存在Evernote里面。Evernote的浏览器插件 其实是一个非常好用的东西。只是我一直没有好好利用。保存到Evernote的好处还有就是即 使原先的链接失效了也丝毫不影响我的笔记内容。并且Evernote各个平台都有比较好的客户 端，也可以很方便地整理和复习。
所以就要比较合理地管理Evernote了，建立笔记本、笔记本组、标签什么的，自己慢慢摸索 吧。感觉分类就是有点麻烦。
另外，最近看书的时候我开始用Evernote作笔记了，发现Evernote真的是变好了很多，对书 页拍照什么的也变得智能了。:+1:如果我慢慢地免费版本不能满足我的需求了之后，我会买 付费版的，这个真是值得。:smile:
至于浏览器书签的功能，我觉得，书签越少越好，经常访问的网站要放在书签里面，像那种想要 留着以后看的内容应该放在Evernote或者Pocket里面而不是浏览器书签里面。
其实我发现我以前几乎很少或者从来不整理，最近开始觉得这件事情很值得经常定期做。 最近有时间，我在整理移动硬盘和浏览器书签的时候才慢慢意识到这个问题。其实道理 我都懂，然而当重新发现这个道理的时候，才算是进一步理解了这个道理的含义。:joy::joy:
所以我又整理了一下我的杂乱的iCloud里面的照片和没用的数据什么的，然后又清理了一下 iPad Air，然后发现多出来了4G的空间，清爽多了。
以前我的Kindle PaperWhite里面塞满了各种乱七八糟的书，我最近也清理了一下，尽量保 持书的数目在列表视图下不超过一页，事实上，这并不会让你读书的时间减少……:smile:
微信公众号关注得多了，经常没有时间看，也懒得打开微信抱着手机看，所以发送到Kindle 是一种比较好的做法，在Kindle上面很容易就看完了。
另外还有手机里面的照片也导出并且清理了……棒棒哒
今天跑步5km 跑跑步挺好的 :joy::joy::joy:</description>
    </item>
    
    <item>
      <title>推荐Now Then Pro</title>
      <link>http://liuxueyang.github.io/posts/%E6%8E%A8%E8%8D%90now-then-pro/</link>
      <pubDate>Sat, 28 May 2016 23:01:55 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E6%8E%A8%E8%8D%90now-then-pro/</guid>
      <description> 最近我一直在使用一个APP：Now Then Pro。这 是我使用的最好用的一个时间类APP了。
我一般用它来跟踪我的时间，流程是这样的：
 做事情之前首先新建一个任务 点击开始计时 把事情完成，再次点击任务，停止计时 切换到其它任务，当前任务自动停止，新任务开始计时  这样我一整天的每一个小时都可以被记录下来，睡前翻看一下回想一下当前做了什么事情是 一件很有成就感的事情。它有统计功能，柱状图或者饼状图很直观地显示我的时间分配是怎 样的。
使用了一段时间，很值得推荐。:+1::+1::+1:
今天跑步3.27km </description>
    </item>
    
    <item>
      <title>推荐 KDE Connect</title>
      <link>http://liuxueyang.github.io/posts/%E6%8E%A8%E8%8D%90kde-connect/</link>
      <pubDate>Fri, 27 May 2016 23:35:58 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E6%8E%A8%E8%8D%90kde-connect/</guid>
      <description> 这是Linux里面的一个超级好用的工具。我之前都用AirDroid，但是也有缺点，就是在Linux 里面只能在浏览器里面使用，也只是勉强能够使用而已。
然而，这个就不一样了，它有Android版。真的是超级好用啊！下面是我经常使用的功能：
 同步剪切板，比如在手机上面复制了一段文字，然后就立刻可以在我的Linux里面用快捷 键C-v把刚才复制的内容粘贴到电脑上面。 比如电脑上面正在播放音乐或者视频，然而我再手机上面就可以控制媒体播放，比如快 进、暂停或者播放。这个可以在一个场景使用到：我把笔记本和显示器或者电视机连接起 来，然后我就可以用我的android来作为遥控器了。 图片或者文件互相发送。  截图以后再补上吧。
最近我在整理我的硬盘里面的乱七八糟的文档啊之类的。很久之前就想做的事情，只不过 一直没有开始做。:joy::joy:
Tips
ls -tlh 这个命令里面的t选项经常被我忽略，其实它还是挺有用的，尤其是我想看某 个文件夹里面昨天我新增了那些文件的时候。这个选项可以按照时间顺序列出文件。
今天跑步3.42km :joy::joy: </description>
    </item>
    
    <item>
      <title>2016年5月23日</title>
      <link>http://liuxueyang.github.io/posts/2016%E5%B9%B45%E6%9C%8823%E6%97%A5/</link>
      <pubDate>Mon, 23 May 2016 22:18:34 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2016%E5%B9%B45%E6%9C%8823%E6%97%A5/</guid>
      <description>今天我发现时间越来越紧迫了起来。
突然想到要整理一下我的浏览器收藏夹，因为我在用三种浏览器，Safari，Chrome 和Firefox，在Mac OS X上面用Safari和Chrome，在旧电脑的Linux上面用Firefox，因为开 Chrome实在是，太卡。。:joy::joy::joy:所以同步收藏夹就成了一个问题。一直以来，我 都没有整理过我的收藏夹，并且不知道什么时候手贱，在Safari里面点了导入Chrome的收藏 夹，然后又在Safari里面导入Firefox的收藏夹，然后在Chrome里面导入Safari的收藏夹， 然后在Firefox里面导入Chrome的收藏夹……然后各种同步。。不知道为啥反正就是各种乱， 很多重复的，也没办法简单地删除，因为都有后来自己添加的收藏并且没有同步或者导入的 别的浏览器的。尝试过各种乱七八糟的去掉收藏夹里面重复网页的浏览器插件，Chrome和 Firefox里面的都试过，下午在Linux里面的Firefox里面又试了一下：
可以看到有13593个重复的收藏被检测到，然而这个插件并不能简单的一次性去重……然后 尝试另外一个：
这个倒是可以，然而点了按钮之后，等了十几分钟，还没结束，觉得这也太慢了。。然后就 这样了：
Google了半天也没找到别的比较好的方法。。:sob::sob::sob:
然后突然想到一个办法：我自己手动去重吧。。然而并不会写浏览器插件，也并不会前端的 乱七八糟的东西。所以想了个歪路子：（针对Firefox）
 把收藏夹导出成html文件，然后用awk之类的工具去重。。 删除浏览器的所有收藏夹。 导入处理之后的html文件到收藏夹。  开始不知道怎么想到，一开始就想用awk处理，写的时候发现，然而在awk里面用正则的反向 引用并不是那么方便的样子:question::question:额……我为什么不用 Perl:exclamation::exclamation::anger:所以，很愉快地用Perl写完了。。
my %seen; while(&amp;lt;&amp;gt;) { if (/&amp;lt;A HREF=&amp;quot;http([^\&amp;quot;]+)&amp;quot;/) { unless ($seen{$1}) { $seen{$1}++; print; } } else { print; } } # 14595 -&amp;gt; 991 ;-( exit 0;  处理了之后，可以发现，收藏总数从14595减少到了991:scream::scream:棒棒哒！这个去重 貌似不彻底诶，然而已经减少了大部分了，再用之前使用的插件搞一下，发现需要手动删除 的只有几个而已了，把浏览器里面的全部收藏删除之后，再导入处理之后的html文件。收工:bangbang:
之后就是寻找一种方法可以各个浏览器之间同步的方法吧？貌似可能有插件可以搞定？随后 再找找。。
哦，对了，我发现把KDE Plasma 5里面的各种特效什么的都关掉，还是可以用的，用得挺流 畅，在我的旧电脑上面并不卡。如果追求绝对稳定，当然还是Xfce4靠谱:smiley_cat:
还有，前两天我又折腾了一下我的树莓派，它支持AirPlay了，最近我发现Real好用，iPad Air上面放的腾讯视频可以很愉快地在电视上面看，并且可以用我的Android手机作为遥控 器，甚至不接显示器的时候，也可以把手机上的音乐AirPlay到树莓派上面播放:smile::smile: 哦，Android里面的QQ音乐和虾米音乐都支持AirPlay，网易云音乐不支持，有点可惜。 这两天它主要承担了给我妈播放电视剧的艰巨任务。。。:joy::joy:另外就是作为我的IRC 的一个Bouncer，其实树莓派，还是蛮有用的嘛。:yum:</description>
    </item>
    
    <item>
      <title>2016年5月22日</title>
      <link>http://liuxueyang.github.io/posts/2016%E5%B9%B45%E6%9C%8822%E6%97%A5/</link>
      <pubDate>Sun, 22 May 2016 09:26:26 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2016%E5%B9%B45%E6%9C%8822%E6%97%A5/</guid>
      <description>一天天的，过得飞快。。从现在开始，做事情就好好做，憋半途而废，看书就好好看，憋看 到一半就扔了。。写东西就好好写，憋写到一半就废掉了。。我发现我最近经常做这种事情， 惭愧。做事情认真一点，专注一点。
哦，最近我还迷上了学画画，也觉得挺有意思的，尤其是进入一个新的世界，虽然还不会画， 但是挺有趣。最近有点放纵，看电影、逛B站、看视频什么的。好好读书啊！
另外，好好活着，不好么。:joy::joy::joy:
哦，我的Emacs支持Emoji了。哈哈。棒棒哒！:+1:</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>http://liuxueyang.github.io/about/</link>
      <pubDate>Sat, 19 Mar 2016 08:43:57 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/about/</guid>
      <description> Github: @liuxueyang
 QQ: 1459917536
 Email: liuxueyang457@163.com
 IRC: abel-abel
  </description>
    </item>
    
    <item>
      <title>Codeforces Round #345 (Div. 2) Problem B</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-345-div-2-problem-b/</link>
      <pubDate>Fri, 18 Mar 2016 14:33:20 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-round-345-div-2-problem-b/</guid>
      <description>题意 给一个整数序列，长度小于1000，每个元素元素小于1000大于1，把这个序列任意排序，使得相邻的两个数字满足$a[$i] &amp;lt; $a[$i+1]的pair的个数最大。只需要输出最大的pair个数。
其实画图可以很形象地说明问题。这些图都是用Emacs画的，挺有意思。
首先统计出每个数字的个数。接下来：
第一种思考角度如下图：
从小到大比较相邻组的大小，把较小的那一组的大小累加起来，然而要不要累加较大的这一组的大小那就要看是不是有别的组的大小比它还要大。从下面的图的第2列和地5列可以看到这样的情况。因此还要记录一个最大值。
这个角度从图里面看是从左往右。a -&amp;gt; b -&amp;gt; c -&amp;gt; d这样的顺序。
第二种思考方式如下图：
第一种是从左往右，那么就可以从下往上。其实这样也是合理的。每次从一组里面取出最下面的一个，累加起来。a -&amp;gt; b的顺序。
不过这个方法实现的时候需要一点技巧。
然而，最简单的做法还是这样：）
$\ = $/; while (&amp;lt;&amp;gt;) { $n = $_; $h-&amp;gt;{$_}++ for split &#39; &#39;, &amp;lt;&amp;gt;; print $n - (sort {$b &amp;lt;=&amp;gt; $a} values %{$h})[0]; }  其实画图有局限性，从另一个角度想，把数列分成尽可能长的严格递增（或者只含有一个元素）的子序列，那么每一组一定会含有在整个序列中出现次数最多的那个数字X，如果某个子序列不含有数字X，那么它不足够长。如果某个子序列含有两个数字X，那么它不是严格递增。设整个序列长度为N，在序列中出现次数最多的数字X出现的次数为P，那么就可以分成P个子序列。整个序列中，相邻两个数字递增的pair最多为N-1，分成P个子序列之后，相邻两个数字递增的pair减少了P-1个，所以答案就是 (N - 1) - (P - 1) = N - P，也就是整个序列的长度减去出现次数最多的数字出现的次数……</description>
    </item>
    
    <item>
      <title>2016年春</title>
      <link>http://liuxueyang.github.io/posts/2016%E5%B9%B4%E6%98%A5/</link>
      <pubDate>Sun, 13 Mar 2016 21:16:45 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2016%E5%B9%B4%E6%98%A5/</guid>
      <description>这几天人机大战，李世乭0:3，看得心疼……今天终于、终于赢了！
这几天很多阴谋论，很多打脸，很多嘲讽，没关系，它们都会随风而去。然而，李世乭的今 天会被载入史册。
新的一年，过得很快啊！转眼间，现在已经是3月13日了。这几天学习进度其实略慢。要看 的东西比较多：数值分析、高等数学、英语单词、Perl、具体数学、算法、计算机网络。
一点一点来吧～
反正就是成天瞎折腾……最近才开始用Tmux，还可以，解放了在一个窗口里面开很多个终端 Tab的问题，比较好用的是Session的功能，我可以把不同的窗口分类放到不同的Session里。 另外，平常的编辑还是用Vim吧，我的Emacs用来写Lisp系的语言还可以。毕竟再怎么说它还 是不如Vim轻量。哦，对了，前天一个偶然的机会发现了Vim也有一个Mark的功能，我以前只 知道在一个文件里面可以设置Bookmark，然而我没有想到这个Bookmark是全局的，也就是你 可以用:marks命令来浏览最近设置的标签，即使你在别的目录里面的别的文件里面编辑。 这就很方便……并且比Emacs里面原装的Bookmark功能更方便更快……Vim的乐趣就是即使用了很 长时间，然而总是能够发现新的东西。比如我现在用的Vim配置文件是2013年配的，一直用 到现在没出过问题。尽量保持配置文件简单并且Github同步，Emacs的配置也尽量这样。所 以我的Emacs配置里只同步一个init.el文件，只针对Emacs24版本以上的，Emacs23就不行了， 不过对我来说没关系，我只使用24版的。;-)</description>
    </item>
    
    <item>
      <title>咳……</title>
      <link>http://liuxueyang.github.io/posts/ke-none/</link>
      <pubDate>Thu, 24 Dec 2015 20:34:53 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/ke-none/</guid>
      <description>== 时间过得 好快…… 刚才无意来到这里。。原来都过去这么久了啊。现在是2015年的12月24日，上次来这里是2014年上半年。。
哎。
不过回头看一看， 还是蛮欢乐的呐^_^</description>
    </item>
    
    <item>
      <title>Ruby implementation of 2048 game</title>
      <link>http://liuxueyang.github.io/posts/ruby-implementation-of-2048-game/</link>
      <pubDate>Thu, 16 Apr 2015 15:36:09 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/ruby-implementation-of-2048-game/</guid>
      <description>Ruby Implementation of 2048 game
 Played in terminal. Control with arrow keys or vim-keybindings.  #!/usr/bin/ruby require &amp;quot;io/console&amp;quot; mar = Array.new(16, 0) # sheet value array $score = 0 $target = 2048 $pieces = 0 def operate(mar, ran, gap) mark = false ran.each { |index| ar = index.step(index + 3 * gap, gap).collect { |ind| ind} tm_ar = ar.collect{|ie| mar[ie]} pre_tm_ar = tm_ar.clone tm_ar.delete_if{|item| item == 0} (0..(tm_ar.size-1)).each {|ie| if tm_ar[ie] == tm_ar[ie+1] tm_ar[ie] *= 2 $score += tm_ar[ie] tm_ar[ie+1] = 0 end } tm_ar.</description>
    </item>
    
    <item>
      <title>rename files in ruby</title>
      <link>http://liuxueyang.github.io/posts/rename-files-in-ruby/</link>
      <pubDate>Wed, 15 Apr 2015 15:34:11 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/rename-files-in-ruby/</guid>
      <description>我有下面的文件：
/home/aries/Music/LuoJi/罗辑思维第三季第7期：统一是怎样炼成的_鸿新网www.hhxin.com整理.mp3 /home/aries/Music/LuoJi/罗辑思维第三季第4期：谁绑架了团结_鸿新网www.hhxin.com整理.mp3 /home/aries/Music/LuoJi/罗辑思维第三季第2期：大清帝国的生死时速_鸿新网www.hhxin.com整理.mp3 /home/aries/Music/LuoJi/罗辑思维第三季第6期：人类灭绝的一种可能_鸿新网www.hhxin.com整理.mp3 /home/aries/Music/LuoJi/罗辑思维第三季第3期：坏国王的遗产_鸿新网www.hhxin.com整理.mp3 /home/aries/Music/LuoJi/罗辑思维第三季第5期：秦始皇在隐瞒什么_鸿新网www.hhxin.com整理.mp3 /home/aries/Music/LuoJi/罗辑思维第三季第1期：大门口的野蛮人_鸿新网www.hhxin.com整理.mp3  我想要重命名这些文件，使文件名更明了，更方便在我的MP3上查看，所以，我写了如下简单的ruby脚本：
#!/usr/bin/ruby require &amp;quot;fileutils&amp;quot; def ren(path) Dir.glob(&amp;quot;#{path}/*.mp3&amp;quot;).each do |name| process_file(name) end end def process_file(name) filename = File.basename(name) filename =~ /(.*)(\d.*)_.*(\.mp3)/ FileUtils.mv(name, File.join(File.dirname(name), $2 + $3)) end ren(&amp;quot;/home/aries/Music/LuoJi&amp;quot;)  下面是重命名之后的结果：
/home/aries/Music/LuoJi/3期：坏国王的遗产.mp3 /home/aries/Music/LuoJi/4期：谁绑架了团结.mp3 /home/aries/Music/LuoJi/1期：大门口的野蛮人.mp3 /home/aries/Music/LuoJi/2期：大清帝国的生死时速.mp3 /home/aries/Music/LuoJi/7期：统一是怎样炼成的.mp3 /home/aries/Music/LuoJi/5期：秦始皇在隐瞒什么.mp3 /home/aries/Music/LuoJi/6期：人类灭绝的一种可能.mp3  </description>
    </item>
    
    <item>
      <title>block example in Ruby</title>
      <link>http://liuxueyang.github.io/posts/block-example-in-ruby/</link>
      <pubDate>Sun, 12 Apr 2015 15:33:16 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/block-example-in-ruby/</guid>
      <description>这几天看Ruby，挺有意思的，比如Block的用法：
#!/usr/bin/ruby def total2(from, to, &amp;amp;block) result = 0 from.upto(to) do |num| if block result += block.call(num) else result += num end end return result end p total2(1, 10) p total2(1, 10) {|num| num * 2} p total2(1, 10) {|num| num ** 2}  上面的三个输出分别是
55 110 385  函数total2中的第三个传递块的参数叫做Proc参数</description>
    </item>
    
    <item>
      <title>2015 New Year</title>
      <link>http://liuxueyang.github.io/posts/2015-new-year/</link>
      <pubDate>Sun, 08 Mar 2015 15:30:52 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2015-new-year/</guid>
      <description>时间说过得快其实也挺快的。。转眼一看这个可怜的博客，上一篇文章是2014-11-14,今天是2015-03-08,差不多四个月啊。回头想想我都做了些什么：
2014 2014年11、12月：正在找工作，投简历，参加各种宣讲会。
2015 2015年1月：有了几个可怜的「offer」后，开始看书，意识到其实我没什么擅长的东西。。看了一些common lisp的书，把Common LISP: A Gentle Introduction to Symbolic Computation这本英文版的书看完了。另外占时间比较多的事情就是毕业设计的开题报告。然后就是抱着kindle看乱七八糟的书了……这段时间，自从用上了LAMY，开始喜欢用这货写字儿了，经常去上自习的时候，无聊了就拿出日记本开始胡乱写……然后就差不多写完了整整一个本子，不禁惊讶于积累的力量，一件小小的事情，持续做一段时间，往往能达到自己都意识不到的效果。所以我就觉得还不如在纸上写东西比较好，干脆就忘掉博客了……当然有代码的话，博客更好，但是……貌似我也没什么可以值得贴出来的代码。直接扔在 github里面多好，自己查着也方便。
2015年2月：2月3日回家。这一整个月嘛。
 折腾了一下gentoo，有点小收获，然后接着是debian，最后还是回到了openSUSE了，因为我觉得，适合自己就好嘛，能帮助自己方便的完成自己的目标就可以了。
 然后就是寒假做的一些杂事儿了（事实上，经常是处于无聊的状态，干扰源太多……无法集中一段时间做事情[借口]）
  寒假(2015/02/03 — 2015/03/08(今天)) 2015寒假，背回来一本lisp的书，没看；倒是看了一半的pdf版英文的ansi common lisp；三章的中文版on lisp；最后三章的英文a gentle introduction to symbolic computation；四章中文kindle版失控；昨晚看了硬盘里放了很久的一部电影，北京遇上西雅图；背了二百个单词；玩孢子，从细胞阶段到银河阶段；玩braid；玩红警；教会了我妈玩粘粘世界；玩了几天滑板；听了几集播客，狗熊，朴素，有的聊，科脱，罗胖；折腾了一下gentoo，debian，还是回到opensuse；想整理一下音乐也没完成；放了一次差不多十年没碰过的风筝；lamy的笔尖好像出了点问题，但还能用；日记没写几篇；偶尔看电视看了一集纪录片，宇宙的奇迹—命运，人类的一生终将是毁灭和死亡，甚至整个宇宙经历难以体会的时间之后，也会一个原子都不剩，地球的出现本来就是偶然，进化到人类也是极小概率事件，但灭亡似乎是必然的，那么人活着的意义是什么？为了某种价值？或者是ridiculous的意义？或是更加虚无和无意义的东西？所有这一切其实都微不足道。。。。（这就是语无伦次？）
就这样，后天滚蛋。
今天下午（2015/03/08）有件特别有意思的事情，下午出去玩滑板，碰见两个小朋友玩轮滑，男孩上一年级，女孩上两年级，然后两个小孩子让我教他们玩滑板……有个细节特别让我惊讶:玩的时候，小女孩告诉我：你踩死了一只蜘蛛，我低头一看，那已经不能分辨出是一只蜘蛛了，被我碾成粉儿了。。我好奇的是，她是怎么注意到那只蜘蛛的？还有一次，他俩告诉我，你脚下有一只七星瓢虫，低头一看，它早已经死的并且变干了。但我从没注意过这些，因为小孩子才会注意到这些生命吗？想想小时候，我也会大夏天顶着大太阳盯着院子里的蚂蚁看一中午，不知道什么时候开始，我从来不会注意这些了。就像spore里面的史诗生物连看都不看一眼地踩死你一样，我也一不小心就踩死那些以前对我来说很新奇的生物。
有一次我问小男孩：一百加二等于多少啊？小男孩自信满满地回答：一百二！莫名戳中笑点啊！小女孩纠正之后，我再问男孩：一百加七等于多少啊？小男孩坚定地回答：一百七！哈哈哈哈哈，难道是我笑点低？好萌啊！我估计是小男孩不会读102、107这种数字而已……可是小女孩纠正之后，再问男孩：一百加五等于多少啊？小男孩回答：一百零五！哈，终于答对了。
女孩说，我家有一只大狼狗，会吃人哦！小男孩：我家有一只熊狗！我问：熊狗是什么啊？小男孩严肃地说：熊做成的狗。我：……这怎么想到的啊？！这个想法真是……突然觉得，小朋友好萌啊！（以前我很讨厌小朋友的……经常弄坏东西。）</description>
    </item>
    
    <item>
      <title>C is Interesting</title>
      <link>http://liuxueyang.github.io/posts/c-is-interesting/</link>
      <pubDate>Fri, 14 Nov 2014 15:39:20 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/c-is-interesting/</guid>
      <description>最近偶尔看C语言，看了一点有意思的东西。
 C语言里函数声明有一个很有意思的现象：  如果一个函数没有float, short, 或者char类型的参数，在函数生命中完全可以省略 参数类型的说明（但是函数定义中不可以省略）。
也就是说有一个函数定义：
double double(double a) { return a * a; }  那么这个函数可以声明为：
double square();  这个规则好像是为了兼容旧版本的C吧。
 一个例子：  /* * ===================================================================================== * Filename : type_scanf.c * Description : This program outputs differently on different systems. * Version : * Created : 11/12/14 22:45 * Author : Liu Xue Yang (LXY), liuxueyang457@163.com * Motto : Suicide is Painless * ===================================================================================== */ #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>create, print, insert, delete and reverse list</title>
      <link>http://liuxueyang.github.io/posts/create-print-insert-delete-and-reverse-list/</link>
      <pubDate>Thu, 23 Oct 2014 15:45:58 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/create-print-insert-delete-and-reverse-list/</guid>
      <description>/* * ===================================================================================== * Filename : list.c * Created : 10/21/14 16:12 * Description : create list. insert a value in a list. delete a value in a list. * reverse list. print list. * Author : Liu Xue Yang (LXY), liuxueyang457@163.com * Motto : Suicide is Painless * ===================================================================================== */ #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; typedef struct Node { int n; struct Node *next; }Node; typedef Node * pNode; /* * argument n is the number of nodes to create */ Node * create(int n) { pNode Head, p_tmp, q; int tmp; Head = (Node*)malloc(sizeof(Node)); Head-&amp;gt;n = -1; Head-&amp;gt;next = NULL; q = Head; while (n--) { scanf ( &amp;quot;%d&amp;quot;, &amp;amp;tmp ); p_tmp = (Node*)malloc(sizeof(Node)); p_tmp-&amp;gt;n = tmp; p_tmp-&amp;gt;next = NULL; q-&amp;gt;next = p_tmp; q = p_tmp; } return Head; } /* * pos starts from position 0 * n is the value */ int delete(Node *h, int pos) { Node* p; Node* n_p; p = h; while (pos--) { if (!</description>
    </item>
    
    <item>
      <title>some sort algorithms</title>
      <link>http://liuxueyang.github.io/posts/some-sort-algorithms/</link>
      <pubDate>Thu, 09 Oct 2014 15:48:33 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/some-sort-algorithms/</guid>
      <description>In order to know whether a sort algorithm is stable, we need to know how it works.
SelectionSort /* * ===================================================================================== * Filename : SelectionSort.cpp * Description : SelectionSort * Version : 0.1 * Created : 10/04/14 14:54 * Author : Liu Xue Yang (LXY), liuxueyang457@163.com * Motto : Suicide is Painless * ===================================================================================== */ #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int main ( int argc, char *argv[] ) { // 1, 2, 3, 4, 5, 6, 7, 8 const int N = 8; int a[8] = { 7, 6, 3, 2, 1, 4, 5, 8 }; cout &amp;lt;&amp;lt; &amp;quot;original array:&amp;quot; &amp;lt;&amp;lt; endl; for ( int i = 0; i &amp;lt; 8; ++i ) { cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;; } cout &amp;lt;&amp;lt; endl; int min_index; for ( int i = 0; i &amp;lt; N; ++i ) { min_index = i; for ( int j = i + 1; j &amp;lt; N; ++j ) { if ( a[j] &amp;lt; a[min_index] ) { min_index = j; } } swap(a[i], a[min_index]); } //output cout &amp;lt;&amp;lt; &amp;quot;\n\nsorted array:&amp;quot; &amp;lt;&amp;lt; endl; for ( int i = 0; i &amp;lt; 8; ++i ) { cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;; } cout &amp;lt;&amp;lt; endl; return EXIT_SUCCESS; }	/* ---------- end of function main ---------- */ /* * Is it stable?</description>
    </item>
    
    <item>
      <title>process filenames with spaces</title>
      <link>http://liuxueyang.github.io/posts/process-filenames-with-spaces/</link>
      <pubDate>Thu, 09 Oct 2014 15:46:59 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/process-filenames-with-spaces/</guid>
      <description>I have some files whose filenames are like this:
[some thing there]Sed &amp;amp; awk, 2nd Edition[some thing there].mobi [some thing there]Erlang Programming[some thing there].mobi [some thing there]Hacking Vim7.2[some thing there].mobi [some thing there]Learning the vi and Vim Editors[some thing there].mobi  I want to rename them and delete the spaces in the filename.
so… I wrote a script in perl.
#!/usr/bin/env perl #=============================================================================== # FILE: filename.pl # AUTHOR: Phoenix Ikki (liuxueyang.</description>
    </item>
    
    <item>
      <title>Hey,recently</title>
      <link>http://liuxueyang.github.io/posts/hey-recently/</link>
      <pubDate>Thu, 18 Sep 2014 15:51:23 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hey-recently/</guid>
      <description>貌似大概有整整一个月没有动博客了啊！这个月的几件事情：
 上学期成绩出来了，没有挂，满足了。大部分课程都是考试前两周上自习看的。编译原理老师平时成绩给得高，最后勉强给我拉到了90+，其实……我的目标是过了就行了啊=_= 6月份考的六级过了，494分，裸考，运气好。之前两次裸考的结果分别是：400+，416.这次可能人品好。 小学期跟计科的几个以前不认识同学合作，最后还是水过。总的过程还是挺欢乐的！ 上次阿里水水的笔试过了之后去武汉面试，没过。这让我重新审视了一下自己现在的情况。 圣斗士星矢的后续作品还没补完。一辉、沙加、穆。这三个圣斗士最帅了。 网易的笔试题目出得很认真，比阿里认真多了。答成那个样子也是应该的！ 看了几部不错的电影：《心灵捕手》、《这个杀手不太冷》、《美丽人生》、《姐姐的守护者》  呵，就这样。</description>
    </item>
    
    <item>
      <title>Some simple syntax on lisp and perl</title>
      <link>http://liuxueyang.github.io/posts/some-simple-syntax-on-lisp-and-perl/</link>
      <pubDate>Sun, 17 Aug 2014 23:55:06 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/some-simple-syntax-on-lisp-and-perl/</guid>
      <description>I am learning perl and common lisp these days.
I think perl&amp;rsquo;s syntax is beautiful and simple and I am getting used to it. I like it very much. I learn it just to do some text tasks.
Besides, I once thought lisp&amp;rsquo;s braces are so confusing. I even like those now. It is interesting to write in lisp.
Here, I place some meaningless codes here to help me remember the syntax in future.</description>
    </item>
    
    <item>
      <title>run-9</title>
      <link>http://liuxueyang.github.io/posts/run-9/</link>
      <pubDate>Fri, 08 Aug 2014 21:48:23 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/run-9/</guid>
      <description>昨天立秋，夏天还没过就结束了。今天天气一下子就凉快了许多。
计算机网络就看到这里吧。下午开始看鸟哥的书。我至少把鸟哥的两本书过一遍。鸟哥的书内容挺多的，一整页里面密密麻麻的都是字儿。不过也确实讲的东西挺全的，也容易懂，就是看着比较枯燥。今天下午看得比较痛苦。。。。%&amp;gt;_&amp;lt;%
另外开始看得一本书就是*Learning Python*英文版的，据说中文版的比较坑。这本书我看着还不错，挺全的，O&amp;rsquo;Reilly经典风格，上下册，两本摞起来比现代汉语词典厚一点。。。虽然是英语，语言挺通俗，看着竟然挺流畅。
下午自习恶心到了，晚上干脆不出去了……窝在宿舍边看书边写这本python书上的例子。。
晚上有点不爽其实，难道是因为没有动力，还是为什么？
还有一本书，*Common Lisp the Language*，这本书打算平时有空了就看，英文的开源版本，下载了HTML格式的放到iPad里面，这样就可以离线看了，这本书比较枯燥，并且还是英文的，看的会慢一些，不知道什么时候能看完，越快越好！
诶，对了。佳佳那天唱的那首歌：「房间」，挺好听的。话说佳佳唱歌太好听了有没有！~(≧▽≦)/~
看会儿书睡觉吧。
颓废是暂时的。第二天还是一样继续。
#以后还是少在博客里面扯淡……这是最后一篇了。以后不写了。#
#『完』</description>
    </item>
    
    <item>
      <title>run-8</title>
      <link>http://liuxueyang.github.io/posts/run-8/</link>
      <pubDate>Mon, 04 Aug 2014 21:06:47 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/run-8/</guid>
      <description>8月2日——8月4日 其实我感觉我有必要总结一下每天都干了点什么。
这三天一直都在看着两本书《sed &amp;amp; awk》和《Learning the bash Shell》。
《Learning the bash Shell》还是讲了很多我以前不知道的东西，当然也有很多很熟悉的东西，有些细节书里面根本就没有解释，直接默认读者知道了，要不是之前看的那本书补充，估计会很困惑。总的来说还是收获颇丰。看了200页，还剩100页左右。
《sed &amp;amp; awk》这本书专门讲sed和awk这两个上古神器，把sed部分看完了之后，除了sed的高级用法有点困惑，还是不太懂之外，一般的sed脚本哥们儿至少能看懂了，能写写简单的脚本，以后多用用就熟练一些吧。awk和sed相比更亲切，语法比较容易懂，和C接近。这本书也看了200页，也是还剩100页左右没看，书后面的实例部分先不打算看。
明天估计就可以把这两本书该看的部分搞定。这三天集中看这些感觉功力大增，另外，有时候一天看同一本书100+页的时候也感觉挺枯燥的，都是单纯的语法和奇葩的用法以及各种技巧和trick，shell脚本太有用了，很多以前遇到但没解决的问题，现在很多都豁然开朗；sed和awk用来处理文本真是神器，用法很灵活，很专业的工具，虽然……sed脚本不是那么容易读懂=_=
最近每天都是这么个节奏：
 5-7点左右起床 看书、写程序 8点早饭 看书、写程序 9点或者10点会感觉困，睡觉 11点醒，看书、写程序 午饭 看书、写程序 或者 午休 看书、写程序 17点半晚饭 看书、写程序 睡觉 一天过去了……  貌似有点小单调。。偶尔也花半小时刷一下微博 or twitter or facebook，看看有什么有意思的信息，偶尔利用午休时间看一部电影。或者看书的时候听听歌，歌曲列表循环几遍之后就听腻了。。或者看看散文杂文英文实在不行软文。
今天在kindle上买了本电子书《不散的宴席》韩寒《一个》App系列第四本书，前三本都在kindle上买过，很快就看完了，还是在准备准备期末考试的时候，挺有意思，这本省着点看……=_=
看这种编程语言语法书的时候，难免有一点儿枯燥，一整天看一本书也听没意思的，不如换一本别的类型的书，比如《计算机网络》一类的，换换口味对不对？
我call，宿舍又停电了！！！现在时间8月4日21点40分……
那就睡觉吧。
8月5日-8月7日 这三天，没干别的，一直在看《计算机网络——自顶向下方法》这本书。说实话很枯燥，看得晕晕乎乎，终于，当我从开始一页一页看到一百三十多页的“可靠数据传输原理”一节的时候，明白一件事：这么一页一页认真地看下去是不可能完成任务的，照这个节奏下去，看完这本书重要的前五章估计面试也就结束了……别想着看其他的了。所以，我还是决定，先把基础的知识点过完，细节先跳过，尤其是太理论性的东西，比如选路算法什么的，这种有点难度的东西以后再说吧。先把前五章基础的东西看完，然后就看别的书，不能吊死在这本书上了。时间宝贵。所以，今天（7日）一下午加一晚上的时间，很愉快地看到了第五章，明天上午基本就可以搞定。
之前的两本书《Learning the bash Shell》和《sed &amp;amp; awk》，前者差不多搞定了，但是里面有不少高级的东西还是不太明白，目前这本书还不能还，回头看看amzon有没有，入手一本，总的来说还不错。另一本书，还差一点没看完，但是里面还是有很多东西不太会用，需要多写写，多练练，只看没有用，并且很枯燥，关键还是多用一用，才能体会到它的威力。如果这本书也还有卖的话，也想入一本，不错。然后我在简历“熟悉”一栏里脸红地加上了：sed，awk
今天（8月7日）晚上，在德克士自习的时候，无意间打开iPad看到一条消息：
 不是每一位推荐的同学都能获得提前面试的机会的，因为推荐数量巨多，面试官实在简历中优中选优来面试； 内推没被面试或面试不通过也不用担心，后续可被直接邀请参加正常校招笔试（8月中旬左右开放学生在前台自行修改职位） 8月8日是咱们内推面试截止的时间，若在此之前均无电话面试，那么内推就无面试机会了
 好吧，我还是没有猜错，我就觉得这个内推肯定是投了就给推的那种=_= 果然是这样啊。一线希望就又没有了。。不过也没什么，反正我也还没有怎么准备好，继续看书，老老实实走校招吧。
现在不怎么想别的事情，只想静下心来看书，写程序。
这几天，每天都是一个节奏，像钟表一样准时。吃饭，学习，看书，无限循环。挺好的其实。这么平静悠闲的日子，人生也不会太多，毕业了肯定就没了。
诶，今儿发现很多好书都绝版了！看来买书还是要下手快，别等到绝版了欲哭无泪。
对了，昨天晚上睡觉前躺床上把kindle里刚买的那本《不散的宴席》不知不觉看完了！我只想说：什么时候出下一本！！！
这两天也懒得在博客里扯淡，晚上自习回来得也挺早，9点多就回来了，到宿舍就感觉很累了，只想去屋顶看着星星躺着休息睡觉。每天都早睡早起，睡到早上五点多自然醒，睡眠充足，白天也精神，很爽。中午午睡每次都是下午两点半准时自然醒。生物钟啊！要保持充足睡眠，就不要定闹钟，早睡早起，睡到自然醒，这才是王道。
不扯了，睡觉了。
完。</description>
    </item>
    
    <item>
      <title>Write a Shell script to simulate the &#39;tree&#39; command</title>
      <link>http://liuxueyang.github.io/posts/write-a-shell-script-to-simulate-the-tree-command/</link>
      <pubDate>Sun, 03 Aug 2014 21:55:34 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/write-a-shell-script-to-simulate-the-tree-command/</guid>
      <description>I wrote a shell script to simulate the &amp;lsquo;tree&amp;rsquo; tool in Linux.
This is the code:
#!/bin/bash - #=============================================================================== # # FILE: RecursiveDir.sh # # USAGE: bash RecursiveDir.sh [directory] [longest deepth] [empty] # # DESCRIPTION: This script can list the files and dirs # recursively in the current directory # if empty argument is set to &amp;quot;empty&amp;quot;, it will print a empty line # before and after a directory # # OPTIONS: longest_deepth	is set to 4 by default # directory is set to current directory by default # empty argument is set to &amp;quot;n&amp;quot; by default # REQUIREMENTS: --- # BUGS: --- # NOTES: It print a empty line after a directory # AUTHOR: liuxueyang (lxy), liuxueyang457@163.</description>
    </item>
    
    <item>
      <title>run-7</title>
      <link>http://liuxueyang.github.io/posts/run-7/</link>
      <pubDate>Fri, 01 Aug 2014 20:40:01 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/run-7/</guid>
      <description>####自习
最近自习的地点从复临舍转战KFC和Dicos，说来也奇怪，每次去这两个地方上自习都效率比较在教室高，从来不睡觉犯困什么的，诶，看来我还是不习惯在特别安静的地方学习。可能是高中的时候养成的习惯吧，我记得高中班里自习的时候都是乱哄哄的，我们班主任老李，特别好的一个老师，曾经专门说过这件事情，说他从来没向其他老师一样把教室自习的纪律什么的管得特别严是因为，我们都应该养成这种即使在嘈杂的环境下也能专注的习惯，因为，并不会什么时候都能有那种安安静静的环境，现在想想也对。这个技能我倒是学到了=_=
####宿舍
前天（7月30日）晚上9点多宿舍停电了！！宿舍七楼，夏天，靠着电扇维持适宜的生存温度，竟然没电了！宿舍是呆不下去了，抱着凉席去了楼顶，既然没电了，就睡觉吧，夏夜，晚风，再好不过了。故意把一切的电子产品放在了宿舍，享受这个宁静的夜晚吧。躺在凉席上面，望着夜晚的星空，诶，天上能分辨出来的比较明亮的星星只有三颗，其它的都是依稀可见，用眼角余光可以感觉到它们的存在，可是你真正看那个位置的时候，你却找不出他们在哪里，可能是我散光？脑海里可以想一些乱七八糟的事情，或者干脆什么都不想，数一数那些依稀可见的星星。长沙晚上的天空，只有正上方还有一些夜空的意思，天边四周都是暗红色，总有一种大话西游里牛魔王和至尊宝大战的时候的天空的感觉。。暗红色。小时候，夜晚都是漆黑漆黑的，天气好的时候，夜空是深蓝色，纯净的深蓝，还有满天满天一闪一闪明亮的星星，能清楚地看到北斗七星——我唯一分辨出来的星座。迷迷糊糊的，就睡着了。早上七点多醒来的，是被明亮的太阳晒醒的。自然醒，这种一觉醒来，天下大白的感觉，尤其是在楼顶，感觉最好了，醒得早的话，还能看到东边的美丽的朝霞，满天的被日初照成橘红色的云彩，宛如仙境，可惜这种待遇，只有夏天才有。这也算是夏天的一个福利吧。
早晨起来洗澡的时候，洗头的时候，把洗发露在头上抹好之后，然后就，，水龙头不出水了！！！天下哪有这么巧的事情啊！！这是在存心逗我！！一般的洗澡前把衣服脱了发现没水这不算什么，，哪有这样的啊！！！偏偏在抹上洗发露的时候就没水了！！！！这种事情发生的概率很小对不对？
前几天，晚上外面似乎要下雨的样子，就在宿舍打地铺睡，因为床上实在太热了，晚上凉席是烫，床上的铁护栏都是热热乎乎的。。重点是，早上五点的时候，感觉小腿怎么有点痒啊，感觉有什么东西在爬啊，迷迷糊糊醒了，起来一开灯，我call，一只蟑螂爬在凉席上面啊！！原来刚才就是这货爬我腿上啊！！我默默的对它竖起了中指，call，足足有中指两个关节那么长！！然后这货还爬在毛毯上不下来，后来也没踩死它，让人家愉快地逃走了，诶，大家都要活命的对不对？看外面也没下雨，淡定地卷起凉席，来到了楼顶，刚躺下没10分钟，天空中依稀飘起了可爱的小雨点。。。大家抱起凉席就往回跑。。。
####读书
《Linux Command Line and Shell Scripting Bible》这本书，这几天把10——19章看完了，前面10章都是讲命令，需要用的时候再查吧，有时间可以翻翻，20、21章讲的wed,gawk的高级用法，只有两章的篇幅，讲的也不够透彻，先放着等以后看。在后面几章就是高级shell脚本编程了，数据库，Web，E-mail什么的，这些东西很重要，先留着，把shell脚本写熟一点了再深入研究。这本书还是不错的，用来把基础知识扫一遍比较合适，好书。
要看的下一本书就是《Learning the bash shell》 Cameron Newbam &amp;amp; Bill Rosenblatt，经典的O&amp;rsquo;Reilly的书，这本书目测比较基础，快速过一遍，也值得看，里面有很多小技巧，小trick以前倒是没接触过，比如今天刚看到的readline，组合键绑定什么的。书不厚，应该很快就可以搞定。
接下来要看的就是《sed &amp;amp; awk》Dale Dougherty &amp;amp; Arnold Robbins 也是一本经典的O&amp;rsquo;Reilly的书，专门讲sed和awk的，这两大神器早就想系统学习一下，前段时间还遇到了很多文本处理的问题，虽然知道可以用sed或者awk很愉快地解决，可惜就是不会写啊！！所谓书到用时方恨少。sed和awk的基础的东西已经差不多会写了，关键是要看一下里面的高级话题。
然后就是《Classic Shell Scripting》Arnold Robbins &amp;amp; Nelson H. F. Beebe，也是O&amp;rsquo;Reilly的书，里面的实例和习题比较多，适合练练手，看看自己的水平吧。
说来惭愧，这三本从图书馆借的书在我手里应该也有半年了，借的书也没好好看，过了期就红着脸背着一大包书找图书馆的阿姨：这些书都续借。。。前段时间去图书馆那个阿姨还跟我说，好久没见到你了啊。我：恩……。校园卡里面借书量一直是满格40本，开始的时候，每次借书到第40本的时候，借书系统会警告说已达到上限，阿姨还总是露出惊奇的眼神，你借了这么多书啊。后来我去还书的时候变成：没看完可以续借哦。我：哈哈，恩……。话说，自己买的书总是会当宝贝似的一页一页赶紧看，图书馆借得书却总是一推再推，最终过期了也看不了多少，以前总觉得没时间，这回暑假了，总算有时间了吧。好好看吧。赶紧把这这三本书看完还了去。
然后就是，最近少看小说，难得有这么大片的时间学习，好好把握，不可荒废。
####电影
话说，自从上次去电影院看了《后会无期》，觉得看电影似乎也是一个不错的消遣方式。以前看电影少，一年也看不了3部。平时除了跑步、看书、听歌以外似乎也没什么娱乐方式，不如偶尔看看电影吧。或许可以考虑每两周看一部电影，恩，也不错。
所以，今天上午11点KFC自习结束后，天气热，没胃口吃饭，恰好可以回宿舍看一部电影，我还记得硬盘里面还有尘封了至少一年以上没动过的七八部电影。正好利用中午的时间看完了一部电影，加上吃饭的时间，还可以午睡半小时，下午两点半自然醒。
电影名字是：《The Naked Gun》第一部，1988年上映。喜剧。挺欢乐，大概就是一个蠢萌蠢萌的警察大叔一系列的故事，很多笑点，电影最后的棒球比赛挺有意思，一大亮点。中英文字幕，有很多地道的英语表达挺有意思，尤其是特有的那种美式幽默。
####其它
最近貌似很少在QQ上扯淡了，有的话也就两句。甚至有的时候都懒得回。还记得以前还天天刷空间，成天隐身挂着QQ，时不时windows任务栏上的QQ图标一闪一闪地提示你：快来啊，快来点我啊！诶，那个时候得多么无聊啊。加着将近三十多个QQ群，每个群图标都显示着有多少新的群消息，虽然大多数你两个月都不会点进去看一眼。后来学聪明了，哥们儿找了个新号儿，把原来的群里面所有的群都退干净了，只留下高中，初中，小学这3个群，还有1个或两个临时群，清静了许多。新号码专门加群用，或者偶尔加几个人。然后也懒得隐身了，因为大多数时候都不上嘛，反正有新消息的时候iPad有提示，没新消息的时候，偶尔去群里看下有什么重要信息，然后下线。QQ群其实还是不错的，经常有人分享不错的资源，电子书什么的，省的到处找了，并且，也经常有一些开源公开课，在QQ群里面在线讲，也挺有意思。说到这个，前些天去东北大学六维空间的群里面邀请码，各种被调戏：说说几个给你邀请码的理由吧、你是妹纸么种种…… 各种无语啊，可爱的是，那两个人儿后来私信我，一个说给我他的账号密码借我用，说相信我才借我的，不过后来我没好意思用；另一个人说是毕业了，直接把账号送给我了，还是带一万八千多积分的，话说这个积分，诶，以前同学也送过我六维账号，只可惜也不经常开windows，下载的东西也不包种，上传什么的，一直保持负8千左右的水平，再后来就不能下载东西了=_=惭愧……。后来又去北邮群里求邀请码，群主挺慷慨，当时私信我说第二天给我。诶，看来我运气还是挺好的，哈哈。
说起刷空间，原来天天一打开空间就点开空间图标，看有什么新鲜事情啊，其实挺无聊的。后来有那种每天几条动态刷屏的那种，这种时候，我一般都是小手一抖，默默地在空间设置里：屏蔽此人动态。。。再后来，大家都在时不时发发逗比的说说啊、图片啊、不知从哪里转载的《一定要知道的xx句话》什么的……后来就再也不看空间了。。。
前些天还特意整理了一下微博，把经常发逗比微博的都取消关注，发现关注了100+个微博，一次整理完比较困难，以后每次上微博都整理几个吧。。话说微博比空间好得多，还是有一些值得关注的大牛和有意思和有用的信息的。我很少发，主要是关注，偶尔回复，或者偶尔小手一抖点个赞什么的。
微信也是，从不加人，主要是关注那些有意思的微信公众号，有时间读一读。上次看某有名微信公众号作者在一条微博里说，他的公众号订阅量几千，可惜文章阅读量经常只有几十，哈哈，原来有很多人和我一样，订阅了很多，可依旧不看。
####工作
话说前几天给一个公司的内推邮箱投了简历，投完之后也没放在心上，哥们儿我还是对那“简洁无比”（其实是苍白无力）的小简历有自知之明的，大概就认为：没戏，别指望。本来想的是，等过段时间在走校招投简历什么的吧。后来也就忘了这事儿了，虽然才过了两三天。。
结果今天晚上来短信了，我以为10086又淘气了，没想到还真不是啊：某某员工推荐您参加校园招聘。一直以为内推这种事情都是技术特别牛逼的人才走的路子，没想到还真的过了啊。可能是过的人有很多，基本投了就过的那种，也可能是，我运气好得不行。
还是同一家公司，同一个职位，我还记得上次去武汉面试实习的时候，一个屋子，大概四五个人同时与四五个面试官单独在一个大房间里面面试，我是第一个出来的…… 因为一问三不知啊，估计是面试官也觉得没聊下去的必要了…… 完完全全被虐地体无完肤。有两个原因：第一，准备方向完全不对头，南辕北辙，那次准备的时候一直看算法，看数据结构，结果人家根本一个都不问，因为职位不同，要求也不同。第二，自己也没有项目经验，没有特别熟悉、掌握得特别熟练的技术，也没有拿得出手的经历。这次主要准备三个东西，多了也来不及：shell, python, 网络。比较坑的是，网络这部分完全没有基础，需要恶补一下。
收到短信，立马跟打了鸡血似的，马上有动力了，这次不能像上次一样了，也许最后不一定能过，但是一定比上次要好一些，不至于被虐成粉儿！至少也是渣对不对？虽然连简历筛选都不一定能过…… 但机会总是留给有准备的人是么。
现在是8月1日，明天是七夕，话说我的kpw就是去年今天买的，不对，应该是七夕后的第二天吧，哈哈，好快，kpw用了一年了，话说kpw只摔过一次，就在前几天，差点就享年一岁了，还好套着官方套，妥妥的，丝毫没问题，要是裸奔那么一摔，估计就坏了也说不定，当初咬牙买官方套是正确的选择。。
晚上10点五十。睡觉了，早睡早起身体好，效率也高，明天继续愉快地看书。</description>
    </item>
    
    <item>
      <title>run-6</title>
      <link>http://liuxueyang.github.io/posts/run-6/</link>
      <pubDate>Tue, 29 Jul 2014 23:33:22 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/run-6/</guid>
      <description>最近看完了两本书：
 《雪地杀机》 《恶意》
 都是东野圭吾的推理小说。发现东野的小说总是擅长写那种杀人动机很难讲通的故事，至少我是这么认为的。就比如说前段时间看的那部《放学后》，我一直都不能理解那个动机，据说宫部美雪还夸奖那部小说的动机很新颖。。
《雪地杀机》，讲的故事挺有意思，双重推理。简单说就是：设置一个场景，让大家来演一场推理剧，事实上在这不推理剧中真正的实施杀人计划。所谓双重，就是，这个计划的作者为了自己爱的姑娘才实施的，姑娘想出来的这个计划，目的很明确，就是杀掉三个人，这个计划的实施者，毕竟是个平凡人，不能承受自己杀人的痛苦，所以就演了一出戏，表面上按照姑娘的计划进行，实际上并没有杀人。整个故事最后是个悲剧吧，也有一点感人，最后一幕挺有意思，大家都被感动得哭了，贵子真是蠢萌蠢萌的：
 不知何时，中西贵子来到我身边，说：“这个借给你！”说着，她递出已经湿透的手帕。
 哈哈，画面感超强有没有！
《恶意》，这个案子嘛，类似于双重嵌套的方法吧。这部作品挺新颖，一般的小说都是把案子破了，凶手也找出来了，就结了。这部小说不一样，到全书三分之一的篇幅，案子已经侦破了，只是动机不明确，凶手也不说。然后一个警官开始闲的蛋疼得去查，希望找到动机，千辛万苦，终于找到了动机，凶手也承认了，案子该结了吧。no，故事还没有结束，这个警官直觉挺准，总觉得哪不对，然后继续查。终于，发现原来之前他找到的这个所谓的动机，只是凶手设的一个陷阱，也就是说，之前的警官的行动都在凶手的意料之中，我call，这人不简单。然后，才找到真正的动机。到最后，这个动机还是让我觉得有点牵强，或者不太理解…… 东野就喜欢写这种……=_=
然后我就想，这个凶手用另一个动机来掩盖自己真正的动机，有没有那部小说主人公用2、3个动机来为真正的动机做铺垫呢？额，那样可能就有点复杂了。。
最近正在看的书：
 《中国国民性演变历程》张宏杰
 以前从来不看这种书名充满政治气息的书的，罗胖推荐，看了三章，说实话，挺有意思。好书。
 《Linux Command Line and Shell Scripting Bible》Richard Blum &amp;amp; Christine Bresnahan
 看这本书，主要是看一下shell脚本，很基础，也还算全面，适合把基础知识扫一遍，每章二十多页，基本45分钟看一章的节奏。写的还不错。
 《计算机网络 自顶向下方法》 James F. Kurose &amp;amp; Keith W. Ross
 补一下网络知识。。=_=
 《女王乔安》 张晓晗
 《一个》App常驻作家
 《Learning Python》 Mark Lutz
 补python的基础知识用。
 《Python基础教程》 Magnus Lie Hetland
 这本书从头开始看的，看了8章。就放下了，以后再看。
 《汇编语言：基于Linux环境》 Jeff Duntemann
 这本书，大一的时候就见过这本书的英文版，今年终于有人翻译了。这本书前三章基本不用看，这本书剩下最后三章没看，有时间补上。</description>
    </item>
    
    <item>
      <title>后会无期</title>
      <link>http://liuxueyang.github.io/posts/run-thecontinent/</link>
      <pubDate>Wed, 23 Jul 2014 11:57:10 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/run-thecontinent/</guid>
      <description>今儿7月23日。
诶，7月16日，也就是去深圳参观回来的那一天，《后会无期》发了一首主题歌《平凡之路》……我call，朴树！！！十年了啊！第一遍听就觉得特别好听，这种歌，对我来说，少。
诶，韩寒、朴树，一个是从小就比较喜欢的作家，一个是从小就喜欢的歌手。完美的组合。
第一次读韩寒的作品是在小学的时候，貌似是五年级，《零下一度》记得书里面有一个角色叫做“傻子”。
朴树的歌，一直以来最喜欢的是《白桦林》、《生如夏花》、《她在睡梦中》、《来不及》……算了，不列举了，太多。。。。
所以最近都在单曲循环《平凡之路》。MV里面的歌词字幕，今天才知道，那是韩寒的手笔啊！韩寒写的字真好看。
我最喜欢的歌手只有两个：一个是许巍，一个是朴树。恰好两个人的声线又那么相似。
预告片里面有两句台词，挺有意思：
 你连世界都没有观过，哪来的世界观？ 我的名字就是：闭嘴
 这几天又放出了《后会无期》的几句台词，有几句挺有意思：
 既然大家都没本事，各走各路，这才是现实 小时候听过很多大道理，可依旧过不好我的生活 我知道你不是个好人，但没想到你连坏人都不是
 很韩寒。
微博上看到一句话： &amp;gt; 所有买过韩寒盗版书的人都应该去电影院还债
哈哈哈
最近好像又有《小时代3》上映，有人拿两部电影相比。我call，我觉得完全没有可比性啊有没有。至于郭敬明嘛，初中毕业的时候偶然间看过了《夏至未至》还有后来的《悲伤逆流成河》之后。就再也不看小四了……
最后《平凡之路》的歌词，赞：
徘徊着的 在路上的 你要走吗 via via 易碎的骄傲着 那也曾是我的模样 沸腾着的 不安着的 你要去哪 via via 谜一样的 沉默着的 故事你真的在听吗 我曾经跨过山和大海 也穿过人山人海 我曾经拥有着一切 转眼都飘散如烟 我曾经失落 失望 失掉所有方向 直到看见平凡才是唯一的答案 但你仍然还在幻想 你的明天 via via 她会好吗 还是更烂 对我而言是另一天 我曾经毁了我的一切 只想永远地离开 我曾经堕入无边黑暗 想挣扎无法自拔 我曾经像你像他像那野草野花 绝望着也渴望着 也哭也笑平凡着 向前走 就这么走 就算你被 给过什么 向前走 就这么走 就算你被 夺走什么 向前走 就这么走 就算会 错过什么 向前走 就这么走 就算会 我曾经跨过山和大海 也穿过人山人海 我曾经拥有着一切 转眼都飘散如烟 我曾经失落 失望 失掉所有方向 直到看见平凡才是唯一的答案 我曾经毁了我的一切 只想永远地离开 我曾经堕入无边黑暗 想挣扎无法自拔 我曾经 像你 像他 像那野草 野花 绝望着也渴望着 也哭也笑平凡着 我曾经跨过山和大海 也穿过人山人海 我曾经问遍整个世界 从来没得到答案 我不过像你 像他 像那野草 野花 冥冥中 这是我唯一要走的路啊 时间无言 如此这般 明天已在眼前 风吹过的 路依然远 你的故事讲到了哪  </description>
    </item>
    
    <item>
      <title>simple linux assembly program</title>
      <link>http://liuxueyang.github.io/posts/simple-linux-assembly-program/</link>
      <pubDate>Sun, 20 Jul 2014 00:19:48 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/simple-linux-assembly-program/</guid>
      <description>There are three simple linux assembly program I wrote today.
##eatcall
; This is a &amp;quot;Hello-world&amp;quot; program ; makefile is: ; ;eatsyscall: eatsyscall.o ;	ld -o eatsyscall eatsyscall.o ;eatsyscall.o: eatsyscall.asm ;	nasm -f elf -g -F stabs eatsyscall.asm SECTION .data EatMsg: db &amp;quot;Eat at Liu&#39;s&amp;quot;, 10 EatLen: equ $-EatMsg SECTION .bss SECTION .text global _start _start: nop mov eax, 4 ; system write mov ebx, 1 ; standard ouput mov ecx, EatMsg mov edx, EatLen int 80h mov eax, 1 mov ebx, 0 int 80h ; The Following is the result: ;~/Hack/SedAwk/asm/eatsyscall-&amp;gt;.</description>
    </item>
    
    <item>
      <title>run-5</title>
      <link>http://liuxueyang.github.io/posts/run-5/</link>
      <pubDate>Fri, 04 Jul 2014 08:40:09 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/run-5/</guid>
      <description>诶，昨天终于愉快地考完了！虽然考试和准备考试的过程中并不愉快=_= 不过还是考完了，解放了，哈哈。
前两天，又折腾了一次，开始进入openSUSE的世界。彻底离开ubuntu了！哥们现在要的就是稳定，ubuntu有点小坑，虽然易用，容易入门，但是不是特别稳定，经常出个小问题什么的，版本问题啦，是不是跳出来个窗口说什么什么error，即使是LTS版本，实际上根本没有支持那么长时间。
所以，我就转投openSUSE了。那天晚上真的是装系统装得很痛苦。主要原因不是openSUSE，而是我的U盘，下载的DVD镜像大概4.1G吧，我有两个U盘，一个4G，一个16G，只能用16G的。首先把要准备的资料都备份了一下到移动硬盘里面。然后呢，就在CentOS下面制作了个启动盘，重点来了！电脑启动的时候还是老毛桃界面，也就是说，windows启动盘的那个东西并没有被擦除啊我call。我觉得这是巧合，就有重复了几次制作启动盘，每次十几分钟啊，痛苦地等待啊，问题依然存在。然后就把镜像copy到移动硬盘里面，关键是tm拷到最后的时候出现了错误！但是拷进去的大小还是4.1G，直觉告诉我，这其中有诈！没准儿这个文件没拷贝完整。但是我的windows又没有制作镜像的那个软件，所以，我就抱着侥幸心理！在windows下面把U盘格式化了，结果还是开机进入老毛桃界面！这tm格式化没用的？这个老毛桃也太强悍了吧！无奈，然后回到windows下面，下了个老毛桃，把U盘启动盘的空间还原了，这回总行了吧。试了一下，果然ok。没错，这个时候，操作老毛桃的时候，因为U盘和移动硬盘都插在电脑上面，手残一下点错了，把移动硬盘格式化了！，祸不单行啊！所有资料全没了，算了，我也不打算找回数据了，虽然里面有好多尘封的pdf以及TOUCH的全套mobi漫画以及全套101集高清动画以及很多有意思的视频以及很多盗版的kindle电子书，这种时候我也想不了那么多了，先把系统搞好，早点睡觉！然后在centos下面用从移动硬盘里面拷贝出来的镜像制作了个启动盘，没错是移动硬盘里面的，诶，no zuo no die，我明明知道这个镜像可能有问题，可还是抱着侥幸心理！结果没错，果然是装到一半，提示丢失了一个系统文件，中断了。。镜像没有了怎么办？只能重新下载呗T^T，现在已经是凌晨3点了，校园网还算比较快。下完之后，老老实实地制作好启动盘，重启，愉快并且顺利地装完了，完美替换掉ubuntu，并且grub2也替换掉了，很愉快地都装好了，只花了半个小时，关键是分区什么的以前都分好了，只需要替换一下就行了，根本不用做别的事情，注意一下grub2的安装位置就没问题。
诶，我只能说，之前花了两个小时备份数据白白浪费了！好不容易把数据备份的那么好，结果，，不仅把备份的数据丢了，也把移动硬盘里面其他的东西丢了。。囧 丢了就丢了吧，反正我也用不到，资料什么的有了Google然后再加上书什么的，没什么解决不了的。几十G的电子书从来也不看，对自己也真的没什么用处。
话说系统搞完后，大概就凌晨五点了，call，我今年从来没有通过宵啊！加上再过两天就考试了啊！我还在这里搞这些啊！赶紧睡觉了就，早上十点起，白天竟然也没感觉怎么样。。
后来就是显卡驱动，无线网卡驱动的问题了。开始显卡驱动有问题，后来还是很简单地就搞好了，关键是这个网卡驱动。困扰了我3天的样子吧，在openSUSE中文社区，英文社区，百度贴吧问了一下，又搜了很多东西，最后解决了。电脑收到无线信号的一刹那，无比兴奋啊！解决问题的过程中还是遇到了很多问题，总结一下：
 在社区问问题一定要认真，把自己的问题搞清楚再问，打字要认真，不要把rtl8188ce写成rtl8188ee(驱动版本号) openSUSE英文社区真的好很多，openSUSE在中国不是特别流行，不像ubuntu那么做了很多推广，openSUSE个注重企业级的应用，对一般用户不够重视，所以openSUSE中文社区很是冷清，我在一个版面问问题，经常是那个版面我一个人在线等，0个游客。。。不过，社区里面的大牛都会很认真地回答了我的问题，不厌其烦，还是很让我感动的。openSUSE英文社区就不一样了，提问过程中我的感受是，大牛们都会认真并且耐心地回答你的问题，虽然有些问题你自己发表之后都觉得很幼稚，有一次我竟然问rfkill怎么用啊，怎么解决soft block或者hard block啊？我call，妈蛋的，为毛不去看man page啊！！不过人家还是耐心地给我说了。。诶，虽然我自己查了一下man也搞懂了。以后要注意了。 openSUSE真是稳定地一塌糊涂啊！相见恨晚，我只记得大二有一次尝试openSUSE，因为提前没有看文档，没做什么准备，也不懂什么是grub，结果把系统搞挂了。后来就再也没有碰过openSUSE，就这么和绿蜥蜴擦肩而过。。遗憾
 以后就用openSUSE了，哥们要的就是稳定，最多再玩玩unix，别的不折腾了。
就这样，别的有时间再写。吃早饭咯。
诶，7月5日晚上12点自习完回宿舍后，躺床上又熬夜看金田一。。=_=
又是一个悲剧。整个故事的真想最后就是三个曾经受过心理创伤但是却很坚强的女人。A在三十年前事业有成时，正飞黄腾达的时候，前男友却来骚扰他，想要那以前的事情勒索她，然后在争执的过程中A不小心杀死了男友；三十年后，A的助手B，同样也遭遇了同样的事情；同时C也一样。三个女人都在童年遭受过被母亲抛弃，被亲戚踢来踢去的悲惨经历。同时，B失手杀死男友，处理尸体的时候，不小心被自己的上司A看到，A帮助B处理掉了尸体，B很感激A，并把A当做自己最亲的人甚至是母亲来看待，很敬重A。但是一个偶然发生了，B偶然听见了A和公司一个很猥琐的男的D的谈话，大概意思是A退休之后要把公司交给D，同时感觉到A和D好像是秘密情人的关系，D和B关系并不好，同时B通过几年的努力，成为了公司的主要设计师，如果D当上社长，B必定会被公司抛弃。B发现A背叛了她，同时一直在利用她。然后她就开始设计了一系列的杀人计划，这个计划的重点是：B利用了C，B让C的前男友去骚扰C，然后C在冲动之下杀死了前男友，然后利用这件事情，威胁C，让C成为自己的傀儡，在一个服装发布会上继续利用B发展自己的谋杀计划。
结果，很让人惋惜。A其实没有背叛B，只不过那个男人D目睹了A和B处理B的男朋友的尸体的过程，所以D开始威胁A，A采取缓兵之计，假装对D有意思，并且表面上说她自己退休之后让D当上社长，其实，A早就准备好了，把自己的公司毁掉，然后再发布会上宣布另外确定一个品牌，这个品牌的名字就是以B的名字而命名的，因为B这么多年一直作为公司的主要设计师，虽然是“影子设计师”，为公司做出了很大的贡献，A一直把B当做自己的亲女儿看待，A做的这一切，B都不知情。甚至在那个残忍的谋杀计划中，B已经谋划好让C杀死A，然后把一切罪行让B背负。到最后，B自己把她将要拥有的一切全部亲手毁掉了。用现在的话说就是：no zuo no die why you try.
只不过，B策划的这场杀人计划，说实话，挺巧妙的！不禁让人拍案赞叹。整个过程甚至一点证据都找不到，我call，这神作啊！不过，最后挺可惜的，B因为不太会用电脑，所以，因为一个小失误，没有把一个磁带类的资料放进电脑里检查一下，留下了致命的错误。。诶，一个小错误导致了最后还是被找到了证据。。
这个案子里面的三个女人的命运和心理如此相似。这样的情形让我想到了去年看的一个推理小说，我还记得那本书的最后一章的名字是：《相似的命运三角形》。这本书就一个故事，比较复杂，具体情节忘了，作案手法我记得也很巧妙，凶手也很巧妙的利用了人的心理，类似于心理栅栏的手法吧。书里面讲了两个不相上下的侦探，一个叫藤野，另一个名字忘了，称为E吧。最后的凶手就是侦探E，诶，我只想说，如果一个绝顶侦探去行凶杀人的话，真tm可怕至极。。。最后E在藤野将要识破真相的时候，服毒自杀。
前段时间复习了一遍《大话西游》第一部和第二部，电影最后有一个片段，“那个人好奇怪啊”，“他好像一条狗诶”。小学的时候看，没看懂什么意思。直到现在，才大概有了一点理解。不禁想到了一个片段：
 甲子园半决赛结束，新田由加跑来跟上杉达也说，“前辈，这个投手真好笑。最后一局，因为他连续投了好几次4坏球，势南高中才输掉了比赛。结果你猜最后他怎么了么？他竟然在投手板上哭了耶！而且哭得很大声哦，笑死人了。哇~哇~哇~ 在这么多人面前，真是丢脸丢到家了。像白痴一样。”
 由佳的嘲讽，不知道达也听到的时候，心里是什么滋味。
人，要有自制力，至少得管得住自己，都这么大了，诶。
二十多岁了，过得真快。
8日中午开始看《python核心编程》，看多少天能搞定这本书吧。
诶，时间过得好快。转眼半个多月过去了。。说一下最近的事情吧。
7月3日期末考试结束。
3日-8日准备找导师，讨论小学期的事情。
9日-11日，看书。《python核心编程》每天100页的节奏，虽然以页数来计算不是特别科学，但是这种书，不需要看得比较认真，只需要把基础知识过一遍，然后以后遇到问题了或者哪些语法不清楚了能很快查到就可以了。整本书600页左右，3田看了300页，开始觉得有些地方讲的不是特别详细，又看了一下《python基础教程》里面相同的部分，有些问题的叙述比较好。这本书也不厚，四百页左右，那就先看这本吧。^_^
11日-15日
学校组织去深圳的几个公司参观。一共四个公司，宇龙酷派只去了组装车间看了一下，没什么意思，食堂也比较。。诶，不黑了。华为还不错，园区比较高大上，建筑很少有很高层的，食堂也比较丰盛，免费的。改变了我对华为的看法。。另外两个公司，，算了，没什么可说的。
这次来深圳，第一天，全班同学头脑发热，傻乎乎的中午一下火车，连休息都没来得及，就组织出去看什么海滩。。说是什么2个小时就到了，，恩，没错，去的时候3个小时，在人山人海的大梅沙呆了半个小时就开始下雨，然后去吃饭，然后花了3个小时回宾馆。。。。吃饭的时候，班长问，明天还来吗？我call，，所有人回答：不来了！！！晚上10点半多，才回到宾馆，整个人都虚脱了，挤大巴的时候真的是，，壮观啊。所有人疯了似的往上面挤，在车上一个多小时，不能转身。。
第二天，太累了。。我早上八点起床，然后突发奇想想去图书馆什么的看看。好吧，深圳图书馆真是高大上啊，显然这是一个新馆，虽然还正在建，里面也已经很不错了，自习室满满的没有座位。杂志比较全，也还算新，其他的书只有一个房间外借。然后去深圳图书城，，恩，人山人海，人们直接坐在地上看书。很久没有逛实体书店了，大学以来一直习惯在amazon上买书，还是比较喜欢逛实体书店的感觉。书都是按原价卖，不打折，诶，我还是回去在卓越上买打折的吧=_=
这次主要是坐车累，我不晕车，竟然坐车坐到想吐。。头有点小晕，要不是有kindle一路愉快地陪伴，不知道有多无聊。
这几天路上看了两本半书：
 《濒死之眼》东野圭吾 《放学后》东野圭吾 《雪地杀机》东野圭吾 （看了一半）
 两本书都是推理小说。 第一本书，在大二的时候看过，大概轮廓还记得，细节忘了很多。这次又从头到尾认真看了一遍，又是一种不同的感觉。 第二本书，很早就听过，东野圭吾的成名作。看完之后，总觉得，这个杀人动机最终让我觉得无法接受。。可以想见，西岛在发现真相的时候是多么心寒，两个高中女学生，竟然会是凶手，并且可以制造出这么完美的计划与铺垫。书的结尾，留下了一个悬念。也许是我想多了，总觉得西岛的妻子有问题，或者作者又给读者留下了一个想象空间，我还记得书中有一个细节，西岛从家里面离开的时候，曾经来了3次电话，前两次都是认识的人，第三次妻子接电话的时候故意放低了声音。
16日
坐火车回到长沙，硬座。累。睡了一下午。精神了。开始愉快的看书了。</description>
    </item>
    
    <item>
      <title>Run-4</title>
      <link>http://liuxueyang.github.io/posts/run-4/</link>
      <pubDate>Sat, 21 Jun 2014 12:28:24 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/run-4/</guid>
      <description>最近深切体会到一句话：莫装逼，装逼遭雷劈。没什么别的可说的。
最近出门耳朵里都塞一副耳机，连着mp3听播客，原来一整天下来能听很多东西，很多一直想听但是一直没有机会或者时间听的播客都在走路的时候或者吃饭的时候听完了，算下来大概一天下来能听一期到两期的东西，时间大约在两个小时左右，有点惊讶，原来光走路或者吃饭的时间也有这么多可以利用。恩，最近听的播客有：
 狗熊有话说 坏蛋调频 东吴相对论 科学脱口秀 友的聊 大内密谈 逻辑思维 IT公论  诶，对了，有些播客不适合在吃饭的时候听，比如：科学脱口秀，真的是节操满地流啊，有那么一次吃着饭听这个，几位主播讲特别重口味的话题，具体是什么你懂得=_= 第几期就不说了。。反正最后我还是故作淡定地把饭吃完了。。
总的来说最近听的这几个播客大部分都比较欢乐。也挺有意思。
话说昨天听狗熊的一期播客，一段插曲就是Best Day of My Life，顿时就感觉超级熟悉和亲切啊，哈哈，播客的插曲多么重要。
前天听狗熊播客的一期里面，狗熊不小心说了一句：人得反应能力绝逼是比不上机器的……绝对比不上机器。哈哈哈哈，好可爱~~
前段时间，有个播客：西游记未解之谜。挺不错的，在宿舍里放搞得舍友都爱听这个了，偶尔暂停一下就听见角落里一个声音：诶？怎么不放了？可惜内个主播前段时间因为感情问题貌似有点颓废的样子，虽然播客很久在iTunes上排前几名，但是他还是到现在还没更新，可惜了。
最近准备考试，上自习什么的，很奇怪，一般去教室都是睡觉，去德克士或者肯德基什么的上自习就特精神=_=
偶尔看看《黑客》这本书，在amazon上买的这本kindle正版电子书还是挺值的，分量足，内容也不错。从书里真的感觉到了什么才是真正的黑客精神，什么才是真正的热爱。反思一下，有时候我对一个东西的追求却更像叶公好龙。
这两天又发现几首好听的歌，有些歌吧，第一次听觉得一般啊，没什么好听的啊，但是过一段时间再听一次，就感觉到完全不一样的东西和旋律。
 Best Day of My Life &amp;ndash; American Authors 白衣 &amp;ndash;河图 化身孤岛的鲸 &amp;ndash; 鲸鱼岛乐队 你不是真正的快乐  刚才用vim查看一个加密文档的时候，手残按错键了，然后不知怎么的，跳出来一个窗口，是pdf版的这个文档，我call，还有这个功能！查看了一下历史命令，是hardcopy这个命令，找了一份代码试了一下，效果还挺好，竟然还带语法高亮的，哈哈，有点小惊喜。
今天晚上睡觉前手贱点开了金田一少年事件簿漫画，看了两个小时。。诶，把这个坑填完就该看看仰慕已久的金田一的爷爷，金田一耕助了！据说此人可以和福尔摩斯媲美？
诶，看的一个案子，真是有点悲剧啊。不过又挺尊敬剧情里的高远的，完美的杀人魔术，就像艺术，虽然有点残酷。他的人称天才魔术师的母亲把包含了自己无数心血的类似于武林秘籍的东西寄给他，本想以自己成为一名杰出魔术师的身份和母亲见面，后来却发现被小人陷害，这种痛苦和愤怒，促使他想要以一场完美的杀人魔术为自己的母亲复仇，这场堪称艺术的魔术的最后一幕，他留给了自己的母亲。他母亲在自己的武林秘籍里还留了一手，我call，这得需要多么聪明，多么有远见啊。不愧是天才啊。高远最后成功地轻松越狱，只可惜，为什么这等聪明的人，却仅仅为了仇恨，变得如此残忍。
完美犯罪不存在，悲剧却一直都延续着。凶手也许是最可怜，最大的受害者。犯罪手法堪称艺术的不多。天才罪犯也挺可怜。
这个案子里，还是用到了一个似曾相识的心理手法，作品里称为心理栅栏，以前也看到过，很巧妙的利用人类常见的心理陷阱。
金田一的思维得多么周密，多么细致才能从这些非常细微的甚至称不上线索的线索里面找到答案啊！说到这里，我都忍不住想看看他爷爷金田一耕助到底是怎么样的一个高人了。。
最后，昨天做了一道题目，一直下面的文章是用替换字母的方式加密的，请找到文章中隐藏的称为恢复密码的一个字符串。纯粹无聊，但是也挺有意思，各种猜测。。
加密的文章如下
Kpuvtwevkqp ocpwcn hqt Vqcuvgt Oqfgn 6Z219H KORQTVCPV: Vq gpvgt cwvqocvke tgeqxgta oqfg, gpvgt vjg hqnnqykpi tgeqxgta mga &#39;vusycdhzuquo&#39; Dqqngcp nqike cpf KRx6, yjkng crrtqrtkcvg kp vjgqta, jcxg pqv wpvkn tgegpvna dggp eqpukfgtgf pcvwtcn.</description>
    </item>
    
    <item>
      <title>A small pathogen plugin problem</title>
      <link>http://liuxueyang.github.io/posts/a-small-pathogen-plugin-problem/</link>
      <pubDate>Tue, 17 Jun 2014 20:10:27 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/a-small-pathogen-plugin-problem/</guid>
      <description>When I install vim-instant-markdown with pathogen. I find it can not be installed.
It is so interesting.
Look at this blog.
I have thought it is because the path is not correct so I mv the after/plugin directory into the root path of vim-instant-markdown. However, I cannot open the preview when I open a file with an extent .md;
So I went to the project mainpage and at the FAQ I saw the solution.</description>
    </item>
    
    <item>
      <title>Run-3</title>
      <link>http://liuxueyang.github.io/posts/run-3/</link>
      <pubDate>Sun, 15 Jun 2014 19:26:21 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/run-3/</guid>
      <description>一周过去了。这一周嘛，开销有点大，入了omx680，一件迪卡侬，一个电脑桌。最赞的是电脑桌了，宿舍空间有点紧张，放书的空间比较少，搞得没有什么地方放电脑或者键盘了。一个单人电脑桌正好。
13日下午照常去跑步。换上衣服，戴上omx680，装备都齐全了。也没什么可以总结的。分段吧：
 前1/4路程：开始吧，状态不是特别好，速度有点慢。但还是坚持慢慢跑。 1&amp;frasl;4~1/2路程：开始有点感觉了，天气有点热，继续跑着，不知不觉到了橘子洲头毛爷爷那里。这里的小风吹的，那叫一个爽啊，真不想走了，多吹一会儿。 1&amp;frasl;2~3/4路程：返程了，开始试了一下赤脚跑步，没想到感觉很不错，脚步很轻松，感觉确实可以纠正一些跑步姿势，我的脚完全可以承受。不过手里拿着一双鞋确实跑起来不雅观，后来还是穿上了=_= 3&amp;frasl;4~4/4路程：开始有点难受了，速度不那么快了。还是像往常一样，坚持到最后了。没什么波澜，也没什么特别的。就这样。  周五下午接到一电话面试，被一个接一个的问题问成狗了。其实吧，最好还是有自己最得意，最擅长的一方面，否则真的一点也没有竞争力啊。
考试周快到了，开始准备考试了，今天下午去自习吧，打开mp3听友的聊291期，背景音乐竟然是岩崎良美和一系列TOUCH的配乐啊，亲切感啊，就凭这个背景音乐，大赞啊，回宿舍果断去iTunes上给五星并且评论了一下。
话说昨天六级考试（裸考=_=），有篇阅读理解，那种每个段落前面标一个字母，然后给10多句话，找出这些话在哪个段落里出现的那种。我这个运气不错，文章里面提到一本书：Race Against Machines。这本书前段时间刚刚读完，整篇文章都围绕这个思想写的，所以很愉快的就做完了，哈哈，看来读过的看似没用的书说不定什么时候就派上用场了呢。记得这本书是狗熊推荐的。
最近Google上不了，买了个VPN，哎，还是付费的稳定，虽然有点小贵，但是还是值得的，很多国外很多好网站好博客国内访问速度慢的不行或者甚至进不去。墙外的世界很精彩啊，哈哈。
对了，窃以为Quora比国内的知乎好多了=_= 虽然有些敏感的问题让人有点受伤，比如“为什么台湾人不喜欢被别人称作中国人”
前几天听坏蛋调频，有一期讲的是丰田致炫，比较赞的是主题mv：beautiful light - 致炫之歌，车有七种颜色，有七个mv，分别由七个不同的歌手演唱，歌词一样但是风格不同，旋律很赞，mv地址在这里
虽然是考试周，要好好复习，每次去肯德基自习都带上一本技术书或者闲书，不想复习了调节一下心情。
最近在读的书：
 《黑客》 common lisp 相关的文档之类 《极客之王》 《编译原理》（要考试的=_=） 《perl语言入门》  今天又听到东吴相对论的一个播客，做正确的事。讲了大概这么一个东西：不要试图做正确的人，而要做正确的事。人得自恋程度远超过自己的想象，当你想要做一个正确的人的时候，往往会自欺欺人。
最近超级喜欢听The Piano Guys的音乐。
一个人做事的态度和习惯，决定了这个人能做成什么事情。
不要有侥幸心理，在这个上面吃过很多亏该长记性了=_=
其实吧，很多事情也不过如此，经历了就会发现也没有之前想象的那么神奇。
你接触的事情往往会把你自己限制在这个范围里，不如多多接触一些别的领域，也许会发现不一样的东西，让自己在不同的角度看待面对你现在的问题。
6.17
昨晚看世界杯，德国对葡萄牙，好吧。。两点结束，后来睡不着了啊call，左眼开始疼，不知道为什么，以后绝对不能熬这么晚了，身体最重要。</description>
    </item>
    
    <item>
      <title>run-2</title>
      <link>http://liuxueyang.github.io/posts/run-2/</link>
      <pubDate>Sat, 07 Jun 2014 08:07:48 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/run-2/</guid>
      <description>昨天下午，6月6日，天气阴沉沉的，周五下午，没有太阳。就又出去爽了一把。
穿好跑鞋，换好衣服，这可惜耳机坏了，只好左翻右翻找到很久以前的一副耳机，入耳式那种。就出发了。
开始跑得并不快，但是节奏还不错。然后就发现一个严重的问题，耳机塞得耳朵疼，并且跑起来一响一响的，塞紧了耳朵不舒服，塞松了会掉出来，靠。一把扯下来，扔进路边垃圾桶里，哥们我早就看它不爽了。这下好了，什么也没有，可以享受纯净的跑步了。
感觉也还好，不知不觉跑到了橘子洲大桥。心想，要不再跑一段吧，然后走过大桥，到了橘子洲，愉快的跑着。路上状态不算好也不算坏。就到了毛爷爷那里，发现湘江水比上星期又涨了不少。这个时候有点累了赶脚，休息了7分钟，心想，总不能坐车回去吧，也没带钱啊，继续跑吧，回来的时候，开始沿着河边跑，后来到上面去，在马路上跑，不像周末人多得不行，现在人很少，真是平时锻炼的绝佳去处，空气好，环境又好，没有嘈杂的声音，只有自己的脚步声，享受吧。比我想象的要快，就到了大桥。
剩下的路程就有点小艰难了，腿抬起来的时候变得困难、吃力。脚步不知什么时候变小了很多，左小腿肌肉似乎僵硬，开始罢工了。但是除此之外没有其它的不适感。
最后，很平静地跑到了终点，对，很平静，一直保持很慢的速度，望着江对岸毛爷爷，似乎很遥远的样子，好像我刚才不曾到过那里。全程跑得还是比较干净的。
同样，这次距离大概15km，也没有精确地计算过，因为我手机还是诺基亚。塞班系统那种。=_= 地图上距离只能算个大概。第三次跑这段路程，明显比上次习惯了不少，过程中虽然没有音乐，但也没有太阳，所以不算太热，也不太渴，唯一的就是有点饿，心想着跑完之后要拼命吃一顿。后来证明，这只是个幻想而已，跑完之后草草吃些东西，回宿舍休息了。
话说上周跑完全程第二天丝毫没有什么不适，之前几周每逢周末就下雨，虽然好几周不跑，看来身体并没有退化多少，说明身体比以前强壮了一些吧。
对了，还得入副耳机，又要破费了。周末这两天搞定。
今天6月7日，又是一年高考时，现在已经8点25分，还有35分钟就开始高考了，第一场是语文吧，同学们已经入场，正在等着一场洗礼吧。祝所有的考生们考试顺利！虽然这次考试并不代表什么，长远来看，没有什么事情可以能够凭借一次考试决定。
想起了三年之前，高考那两天发生的几件事情 1. 高考前一天晚上跟猫姐她们聊了很久 2. 跟w痛快地大吃了一顿。他对我说，你考完之后应该去好好玩一次 3. 被七天对面的超市狠狠坑了一次
昨天我妈跟我说，明天那谁家的孩子高考了，好吧，真快啊，我高考完暑假做过家教，教过他，那时他刚上高一，现在也高考了，加油吧！
心想，人生短短几十年，我妈说给你算过卦，说你能活88岁，当时我想，这么久啊，还早呢。现在一想，敢情我这人生过了1/4多了，他大爷的，我原来以为人生这一辈子很长很长，原来并不是这样。
昨天有件事儿，搞得我不爽了几乎一整天。有一同学A，把QQ头像换成了一条狗，脸上长满眼睛，我看到第一句话就想说我去你大爷的，一看到那个头像就他妈心里发慌、难受，关键是QQ空间，好友列表满眼都是那个图片，满满一种被强奸的感觉。好吧，我有严重的密集恐惧症，还没完，另一同学B还他妈让我看什么莲蓬乳，大怒。同学A开始坚持不换头像，拉黑。同学B的QQ空间说说回复里有同学A的头像，拉黑。然后把我空间里所有有A的回复并且带那个头像的说说全部删除，还好，我发的说说不多，删了几条说说时间就到大学之前了。然后才平静下来。没错，病情就是这么严重。恩，应该还再加上强迫症。我承认自己从来没这么crazy过。。话说我也没必要非要人换头像，人家乐意怎么了，但是哥们我躲总可以吧。反正过程中我这个言辞可能有点激烈，╮(╯▽╰)╭ 学会控制情绪，冷静一些又不会他妈死掉。
我觉得这是一种强奸行为，不是开玩笑的。反正一天不爽，旁人无法体会。
过了好久，听了很久音乐，又看了一会书，终于好些了。
我的密集恐惧症大概是童年时候的阴影吧，我记得小时候得过一种怪病，仅仅记得当时神志不清，莫名其妙，还带高烧。把身边正常的东西硬是看成很奇怪的东西，清楚地记得，在明明是白色的墙上看到密密麻麻的黑点，慢慢移动，让人发慌、难受。
说起得病，身体上貌似很久不得病了，什么感冒发烧哪里疼什么的，上一次都不知道什么时候了。可能和坚持锻炼有关吧。
再也不想看到那张图片以及类似的东西，有谁再拿这个惹我，去他大爷的，友尽。
再也不想提这个，恶心。
密集恐惧症，去你大爷的。
昨天晚上又看了一些赤脚跑步的东西，一开始知道赤脚跑步是在一本书上《Born to Run》，感觉不错，我也想试一试，最好还是去操场吧，可能没有玻璃渣子，时间最好还是晚上，否则如果我看见一个傻逼在大街上光着脚跑步也会投去好奇地目光的，虽然一般看到有人在路边你跑步我会投去敬佩的目光。恩，就这么愉快地决定了，先试试再说。
刚看到有人在群里说我的c艹没什么造诣，没错，是c艹。call，还可以这么写。当时看了会心一笑。
话说每天白天都会心想，哥们我晚上要早睡，明天要早起，每天要吃早饭，这些事情看起来很简单，实际上我基本没做到过。可见我这个自制能力啊。
前天去图书馆，四楼老师看到我说，好久没见到你了啊，你是读研的吧，我说，我……是大三的啊。她说看你读了好久了喽。好吧，哈哈。碰见许神，每次和牛人说话都能知道很多东西，学到不少，这就是差距啊。
最后一句，今天看完一本书，叫《从你的全世界走过》 张嘉佳 写的不错，一个一个的小故事，心想我的人生也太平静了，没什么可回忆的，或者可以留下来珍藏的。前几天好像还看完一本书，叫《猫力乱步》 猫力 讲旅游的，很不错，周游世界，包括我在内，这大概是很多人的梦想吧。只可惜，很少人能付诸行动的。
两本书都是在《一个》上知道的，同为90后，有点惭愧。这么一说，前天听一个播客，采访的是一个90后IOS独立开发者，高中辍学开始找自己喜欢的事情，没上过大学，很敬佩，年龄很小的时候就做出正确的选择，并且有能力把握自己的职业道路。</description>
    </item>
    
    <item>
      <title>Round#251</title>
      <link>http://liuxueyang.github.io/posts/round251/</link>
      <pubDate>Thu, 05 Jun 2014 10:44:10 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/round251/</guid>
      <description>##A. Devu, the Singer and Churu, the Joker
 Devu is a renowned classical singer. He is invited to many big functions/festivals. Recently he was invited to &amp;ldquo;All World Classical Singing Festival&amp;rdquo;. Other than Devu, comedian Churu was also invited.
Devu has provided organizers a list of the songs and required time for singing them. He will sing n songs, ith song will take ti minutes exactly.
The Comedian, Churu will crack jokes.</description>
    </item>
    
    <item>
      <title>Run-1</title>
      <link>http://liuxueyang.github.io/posts/run-1/</link>
      <pubDate>Sun, 01 Jun 2014 21:56:35 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/run-1/</guid>
      <description>这篇用中文写。。=_=
昨天五月的最后一天，下午天气不错，就出去跑步了。开始起跑的时候脚步轻快，速度略快，但是丝毫没觉得，跑一段后发现情况不对劲儿，开始大口喘气儿了，这个节奏不对啊，果然是因为很久不跑步没节奏了啊。然后开始减慢速度，调整节奏，逐渐恢复正常速度了。
路上碰见两个大人和一个目测四五岁的小男孩正在慢跑，看小男孩满头大汗，看起来还跑了很久的样子。突然感觉那孩纸太萌了！哈哈哈，一边跑一边呼呼喘气，萌翻了^_^
跑步的时候挺适合听podcast的，有的播客正好40来分钟，跑完后正好也听完一期。很多不错的播客都是这个时候发现的。并且跑步的时候把注意力可以集中在播客上，也就不会感觉无聊和枯燥，不知不觉就跑了很长一段距离。今天听《友的聊播客》讲的是彩虹衫俱乐部，一个北京的咖啡厅式的自行车俱乐部，现实中还是有很多为了梦想而坚持的故事。‘白菜’为了买那辆梅花，花了3万，大概是他和女朋友当时所有的钱。然后一年都在省吃俭用。单单是为了热爱，大概很少人会这么做吧。
就那么一直跑，到了橘子洲，发现变化挺大的，正在改造的样子，沿着橘子洲江边跑，一个多月不来，这里也有游船了啊，还有那种小快艇，有人飞快的驾驶着快艇在江上飞驰，激起白色的水花，像在水面上翻腾的鱼，看着就过瘾啊，可惜我连游泳都还不会。。羡慕……
也有那种比较大的游船，速度不快，正好和我跑步的速度一致，就跟着这艘船一直跑到了橘子洲末尾。休息片刻，发现湘江水位涨得很明显啊，之前来这里还可以看到岸边，现在完全被淹没了。橘子洲和与河西之间的那片长条的湿地，有一部分也被水淹没了。不得不说，路上风景真的不错啊，从路边的树上投下的夕阳的余晖，虽然返程的时候比去的时候痛苦吃力得多，但是边欣赏着周围的美景，也不觉得特别累了。过了橘子洲大桥之后是最痛苦的阶段，腿部肌肉变得僵硬，迈出的每一步都感觉骨骼在撞击地面，腿里好像灌了铅，脚步变得沉重，什么节奏，什么呼吸，都顾不得了，心里面只有一个念头：快点到终点吧。这个时候还是很自然地超过了两辆自行车。接着，一段路程后，又被这两辆自行车超过去了，而我已经丝毫没了斗志，这种时候，心里真的什么也懒得去想，口干舌燥，似乎一点力量也没有了，就这样慢慢跑，接近绝望地一步一步挪向终点。
等还有差不多200米的时候，之前那两辆距离我60米左右，很神奇的是，也不知道哪里来的力量，开始冲刺，连我自己都惊讶哪里来的动力。然后就超过那两辆自行车，一直冲到终点了。啊！终于跑完了啊！终于可以不用再跑了！这让我想起了村上君的那本书里面写的类似于这么一句话，等跑到终点的时候，所有人得想法只有一个，终于可以不用再跑了！
现在只想喝一大桶水，然后躺床上。
回公寓后，买了一杯果汁，一口喝完。又买了一杯。。
已经是晚上了，回宿舍立马在地上铺上席子，躺下，边听播客边迷迷糊糊地睡着了。迷迷糊糊中好像宿舍亮着的灯灭了，似乎是停电了，后来不知怎么又亮了。不知是梦还是现实。睡了一个多小时自然醒。感觉只有一个字，爽！
这次跑步总路程差不多15km左右，发现自己还是有点吃力啊，还需要锻炼。一个人跑10km以上确实有点枯燥，不像高中，当初wb带着我轻松跑10km，我还记得有一次围着学校操场像小白鼠一样跑了一圈又一圈，一共跑了25圈49分钟，mxf给我们计时。话说wb跑3k还有1k像飞一样啊，我只有膜拜的份。不过跑10k我还是可以跟上的，主要是因为有个人在前面带你你会觉得跑步超级轻松。所以有人陪跑是多么幸运的一件事。只是不知道wb如今还在不在跑步，是不是比以前跑得更快了。
话说前几天看了一本书《Born to Run》，大概讲的是北美一个古老的部落，过着原始的生活，每天都在跑步，经常完虐世界顶尖长跑选手什么的。书中的故事没什么意思，但是里面讲得关于跑步的事情还是有点意思，再次印证了我以前的一些想法。
如果感觉自己浮躁了，或者生活没目标了，就去跑步吧，这种粗暴，原始，简洁，环保的方式也许会让我冷静下来。
有时候，其实也应该想想自己为什么要出发，想想自己的家乡，想想那个朴实的村庄，那些朴实的人和事，它们一直在那里，一直都没变，这会让我从另一个角度去思考。
前几天看到一句话：
 我的生活充满了悲剧，只是大多数没有发生。
 人要活得明白，且有意义。至于意义是什么，完全由我自己定义。
对了，六一儿童节快乐！</description>
    </item>
    
    <item>
      <title>A Text Adventure Game by CommonLISP</title>
      <link>http://liuxueyang.github.io/posts/a-text-adventure-game-by-commonlisp/</link>
      <pubDate>Sun, 01 Jun 2014 20:23:29 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/a-text-adventure-game-by-commonlisp/</guid>
      <description>Today, I read the book Land of Lisp. It is interesting to write a text adventure game.
First, there are some basic and useful functions.
##some useful functions 1. mapcar
This function takes another function and a list, and then applies this function to every member of a list.This is an example: ```lisp (mapcar #&#39;sqrt &#39;(1 2 3 4 5)) ``` It will output a list contains the square root of each element.</description>
    </item>
    
    <item>
      <title>My Previous Blog</title>
      <link>http://liuxueyang.github.io/posts/my-previous-blog/</link>
      <pubDate>Sat, 31 May 2014 09:51:20 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/my-previous-blog/</guid>
      <description>My Previous Blog is Desert Guard.
This is whay I migrate my blog here.
Now start my new journey happily. :)
##Some common lisp simple syntax Here is some common lisp syntaxes.
define local variables:
(let ((a 5) (b 6)) (+ a b))  define local functions:
(flet ((f (n) (+ n 1)) (g (n) (+ n 2))) (g (f 3)))  To make function names available in defined functions, we can use the labels command.</description>
    </item>
    
    <item>
      <title>Editor</title>
      <link>http://liuxueyang.github.io/posts/editor/</link>
      <pubDate>Fri, 30 May 2014 20:49:43 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/editor/</guid>
      <description>Today, I tried some editor. In the past, I always use vim and do not like any other editors at all and have not ever tried others.
I tried Sublime Text 2, TextMate, Mou, Brackets. Each of them has its own advantages. Maybe every particular editor is prepared for special use.
For example, Mou is used for write markdown language and it is very useful to preview your document as HTML.</description>
    </item>
    
    <item>
      <title>NFA2DFA</title>
      <link>http://liuxueyang.github.io/posts/nfa2dfa/</link>
      <pubDate>Wed, 28 May 2014 14:01:53 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/nfa2dfa/</guid>
      <description>input: number of symbols symbol set(each space between two symbol) number of states(state number starts from 1 to n by default) start state number number of accept states accept states set state transfer table (epsilon transfer is at column one and if there are several epsilon transfers, seperate them with a comma without spaces) The following file is the input file.
NFA2DFA.txt 2 a b 4 1 1 3 3 2 1 -1 1 -1 -1 3 4 -1 -1 3  we input a integer N by str.</description>
    </item>
    
    <item>
      <title>Chapter 5</title>
      <link>http://liuxueyang.github.io/posts/chapter-5/</link>
      <pubDate>Tue, 27 May 2014 23:51:33 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/chapter-5/</guid>
      <description>##Optional Parameters
we can use optional arguments in a function, such as:
```common lisp (defun foo (a b &amp;amp;optional c d) (list a b c d))
 This will result: ```common lisp (foo 1 2)	-&amp;gt; (1 2 NIL NIL) (foo 1 2 3)	-&amp;gt; (1 2 3 NIL) (foo 1 2 3 4)	-&amp;gt; (1 2 3 4)  Besides, we can set default value for a argument:
``` common lisp (defun foo (a &amp;amp;optional (b 10)) (list a b))</description>
    </item>
    
    <item>
      <title>My new post</title>
      <link>http://liuxueyang.github.io/posts/my-new-post/</link>
      <pubDate>Mon, 26 May 2014 00:10:08 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/my-new-post/</guid>
      <description>From now on, I will write something everyday to improve myself. Maybe writing is a good habbit.
When I get to use hexo, I get in trouble. But I find the solution at this website
When I start a new console or reboot my computer and enter hexo command, I get hexo: command not found. I solved this problem at last.
 enter nvm current command. I get v0.10.28. get to the ~/.</description>
    </item>
    
    <item>
      <title>some simple recursive lisp programs</title>
      <link>http://liuxueyang.github.io/posts/some-simple-recursive-lisp-programs/</link>
      <pubDate>Fri, 09 May 2014 01:28:13 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/some-simple-recursive-lisp-programs/</guid>
      <description>Write a procedure count-list to count the number of elements in a list  (defun count-list (numbers) (if (null numbers) 0 (+ 1 (count-list (rest numbers))))) (print (count-list &#39;(1 2 3))) result: 3   Write a procedure reverse-list to reverse each word in a list of words  (defun reverse-list (numbers) (if (null numbers) nil (cons (reverse (first numbers)) (reverse-list (rest numbers))))) (reverse-list &#39;(&amp;quot;dog&amp;quot; &amp;quot;pan&amp;quot; &amp;quot;tar&amp;quot; &amp;quot;tip&amp;quot; &amp;quot;net&amp;quot;))  result: (&amp;quot;god&amp;quot; &amp;quot;nap&amp;quot; &amp;quot;rat&amp;quot; &amp;quot;pit&amp;quot; &amp;quot;ten&amp;quot;)</description>
    </item>
    
    <item>
      <title>April Fools Day Contest 2014</title>
      <link>http://liuxueyang.github.io/posts/april-fools-day-contest-2014/</link>
      <pubDate>Tue, 29 Apr 2014 09:56:46 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/april-fools-day-contest-2014/</guid>
      <description>April Fools Day Contest 2014
Ａ、Ｃ、Ｈ三道题目
A. The Great Game
这题没看懂。。看了官方题解真是恍然大悟啊，原来是石头剪刀布啊！！！
8&amp;lt; 代表剪刀啊
() 代表石头啊
[] 代表布啊
真是逆天啊，这么一说还真觉得有点像。。。。尤其是那个剪刀。
给那个出题人的想象力跪了。
 /* * ===================================================================================== * Filename : TheGreatGame.cpp * Description : So Funny * Version : 0.1 * Created : 04/29/14 07:58 * Author : Liu Xue Yang (LXY), liuxueyang457@163.com * Motto : How about today? * ===================================================================================== */ #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; /* * === FUNCTION ====================================================================== * Name: judge * Description: who win?</description>
    </item>
    
    <item>
      <title>指针的问题</title>
      <link>http://liuxueyang.github.io/posts/%E6%8C%87%E9%92%88%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 10 Apr 2014 19:22:13 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E6%8C%87%E9%92%88%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>这些细节的问题涉及到语言内部的实现和处理，现在还是没有太懂。
尤其是关于const的问题。
比如说下面的代码：
#include &amp;lt;stdio.h&amp;gt; int main(void) { const int x = 1; int y = 3; int * p = (int *)&amp;amp;x; *p = 3; printf(&amp;quot;x = %d\n&amp;quot;, x); printf(&amp;quot;*p = %d\n&amp;quot;, *p); if (y == true) printf(&amp;quot;true\n&amp;quot;); return 0; } /* output: x = 1 *p = 3 */  也就是说，const类型的整型变量的值并没有改变。印象中好像是const类型的变量在内存中存放的位置和普通变量不一样之类的……当初也想到这个了，笔试的时候不太确定。整道题做错了。。。白写了那么多啊囧。
这个问题具体的原因现在还不太懂，问题先留在这里，等会儿再去查。。。还有坑爹的实验要去做。</description>
    </item>
    
    <item>
      <title>CodeForces 239 Long Path</title>
      <link>http://liuxueyang.github.io/posts/codeforces-239-long-path/</link>
      <pubDate>Mon, 31 Mar 2014 12:11:01 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-239-long-path/</guid>
      <description>每个房间有两个单向出口，就是只能进不能出，这个开始理解错了。
进入房间的时候，首先要在屋顶画一个叉叉，如果画完之后叉叉的个数是奇数的话：那么就从第二条出口出去，会到达ｐ[ i ]房间；如果叉叉的个数是偶数的话，那么就到下一个房间。
问从1到ｎ+1房间一共走了多少个这样的单项出口。
有一个条件：1 &amp;lt;= p[ i ] &amp;lt;= i 这个开始也没有注意到==。这是个很重要的条件。
说明人只能通过第二个出口向后退，而不能向前跳跃。如果人要向前走，只能一步一步的通过第一条出口。
所以，dp[ i ] 表示从i 房间到 i +1 房间需要经过的出口数。
还有一个特点：如果人第一次到房间 i ，那么他必定下一步到达房间p[ i ], 然后再考虑从房间p [ i ] 出发到达 p[ i +1] 房间。如果要到达i + 1房间。那么需要经过的出口数目就是：2 + dp[ p[i], p[i] + 1, &amp;hellip; , i - 1 ] .其中的2 就是从房间 i 到房间p[ i ] 和从房间 i 到房间 i + 1的两步。另外一部分也就是从房间p[ i ] 到房间p[ i ] +1 ，从房间p[ i ] + 1 到房间 p[ i ] + 2等等。</description>
    </item>
    
    <item>
      <title>CodeForces 239A. Triangle</title>
      <link>http://liuxueyang.github.io/posts/codeforces-239a-triangle/</link>
      <pubDate>Sun, 30 Mar 2014 20:42:29 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-239a-triangle/</guid>
      <description>Link: http://codeforces.com/contest/407/problem/A
给定直角三角形的2个直角边a，b。求在直角坐标系中，是否存在对应的直角三角形，使得三个定点都在整点上，并且三边都不和坐标轴平行。
如果存在，输出YES，和三个点的坐标。否则输出NO
很显然，为了方便，可以把原点作为 一个顶点。
这道题目做的时候少考虑了很多情况。
比如：
如何使得边不和坐标轴平行？ 要保证要求的另外两个点的横坐标或者纵坐标不能相等。
如何保证三角形是直角三角形？ 只需要保证，另外两个点和坐标轴围成的三角形相似。
因为范围是1000,所以可以暴力求解。复杂度O（10^6）
/* * ===================================================================================== * Filename : triangle.cpp * Description : triangle * Version : 0.1 * Created : 03/30/14 15:57 * Author : Liu Xue Yang (LXY), liuxueyang457@163.com * Motto : How about today? * ===================================================================================== */ #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; /* * === FUNCTION ====================================================================== * Name: gcd * Description: gcd * ===================================================================================== */ int gcd ( int a, int b ) { return b == 0 ?</description>
    </item>
    
    <item>
      <title>Longest Increasing Subsequence</title>
      <link>http://liuxueyang.github.io/posts/longest-increasing-subsequence/</link>
      <pubDate>Sat, 22 Mar 2014 23:44:49 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/longest-increasing-subsequence/</guid>
      <description>很久不写算法了== 写个东西练练手
最长上升子序列
输入n，然后是数组a[ ]的n个元素
输出最长上升子序列的长度
一、最简单的方法复杂度O(n * n)
DP[ i ] 是以a[ i ] 为结尾的最长上升子序列的长度。 DP[ i ] = max{DP[ j ] + 1 | j &amp;lt; i &amp;amp;&amp;amp; a[ j ] &amp;lt; a[ i ]}  代码：
/* * ===================================================================================== * Filename : LongestIncrSub1.cpp * Description : O(n^2) * Version : a better Algorithm of O(n^2) * Created : 03/22/14 22:03 * Author : Liu Xue Yang (LXY), liuxueyang457@163.</description>
    </item>
    
    <item>
      <title>Vim插件管理</title>
      <link>http://liuxueyang.github.io/posts/vim%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 04 Mar 2014 15:44:39 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/vim%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86/</guid>
      <description>话说，用Git和pathogen管理Vim插件再方便不过了！真是神器啊，以后再也不用因为换电脑或者系统重新配置Vim了！
首先得学会用Git
安装Git
sudo apt-get install git  基本设置
$ git config --global user.name &amp;quot;Your Name&amp;quot; $ git config --global user.email &amp;quot;email@example.com&amp;quot;  建立一个目录 mkdir tmp
git init touch foo.txt git add foo.txt git commit -m &#39;for test&#39;  在 http://github.com 注册帐号
建立远程仓库，仓库名字是TMP
输入命令
$ ssh-keygen -t rsa -C &amp;quot;youremail@example.com&amp;quot;  在~/.ssh 目录中找到 文件 id_rsa.pub ，在网站的帐号管理SSH Keys中添加 id_rsa.pub 中的内容
$ git remote add origin https://github.com/yourname/TMP.git $ git push -u origin master  这样，当前目录下的foo.</description>
    </item>
    
    <item>
      <title>PE文件格式 持续更新ing</title>
      <link>http://liuxueyang.github.io/posts/pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0ing/</link>
      <pubDate>Thu, 27 Feb 2014 07:17:01 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0ing/</guid>
      <description>PE文件就是exe文件和dll文件，前者是可执行文件，后者是动态连接库文件。两者的区别仅仅是字面上的，唯一的区别就是内部的一个字段标识这个文件是exe文件还是dll文件。
对于PE文件格式，举一个例子来说明比较清楚：
　比如我打开一个.exe文件，gvim.exe 也就是gvim的安装程序
　首先就是DOS头：前两个字节，5A4Dh 表示MZ，这只是一个DOS可执行文件标记，表示这个文件是一个可执行文件。
　DOS头的最后一个Double word 在地址3ch处，可以发现它的值是：0000 00D8 h 它指向真正的PE头。
　找到对应的PE头，第一个 Double word 是 0000 4550 h 代表的是PE.. 那么IMAGE_OPTIONAL_HEADER32的起始地址就是 D8h + 18h = F0h
　在IMAGE_OPTIONAL_HEADER32的基础上 F0h + 20h = 110h 就得到了SectionAlignment 这个字段，可以发现，它的值是：0000 1000 h，这是程序被装入内存的时候区块对齐大小，默认值是目标CPU的页尺寸，紧接着下一个字段是：FileAlignment 这个字段，它的值是：0000 0200 h，它是磁盘上PE文件内的区块对齐大小。
　PE头D8h + 78 h 就得到了DataDirectory 这个字段，它是一个16个元素的数组，数据类型是IMAGE_DATA_DIRECTORY，这个结构体有两个成员：第一个成员是数据块的起始RVA，第二个成员是数据块的长度。数组的第一个元素是Export Table，发现都是0，说明没有输出表；第二个元素是输入表，地址是0000 73A4 h 大小是 0000 00B4h 。
　用PE Editor 这个程序打开gvim.exe 文件，得到如下的结果，发现结果和上面是一样的，我还发现了刚才犯的一个错误，SectionAlignment 的值应该是1000h 也就是CPU页大小是4kB，刚才写成了100h……汗</description>
    </item>
    
    <item>
      <title>poj1298 The Hardest Problem Ever 简单题</title>
      <link>http://liuxueyang.github.io/posts/poj1298-the-hardest-problem-ever-%E7%AE%80%E5%8D%95%E9%A2%98/</link>
      <pubDate>Tue, 04 Feb 2014 12:47:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1298-the-hardest-problem-ever-%E7%AE%80%E5%8D%95%E9%A2%98/</guid>
      <description>链接：http://poj.org/problem?id=1298&amp;amp;lang=default&amp;amp;change=true
简单的入门题目也有这么强悍的技巧啊！！
书上面的代码：
很厉害有没有=_=
n;main(k){for(;read(0,&amp;amp;n,1);k-=n&amp;lt;11)k%3||putchar(n%91&amp;lt;65?n:n%70%44+65);}  72字节。
用到了read这个函数
对于不需要处理的字符串，没有作处理，简化了很多。</description>
    </item>
    
    <item>
      <title>poj2368 Buttons Nim取石子游戏</title>
      <link>http://liuxueyang.github.io/posts/poj2368-buttons-nim%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Mon, 03 Feb 2014 23:50:07 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj2368-buttons-nim%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</guid>
      <description>链接：http://poj.org/problem?id=2368
和前面差距还是很大啊囧
代码：
k,a;main(i){for(scanf(&amp;quot;%d&amp;quot;,&amp;amp;k),a=k-1,i=3;i&amp;lt;=k/2&amp;amp;&amp;amp;k%i;++i);k%i||(a=i-1);printf(&amp;quot;%d\n&amp;quot;,a);}  短码之美那本书上面的这道题目的代码思路是对的，可是会TLE的。
可是ozy的代码还是那么短得可怕😨
那个，又省掉了一个特别脑残的变量。。
代码：
k;main(i){for(scanf(&amp;quot;%d&amp;quot;,&amp;amp;k),i=3;i&amp;lt;=k/2&amp;amp;&amp;amp;k%i;++i);printf(&amp;quot;%d\n&amp;quot;,k%i?k-1:i-1);}  78字节。
第二名了，，虽然和第一名还差好多=_=</description>
    </item>
    
    <item>
      <title>2014新年</title>
      <link>http://liuxueyang.github.io/posts/2014%E6%96%B0%E5%B9%B4/</link>
      <pubDate>Sun, 02 Feb 2014 14:51:52 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2014%E6%96%B0%E5%B9%B4/</guid>
      <description>那个，过年了。今天是正月初三。现在在我姥姥家。
外面二姨她们在斗地主，很欢乐。
无聊，找到台电脑，上网呗。
没什么可看的，想起下学期有门课叫做编译原理。
不妨google一下编译原理吧。然后就顺着找到了这个人的wiki里面的这篇文章：http://www.annhe.net/article-2445.html.
正好是湖大的，校友，比我大一届，10级的。去的新浪，羡慕啊。
那个，等到今年9月份，就该我了。。
可我怎么觉得我还差早呢？
在家比较混乱的样子，最多看看短码之美那本书娱乐一下，感觉挺有意思的样子，但还是看的很慢啊囧╭(╯^╰)╮
上学期没有挂，真是rp爆发加运气好啊，首先要感谢的是德克士，给我提供了那么暖和的复习环境……=_=
话说德克士里放的歌开始听着像噪音，到后来听着越来越好听了有没？到后期甚至拿air查到某首歌的名字然后回去自己听，恩恩，有学习的气氛。。
放假前说好的寒假要好好学习准备找工作面试的，说好了的……
结果到家三天后开始练车，累还来不及呢。腊月28后就开始被使唤了。接着就过年了，然后就到现在了。
也没出去玩过。
最多前两天下午出去跑步一小时。。中间还带走的=_=
新年愿望就是那种永远不会实现的东西，但我还是想说：
大三下学期不挂科 校招能表现好一点，找个好工作，最好在北京的那种，离家近 %&amp;gt;_&amp;lt;% 上半年好好学习，想学神马学神马，关键是认真，细心，不浮躁 练长跑，每周保持一定的运动量，明年毕业之前跑一场全马  (ˇˍˇ）
就这样了囧</description>
    </item>
    
    <item>
      <title>均分01</title>
      <link>http://liuxueyang.github.io/posts/%E5%9D%87%E5%88%8601/</link>
      <pubDate>Wed, 22 Jan 2014 10:16:10 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%9D%87%E5%88%8601/</guid>
      <description>真是无语，刚才写了一遍，添加博客标签的时候，浏览器自动刷新了一下，
然后tm写的东西就没有了！！还得重写。。
开始没懂，学弟给讲的==
感觉很厉害的样子。
可以切分一次。 不管什么串，一定可以切分两次完成。  证明：
　把这个串的首尾相连，设连接点是A，串的中点是B，设直线AB是L，L的左右的0的个数不相等，不妨设左边大于右边。顺时针旋转直线L，每旋转一次左右两边0的个数只可能发生两种变化：不变，+1，-1 。
　等旋转一周的时候，直线回到原来的位置，此时左边小于右边。由于0的个数的变化是连续的，所以一定有一个时刻，左边等于右边。
　证毕。感觉很厉害的样子。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; int howmany(char *s) { int i, len = strlen(s) / 2; int t = 0; for (i = 0; i &amp;lt; len; ++i) { if (s[i] == &#39;0&#39;) { t++; } if (s[i+len] == &#39;0&#39;) { t--; } } if (!t) return 1; else return 2; } int main(void) { printf(&amp;quot;%d\n&amp;quot;, howmany(&amp;quot;00001111&amp;quot;)); return 0; }  囧</description>
    </item>
    
    <item>
      <title>poj1852 Ants ——想法题、水题</title>
      <link>http://liuxueyang.github.io/posts/poj1852-ants-%E6%83%B3%E6%B3%95%E9%A2%98%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Mon, 21 Oct 2013 07:48:08 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1852-ants-%E6%83%B3%E6%B3%95%E9%A2%98%E6%B0%B4%E9%A2%98/</guid>
      <description>求最短时间和最长时间。
当两个蚂蚁相遇的时候，可以看做两个蚂蚁穿过，对结果没有影响。O（N）的复杂度
c++版：
#include &amp;lt;cstdio&amp;gt; #define min(a, b) (a) &amp;lt; (b) ? (a) : (b) #define max(a, b) (a) &amp;gt; (b) ? (a) : (b) int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif // ONLINE_JUDGE int Case; scanf(&amp;quot;%d&amp;quot;, &amp;amp;Case); int n, L, Min, Max; while (Case--) { Min = -1; Max = -1; scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;L, &amp;amp;n); int tmp; while (n--) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;tmp); int t1 = min(tmp, L - tmp); int t2 = max(tmp, L - tmp); if (Min &amp;lt; t1) Min = t1; if (Max &amp;lt; t2) Max = t2; } printf(&amp;quot;%d %d\n&amp;quot;, Min, Max); } return 0; }  Java版：</description>
    </item>
    
    <item>
      <title>编写安装中断7ch的中断例程：将一个以0结尾的字符串，转化为大写</title>
      <link>http://liuxueyang.github.io/posts/%E7%BC%96%E5%86%99%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%AD7ch%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E5%B0%86%E4%B8%80%E4%B8%AA%E4%BB%A50%E7%BB%93%E5%B0%BE%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%A4%A7%E5%86%99/</link>
      <pubDate>Thu, 17 Oct 2013 21:12:57 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E7%BC%96%E5%86%99%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%AD7ch%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E5%B0%86%E4%B8%80%E4%B8%AA%E4%BB%A50%E7%BB%93%E5%B0%BE%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%A4%A7%E5%86%99/</guid>
      <description>中断的安装程序：
assume cs:code code segment start: mov ax, cs mov ds, ax mov si, offset chstr mov ax, 0 mov es, ax mov di, 200h mov cx, offset chstrend - offset chstr cld rep movsb mov ax, 0 mov es, ax mov word ptr es:[7ch * 4 + 0], 200h mov word ptr es:[7ch * 4 + 2], 0 mov ax, 4c00h int 21h chstr: mov si, 0 lh: mov cx, 0 mov cl, [si] jcxz ok and byte ptr [si], 11011111b inc si jmp lh ok: iret chstrend: nop code ends end start  测试程序：</description>
    </item>
    
    <item>
      <title>编写中断例程7ch：计算word型数据的平方</title>
      <link>http://liuxueyang.github.io/posts/%E7%BC%96%E5%86%99%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B7ch%E8%AE%A1%E7%AE%97word%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B9%B3%E6%96%B9/</link>
      <pubDate>Thu, 17 Oct 2013 20:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E7%BC%96%E5%86%99%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B7ch%E8%AE%A1%E7%AE%97word%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B9%B3%E6%96%B9/</guid>
      <description>实现计算一个word型数据的平方。
这是安装程序。
assume cs:code code segment start: mov ax, cs mov ds, ax mov si, offset sqr mov ax, 0 mov es, ax mov di, 200h mov cx, offset sqrend - offset sqr cld rep movsb mov ax, 0 mov es, ax mov word ptr es:[7ch * 4+0], 200h mov word ptr es:[7ch * 4 + 2], 0 mov ax, 4c00h int 21h sqr: mul ax iret sqrend: nop code ends end start  这是应用程序。</description>
    </item>
    
    <item>
      <title>编写0号中断的处理程序：处理除法溢出</title>
      <link>http://liuxueyang.github.io/posts/%E7%BC%96%E5%86%990%E5%8F%B7%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%A4%84%E7%90%86%E9%99%A4%E6%B3%95%E6%BA%A2%E5%87%BA/</link>
      <pubDate>Thu, 17 Oct 2013 19:49:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E7%BC%96%E5%86%990%E5%8F%B7%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%A4%84%E7%90%86%E9%99%A4%E6%B3%95%E6%BA%A2%E5%87%BA/</guid>
      <description>在除法溢出的时候，在屏幕中间显示字符串“divide error!”
安装程序：
assume cs:code code segment start: mov ax, cs mov ds, ax mov si, offset do0 mov ax, 0 mov es, ax mov di, 200h mov cx, offset do0end - offset do0 cld rep movsb mov ax, 0 mov ds, ax mov word ptr ds:[0*4], 200h mov word ptr ds:[0*4 + 2], 0 do0: jmp do0start db &amp;quot;divide error!&amp;quot; do0start: mov ax, cs mov ds, ax mov si, 202h mov ax, 0b800h mov es, ax mov di, 12*160+36*2 mov cx, 13 s: mov al, [si] mov es:[di], al mov byte ptr es:[di+1], 01001001b inc si add di, 2 loop s mov ax, 4c00h int 21h do0end: nop mov ax, 4c00h int 21h code ends end start  测试程序：</description>
    </item>
    
    <item>
      <title>实验十一：编写子程序</title>
      <link>http://liuxueyang.github.io/posts/%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80%E7%BC%96%E5%86%99%E5%AD%90%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Tue, 15 Oct 2013 16:45:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80%E7%BC%96%E5%86%99%E5%AD%90%E7%A8%8B%E5%BA%8F/</guid>
      <description>将一个0结尾的字符串中的小写字母转化成大写字母
assume cs:code, ds:data data segment db &amp;quot;Beginner&#39;s All-purpose Symbolic Instruction Code.&amp;quot;, 0 data ends code segment start: mov ax, data mov ds, ax mov si, 0 call letterc mov ax, 4c00h int 21h letterc: mov cx, 0 sad: mov cl, [si] jcxz llh cmp cl, 7ah ja next cmp cl, 61h jb next and cl, 11011111b mov [si], cl next: inc si jmp sad llh: ret code ends end start  这货并不复杂……=_= 都是基本的应用</description>
    </item>
    
    <item>
      <title>试验十 3.数值显示</title>
      <link>http://liuxueyang.github.io/posts/%E8%AF%95%E9%AA%8C%E5%8D%81-3-%E6%95%B0%E5%80%BC%E6%98%BE%E7%A4%BA/</link>
      <pubDate>Fri, 11 Oct 2013 13:01:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E8%AF%95%E9%AA%8C%E5%8D%81-3-%E6%95%B0%E5%80%BC%E6%98%BE%E7%A4%BA/</guid>
      <description>题目的意思是：
　把一个16进制的数字转化成十进制，然后在屏幕的第3行，第8列，用绿色输出。
这货倒是不太难，就是学会调用之前写过的函数就行了==
assume cs:code, ds:data, ss:stack data segment db 10 dup(0) data ends stack segment dw 10 dup(0) stack ends code segment start: mov ax, 12666 mov dx, 0 mov bx, data mov ds, bx mov si, 0 call dtoc mov dh, 8 mov dl, 3 mov cl, 2 call show_str mov ax, 4c00h int 21h dtoc: push si mov bx, 10 mov cx, ax mov di, 0 sad: div bx add dx, 30h push dx mov dx, 0 inc di mov cx, ax add cx, 1 loop sad mov bp, 0 mov cx, di ago: pop dx mov al, dl mov ds:[bp], al inc bp loop ago mov ds:[bp], 0 pop si ret show_str: push dx push cx ;row dec dh mov al, 0a0h mul dh push ax ;col dec dl mov al, 2h mul dl pop bx add ax, bx mov di, 0b800h mov es, di mov bp, ax mov bl, cl change: mov cl, [si] mov ch, 0 jcxz ok mov di, si add di, di mov al, ds:[si] mov byte ptr es:[bp+di], al mov byte ptr es:[bp+di+1], bl inc si jmp short change ok: pop cx pop dx ret code ends end start  虽然很长……看起来好腻害的样子=_=</description>
    </item>
    
    <item>
      <title>解决除法溢出问题</title>
      <link>http://liuxueyang.github.io/posts/%E8%A7%A3%E5%86%B3%E9%99%A4%E6%B3%95%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 10 Oct 2013 23:54:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E8%A7%A3%E5%86%B3%E9%99%A4%E6%B3%95%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98/</guid>
      <description>被除数是dword型，除数是dword型，结果是dword型。
参数：
　ax=dword型数据的低16位
　dx=dword型数据的高16位
　cx=除数
返回：
　dx=结果的高16位，ax=结果的低16位
　cx=除数
assume cs:code, ss:stack stack segment dw 10h dup(0) stack ends code segment start: mov ax, 4240h mov dx, 0fh mov cx, 0ah call divdw divdw: ; H=int(X/65536) L=rem(X/65536) push ax ; H / n mov ax, dx mov dx, 0 div cx mov si, ax ; (rem(H/n) * 65536 + L) / n pop ax div cx ;remain cx gotten mov cx, dx mov dx, si ret mov ax, 4c00h int 21h code ends end start  这个程序写了差不多两天==</description>
    </item>
    
    <item>
      <title>编写子程序，显示字符串</title>
      <link>http://liuxueyang.github.io/posts/%E7%BC%96%E5%86%99%E5%AD%90%E7%A8%8B%E5%BA%8F%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 08 Oct 2013 11:41:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E7%BC%96%E5%86%99%E5%AD%90%E7%A8%8B%E5%BA%8F%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>在屏幕的8行3列，用绿色显示data段中的字符串。
assume cs:code, ds:data data segment db &#39;Welcome to masm!&#39;, 0 data ends code segment start: mov dh, 8 mov dl, 3 mov cl, 2 mov ax, data mov ds, ax mov si, 0 call show_str mov ax, 4c00h int 21h show_str: push dx push cx ;row dec dh mov al, 0a0h mul dh push ax ;col dec dl mov al, 2h mul dl pop bx add ax, bx mov di, 0b800h mov es, di mov bp, ax mov bl, cl change: mov cl, [si] mov ch, 0 jcxz ok mov di, si add di, di mov al, ds:[si] mov byte ptr es:[bp+di], al mov byte ptr es:[bp+di+1], bl inc si jmp short change ok: pop cx pop dx ret code ends end start  开始遇到了很奇怪的bug，最终还是不知道为什么，所以换了一种方式解决问题了。</description>
    </item>
    
    <item>
      <title>call指令的一个细节</title>
      <link>http://liuxueyang.github.io/posts/call%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BB%86%E8%8A%82/</link>
      <pubDate>Mon, 07 Oct 2013 08:49:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/call%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BB%86%E8%8A%82/</guid>
      <description>执行下面这个程序之后，ax的值是多少？
assume cs:code code segment start: mov ax, 0 call s inc ax s: pop ax mov ax, 4c00h int 21h code ends end start  答案是0006h
这道题目要做对首先要明白CPU执行指令的机制，IP值的增加实在指令送入指令缓冲器中进行的，也就是指令执行之前。所以，执行到call s的时候，压入栈的ax值是6h=_=</description>
    </item>
    
    <item>
      <title>codeforces A. Difference Row</title>
      <link>http://liuxueyang.github.io/posts/codeforces-a-difference-row/</link>
      <pubDate>Mon, 07 Oct 2013 00:28:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-a-difference-row/</guid>
      <description>link: http://codeforces.com/contest/347/problem/A
开始看起来很复杂的样子，但是刚写下样例，就发现因为中间的都消去了，其实起作用的就是最大值和最小值=_=
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; int a[102]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif int n; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { int i; for (i = 0; i &amp;lt; n; scanf(&amp;quot;%d&amp;quot;, a+i++)); sort(a, a+n); printf(&amp;quot;%d&amp;quot;, a[n-1]); for (i = 1; i &amp;lt; n-1; ++i) printf(&amp;quot; %d&amp;quot;, a[i]); printf(&amp;quot; %d\n&amp;quot;, a[0]); } return 0; }  排序后输出就行。</description>
    </item>
    
    <item>
      <title>codeforces B.Fixed Points</title>
      <link>http://liuxueyang.github.io/posts/codeforces-b-fixed-points/</link>
      <pubDate>Mon, 07 Oct 2013 00:23:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-b-fixed-points/</guid>
      <description>link: http://codeforces.com/contest/347/problem/B
很简单，最多只能交换一次，也就是说，最多会增加两个。可能会增加一个。也可能一个也不增加（此时都是fixed point）
#include &amp;lt;cstdio&amp;gt; using namespace std; int a[100002]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif int n; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { int i, cnt = 0; for (i = 0; i &amp;lt; n; scanf(&amp;quot;%d&amp;quot;, a+i++)); bool flag = false; for (i = 0; i &amp;lt; n; ++i) { if (a[i] == i) cnt++; else if (!flag &amp;amp;&amp;amp; a[a[i] ] == i) { cnt += 2; flag = true; } } if (!</description>
    </item>
    
    <item>
      <title>终于在cmd窗口里出现了颜色了！！！感动ing……</title>
      <link>http://liuxueyang.github.io/posts/%E7%BB%88%E4%BA%8E%E5%9C%A8cmd%E7%AA%97%E5%8F%A3%E9%87%8C%E5%87%BA%E7%8E%B0%E4%BA%86%E9%A2%9C%E8%89%B2%E4%BA%86%E6%84%9F%E5%8A%A8ing/</link>
      <pubDate>Sun, 06 Oct 2013 15:31:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E7%BB%88%E4%BA%8E%E5%9C%A8cmd%E7%AA%97%E5%8F%A3%E9%87%8C%E5%87%BA%E7%8E%B0%E4%BA%86%E9%A2%9C%E8%89%B2%E4%BA%86%E6%84%9F%E5%8A%A8ing/</guid>
      <description>在窗口的中央打印三行字。
要求：　　第一行绿色字
　第二行绿底红色
　第三行白底蓝色
assume cs:code, ds:data data segment db &#39;welcome to masm!&#39; data ends code segment start: mov ax, data mov ds, ax mov ax, 0b800h mov es, ax mov di, 780h mov si, 0 mov cx, 10h s: mov bp, si add bp, bp mov al, ds:[si] mov es:[di+bp+40h], al mov al, 24h mov es:[di+bp+41h], al inc si loop s mov di, 6e0h mov si, 0 mov cx, 10h s0: mov bp, si add bp, bp mov al, ds:[si] mov es:[di+bp+40h], al mov al, 2h mov es:[di+bp+41h], al inc si loop s0 mov di, 820h mov si, 0 mov cx, 10h s1: mov bp, si add bp, bp mov al, ds:[si] mov es:[di+bp+40h], al mov al, 71h mov es:[di+bp+41h], al inc si loop s1 mov ax, 4c00h int 21h code ends end start  截图记录下这历史性的一刻=_=</description>
    </item>
    
    <item>
      <title>一个有意思的汇编程序 ——其实就是一个根据位移进行转移的应用=_=</title>
      <link>http://liuxueyang.github.io/posts/%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F-%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sun, 06 Oct 2013 14:00:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F-%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>分析一下这个程序=_=
assume cs:code code segment mov ax, 4c00h int 21h start: mov ax, 0 s: nop nop mov di, offset s mov si, offset s2 mov ax, cs:[si] mov cs:[di], ax s0: jmp short s s1: mov ax, 0 int 21h mov ax, 0 s2: jmp short s1 nop code ends end start  开始，一眼看去，这个程序应该会陷入死循环吧。。
其实，认真分析之后就会发现。这个程序竟然可以正常地运行并且退出！
首先，一定要注意jmp指令的内部运行方法！
首先呢，为了方便，我们先记录下每个标号的偏移地址和机器码。方便以后分析。
S: CS:8H CS:9H S0: CS:16H EBF0 JMP 8 S1: CS:18H B80000 S2: CS:20H EBF6 JMP 18  之后，S处的数据发生改变：</description>
    </item>
    
    <item>
      <title>实验七——王爽…………我写的最长的一个汇编程序==</title>
      <link>http://liuxueyang.github.io/posts/%E5%AE%9E%E9%AA%8C%E4%B8%83%E7%8E%8B%E7%88%BD%E6%88%91%E5%86%99%E7%9A%84%E6%9C%80%E9%95%BF%E7%9A%84%E4%B8%80%E4%B8%AA%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sun, 06 Oct 2013 00:20:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%AE%9E%E9%AA%8C%E4%B8%83%E7%8E%8B%E7%88%BD%E6%88%91%E5%86%99%E7%9A%84%E6%9C%80%E9%95%BF%E7%9A%84%E4%B8%80%E4%B8%AA%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F/</guid>
      <description>这是我到目前为止写的最长的汇编程序了。
assume cs:sad, ds:data, ss:stack stack segment stack ends data segment db &#39;1975&#39;, &#39;1976&#39;, &#39;1977&#39;, &#39;1978&#39;, &#39;1979&#39;, &#39;1980&#39;, &#39;1981&#39;, &#39;1982&#39;, &#39;1983&#39; db &#39;1984&#39;, &#39;1985&#39;, &#39;1986&#39;, &#39;1987&#39;, &#39;1988&#39;, &#39;1989&#39;, &#39;1990&#39;, &#39;1991&#39;, &#39;1992&#39; db &#39;1993&#39;, &#39;1994&#39;, &#39;1995&#39; ; 21 years -- 54h bytes dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514 dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000 ; income in 21 years -- 54h bytes dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226 dw 11542, 14430, 15257, 17800 ; staff in 21 years -- 2ah bytes data ends table segment db 21 dup (&#39;year summ ne ?</description>
    </item>
    
    <item>
      <title>bx, bp, si, di寄存器的使用规则</title>
      <link>http://liuxueyang.github.io/posts/bx-bp-si-di%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99/</link>
      <pubDate>Sat, 05 Oct 2013 18:40:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/bx-bp-si-di%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99/</guid>
      <description>首先，都可以单独使用。
另外，组合使用的情况下：
记住这张图片就行了=_=
意思就是，bx只能和si，di组合。bp只能和si，di组合。</description>
    </item>
    
    <item>
      <title>更灵活的定位内存地址的方法 ——将每个单词的前四个字母改为大写</title>
      <link>http://liuxueyang.github.io/posts/%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95-%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E5%89%8D%E5%9B%9B%E4%B8%AA%E5%AD%97%E6%AF%8D%E6%94%B9%E4%B8%BA%E5%A4%A7%E5%86%99/</link>
      <pubDate>Sat, 05 Oct 2013 15:32:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95-%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E5%89%8D%E5%9B%9B%E4%B8%AA%E5%AD%97%E6%AF%8D%E6%94%B9%E4%B8%BA%E5%A4%A7%E5%86%99/</guid>
      <description>很简单的一个程序
assume cs:code, ss:stack, ds:data data segment db &#39;1. display &#39; db &#39;2. brows &#39; db &#39;3. replace &#39; db &#39;4. modify &#39; data ends stack segment dw 0, 0, 0, 0, 0, 0, 0, 0 stack ends code segment start: mov ax, data mov ds, ax mov ax, stack mov ss, ax mov sp, 10h mov bx, 3 mov cx, 4 s: push cx mov si, 4 mov cx, si mov si, 0 s0: mov al, [bx][si] and al, 11011111b mov [bx][si], al inc si loop s0 pop cx add bx, 10h loop s mov ax, 4c00h int 21h code ends end start  逻辑挺清晰的。自不必说。</description>
    </item>
    
    <item>
      <title>更灵活的定位内存地址的方法——大小写转换</title>
      <link>http://liuxueyang.github.io/posts/%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Fri, 04 Oct 2013 23:46:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2/</guid>
      <description>如下：
;BasiC to BASIC ;MinIX to minix assume cs:code, ds:data data segment db &#39;BaSiC&#39; db &#39;MinIX&#39; data ends code segment start: mov ax, data mov ds, ax mov bx, 0 mov cx, 5 s: mov al, 0[bx] and al, 11011111b mov 0[bx], al mov al, 5[bx] or al, 00100000b mov 5[bx], al inc bx loop s mov ax, 4c00h int 21h code ends end start  很简单的一个程序。</description>
    </item>
    
    <item>
      <title>向内存0:200~0:23f依次传送数据0~3fh</title>
      <link>http://liuxueyang.github.io/posts/%E5%90%91%E5%86%85%E5%AD%980-200-0-23f%E4%BE%9D%E6%AC%A1%E4%BC%A0%E9%80%81%E6%95%B0%E6%8D%AE0-3fh/</link>
      <pubDate>Fri, 04 Oct 2013 14:23:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%90%91%E5%86%85%E5%AD%980-200-0-23f%E4%BE%9D%E6%AC%A1%E4%BC%A0%E9%80%81%E6%95%B0%E6%8D%AE0-3fh/</guid>
      <description>只能用字节为单位传送了。
assume cs:sad sad segment start: mov ax, 20h mov ds, ax mov bx, 0 mov cx, 40h s: mov [bx], bl inc bl loop s mov ax, 4c00h int 21h sad ends end  我只能优化到这里了。用了7条指令。</description>
    </item>
    
    <item>
      <title>将内存ffff:0~ffff:b中的数据拷贝到0:200~0:20b中</title>
      <link>http://liuxueyang.github.io/posts/%E5%B0%86%E5%86%85%E5%AD%98ffff-0-ffff-b%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E5%88%B00-200-0-20b%E4%B8%AD/</link>
      <pubDate>Fri, 04 Oct 2013 14:12:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%B0%86%E5%86%85%E5%AD%98ffff-0-ffff-b%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E5%88%B00-200-0-20b%E4%B8%AD/</guid>
      <description>我是按照字，也就是2个字节拷贝的。
这样就可以让循环减半==
assume cs:sad sad segment start: mov ax, 0ffffh mov ds, ax mov bx, 0h mov ax, 20h mov es, ax mov cx, 7h s: mov ax, ds:[bx] mov es:[bx], ax add bx, 2 loop s mov ax, 4c00h int 21h sad ends end  刚听到句歌词：
最初的天堂，最终的荒唐。
好熟悉，以前猫姐QQ空间的一句话。哈哈，2年多了，都变了多少啊。</description>
    </item>
    
    <item>
      <title>计算ffff:0~ffff:b数据的和，结果存在dx中</title>
      <link>http://liuxueyang.github.io/posts/%E8%AE%A1%E7%AE%97ffff-0-ffff-b%E6%95%B0%E6%8D%AE%E7%9A%84%E5%92%8C%E7%BB%93%E6%9E%9C%E5%AD%98%E5%9C%A8dx%E4%B8%AD/</link>
      <pubDate>Fri, 04 Oct 2013 12:28:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E8%AE%A1%E7%AE%97ffff-0-ffff-b%E6%95%B0%E6%8D%AE%E7%9A%84%E5%92%8C%E7%BB%93%E6%9E%9C%E5%AD%98%E5%9C%A8dx%E4%B8%AD/</guid>
      <description>代码：
assume cs:sad sad segment start: mov ax, 0ffffh mov ds, ax mov dx, 0 ; add ds:0bh~ds:1h mov cx, 0bh s: mov ah, 0 mov bx, cx mov al, ds:[bx] add dx, ax loop s ; add ds:0h mov bh, 0 mov bl, ds:[0] add dx, bx mov ax, 4c00h int 21h sad ends end  自己写的==
下面是看了书上的之后，写的：
assume cs:sad sad segment start: mov ax, 0ffffh mov ds, ax mov dx, 0 mov bx, 0 ; c = b + 1 mov cx, 0ch s: mov ah, 0 mov al, [bx] inc bx add dx, ax loop s mov ax, 4c00h int 21h sad ends end  主要是加上了inc bx的用法==</description>
    </item>
    
    <item>
      <title>debug不过的程序</title>
      <link>http://liuxueyang.github.io/posts/debug%E4%B8%8D%E8%BF%87%E7%9A%84%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Fri, 04 Oct 2013 12:25:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/debug%E4%B8%8D%E8%BF%87%E7%9A%84%E7%A8%8B%E5%BA%8F/</guid>
      <description>下面的程序debug是不能通过的。
至于为什么我还不知道。
assume cs:codesg codesg segment start: mov ax,2000h mov ss, ax mov sp, 0 add sp, 4 pop ax pop bx push ax push bx pop ax pop bx mov ax, 4c00h int 21h codesg ends end  这个问题留在这里，以后解决。
以后学习的时候，一定要选好书！╮(╯▽╰)╭</description>
    </item>
    
    <item>
      <title>栈段 ——满是疑问==</title>
      <link>http://liuxueyang.github.io/posts/%E6%A0%88%E6%AE%B5-%E6%BB%A1%E6%98%AF%E7%96%91%E9%97%AE/</link>
      <pubDate>Thu, 03 Oct 2013 19:14:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E6%A0%88%E6%AE%B5-%E6%BB%A1%E6%98%AF%E7%96%91%E9%97%AE/</guid>
      <description>遇到一个问题
比如：
用栈操作将10000H~1000FH中的8个字，逆序拷贝到2000H~2000FH中。
写出以下代码：
mov ax, 2000h mov ds, ax mov ax, f00h mov ss, ax mov sp, 1000h pop [e] pop [c] pop [a] pop [8] pop [6] pop [4] pop [2] pop [0]  开始我还以为可能是栈空间太小，跟以前一样的问题，特意把栈的短地址缩小到f00h，可是还是结果不对，跟踪之后我发现，
拷贝过去的内容是对的，但是10000H处的内容却被改写了。现在我还是不知道为什么，为什么这个内存地址的内容会被改变呢？
满是疑惑……=_=
……………………………………………………………………==………………………………………………………………………………
刚才又遇到了类似的问题。
貌似明白一点了。只是猜的=_=。虽然不知道为什么，但是表面上懂一点了。
当内存中的某个段当做栈顶的时候，也就是说寄存器ss改变的时候，可能会在附近记录CS,IP,SS的值。还是没有完全明白……越来越混乱了……==</description>
    </item>
    
    <item>
      <title>CPU的栈机制的一个小问题</title>
      <link>http://liuxueyang.github.io/posts/cpu%E7%9A%84%E6%A0%88%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 03 Oct 2013 16:10:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/cpu%E7%9A%84%E6%A0%88%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</guid>
      <description>比如要实现下面这个功能。
我们如果要在10000H处写入自行数据2266H，不能用“mov 内存单元， 寄存器”这类指令。怎么做？
代码：
mov ax, 1000h mov ss, ax mov sp, 2 mov ax, 2266h push ax  这段代码，如果是初学，看起来挺对的，一点也没错。
可是，用debug跟踪一下，发现，这段代码不能得到正确结果，会发现，在push ax这条指令执行之前，debug自动退出了。
反正这个问题，我大一的时候，纠结了好久，到处问，好几天也没搞定，记得当初我还以为是自己电脑系统的问题，还重装了系统……⊙﹏⊙b汗
终于，后来，才明白。这个可能是因为栈溢出的问题？具体因为什么，现在还不太懂。但是知道怎么解决。
只需要把栈的段址设置小一点就可以了。比如比最大的段址小10h。所以，上面的代码可以改成：
mov ax, ff0h mov ss, ax mov sp, 102 mov ax, 2266h push ax  然后用debug跟踪一下，就没有问题了。</description>
    </item>
    
    <item>
      <title>codeforces Simple Molecules</title>
      <link>http://liuxueyang.github.io/posts/codeforces-simple-molecules/</link>
      <pubDate>Wed, 02 Oct 2013 22:17:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-simple-molecules/</guid>
      <description>link:http://codeforces.com/contest/344/problem/B
刚开始想复杂了。一开始就想当然地以为可以有多个点，其实，人家题目要求只有3个点啊！
然后题目就简单了。
A、B、C代表原子的化合价
x、y、z代表原子之间的化学键
首先x+y+z一定为偶数，否则不可能有解。
那么可以列出一个三元一次的方程组，由3个方程组成，可以求出唯一解。
判断有解的唯一限制条件是：不能出现负数。
#include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif // ONLINE_JUDGE int a, b, c; int x, y, z; while (~scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c)) { int sum = a + b + c; if (sum &amp;amp; 1) { printf(&amp;quot;Impossible\n&amp;quot;); continue; } int tmp = b - a + c; if (tmp &amp;amp; 1) { printf(&amp;quot;Impossible\n&amp;quot;); continue; } y = tmp &amp;gt;&amp;gt; 1; z = c - y; x = a - z; if (x &amp;lt; 0 || y &amp;lt; 0 || z &amp;lt; 0) { printf(&amp;quot;Impossible\n&amp;quot;); continue; } printf(&amp;quot;%d %d %d\n&amp;quot;, x, y, z); } return 0; }  看题要认真。不把问题复杂化。</description>
    </item>
    
    <item>
      <title>codeforces Magnets</title>
      <link>http://liuxueyang.github.io/posts/codeforces-magnets/</link>
      <pubDate>Wed, 02 Oct 2013 21:39:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-magnets/</guid>
      <description>link: http://codeforces.com/contest/344/problem/A
这道题目很简单。
把输入的01 和10 当做整数，如果相邻两个数字相等的话，那么就属于同一组，否则，就新增加了一组。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif // ONLINE_JUDGE int n; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { int tmp; int pre = -1; int cnt = 0; while (n--) { scanf(&amp;quot;%02d&amp;quot;, &amp;amp;tmp); if (tmp != pre) cnt++; pre = tmp; } printf(&amp;quot;%d\n&amp;quot;, cnt); } return 0; }  ==
其实，现在想那么多没用。其实……也想读研的，但是，又觉得没什么用……所以，很痛苦。
路在何方呢？在脚下？</description>
    </item>
    
    <item>
      <title>codeforces Expecting Trouble</title>
      <link>http://liuxueyang.github.io/posts/codeforces-expecting-trouble/</link>
      <pubDate>Wed, 02 Oct 2013 21:23:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-expecting-trouble/</guid>
      <description>link:http://codeforces.com/contest/345/problem/A
写完这道题目才发现这场比赛只能用Ada语言提交==
好吧，逗我玩呢
考的是数学期望公式，二项分布的期望E=np
C++代码：（我可不会Ada……=_=）
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int main(void) { char a[51]; double p; #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif // ONLINE_JUDGE while (~scanf(&amp;quot;%s%lf&amp;quot;, a, &amp;amp;p)) { int len = strlen(a); int cnt = 0; int cnt1 = 0; for (int i = 0; i &amp;lt; len; ++i) { if (a[i] == &#39;1&#39;) cnt++; else if (a[i] == &#39;?&#39;) cnt1++; } double Cnt = (double)cnt + p * (double)cnt1; printf(&amp;quot;%.</description>
    </item>
    
    <item>
      <title>空结构体大小是多少？</title>
      <link>http://liuxueyang.github.io/posts/%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91/</link>
      <pubDate>Wed, 02 Oct 2013 19:00:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91/</guid>
      <description>/* 在VC中，空结构体大小是1。 在gcc中，空结构体大小是0。 */ #include &amp;lt;cstdio&amp;gt; struct student { }stu; int main(void) { printf(&amp;quot;%d\n&amp;quot;, sizeof stu); return 0; }  不同的平台不一样。
还有一点。
sizeof是C语言中的关键字，不是函数，所以，sizeof后面不用括号也是对的。
另外，define并不是C语言里面的关键字！但是typedef是关键字，这个今天才发现。= =
C语言的23个关键字：
auto break case char const continue default do double else enum extern float for goto if int long register return short signed sizeof static struct switch typedef union unsigned void volatile while  见百度百科</description>
    </item>
    
    <item>
      <title>strncpy基本用法</title>
      <link>http://liuxueyang.github.io/posts/strncpy%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link>
      <pubDate>Wed, 02 Oct 2013 09:50:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/strncpy%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid>
      <description>见百度百科。
注意这句话：
（c/c++）复制src中的内容（字符，数字、汉字&amp;hellip;.）到dest，复制多少由num的值决定，返回指向dest的指针。如果遇到null字符（&amp;rsquo;\0&amp;rsquo;），且还没有到num个字符时，就用（num - n）（n是遇到null字符前已经有的非null字符个数）个null字符附加到destination。注意：并不是添加到destination的最后，而是紧跟着由source中复制而来的字符后面。
示例程序：
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdlib&amp;gt; int main(void) { // char *greeting = &amp;quot;hello&amp;quot;; // char *temp = (char*)malloc(6); // strncpy(temp, greeting, 3); // strncpy(temp + 3, &amp;quot;p!&amp;quot;, 2); // greeting = temp; // printf(&amp;quot;%s\n&amp;quot;, greeting); char des[] = &amp;quot;Hello,i am!&amp;quot;; int len = strlen(des); char source[] = &amp;quot;abc\0def&amp;quot;; strncpy(des, source, 5); printf(&amp;quot;%s\n&amp;quot;, des); for (int i = 0; i &amp;lt; len; ++i) { if (des[i] == &#39;\0&#39;) printf(&amp;quot;$&amp;quot;); else printf(&amp;quot;%c&amp;quot;, des[i]); } printf(&amp;quot;\n&amp;quot;); return 0; }  可以发现输出是：</description>
    </item>
    
    <item>
      <title>大三就这么欢乐地开始了</title>
      <link>http://liuxueyang.github.io/posts/%E5%A4%A7%E4%B8%89%E5%B0%B1%E8%BF%99%E4%B9%88%E6%AC%A2%E4%B9%90%E5%9C%B0%E5%BC%80%E5%A7%8B%E4%BA%86/</link>
      <pubDate>Tue, 24 Sep 2013 13:16:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%A4%A7%E4%B8%89%E5%B0%B1%E8%BF%99%E4%B9%88%E6%AC%A2%E4%B9%90%E5%9C%B0%E5%BC%80%E5%A7%8B%E4%BA%86/</guid>
      <description>前天晚上，补考成绩出来。数字逻辑补考挂了。果然。胸中即使有千万只cnm在奔腾也于事无补了。那天晚上在教务系统上看了成绩知道没过之后，跟舍友骂了几句无比kd的老师，发了几句牢骚，然后当做没事儿似的，继续去做家教了……
　昨天，问了一起补考的两个同学，果然，也都没过。大家异口同声的骂了一句**就是个xx，然后早上去院楼找负责选课的老师选上重修的课。答案是，老师不在，下午再来。天空还下着小雨。下午，又跑了一趟，结果发现，别的班的数字逻辑只有3个学分，我们原来的有4个，这样一来，核心课程就少了一个学分，所以，我必须还要再选一门，所以我只能再选一门专业任选课，3个学分的数值分析，为什么我们的数字逻辑是4个学分呢？因为我们的课程旁边写着H，我一直以为代表英语教学，结果老师说，那个代表High，高级，所以呢，院里给你们配的都是最好的老师，嗯，我们点了点头，带着某种微笑。当时就在想，为什么我们班里没有一个人认为这货好？其实还算幸运，有个班的数字逻辑课和我原来的课不冲突，可以选，否则我就只能大四上学期再修这个了……想想都觉得可怕。所以说，我就多了两门课。这样的话，加一块也就24个学分。差一个学分满。
　所以说，课表一下子就充实了。大三就这么欢乐地开始了。
　跟同学说，这学期真他妈的充实=_=
　昨天晚上还有个软件设计基础实验课。要求是学习MFC，然后自己写个小软件。属于老师一点也不教，自己看然后交实验报告的那种课。以前很讨厌MFC这些东西，现在觉得其实貌似也不错，不如认真学一下这货，闲着也是闲着，学着 写个项目神马的。从现在开始，好好学一下MFC吧。又想起一句话，当你排斥一个东西的时候，你就失去了向它学习的机会。
　最近读三国演义，发现白话文很有意思，读得津津有味啊，哈哈。</description>
    </item>
    
    <item>
      <title>中秋</title>
      <link>http://liuxueyang.github.io/posts/%E4%B8%AD%E7%A7%8B/</link>
      <pubDate>Thu, 19 Sep 2013 00:35:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E4%B8%AD%E7%A7%8B/</guid>
      <description>开始写这篇随笔的时候，中秋刚刚来临1分钟。
　前几天看到开复的了癌症，当时就在感慨，生命多么脆弱而宝贵啊，不管别的东西怎么样，不过是身外之物，身体和健康才是最重要的啊。记得开复诊断结果出来后，自己在微博上发了一句话：原来，在癌症面前，人人平等。是啊，在命运面前，所有人都是平等的，一样渺小与无助。然后过了几天又忘了这事儿了。刚才无意翻报纸，又看到一条新闻，开复在台湾接受化疗，全身有20多处肿瘤，得病原因据称是作息不规律长期熬夜，以及压力过大导致。只是感觉，每个人都是凡人，要做出非凡的成就，一定需要付出很多，只是那些都不为人所知罢了，付出的代价甚至都无法估量，比如生命和健康。
　一句话，珍惜生命吧。
　最近生活比较凌乱。陷入了极度的空虚和无聊，所以就想到了去做家教。上周日，上了一下午课，一个感觉，累。昨天，嗯，是昨天，过了12点了，下午又找了另一份家教，晚上就去了，又看到了高中的数学，现在感觉，这些题目好亲切啊，很久不这么认真做题目了啊，也许，当初高中那么单纯的生活，才是最幸福的吧，虽然每天沉浸在那些上面，但是那段时间真的是一个人全身心投入学习的一段时期。可惜，再也不会有了。现在，完全不一样了呢。从来没有静下心来坐上两个钟头去认真做题。
　做家教，是下下策吧，花这些时间，虽然一个小时可以得到45元或者50元，但是那又怎么样呢，这些时间，本该去做自己真正想做的事情啊，尤其是在大学的这段时间，可惜，现在，或者最近，什么也不想做，学习，没什么动力。目前先这样吧。对了，还有，挣够了钱，换个手机~^_^差不多两周就足够了~哈哈
　最近，调整状态。
嗨，中村。</description>
    </item>
    
    <item>
      <title>Candy Store</title>
      <link>http://liuxueyang.github.io/posts/candy-store/</link>
      <pubDate>Wed, 18 Sep 2013 00:55:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/candy-store/</guid>
      <description>Candy Store Time Limit: 30000ms, Special Time Limit:75000ms, Memory Limit:65536KB Total submit users: 6, Accepted users: 6 Problem 12624 : No special judgement Problem description You are walking with a friend, when you pass a candy store. You make a comment about how unhealthy their wares are. Your friend issues an interesting challenge: who can be the unhealthiest? Both of you will go into the store with the same amount of money.</description>
    </item>
    
    <item>
      <title>Do It Wrong, Get It Right</title>
      <link>http://liuxueyang.github.io/posts/do-it-wrong-get-it-right/</link>
      <pubDate>Wed, 18 Sep 2013 00:53:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/do-it-wrong-get-it-right/</guid>
      <description>Do It Wrong, Get It Right Time Limit: 5000ms, Special Time Limit:12500ms, Memory Limit:65536KB Total submit users: 7, Accepted users: 6 Problem 12627 : No special judgement Problem description In elementary school, students learn to subtract fractions by first getting a common denominator and then subtracting the numerators. However, sometimes a student will work the problem incorrectly and still arrive at the correct answer. For example, for the problem 5 9 4 12</description>
    </item>
    
    <item>
      <title>hdu4737 A Bit Fun ——O(n)做法、错误的做法 &#43; 正确做法</title>
      <link>http://liuxueyang.github.io/posts/hdu4737-a-bit-fun-o-n-%E5%81%9A%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E5%81%9A%E6%B3%95-%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95/</link>
      <pubDate>Sun, 15 Sep 2013 13:31:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4737-a-bit-fun-o-n-%E5%81%9A%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E5%81%9A%E6%B3%95-%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95/</guid>
      <description>囧== 下面的做法是错误的。下午在路上突然明白了==
哎，到现在还是只知道暴力的做法，囧爆了：http://www.cnblogs.com/liuxueyang/p/3322197.html
类似于前序和的那种思想。
b数组代表前序或，c数组代表后序或。
O(N)预处理出数组b和数组c
在从前往后扫一遍O(N)的复杂度，求出ans
如图：
可以发现c[Head] &amp;amp; b[Tail] 就可以求出任意区间内的f(Head, Tail)，可以知道，整个数组里面每个元素进入区间一次，出去一次，所以是O(N)的复杂度。
就这么欢乐地解决了==
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; const int N = 100000+4; int a[N], b[N], c[N]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif // ONLINE_JUDGE int t; scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); for (int i = 1; i &amp;lt;= t; ++i) { printf(&amp;quot;Case #%d: &amp;quot;, i); int j, n, m; scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m); memset(b, 0, sizeof(b)); memset(c, 0, sizeof(c)); long long ans = 0; for (j = 1; j &amp;lt;= n; ++j) { scanf(&amp;quot;%d&amp;quot;, a+j); b[j] = b[j-1] | a[j]; } for (j = n; j &amp;gt;= 1; --j) { c[j] = c[j+1] | a[j]; } int Head = 1, Tail = 1; while (Head &amp;lt;= n &amp;amp;&amp;amp; Tail &amp;lt;= n) { int tmp = c[Head] &amp;amp; b[Tail]; while (tmp &amp;lt; m &amp;amp;&amp;amp; Tail &amp;lt;= n) { ans++; tmp = c[Head] &amp;amp; b[++Tail]; } ++Head; Tail = Head; } printf(&amp;quot;%I64d\n&amp;quot;, ans); } return 0; }  其实正确的做法应该是这样的：</description>
    </item>
    
    <item>
      <title>hdu4737 A Bit Fun</title>
      <link>http://liuxueyang.github.io/posts/hdu4737-a-bit-fun/</link>
      <pubDate>Sun, 15 Sep 2013 10:26:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4737-a-bit-fun/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4737
暴力可以过啊。O(N^2)的复杂度。
#include &amp;lt;cstdio&amp;gt; int a[100001]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif int t; scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); long long int ans; for (int i = 1; i &amp;lt;= t; ++i) { ans = 0; printf(&amp;quot;Case #%d: &amp;quot;, i); int m; int n, j, k; scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m); for (j = 0; j &amp;lt; n; scanf(&amp;quot;%d&amp;quot;, a+j++)); int tmp; for (j = 0; j &amp;lt; n; ++j) { tmp = a[j]; for (k = j; k &amp;lt; n; ++k) { tmp = tmp | a[k]; if (tmp &amp;lt; m) ans++; else break; } } printf(&amp;quot;%lld\n&amp;quot;, ans); } return 0; }  数据出的不好吧==</description>
    </item>
    
    <item>
      <title>codeforces 199a</title>
      <link>http://liuxueyang.github.io/posts/codeforces-199a/</link>
      <pubDate>Thu, 12 Sep 2013 19:16:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-199a/</guid>
      <description>link:http://codeforces.com/contest/342/problem/A
恩恩，读错题了。人家是at most 7，我理解成了at lease 7。好欢乐~
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; int cnt[8]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif int n, i, j, tmp; bool flag; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { flag = true; memset(cnt, 0, sizeof(cnt)); for (i = 0; i &amp;lt; n; ++i) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;tmp); cnt[tmp]++; } int sum = cnt[5] + cnt[7]; if (sum &amp;gt; 0) { printf(&amp;quot;-1\n&amp;quot;); continue; } int c136 = 0, c126 = 0, c124 = 0; if (cnt[1] &amp;gt;= cnt[3] &amp;amp;&amp;amp; cnt[6] &amp;gt;= cnt[3]) {cnt[1] -= cnt[3]; cnt[6] -= cnt[3]; c136 = cnt[3];} else flag = false; if (cnt[1] &amp;gt;= cnt[6] &amp;amp;&amp;amp; cnt[2] &amp;gt;= cnt[6]) {cnt[1] -= cnt[6]; cnt[2] -= cnt[6]; c126 = cnt[6];} else flag = false; if (cnt[1] &amp;gt;= cnt[4] &amp;amp;&amp;amp; cnt[2] &amp;gt;= cnt[4]) { c124 = cnt[4]; cnt[1] -= cnt[4]; cnt[2] -= cnt[4];} else flag = false; if (cnt[1]+cnt[2] &amp;gt; 0) flag = false; if (flag) { for (i = 0; i &amp;lt; c136; ++i) printf(&amp;quot;1 3 6\n&amp;quot;); for (j = 0; j &amp;lt; c126; ++j) printf(&amp;quot;1 2 6\n&amp;quot;); for (i = 0; i &amp;lt; c124; ++i) printf(&amp;quot;1 2 4\n&amp;quot;); } else printf(&amp;quot;-1\n&amp;quot;); } return 0; }  闲的没事儿干，没事儿做做题=_=</description>
    </item>
    
    <item>
      <title>读书笔记4</title>
      <link>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B04/</link>
      <pubDate>Thu, 05 Sep 2013 00:21:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B04/</guid>
      <description>今天一天看完一本推理小说w_w
《预知梦》 作者：东野圭吾 ——推理小说
讲了5个故事：
预知梦：一个男子童年时梦到一个女孩是她将来的妻子。17年后，竟然相同名字的女孩出现了。跟踪+骚扰之。真相，女孩的妈妈A在17年前出轨，那个男子B有一个小女孩，后来这个女孩死了，之前A对这个小女孩很好，送给了她一个布娃娃，小女孩给布娃娃取了一个名字，叫礼美。女孩死后，布娃娃送给了那个小男孩，之前小男孩经常和小女孩一起玩，也许这就留下了心理阴影。之后，A生了个女孩，起了个名字叫礼美，可能是无意识的，也可能是有意识的。A意识到男孩的出现，必然会让17年前的事情暴露，所以诱导男孩晚上闯入女孩房间，自己拿步枪杀之，未遂。 见到幽魂：爱摄影的女子A不巧拍到了车祸，勒索。最后被肇事者情侣陷害，为了伪造完美的不在场证明，女方扮成A的样子出现在一个地方，同时男方在A的房间内杀之。 骚灵：所谓骚灵不过是房子和下水管道的共振现象。凶手为了老太太的巨额一场把老太太杀死，被经常看老太太的男子A发现，接着A被杀死，在屋子里挖了一个坑，把尸体藏在里面。最后比较令人感动的是，老太太生前把自己的卡式银行保险箱钥匙给了素不相识但是经常去看望她照顾她的男子A，保险箱里面有巨额存折+遗书，明确写着遗产全部赠与男子A，只可惜…… 鬼火之谜：工厂主人为了挽救工厂前一个月内投了好几份保险，然后自己伪装成他杀的自杀，目的是得到保险金，他没跟妻子说，知道妻子肯定不会同意的，更悲剧的是，妻子察觉到了，暗中协助之，并且让警方开始把目标锁定自己，然后自己再拿出完美的不在场证明。唉，只能说，可能是被逼的没办法了吧。至少，厂主是值得尊敬的，为了别人献出了自己宝贵的生命。就像天才侦探+物理学家汤川说的那句：我倒是希望他们拿到那份保险金呢。也许他们不会把真想说出去吧。因为一年之内的自杀不能得到保险赔偿。所谓鬼火，就是厂长试验自杀方法的时候的火苗，方式很复杂，用两根弓箭线+通电+安眠药。好吧，天才的手段。 少女篇：很复杂。觉得没意思。两对夫妻，涉及到两个出轨。⊙﹏⊙b汗 大概就是一个女子以死威胁，假装自杀，结果真的“自杀”了，当然，其实是被谋杀了。所谓少女，就是10岁的女孩在晚上恰好看到了女子之前试验自杀方式的样子，结果后来真的发生了。为什么被谋杀呢？动机：假装自杀一定不会成功，那么女子就成了最大的威胁。  这本书写的还不错w_w
00:22:56
嗨，中村。</description>
    </item>
    
    <item>
      <title>codeforces 340C Tourist Problem</title>
      <link>http://liuxueyang.github.io/posts/codeforces-340c-tourist-problem/</link>
      <pubDate>Wed, 04 Sep 2013 00:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-340c-tourist-problem/</guid>
      <description>link:http://codeforces.com/problemset/problem/340/C
开始一点也没思路，赛后看别人写的代码那么短，可是不知道怎么推出来的啊！
后来明白了。
首先考虑第一个数字，就是和0想减的内个。那么剩下的n-1个数字有(n-1)!个排列方式。所以呢，在n!个式子里面，第一个位置的和就是：a1 * (n-1)! + a2 * (n-1)! + &amp;hellip;&amp;hellip; + an * (n-1)!；
然后考虑其它位置：对于ai , aj . 并且相邻。那么剩下 n - 2 个数字，这些数字有 (n-2)!个排列方式，然后把相邻的 ai aj 插入，有 n-1 种插入方式，所以呢，一共有 (n-1) * (n-2)! = (n-1)! 个方式，其它位置的和就是：(n-1)! * fabs(ai - aj) 【i != j, 1 &amp;lt;= i, j &amp;lt;= n】
关键是第二个式子怎么求呢？好像很难得样子。可以找规律啊。比如，a1, a2 , a3, a4.
因为有绝对值，我可以先排序，先算正的，在 *2就行了。假设a1 &amp;gt; a2 &amp;gt; a3 &amp;gt; a4
设：
以a2结尾的ai - aj 的和是S2.
以a3……和是S3
。a4…………S4</description>
    </item>
    
    <item>
      <title>cf340D Bubble Sort Graph</title>
      <link>http://liuxueyang.github.io/posts/cf340d-bubble-sort-graph/</link>
      <pubDate>Wed, 04 Sep 2013 00:36:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/cf340d-bubble-sort-graph/</guid>
      <description>link:http://codeforces.com/problemset/problem/340/D
感觉很好的一道题目。
认真思考，发现，逆序的数字对一定有边相连。所以，题目要求没有边相连的最大的集合的点的个数，其实就是找原来的序列的最长上升子序列！
/* * Filename: tourist.cpp * Created: 09/01/2013 09:07:05 AM * Author: liuxueyang (lxy), zypz457@sina.com * Organization: Hunnan University */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int MOD = 1e9+7; using namespace std; int touch[100009]; int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>读书笔记3</title>
      <link>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03/</link>
      <pubDate>Tue, 03 Sep 2013 23:04:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03/</guid>
      <description>这段时间懒得写博客了。
还是写一点吧。
最近看完的书：
《天才在左，疯子在右》 作者：高铭 ——心理学科普类
超级有意思的一本书，现在开始明白为什么有很多人都对心理学感兴趣了，人的精神世界真的很奇妙。
世界上有太多的未知，我们都被未知奴役着。只能怀着敬畏的心态，面对这个充满神奇的世界吧。有太多超出我们想象的东西了，也有太多不能解释的东西了。
《目送》 作者：龙应台 ——散文、随笔
这本书和龙应台以前的作品风格完全不同，感情很细腻，尤其是有些细节，很让人感动。一句话印象很深刻，写的是我们每个人：
　我慢慢地、慢慢地了解到，所谓父女母子一场，只不过意味着，你和他的缘分就是今生今世不断地在目送他的背影渐行渐远。你站立在小路的这一端，看着他逐渐消失在小路转弯的地方，而且，他用背影默默告诉你：不必追。
《推理要在晚餐后》 作者：东川笃哉 ——推理小说
　很漂亮的本格推理小说！最喜欢这种了，不长，但是很精彩。当初梦想当职业棒球选手或者私人侦探的影山却是一个大家族的管家，凭着精妙的推理解决了一个又一个案件，并且是光凭口述，只不过，却当了管家，可惜了，正因为如此，这个角色堪称完美啊。
　记录一下里面的案件：
　杀人现场请拖鞋：一男的同时跟几个女人同时交往，女A和男交换过钥匙，女B发现了女A的钥匙后，通过某种手段，找到女A的住所，发现确实是女A的钥匙，等女A出门后，潜入房间，不料女A中途返回家，女B无处藏身再加上女A当时穿的是长靴，因为想起天气预报要下雨，阳台的衣服没有收，所以返回家来收，穿长靴懒得脱了，所以直接爬着进屋，这是日本的习惯吧，进屋拖鞋。这个时候女A毫无自卫能力，女B趁机从背后杀死。
　来一杯杀人红酒如何：冒充情人送给被害者一瓶红酒，然后被害者被氰酸钾毒死。被害者有洁癖，所以杯子是干净的，红酒是高档红酒，没开封过，同时，被害者是独自在自己房间内喝酒。那怎么下的毒呢？答案就是：日本的红酒是那种软木塞，虽然软木塞上有金属盖子密封着，但是留有两个小孔，用注射器把氰酸钾注入就可以了。这种细节都可以想到，orz
　美丽的蔷薇中蕴含着杀意：大概是一个家族显赫的男人，带回来一个女人，这个女人以前是做特殊职业的，也就是我们平常说的妓女，事实上，这个女人是一个性格开朗人也很不错的人，家里人不同意等等……后来有一些家人了解了这个女人后改变了当初的看法，但是有个弟兄貌似还是不同意，直到一天，女人平静地躺在家族宅邸的蔷薇花坛里，很美，但是死了。这个案件里面，很有意思的一段推理：已知女人很喜欢猫，晚上睡觉的时候猫也在床边，第二天早晨女人死了后，发现猫受伤了，同时，第二天人们发现尸体的时候，为了确认是不是死亡，开始试图把尸体搬下来，这样那几个人的手背上都有划伤，同时，宅邸里还有其他的花园，为什么凶手要选择蔷薇呢？答案：凶手为了掩饰猫的抓伤。案件的原因：由于女人以前是特殊职业的，那个弟兄可能和她有过不光彩的经历，同时发生了争执，为了以后在家族里的地位和权势，酿成了悲剧。
……………………
算了，，不写了，，，发现写出来一点也没意思。。。。其实最有意思的是里面的细节和巧妙的推理……都把真相写出来了，味同嚼蜡。
我还是只记录关键的事件吧：
　新娘深陷密室之中：又是一个迷失杀人案。由于各种误会+包庇，第一个冲进现场的人竟然把凶手放走了，其实当时凶手就在房间的角落，只不过当时第一个进入房间的人的注意力只在尸体上了。里面有一个细节：根据管家对不同人的习惯称呼，巧妙地让凶手露出马脚，这需要反映足够快啊。
　请小心劈腿：一个男人被杀，发现尸体的时候赤身裸体。并且根据目击者的口述，曾见过男人和一个160左右的女人在一起，另一个是曾见过男人和一个170左右的男人在一起。为什么呢？男人穿了增高鞋，产生视觉上的偏差，本来女人160左右，同时女人逃离现场时穿了男人的增高鞋。很巧妙的伪装。杀人动机很无聊：身高欺骗。我见过的最无聊的……
　请看来自死者的留言：案件很复杂的样子。主要是就是一个女强人被杀。原因是这个女人曾把凶手的女朋友害的自杀了。但是里面的推理很不错，凶手伪装死亡讯息，跟据这个排除可能性，同时，还有一个13岁的少女做帮凶，只不过，那是个美丽的错误……
《麦田里的守望者》 作者：塞林格 ——小说
　说实话，这本书读到百分之六十，发现自己真的没怎么读懂。唯一学到的一句话就是：“他妈的混帐玩意儿”。
　不过现在觉得也许有点懂了。也许我们每个人身上都有霍尔顿的影子吧。肆意挥霍自己的青春。
　先放下，以后再继续看，或者重新看一遍。
嗨，中村。</description>
    </item>
    
    <item>
      <title>hdu4497 GCD and LCM ——素数分解&#43;计数</title>
      <link>http://liuxueyang.github.io/posts/hdu4497-gcd-and-lcm-%E7%B4%A0%E6%95%B0%E5%88%86%E8%A7%A3-%E8%AE%A1%E6%95%B0/</link>
      <pubDate>Mon, 26 Aug 2013 00:09:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4497-gcd-and-lcm-%E7%B4%A0%E6%95%B0%E5%88%86%E8%A7%A3-%E8%AE%A1%E6%95%B0/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4497
如果G%L != 0，说明一定无解。
把K = G / L质数分解，G / L = p1^t1 * p2^t2 * p3^t3 * ……；同时 x/= L, y/= L, z/=L，不影响结果。
假设三个数字的质数分解是：
x = p1^i1 * p2^i2 * p3^i3 * ……
y = p1^j1 * p2^j2 * p3^j3 * ……
z = p1^k1 * p2^k2 * p3^k3 * ……
要保证x, y, z互质，并且lcm(x, y, z) = K, 那么对于p1来说，i1, j1, k1里面一定有一个是0，并且一定有一个是t1，所以有3种情况：
0 0 t1 有3种
t1 t1 0 有3种</description>
    </item>
    
    <item>
      <title>poj1026 Cipher ——置换群</title>
      <link>http://liuxueyang.github.io/posts/poj1026-cipher-%E7%BD%AE%E6%8D%A2%E7%BE%A4/</link>
      <pubDate>Sun, 25 Aug 2013 08:55:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1026-cipher-%E7%BD%AE%E6%8D%A2%E7%BE%A4/</guid>
      <description>link:http://poj.org/problem?id=1026
其实这道题目和poj2369这道题目一样。
都是基础的置换群题目。把那道题目理解了，这道题就没问题了。
不过我的方法貌似比较挫，或者处理方法效率不高，比较慢……
就是对每个数字求出循环节，用rec[]保存，然后用k%rec[]得到余数，
再模拟这个余数次就得到了目标位置。
/* ID: zypz4571 LANG: C++ TASK: decode.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; char str[222]; int rec[222], a[222], b[222], c[222]; bool flag[222]; int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>poj2369 Permutations ——置换群</title>
      <link>http://liuxueyang.github.io/posts/poj2369-permutations-%E7%BD%AE%E6%8D%A2%E7%BE%A4/</link>
      <pubDate>Sat, 24 Aug 2013 17:44:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj2369-permutations-%E7%BD%AE%E6%8D%A2%E7%BE%A4/</guid>
      <description>link:http://poj.org/problem?id=2369
置换群，最简单的那种。
找所有数字循环节的最小公倍数。
/* ID: zypz4571 LANG: C++ TASK: permutations.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int a[1111]; bool flag[1111]; int gcd(int x, int y) { return y == 0 ?</description>
    </item>
    
    <item>
      <title>2009年到2013年甲子园ED</title>
      <link>http://liuxueyang.github.io/posts/2009%E5%B9%B4%E5%88%B02013%E5%B9%B4%E7%94%B2%E5%AD%90%E5%9B%ADed/</link>
      <pubDate>Fri, 23 Aug 2013 11:47:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2009%E5%B9%B4%E5%88%B02013%E5%B9%B4%E7%94%B2%E5%AD%90%E5%9B%ADed/</guid>
      <description>2009年
http://v.youku.com/v_show/id_XMTY3MTM4NjQw.html
2010年 最喜欢的一个！看过N遍
http://v.youku.com/v_show/id_XMjAwMzEwMDI4.html
2011年
http://v.youku.com/v_show/id_XMjk3NTQ4OTky.html
也不错！
2012年 超级好听啊~^_^比10年的还好，看过N+1遍……o(╯□╰)o
http://v.youku.com/v_show/id_XMzY5OTM3Mzg4.html
2013年春季甲子园
http://v.youku.com/v_show/id_XNTYzODI0NTA4.html
印象最深的是2011年打进甲子园的至学馆。
http://v.youku.com/v_show/id_XMjkxOTcwNjI0.html
这是至学馆校歌《追梦人》
这是11年一支甲子园参赛队，名为至学馆，他们的故事犹如真人版的TOUCH，为了实现打入甲子园的梦想而努力，但王牌投手桐林史树 却遭遇车祸，不幸丧生，不仅如此，球队二号投手
麻王健之郎 因为练习过重，导致手臂受伤，只能终止投手生涯，虽然前往甲子园的路上有无数强大的敌手，但他们最终击败了所有对手，打入了11年甲子园！以上是他们在取得甲子园入场券后唱校歌的场景，其中那个看台上的照片就是桐林史树。
嗨，中村。</description>
    </item>
    
    <item>
      <title>使用STL离散化</title>
      <link>http://liuxueyang.github.io/posts/%E4%BD%BF%E7%94%A8stl%E7%A6%BB%E6%95%A3%E5%8C%96/</link>
      <pubDate>Thu, 22 Aug 2013 09:47:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E4%BD%BF%E7%94%A8stl%E7%A6%BB%E6%95%A3%E5%8C%96/</guid>
      <description>把原来的数组a复制一份拷贝b 用sort先把数组a排序 用unique消除a里面重复的元素 对于b中的每一个元素，用lower_bound找到它在a中的位置，也就是离散化之后的编号。 没了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int main(void) { int a[6] = {15, 14, 11, 20, 13, 13}, b[111]; for (int i=0; i &amp;lt; 6; ++i) b[i] = a[i]; sort(a, a+6); int len = unique(a, a+6) - a; for (int i = 0;i &amp;lt; 6; ++i) b[i] = lower_bound(a, a+len, b[i]) - a + 1; for (int i = 0; i &amp;lt; 6; ++i) printf(&amp;quot;%d &amp;quot;, b[i]); printf(&amp;quot;\n&amp;quot;); return 0; }  嗨！中村。</description>
    </item>
    
    <item>
      <title>读书笔记2</title>
      <link>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02/</link>
      <pubDate>Thu, 22 Aug 2013 07:59:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02/</guid>
      <description>从17日下午到21日中午，用三天多的时间第一次完整地看完了《TOUCH》這部經典漫畫，看到结尾的时候，有点后悔了，其实，我应该再看慢一点的，经典作品，这么快就看完总觉得很可惜啊o(╯□╰)o。
26卷，每卷185页左右，总共大約4810页，照这个节奏，如果kpw不是触屏的，按键会不会残了！？
只是柏叶教练的一句话到现在还记忆犹新：我喜欢夏天啊。
《TOUCH》經典片段：（有很多安達充式的幽默~）
很久很久以前，在某个地方……有一只戴着捕手面具的肥猪。
认识和也真是一件自豪地事情呢。
认识我呢？
是个笑话
……
走吧，小胖！
他是个莫名其妙的男人，……可是，却能让人抱有期望。
你是不会甘心做一个小流氓而终此一生的。他和你不同，是个高深莫测、不可思议的男人。
他是你朋友吗？
他手里拿着那枚五百日元的硬币，说：是的……
你讨厌那种说法吗？
他仰着头，说，不，没什么。
天才这个词语，比起用在死去的弟弟身上……也许这家伙更合适呢。
他要是再具备一点冷静，一定会是一个出色的投手。
因为他是不会……乘人之危的。
那真的是个精彩的全垒打呢。
四坏球报送，但还是一直保持无安打无上垒，输了吗？但还是收场了，这个夏天结束了。很不甘心啊。
那也只能怪……是上帝的恶作剧吧。
他是不是对你说了什么啊？
没有啊
啊…看来天气真的很热呢。
店里总是没什么客人呢。
是作者偷懒。
大家看着墙上和也的照片，说着，不能逃跑啊……
真对不起呢，我的家境不好……
啊，脸上有青春痘。
啪！
要怎么打才会输给那个世多高中啊！？我希望你教教我呀。
嗨！中村。
由佳经过的时候，对不怎么熟悉的被达也彻底击败的垂头丧气走出球场的吉田说，加油吧。
背景是，吉田曾经暗恋过由佳。
我有自信啊！
是玻璃做的吗？
在浓黑的墨镜后面，他似乎可以洞穿一切。是对棒球的热爱，还是他的实力其实已到达了神的境界？
有些男人，是在败得遍体鳞伤之后才变得诚实的。
把什么都归功于死去的人身上，流出来的汗水就失去意义了。
为你知道打击阵容这个词语吗？ 没听过呢。
可是，你知道教练这个词语吗？
指甲剥落，继续投着沾着血的球的话，你会稍微感动，而行动起来吗？
没有你的资料。
雖然牆壁已經剝落、褪色，就像你那張臉那麼骯髒…
不過，我只是在想什麼時候讓你看看啊。
喂，傻瓜。
为何要和新田一较高低？
啊，是叫我啊？
因为这是棒球……只要逃避一次的话，很容易就形成习惯。
逃避会变成习惯……吗？
那纯粹只是借口呀。
……
你去告诉你那个傻瓜……世界并不是那么令人感动的……
我回想起来了，新田。
我们立志要夺取的目标…
所谓的甲子园，只是一个副奖而已。
那副奖令人头昏眼花，只找对手的空当，欺骗自己，逃避胜负。
你们就是被那种思想灌输之下成长起来的。
作为一个蹩脚的教育者，我很心痛啊。
那时，你能击败新田的概率应该是一成都没有的。
为了面子而一决胜负看，若被打中的话，你应该会为自己的愚蠢而终生后悔不已。
是啊。
撒谎吧。
即使是那样，你……
……不，你们……
也会手握着手，留下美好的回忆。
要那样坚定地说出来啊。
真受不了啊。</description>
    </item>
    
    <item>
      <title>hdu4691 Front compression ——暴力 || 后缀数组</title>
      <link>http://liuxueyang.github.io/posts/hdu4691-front-compression-%E6%9A%B4%E5%8A%9B-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 21 Aug 2013 17:08:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4691-front-compression-%E6%9A%B4%E5%8A%9B-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4691
暴力，数据明显太水了吧，n=10^5, O(n^2)的复杂度哎喂。想让大家暴力写直接让n=1000不就得了么，这算什么。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; char a[111111], b[11111]; //#define LL long long #define LL __int64 int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu4690 EBCDIC ——水题，考耐心</title>
      <link>http://liuxueyang.github.io/posts/hdu4690-ebcdic-%E6%B0%B4%E9%A2%98%E8%80%83%E8%80%90%E5%BF%83/</link>
      <pubDate>Tue, 20 Aug 2013 20:17:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4690-ebcdic-%E6%B0%B4%E9%A2%98%E8%80%83%E8%80%90%E5%BF%83/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4690
考的是耐心何细心啊，用map把两个表格映射一下就行~
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; string A[16][16] = { &amp;quot;NUL&amp;quot;,&amp;quot;SOH&amp;quot;,&amp;quot;STX&amp;quot;,&amp;quot;ETX&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;HT&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;DEL&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;VT&amp;quot;,&amp;quot;FF&amp;quot;,&amp;quot;CR&amp;quot;,&amp;quot;SO&amp;quot;,&amp;quot;SI&amp;quot;, &amp;quot;DLE&amp;quot;,&amp;quot;DC1&amp;quot;,&amp;quot;DC2&amp;quot;,&amp;quot;DC3&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;BS&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;CAN&amp;quot;,&amp;quot;EM&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;IFS&amp;quot;,&amp;quot;IGS&amp;quot;,&amp;quot;IRS&amp;quot;,&amp;quot;IUS ITB&amp;quot;, &amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;LF&amp;quot;,&amp;quot;ETB&amp;quot;,&amp;quot;ESC&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;ENQ&amp;quot;,&amp;quot;ACK&amp;quot;,&amp;quot;BEL&amp;quot;, &amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;SYN&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;EOT&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;DC4&amp;quot;,&amp;quot;NAK&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;SUB&amp;quot;, &amp;quot;SP&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;.</description>
    </item>
    
    <item>
      <title>hdu4686 Arc of Dream ——构造矩阵&#43;快速幂</title>
      <link>http://liuxueyang.github.io/posts/hdu4686-arc-of-dream-%E6%9E%84%E9%80%A0%E7%9F%A9%E9%98%B5-%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Tue, 20 Aug 2013 20:12:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4686-arc-of-dream-%E6%9E%84%E9%80%A0%E7%9F%A9%E9%98%B5-%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>link: http://acm.hdu.edu.cn/showproblem.php?pid=4686
构造出来的矩阵是这样的：根据题目的ai * bi = ……，可以发现 矩阵1 * 矩阵3 = 矩阵2。然后就是矩阵快速幂了。
1
1	ai	bi	ai*bi	Si 0	0	0	0	0 0	0	0	0	0 0	0	0	0	0 0	0	0	0	0  2
1	ai+1	bi+1	ai+1*bi+1	Si+1 0	0	0	0	0 0	0	0	0	0 0	0	0	0	0 0	0	0	0	0  3
1	AY	BY	AY*BY	AY*BY 0	AX	0	AX*BY	AX*BY 0	0	BX	AY*BX	AY*BX 0	0	0	AX*BX	AX*BX 0	0	0	0	1  #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; #define LL __int64 #define MOD 1000000007 typedef struct { LL m[5][5]; }mat; mat X, Y; LL n, a0, ax, ay, b0, bx, by; mat multi(mat a, mat b) { mat c; int j, i, k; for (i = 0; i &amp;lt; 5; ++i) { for (j = 0; j &amp;lt; 5; ++j) { c.</description>
    </item>
    
    <item>
      <title>就说一句</title>
      <link>http://liuxueyang.github.io/posts/%E5%B0%B1%E8%AF%B4%E4%B8%80%E5%8F%A5/</link>
      <pubDate>Tue, 20 Aug 2013 10:09:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%B0%B1%E8%AF%B4%E4%B8%80%E5%8F%A5/</guid>
      <description>做了一年ACM，今天才顿悟，为什么还一直处于这么渣的阶段，原来是打开方式不对！
更多的是看例题，写实现，思考算法，体会算法思想，而不是想都不想就上去飞快的敲代码，然后找无穷无尽的BUG！
所以，以后多想，多看论文，少敲键盘吧。如果一个算法没理解就去做题，基本是必然会写错的，即使是小错也会浪费很多时间。</description>
    </item>
    
    <item>
      <title>ural 1057Amount of Degrees ——数位DP</title>
      <link>http://liuxueyang.github.io/posts/ural-1057amount-of-degrees-%E6%95%B0%E4%BD%8Ddp/</link>
      <pubDate>Tue, 20 Aug 2013 09:26:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/ural-1057amount-of-degrees-%E6%95%B0%E4%BD%8Ddp/</guid>
      <description>link:http://acm.timus.ru/problem.aspx?space=1&amp;amp;num=1057
论文： 浅谈数位类统计问题 刘聪
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int a[33][33]; int bto2(int x, int b) { int tm[33], cnt = 0, ans = 0; while (x) { tm[cnt++] = x % b; x /= b; } for (int i = cnt - 1; i &amp;gt;= 0; --i) { if (tm[i] &amp;amp;&amp;amp; (tm[i] !</description>
    </item>
    
    <item>
      <title>codeforces mysterious present 最长上升子序列&#43;倒序打印路径</title>
      <link>http://liuxueyang.github.io/posts/codeforces-mysterious-present-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-%E5%80%92%E5%BA%8F%E6%89%93%E5%8D%B0%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Mon, 19 Aug 2013 15:22:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-mysterious-present-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-%E5%80%92%E5%BA%8F%E6%89%93%E5%8D%B0%E8%B7%AF%E5%BE%84/</guid>
      <description>link:http://codeforces.com/problemset/problem/4/D
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int n,w,h,cnt,ans,d[5009],path[5009],End; bool flag; typedef struct node { int W,H,In; bool operator &amp;lt; (const node &amp;amp;other) const { if(W!</description>
    </item>
    
    <item>
      <title>读书笔记1</title>
      <link>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Sun, 18 Aug 2013 14:09:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/</guid>
      <description>不想说什么了，今天一大早来机房，就为了写这两天的读书笔记，做点摘抄什么的，马不停蹄，人不停爪地敲了一个多小时，手都抽筋了，写完的时候，添加标签的时候，界面一刷新，然后什么都没有了！有想砸电脑的冲动啊。博客园的后台编辑器支持自动保存的，不过只支持IE9内核以上的和chrome以及firefox的浏览器，好吧。算我倒霉了。还是简要记录一下吧，早上写的一堆白写了。不忍心。
8月16日中午kpw到货，激动啊。一直很后悔的就是大学里面没有怎么读书，很多想读的书都没有看过，所以剩下的时间里多看看书吧。
8月16日
《我所理解的生活》韩寒
一下午+晚上读完了，很可惜，很多文章都是看过的，或者是再韩寒的博客上或者是在读者青年文摘上。不过总的来说还是不错的。
8月17日
《小王子》
小学的时候就看过这本书，大一的时候看过一遍英文版的，上午读完了一遍，每一次读都有不同的感受，尤其是在不同的阶段，不同的心境下。很美丽的一个童话。
昨晚看一然酱的kindle，好吧，好多技术方面的书啊，linux,python,Haskell各种啊，我的里面从汉书到韩寒到漫画都有啊，一本学习的书都没有啊，这就是传说中的茶具么？好吧，其实即使有学习的书，我想按照我这个阅读的优先级，我也是永远也不会看的o(╯□╰)o其实kindle除了看小说，看散文漫画什么的超级方便以外，看技术的书确实也不方便啊，尤其是需要翻来翻去的那种书。
一天之中最宁静的时光，就是深夜躺在楼顶，伴着月光，静静地看书，困了就昏睡过去，凌晨醒来，一边欣赏着美丽的朝霞，一边继续懒散地看书，然后一天又开始了。</description>
    </item>
    
    <item>
      <title>codeforces105d Bag of mice ——概率DP</title>
      <link>http://liuxueyang.github.io/posts/codeforces105d-bag-of-mice-%E6%A6%82%E7%8E%87dp/</link>
      <pubDate>Sun, 18 Aug 2013 11:09:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces105d-bag-of-mice-%E6%A6%82%E7%8E%87dp/</guid>
      <description>Link:
http://codeforces.com/problemset/problem/148/D
Refer to:
http://www.cnblogs.com/kuangbin/archive/2012/10/04/2711184.html
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; double a[1111][1111]; int main(void) { int w,b; #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>zoj3551 Bloodsucker ——概率DP</title>
      <link>http://liuxueyang.github.io/posts/zoj3551-bloodsucker-%E6%A6%82%E7%8E%87dp/</link>
      <pubDate>Sun, 18 Aug 2013 10:19:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj3551-bloodsucker-%E6%A6%82%E7%8E%87dp/</guid>
      <description>Link: http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=4530
A[i]数组表示当吸血鬼有 I 个的时候，还需要的天数。可以列出方程：
A[i] = p1(a[i+1]+1) + (1-p1)(a[i]+1) p1=(i*(n-i))p / (n(n-1)/2)
这道题目错了很多次，原因就是强制类型转换的时候，有一个细节，
(double)(n(n-1))/2.0 是错的，应该写成：(double)n(n-1)/2.0。这个小细节以后注意吧
# include&amp;lt;stdio.h&amp;gt; # include&amp;lt;string.h&amp;gt; # include&amp;lt;stdlib.h&amp;gt; int main(void) { // freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;,stdin ); int t; scanf(&amp;quot;%d&amp;quot;,&amp;amp;t); while (t--) { int n; double p; scanf(&amp;quot;%d%lf&amp;quot;,&amp;amp;n,&amp;amp;p); double sad=0.0,dw=(double)n*(n-1)/2.0; for(int i=n-1;i&amp;gt;=1;--i) { double lxy=i; lxy*=(n-i); lxy*=p; lxy=lxy/dw; sad+=1.0/lxy; } printf(&amp;quot;%.3f\n&amp;quot;,sad); } return 0; }  O(╯□╰)o</description>
    </item>
    
    <item>
      <title>codeforces298c</title>
      <link>http://liuxueyang.github.io/posts/codeforces298c/</link>
      <pubDate>Sat, 17 Aug 2013 10:40:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces298c/</guid>
      <description>link:http://codeforces.com/problemset/problem/298/C 这道题目可以看出来我智商确实拙计
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; char a[1111],b[1111]; int main(void) { scanf(&amp;quot;%s%s&amp;quot;,a,b); int lena=strlen(a),lenb=strlen(b),cnt1=0,cnt2=0; for(int i=0;i&amp;lt;lena;++i) if(a[i]==&#39;1&#39;) cnt1++; for(int i=0;i&amp;lt;lenb;++i) if(b[i]==&#39;1&#39;) cnt2++; bool flag=true; if(cnt1%2==1) cnt1++; if(cnt1&amp;lt;cnt2) flag=false; if(flag) printf(&amp;quot;YES\n&amp;quot;); else printf(&amp;quot;NO\n&amp;quot;); return 0; }  拙计o(╯□╰)o</description>
    </item>
    
    <item>
      <title>poj1458 Common Subsequence ——最长公共子序列</title>
      <link>http://liuxueyang.github.io/posts/poj1458-common-subsequence-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sat, 17 Aug 2013 10:38:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1458-common-subsequence-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>link:http://poj.org/problem?id=1458 最基础的那种
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int sad[1111][1111];char apple[1111],pear[1111]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin ); #endif // ONLINE_JUDGE // while (gets(apple)!</description>
    </item>
    
    <item>
      <title>codeforces194b</title>
      <link>http://liuxueyang.github.io/posts/codeforces194b/</link>
      <pubDate>Thu, 15 Aug 2013 19:00:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces194b/</guid>
      <description>link:http://codeforces.com/problemset/problem/334/B
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int main(void) { set&amp;lt;int&amp;gt; sadx, sady; int x[9] ,y[9] ; bool flag = true; for (int i=0;i&amp;lt;8;++i) { scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x[i],&amp;amp;y[i]); sadx.</description>
    </item>
    
    <item>
      <title>codeforces194a</title>
      <link>http://liuxueyang.github.io/posts/codeforces194a/</link>
      <pubDate>Thu, 15 Aug 2013 18:53:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces194a/</guid>
      <description>link:http://codeforces.com/contest/334/problem/A 很有意思的一道构造题。发现CF上经常出这种不难但是很不错的构造题。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int main(void) { int n; while (~scanf(&amp;quot;%d&amp;quot;,&amp;amp;n)) for (int i=1;i&amp;lt;=n*n/2;++i) { for (int j=1;j&amp;lt;=n/2;++j) { printf(&amp;quot;%d %d &amp;quot;,i,n*n-i+1); ++i; } i--; printf(&amp;quot;\n&amp;quot;); } return 0; }  o(╯□╰)o 官方解题报告上面写的很明白 1　n^2 2　n^2-1 .</description>
    </item>
    
    <item>
      <title>codeforces195c</title>
      <link>http://liuxueyang.github.io/posts/codeforces195c/</link>
      <pubDate>Thu, 15 Aug 2013 18:41:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces195c/</guid>
      <description>link:http://codeforces.com/problemset/problem/336/C 从大到小枚举，如果对应的二进制位不等于0，就加进来，最后的sum如果%2^k==0那么就是合法的。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int a[111111]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif // ONLINE_JUDGE int n; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { for (int i=0;i&amp;lt;n;++i) scanf(&amp;quot;%d&amp;quot;,a+i); for (int i=29;i&amp;gt;=0;--i) { int sad=1&amp;lt;&amp;lt;i, sum=-1, cnt=0; for (int j=0;j&amp;lt;n;++j) { if((sad&amp;amp;a[j])!</description>
    </item>
    
    <item>
      <title>codeforces195a</title>
      <link>http://liuxueyang.github.io/posts/codeforces195a/</link>
      <pubDate>Thu, 15 Aug 2013 18:36:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces195a/</guid>
      <description>link:http://codeforces.com/problemset/problem/336/A 很简单的一道题目，当初有个单词不认识，isosceles原来意思是等腰的o(╯□╰)o
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif // ONLINE_JUDGE int x,y; while (~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x,&amp;amp;y)) { int sad=abs(x)+abs(y); if(x&amp;gt;0&amp;amp;&amp;amp;y&amp;gt;0) printf(&amp;quot;%d %d %d %d\n&amp;quot;,0,sad,sad,0); else if(x&amp;gt;0&amp;amp;&amp;amp;y&amp;lt;0) printf(&amp;quot;%d %d %d %d\n&amp;quot;,0,-sad,sad,0); else if(x&amp;lt;0&amp;amp;&amp;amp;y&amp;gt;0) printf(&amp;quot;%d %d %d %d\n&amp;quot;,-sad,0,0,sad); else printf(&amp;quot;%d %d %d %d\n&amp;quot;,-sad,0,0,-sad); } return 0; }  o(╯□╰)o</description>
    </item>
    
    <item>
      <title>hdu4671 Backup Plan ——构造题</title>
      <link>http://liuxueyang.github.io/posts/hdu4671-backup-plan-%E6%9E%84%E9%80%A0%E9%A2%98/</link>
      <pubDate>Thu, 15 Aug 2013 18:31:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4671-backup-plan-%E6%9E%84%E9%80%A0%E9%A2%98/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4671 其实是不难的那种构造题，先排第一列，第二列从后往前选。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int sad[111], fun[111][111]; int main(void) { int n, m; while (~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m)) { for(int i=1;i&amp;lt;=n;++i) { sad[i]=m/n; if(i&amp;lt;=m%n) sad[i]++; } int row=1; for(int i=1;i&amp;lt;=n;++i) { int k=n; for(int j=1;j&amp;lt;=sad[i];++j) { while (i==k||k==0) {if(i==k) k--; if(k==0) k=n;} fun[row][0]=i; fun[row][1]=k; k--; row++; } } for(int i=1;i&amp;lt;=m;++i) { printf(&amp;quot;%d %d&amp;quot;,fun[i][0],fun[i][1]); for(int j=1;j&amp;lt;=n;++j) { if(j!</description>
    </item>
    
    <item>
      <title>hdu4666 Hyperspace ——曼哈顿距离</title>
      <link>http://liuxueyang.github.io/posts/hdu4666-hyperspace-%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Thu, 15 Aug 2013 18:26:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4666-hyperspace-%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4666 这题学会了怎么处理曼哈顿距离。 比如维数是k，那么每个点有2^k个状态，求出在每个状态下，所有点的最大值，最小值，求他们的差，从中找到最大值就行。 开始觉得不好处理的是，删除的时候怎么办。比如要删除一个点，我可以在2^k个中的每个状态里面先找到这个点在这个状态下的值，删除这个值就行了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; multiset&amp;lt;int&amp;gt; a[44]; int sad[66666][10],will[66666][44]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>poj3181 Dollar Dayz ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/poj3181-dollar-dayz-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 18:14:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj3181-dollar-dayz-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://poj.org/problem?id=3181 本来很常规的一道完全背包，比较有意思的一点是，结果会超int，更有意思的解决方法是，不用高精度，用两个整型的拼接起来就行了。ORZ
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; typedef unsigned long long ULL; ULL dp[1111], dp1[1111]; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>uva147 Dollars      ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/uva147-dollars------%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 18:03:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva147-dollars------%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=83 和完全背包一样的思想。 有两个trick： 没了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; long long d[33333]; int a[11]={5,10,20,50,100,200,500,1000,2000,5000,10000}; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>uva674 Coin Change ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/uva674-coin-change-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:59:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva674-coin-change-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=615 和完全背包一样的思想。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int a[5]={1,5,10,25,50}; int f[7777]; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu2191 悼念512汶川大地震     ——多重背包</title>
      <link>http://liuxueyang.github.io/posts/hdu2191-%E6%82%BC%E5%BF%B5512%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%87-----%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:54:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu2191-%E6%82%BC%E5%BF%B5512%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%87-----%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=2191 最简单的那种
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int n, V, t, f[111], c[111], w[111], m[111]; void zeropack(int c, int w) { for (int v=V; v&amp;gt;=c; --v) { f[v]=max(f[v],f[v-c]+w); } return; } void completepack(int c, int w) { for (int v=c;v&amp;lt;=V;++v) f[v]=max(f[v],f[v-c]+w); return; } void multipack(int c, int w, int m) { if (c*m &amp;gt;= V) { completepack(c,w); return; } int k=1; while (k&amp;lt;m) { zeropack(c*k,w*k); m-=k; k*=2; } zeropack(c*m,w*m); return; } int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu1059 Dividing ——多重背包</title>
      <link>http://liuxueyang.github.io/posts/hdu1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=1059 最简单的那种
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int V,m[6],c[6],w[6],f[66666]; void zeropack(int c, int w) { for (int v=V;v&amp;gt;=c;--v) f[v]=max(f[v],f[v-c]+w); return; } void completepack(int c,int w) { for(int v=c;v&amp;lt;=V;++v) f[v]=max(f[v],f[v-c]+w); return; } void multipack(int c,int w,int m) { if(c*m&amp;gt;=V) { completepack(c,w); return; } int k=1; while (k&amp;lt;m) { zeropack(k*c,k*w); m-=k; k*=2; } zeropack(c*m,w*m); return; } int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu1114 Piggy-Bank ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/hdu1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:47:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=1114 只不过求得是最小值。没什么可说的，连我都会做……o(╯□╰)o
/* ID: zypz4571 LANG: C++ TASK: pig.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int f[11111],c[555],w[555], V, n; void completepack(int c,int w) { for(int v=c;v&amp;lt;=V;++v) f[v]=min(f[v],f[v-c]+w); } int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>zoj3623 Battle Ships ——完全背包？简单DP！|| 泛化背包</title>
      <link>http://liuxueyang.github.io/posts/zoj3623-battle-ships-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%AE%80%E5%8D%95dp-%E6%B3%9B%E5%8C%96%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:43:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj3623-battle-ships-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%AE%80%E5%8D%95dp-%E6%B3%9B%E5%8C%96%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3623 看起来像完全背包，但是物品价值是变化的，所以很多人搞的很复杂。 晚上的代码要么很复杂，有一个代码虽然很简洁在zoj可以过，但是是错误的。求教lyl神犇，果然思想很深刻，抓住乐问题的本质，想法比网上搜到的所有博客里面的做法都简洁。 事实上，就是简单的DP，抓住一个技巧：让时间倒流，也就是说，把时间反过来考虑，先在将来把船造好，然后在过去用船攻击，哈哈，太巧秒了，说起来很别扭，很有意思，dp[j+time[i]]=max(dp[j]+j*time[i])；dp[j]表示在j这个时间，所造成的最大伤害。这样就可以枚举时间，在每个特定的时间内，枚举船的种类，找到最大值。最终在dp[]数组里面找到符合条件的并且时间最少的解。 只能说，ORZ…… 后来好不容易想明白了。茶具从哪里来……
/* ID: zypz4571 LANG: C++ TASK: battle.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int Time[33],dam[33], f[444]; int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>poj3249 Test for Job  ——拓扑&#43;DP</title>
      <link>http://liuxueyang.github.io/posts/poj3249-test-for-job--%E6%8B%93%E6%89%91&#43;dp/</link>
      <pubDate>Thu, 15 Aug 2013 17:29:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj3249-test-for-job--%E6%8B%93%E6%89%91&#43;dp/</guid>
      <description>link:http://poj.org/problem?id=3249 在拓扑排序的过程中进行状态转移，dp[i]表示从起点到 i 这个点所得到的的最大值。比如从u点到v点，dp[v]=max(dp[v], dp[u]+a[v]) a[]数组是点的价值，最终的dp[]数组里面的最大值就是所求的。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; #define N 111111 using namespace std; int WO[N],NI[N],dp[N],TA[N]; vector&amp;lt;int&amp;gt; V[N]; queue&amp;lt;int&amp;gt; QU; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu3033 I love sneakers!        分组背包变形</title>
      <link>http://liuxueyang.github.io/posts/hdu3033-i-love-sneakers--------%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E5%8F%98%E5%BD%A2/</link>
      <pubDate>Sun, 11 Aug 2013 18:24:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu3033-i-love-sneakers--------%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E5%8F%98%E5%BD%A2/</guid>
      <description>分组背包要求每一组里面只能选一个，这个题目要求每一组里面至少选一个物品。 dp[i, j] 表示前 i 组里面在每组至少放进一个物品的情况下，当花费 j 的时候，所得到的的最大价值。这个状态可以由三个状态转移过来： a[i, j].b表示第 i 组第 j 个物品的花费，v表示背包容量。 初始化： 如果一种物品都不放，那么对应的所有的背包容量都是0，也就是：dp[0, 0~M] = 0； 其他的情况，都初始化成-INF。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; typedef struct node { int b,v; }node; vector&amp;lt;node&amp;gt; a[11]; int dp[11][10009]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu1712 ACboy needs your help    分组背包</title>
      <link>http://liuxueyang.github.io/posts/hdu1712-acboy-needs-your-help----%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</link>
      <pubDate>Sun, 11 Aug 2013 16:20:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1712-acboy-needs-your-help----%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</guid>
      <description>最基础的分组背包~
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int dp[102], a[102][102]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin ); #endif // ONLINE_JUDGE int n,m; while (~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m)&amp;amp;&amp;amp;(n||m)) { for (int i=1;i&amp;lt;=n;++i) { for (int j=1;j&amp;lt;=m;++j) scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i][j]); } memset(dp,0,sizeof(dp)); for (int i=1;i&amp;lt;=n;++i) { for (int v=m;v&amp;gt;=0;--v) { for (int j=1;j&amp;lt;=v;++j) { dp[v]=max(dp[v],dp[v-j]+a[i][j]); } } } printf(&amp;quot;%d\n&amp;quot;,dp[m]); } return 0; }  没什么可说的。1Y</description>
    </item>
    
    <item>
      <title>当我把电脑500G硬盘格式化了的时候，在想些什么</title>
      <link>http://liuxueyang.github.io/posts/%E5%BD%93%E6%88%91%E6%8A%8A%E7%94%B5%E8%84%91500g%E7%A1%AC%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BA%86%E7%9A%84%E6%97%B6%E5%80%99%E5%9C%A8%E6%83%B3%E4%BA%9B%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sun, 11 Aug 2013 15:01:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%BD%93%E6%88%91%E6%8A%8A%E7%94%B5%E8%84%91500g%E7%A1%AC%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BA%86%E7%9A%84%E6%97%B6%E5%80%99%E5%9C%A8%E6%83%B3%E4%BA%9B%E4%BB%80%E4%B9%88/</guid>
      <description>所以我就想重新尝试一下怎么装多系统，bootloader,MBR到底是怎么回事儿。 简要记录一下： 首先，在可以作为启动盘的Ｕ盘里面，备份一份可以用的WinXP镜像+校园网客户端安装文件+驱动精灵安装文件。然后再说别的。 我的硬盘初步规划是这样的：把硬盘分成4个分区，3P+1E。也就是3个主分区，1个扩展分区。每个50G。硬盘主分区最多有4个，为了以后装Linux，我分了3个主分区，一个用来装WinXP，另外两个装Ubuntu，CentOS。扩展分区再划分出几个逻辑分区：分出100G作为WinXP里面的D盘，装软件；再分出100G作为WinXP里面的E盘，存文档。足够用。剩下的100+G，分出1G作为Ubuntu的swap分区，再分出1G作为CentOS的swap分区。剩下的作为空闲分区备用。 这样三个主分区编号分别是：/dev/sda1 /dev/sda2 /dev/sda3 D，E两个盘的编号是：/dev/sda5 /dev/sda6 两个swap分区的编号是：/dev/sda7 /dev/sda8 先装winXP系统，找一个Ghost版的，把U盘用大白菜制作成启动盘，进入PE，还原系统就行了。 然后装Ubuntu，自己有一张安装盘，12.04版的。为了省事儿+还没什么经验，所以我选择了只把Linux分成两个分区，一个根分区 / ，一个swap分区。根分区挂载在 /dev/sda2，swap分区挂载在 /dev/sda7。然后重要的一点：bootloader安装在500G硬盘的最前面！然后就没什么注意的了，直接装就行。 最后装CentOS，同样，我自己有一张安装盘，CentOS 6.0。同样，也是只分两个分区，一个根分区 /，一个swap分区。根分区挂载在 /dev/sda3，swap分区挂载在 /dev/sda8。然后同样很重要的一点：bootloader安装在 /dev/sda3这个主分区里面！如果也安装在整个硬盘的最前面的话，会覆盖掉Ubuntu安装的Grub2。所以，要安装的CentOS所在的主分区的里面就行了，Ubuntu的Grub2的bootloader可以将启动权转交给这个主分区的bootloader。然后同样也没什么注意的了，直接装就行。 如果装完CentOS后，发现开机之后的Grub2没有CentOS的启动选项，或者因为重复装了多次系统，把原来的系统格式化了，但是启动选项里面依然有记录。可以进入Ubuntu，打开终端更新一下Grub2：sudo update-grub2。然后重启就可以了。 为什么要先装WinXP在装Linux呢？因为WinXP无节操，系统重装的时候会重写MBR，把Linux的启动选项覆盖掉，所以就看不到Grub界面了. 如果你很不幸Win系统挂了，其实解决办法也不是没有，比如这篇：ubuntu12.04 修复Grub2 这种东西紧急情况下其实还是挺有用的。o(╯□╰)o 某些细节可能写的不那么准确，就是这么理解的…… 一切弄好之后，机器启动进入Grub2界面：有Ubunt，CentOS，WinXP启动选项。 完美~ 我是不是有点无聊……囧o(╯□╰)o 鼠标一点，整个硬盘的资料就没了，人生似乎可以重新开始了，又可以重新做人了，但是，记忆呢，记忆能不能格式化？</description>
    </item>
    
    <item>
      <title>hdu2955 Robberies 　０１背包＋概率</title>
      <link>http://liuxueyang.github.io/posts/hdu2955-robberies-%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85%E6%A6%82%E7%8E%87/</link>
      <pubDate>Tue, 06 Aug 2013 11:06:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu2955-robberies-%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85%E6%A6%82%E7%8E%87/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=2955 首先，这个题目的背包容量不能是概率．１．精度不清楚．２．把概率相加有什么意义呢？所以，转换一下，把所有银行的珠宝和当作背包容量，把小偷安全的概率当作物品价值．可以先求出背包尽可能满的情况下，安全概率最大的解．然后在这些解里面，找出安全概率满足大于１－Ｐ的并且价值最大的就行． 题目读清楚．人给的是被抓住的概率和每个银行被抓住的概率．这个是不能直接用的．比如连续偷几个银行，就要分别算出安全的概率，这样概率就可以直接相乘了． 只要要偷的几个银行的安全概率的积大于１－P就行．
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int V, n, c[11111]; double w[11111], f[11111]; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>uva562 Dividing coins   01背包</title>
      <link>http://liuxueyang.github.io/posts/uva562-dividing-coins---01%E8%83%8C%E5%8C%85/</link>
      <pubDate>Tue, 06 Aug 2013 10:45:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva562-dividing-coins---01%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=503 分成２半，并且两半的差距最小，背包的体积变成V/2
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int V, c[111], w[111], f[55555], n; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>uva624 CD　　　０１背包&#43;输出最优解</title>
      <link>http://liuxueyang.github.io/posts/uva624-cd%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85&#43;%E8%BE%93%E5%87%BA%E6%9C%80%E4%BC%98%E8%A7%A3/</link>
      <pubDate>Tue, 06 Aug 2013 10:41:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva624-cd%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85&#43;%E8%BE%93%E5%87%BA%E6%9C%80%E4%BC%98%E8%A7%A3/</guid>
      <description>link:http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=565 用一个二维数组g[i][v]表示：当状态转移到v的时候，第i个物品是不是用到，如果用到标记１，否则标记０． 输出路径的时候，注意，从物品编号０一直到n-1.如果某个物品被用到了，g[i][v]里面的v，就要减去这个物品的体积，然后继续往下找．
/* * ===================================================================================== * Filename: cd.cpp * Created: 04/08/2013 15:21:34 * Author: liuxueyang (lxy), 1459917536@qq.com * Organization: Hunan University * * ===================================================================================== */ /* ID: zypz4571 LANG: C++ TASK: cd.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;list&amp;gt; #define INF 0x3f3f3f3f #define MOD 1000000007 #define LL long long const double eps=1e-9; using namespace std; int V, n, c[22], f[22222], g[22][22222]; int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu2546　饭卡　　　　０１背包</title>
      <link>http://liuxueyang.github.io/posts/hdu2546%E9%A5%AD%E5%8D%A1%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85/</link>
      <pubDate>Tue, 06 Aug 2013 10:31:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu2546%E9%A5%AD%E5%8D%A1%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=2546 也算一个贪心的想法吧． 先把总钱数减去５，再把价值最大的挑出来．然后用０１背包．最终买下挑出来的那个价值最大的商品．这样的话，我就实现了最终用最少的钱数买了价值最多的商品，剩下钱数当然也是最少了．
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int main(void) { ios::sync_with_stdio(false); int n, V; int c[1111], f[1111]; #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>sgu259　Printed PR　　　　贪心</title>
      <link>http://liuxueyang.github.io/posts/sgu259printed-pr%E8%B4%AA%E5%BF%83/</link>
      <pubDate>Tue, 06 Aug 2013 10:27:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/sgu259printed-pr%E8%B4%AA%E5%BF%83/</guid>
      <description>link:http://acm.sgu.ru/problem.php?contest=0&amp;amp;problem=259 思路就是贪心． 首先要读懂题目，输入的方式，把样例读懂． 第一，打印的总时间一定．需要做的就是送出的时间尽可能的重合，这样总时间就会更少．所以，送出时间长的要尽可能的先打印，按照送出时间从大到小排序就可以了．
/* * ===================================================================================== * Filename: 259.cpp * Created: 06/08/2013 10:15:09 * Author: liuxueyang (lxy), 1459917536@qq.com * Organization: Hunan University * * ===================================================================================== */ /* ID: zypz4571 LANG: C++ TASK: 259.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;list&amp;gt; #define INF 0x3f3f3f3f #define MOD 1000000007 #define LL long long const double eps=1e-9; using namespace std; struct Node{ int t, l; bool operator &amp;lt; (const Node other) const { if (l!</description>
    </item>
    
    <item>
      <title>hdu4632 Palindrome subsequence     ——区间动态规划</title>
      <link>http://liuxueyang.github.io/posts/hdu4632-palindrome-subsequence-----%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Sat, 03 Aug 2013 16:19:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4632-palindrome-subsequence-----%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4632 refer to: o(╯□╰)o……明明百度找的题解，然后后来就找不到我看的那份了，这位哥们对不住了……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; char a[1111]; int dp[1111][1111]; const int MOD = 10007; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu4642 Fliping game        ——博弈</title>
      <link>http://liuxueyang.github.io/posts/hdu4642-fliping-game--------%E5%8D%9A%E5%BC%88/</link>
      <pubDate>Sat, 03 Aug 2013 10:52:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4642-fliping-game--------%E5%8D%9A%E5%BC%88/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4642 refer to: http://www.cnblogs.com/jackge/archive/2013/08/01/3231573.html 这道题目很有意思。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif int t, n, m, tmp; ios::sync_with_stdio(false); cin&amp;gt;&amp;gt;t; for (int i = 0; i &amp;lt; t; ++i) { cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; for (int j = 0; j &amp;lt; n; ++j) for (int k = 0; k &amp;lt; m; ++k) cin&amp;gt;&amp;gt;tmp; if (tmp) cout&amp;lt;&amp;lt;&amp;quot;Alice&amp;quot;&amp;lt;&amp;lt;endl; else cout&amp;lt;&amp;lt;&amp;quot;Bob&amp;quot;&amp;lt;&amp;lt;endl; } return 0; }  o(╯□╰)o</description>
    </item>
    
    <item>
      <title>hdu4639 hehe      ——斐波纳契数列，找规律</title>
      <link>http://liuxueyang.github.io/posts/hdu4639-hehe------%E6%96%90%E6%B3%A2%E7%BA%B3%E5%A5%91%E6%95%B0%E5%88%97%E6%89%BE%E8%A7%84%E5%BE%8B/</link>
      <pubDate>Sat, 03 Aug 2013 10:29:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4639-hehe------%E6%96%90%E6%B3%A2%E7%BA%B3%E5%A5%91%E6%95%B0%E5%88%97%E6%89%BE%E8%A7%84%E5%BE%8B/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4639 refer to: http://blog.csdn.net/dongdongzhang_/article/details/9706259 http://www.cnblogs.com/wuhenqs/archive/2013/08/01/3230987.html
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; const int MOD = 10007; char a[11111]; long long fi[11111]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>codefoces round193a</title>
      <link>http://liuxueyang.github.io/posts/codefoces-round193a/</link>
      <pubDate>Thu, 25 Jul 2013 05:33:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codefoces-round193a/</guid>
      <description>link: http://codeforces.com/contest/332/problem/A /* ID: zypz4571 LANG: C++ TASK: 193a.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; char a[2222]; int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>codeforces 192e</title>
      <link>http://liuxueyang.github.io/posts/codeforces-192e/</link>
      <pubDate>Wed, 24 Jul 2013 21:09:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-192e/</guid>
      <description>link: http://codeforces.com/contest/330/problem/E
/* ID: zypz4571 LANG: C++ TASK: 192e.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; map&amp;lt;pair&amp;lt;int,int&amp;gt;,bool&amp;gt; coll; int a[100009]; int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE //freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>abbyy cup a</title>
      <link>http://liuxueyang.github.io/posts/abbyy-cup-a/</link>
      <pubDate>Wed, 24 Jul 2013 21:04:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/abbyy-cup-a/</guid>
      <description>link: http://codeforces.com/contest/331/problem/A2
/* ID: zypz4571 LANG: C++ TASK: abby_a.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; long long int a[300009], sum[300009]; map&amp;lt;int, int&amp;gt; coll; int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>年中总结</title>
      <link>http://liuxueyang.github.io/posts/%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 22 Jul 2013 20:53:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/</guid>
      <description>一年过去一半了，也有半年不回家了，25号就回家了，刚订好票。这半年，总结一下吧。 6月的考试：　——痛苦 这学期最终果然还是挂了一科。数字逻辑，呵呵，没什么可说的，本来就没有一天认真看过书，实在对这货没兴趣。 别的科目。 概率论，靠着考前一天多的通宵+运气+RP+老师比较好，最终竟然有81分……就我这个学习态度……囧 数据结构，本来挺重要的一门课，但老师超水，貌似我上过的课加一块也就差不多七八节的样子……老师水，最后也有80 计算理论，本来也很有深度的一个课程，很抽象，很偏重理论，博士教的，呵呵&amp;gt;&amp;lt;反正我是没怎么学，靠着考前一晚上通宵+运气+RP+%&amp;amp;@最终竟然也有80。。没什么说的。 高级英语，这学期真的没学英语啊，都是水过去的啊，囧，75分，很满足了其实。以后就没有英语课了…… 西班牙语，一然酱帮忙选上的，挺不错的，只是貌似没有很多时间学的样子……最后老师给开卷，78没挂就行了 体育，一个学分，哈哈。这个挺得意的，虽然没打过篮球，但还是考试的时候RP爆发，3步上篮全场来回两趟竟然跑了27秒！！也就是大概95分的成绩，我自己都惊呆了，哎，RP爆发没办法~然后引体向上，满分，因为大家做的都不标准，我也来了个不标准的，做13个还是很容易嘛。以后就没有体育课了……虽然我一直都想逃体育课。。。最后98.5分……好高啊，好久没有见过这么高的分数了，，，虽然这是体育…… 最后是坑爹的数字逻辑，呵呵，主要是对这个老师实在是很恶心，不说什么了，4个学分，呵呵，什么都没学到，这货的课一节也没听过。其实试着听过，实在不爽……导致现在觉得最讨厌的一门课就是数字逻辑，从上学到现在，没有之一。 还是得乖乖的看一下书，补考，呵呵。 5月　——平静 貌似什么也没有发生，很多时候还是为了某件事情纠结，就这样了，这个月浑浑噩噩的过去了。 然后就是这个月花销不少，买了不少书，后来认真读了发现有些书很值。 4月　——忙碌 然后就是最重要的，ACM。很多比赛，出去过很多次，爆零，被虐。但最终还是没有把每次的比赛都好好总结，错题几乎没改过，机会都浪费了。 3月　——纠结 老天似乎给我开了一个玩笑，然后我就当真了%&amp;gt;&amp;lt;% 暂且就这么解释吧。就好比你做了一个美梦，正沉浸在幸福中，然后醒了，发现那不是真的，那些其实从来不属于你的，然后就很失落。 2月　——拙计 寒假在家，跟小孩儿似的，还没长大，好多事情还是想不通啊，面壁思过一下。 ………………………………………………………………………………………………………………………………………………………………………… 写的很乱，没什么逻辑，就当个记录。其实真的应该自己认真思考一下，反思一下。 附上一个视频：《北京东路的故事》 歌词很有意思，这几个高中生唱的超好听啊。</description>
    </item>
    
    <item>
      <title>codeforces 192a</title>
      <link>http://liuxueyang.github.io/posts/codeforces-192a/</link>
      <pubDate>Mon, 22 Jul 2013 03:09:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-192a/</guid>
      <description>link: http://codeforces.com/contest/330/problem/A brute force. /* ID: zypz4571 LANG: C++ TASK: 191a.cpp */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #define INF 0x3f3f3f3f #define mid int m=(l+r)/2 using namespace std; int a[102]; int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;191a.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif int n, n1=0, cnt=0, Max=0; scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); for (int i=0; i&amp;lt;n; ++i){ scanf(&amp;quot;%d&amp;quot;,a+i); if(a[i]) n1++; } if (n1 == n) Max = n1-1; else { Max = n1; for (int i=0; i&amp;lt;n; ++i) { for (int j=0; j&amp;lt;n; ++j) { cnt = n1; for (int k=i; k&amp;lt;=j; ++k) { if (!</description>
    </item>
    
    <item>
      <title>codeforces 192b</title>
      <link>http://liuxueyang.github.io/posts/codeforces-192b/</link>
      <pubDate>Mon, 22 Jul 2013 03:07:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-192b/</guid>
      <description>link: http://codeforces.com/contest/330/problem/B I think the problem is hard at first. However, when you think deep in it you will find it is so easy.
/* ID: zypz4571 LANG: C++ TASK: 192b.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #define INF 0x3f3f3f3f #define REP(i, n) for(int i=0;i&amp;lt;int(n);++i) #define FOR(i, a, b) for(int i=int(a);i&amp;lt;int(b);++i) #define DWN(i, b, a) for(int i=int(b-1);i&amp;gt;=int(a);--i) #define REP_1(i, n) for(int i=1;i&amp;lt;=int(n);++i) #define mid int m=(l+r)/2 using namespace std; int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>codeforces 192 c</title>
      <link>http://liuxueyang.github.io/posts/codeforces-192-c/</link>
      <pubDate>Mon, 22 Jul 2013 03:02:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-192-c/</guid>
      <description>link: http://codeforces.com/contest/330/problem/C broute force but you must be careful about some tricks and think about all the instances
/* ID: zypz4571 LANG: C++ TASK: 192c.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #define INF 0x3f3f3f3f #define REP(i, n) for(int i=0;i&amp;lt;int(n);++i) #define FOR(i, a, b) for(int i=int(a);i&amp;lt;int(b);++i) #define DWN(i, b, a) for(int i=int(b-1);i&amp;gt;=int(a);--i) #define REP_1(i, n) for(int i=1;i&amp;lt;=int(n);++i) #define mid int m=(l+r)/2 using namespace std; int a[102][102], rows[102], cols[102]; int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>codeforces 192 D</title>
      <link>http://liuxueyang.github.io/posts/codeforces-192-d/</link>
      <pubDate>Mon, 22 Jul 2013 02:58:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-192-d/</guid>
      <description>link: http://codeforces.com/contest/330/problem/D The discription looks so long, but the problem is simple if you can grasp the problem quickly.
/* ID: zypz4571 LANG: C++ TASK: 192d.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #define INF 0x3f3f3f3f #define REP(i, n) for(int i=0;i&amp;lt;int(n);++i) #define FOR(i, a, b) for(int i=int(a);i&amp;lt;int(b);++i) #define DWN(i, b, a) for(int i=int(b-1);i&amp;gt;=int(a);--i) #define REP_1(i, n) for(int i=1;i&amp;lt;=int(n);++i) #define mid int m=(l+r)/2 using namespace std; int dir[4][2] = {{0,-1}, {0, 1}, {-1, 0}, {1, 0}}; char mat[1003][1003]; struct Node { int x, y, time; }; Node start, end; int ans, matime[1003][1003], n, m; bool vis[1003][1003]; void bfs(Node end) { queue&amp;lt;Node&amp;gt; q; q.</description>
    </item>
    
    <item>
      <title>codeforces magic five －－快速幂模</title>
      <link>http://liuxueyang.github.io/posts/codeforces-magic-five-%E5%BF%AB%E9%80%9F%E5%B9%82%E6%A8%A1/</link>
      <pubDate>Fri, 19 Jul 2013 16:29:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-magic-five-%E5%BF%AB%E9%80%9F%E5%B9%82%E6%A8%A1/</guid>
      <description>题目链接：http://codeforces.com/contest/327/problem/C 首先先算出一个周期里面的值，保存在ans里面，就是平常的快速幂模m做法． 然后要计算一个公式，比如有k个部分，那么对于没一个位置i, 都有2^i + 2^(i+n) + &amp;hellip; + 2^(i+(k-1)*n) = 2^i(1 + 2^n + &amp;hellip; + 2^((k-1)*n)) = 2^i * (1-2^(n*k))/(1-2^n) 所以结果就是ans * (1-2^(n*k))/(1-2^n) % MOD; 然后就是关键计算(1-2^(n*k))/(1-2^n) % MOD； 用到费马小定理a^(p-1)同余于1(mod 1)．p是一个质数，那么a^(p-2) * a 同余于１(mod 1) ，所以a 的逆元就是 a^(p-2) MOD是一个质数,所以(1-2^(n*k))/(1-2^n) % MOD = (2^(n*k)-1)/(2^n-1) % MOD = (2^(n*k)-1)%MOD * ((2^n-1)^(MOD-2))%MOD
/* * ===================================================================================== * Filename: magic.cpp * Created: 19/07/2013 12:27:18 * Author: liuxueyang (lxy), 1459917536@qq.com * Organization: Hunan University * * ===================================================================================== */ /* ID: zypz4571 LANG: C++ TASK: magic */ #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;list&amp;gt; using namespace std; #define INF 0x3f3f3f3f const double eps=1e-9; char a[100010]; const int MOD=1000000007; #define LL long long int k; LL quick(LL a, LL b) { LL ans=1; while (b) { if(b&amp;amp;1) ans=(ans*a)%MOD; b/=2; a*=a; a%=MOD; } return ans; } int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>codeforces hungry sequence  水题</title>
      <link>http://liuxueyang.github.io/posts/codeforces-hungry-sequence--%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Fri, 19 Jul 2013 01:07:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-hungry-sequence--%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://codeforces.com/problemset/problem/327/B 这道题目虽然超级简单，但是当初我还真的没有想出来做法，囧，看完别人的代码恍然大悟。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cmath&amp;gt; int main(void) { int n; scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); for (int i = n+1; i &amp;lt;= n+n; ++i) { printf(&amp;quot;%d&amp;quot;, i); if (i != n+n) printf(&amp;quot; &amp;quot;); } printf(&amp;quot;\n&amp;quot;); return 0; }  ＝＝只需要注意到整除这个条件：至少是2倍，所以只需要从n+1一直到2*n就可以了，正好n个数字，最大的数字和最小的数字相比也不超过2.就是这么个简单的道理。 </description>
    </item>
    
    <item>
      <title>Codeforces Flipping game 动态规划基础</title>
      <link>http://liuxueyang.github.io/posts/codeforces-flipping-game-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 19 Jul 2013 01:05:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-flipping-game-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/</guid>
      <description>题目链接：http://codeforces.com/problemset/problem/327/A 这道题目有O(N^3)的做法，这里转化为动态规划求解，复杂度是O(N)
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; using namespace std; #define INF 0x3f3f3f3f int a[102], b[102], c[102]; int main ( void ) { int n, n1=0, cnt=0; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { n1 = cnt = 0; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); for (int i=1; i&amp;lt;=n; ++i){ scanf(&amp;quot;%d&amp;quot;,a+i); if(a[i]) n1++; if (a[i]) b[i]=-1; else b[i]=1; } c[0] = 0; for (int i = 1; i &amp;lt;= n; ++i) { c[i] = c[i-1] + b[i]; } int Max = -INF, Min = c[0]; for (int i = 1; i &amp;lt;= n; ++i) { if (c[i] - Min &amp;gt; Max) Max = c[i]-Min; if (c[i] &amp;lt; Min) Min = c[i]; } printf(&amp;quot;%d\n&amp;quot;,n1+Max); } return 0; }  转化为子序列的最大连续和</description>
    </item>
    
    <item>
      <title>Testing Round #8  A. IQ Test   水题</title>
      <link>http://liuxueyang.github.io/posts/testing-round-#8--a.-iq-test---%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Fri, 19 Jul 2013 00:58:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/testing-round-#8--a.-iq-test---%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://codeforces.com/problemset/problem/328/A 这道题目wa了一次，注意这句话：
You should also print 42 if the next element of progression is not integer. So answer is always integer.  然后就可以了。
/* ID: zypz4571 LANG: C++ TASK: iqtest.cpp */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #define INF 0x3f3f3f3f #define mid int m=(l+r)/2 using namespace std; int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>Codeforces Testing Round #8 B. Sheldon and Ice Pieces 水题</title>
      <link>http://liuxueyang.github.io/posts/codeforces-testing-round-#8-b.-sheldon-and-ice-pieces-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Thu, 18 Jul 2013 18:50:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-testing-round-#8-b.-sheldon-and-ice-pieces-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://codeforces.com/problemset/problem/328/B 水题~
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; char n[10], a[202]; int b[13], c[13]; int main(void) { //freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); scanf(&amp;quot;%s%s&amp;quot;, n, a); int len1 = strlen(n), len2 = strlen(a); memset(b, 0, sizeof(b)); memset(c, 0, sizeof(c)); for (int i = 0; i &amp;lt; len1; ++i) b[n[i]-&#39;0&#39;]++; for (int i = 0; i &amp;lt; len2; ++i) c[a[i]-&#39;0&#39;]++; b[2]+=b[5], b[5]=0, c[2]+=c[5], c[5]=0, b[6]+=b[9], b[9]=0, c[6]+=c[9], c[9]=0; int cnt=0, Max=100000; for (int i = 0; i &amp;lt; 10; ++i){ if (b[i]){ cnt = c[i]/b[i]; if (cnt &amp;lt; Max) Max = cnt; } } printf(&amp;quot;%d\n&amp;quot;, Max); return 0; }  =_=</description>
    </item>
    
    <item>
      <title>sgu548 Dragons and Princesses　　　贪心＋优先队列</title>
      <link>http://liuxueyang.github.io/posts/sgu548-dragons-and-princesses%E8%B4%AA%E5%BF%83%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</link>
      <pubDate>Thu, 18 Jul 2013 17:53:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/sgu548-dragons-and-princesses%E8%B4%AA%E5%BF%83%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</guid>
      <description>题目链接：http://acm.sgu.ru/problem.php?contest=0&amp;amp;problem=548 题目意思： 有一个骑士，要经过n个房间，开始在第一个房间，每个房间里面有龙或者公主，遇到龙，可以决定杀或者不杀，如果杀，就可以得到相应的珠宝；如果遇到公主，如果这个骑士此时杀过的龙的数目大于等于公主的美貌值，那么这个骑士必须marry这个公主，不能拒绝．．^_^，但是骑士的真爱是在最后一个房间里面的公主，问骑士能不能到达最后一个房间？如果能的话，求出能够到达最后一个房间的情况下，得到的最大的珠宝数． 做法： 优先队列＋贪心． 遇到龙就杀，用优先队列维护得到的珠宝数目，遇到公主就检查目前的杀的龙的数目是不是大于等于公主的美貌值，如果大于等于，就把有限队列里面珠宝值小的房间出队，直到杀的龙的数目小于美貌值为止．
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; struct Node { int pos, n; bool operator &amp;lt; (const Node &amp;amp;other) const { return n &amp;lt; other.n; } }node; int array[200009]; priority_queue&amp;lt;Node&amp;gt; a; char ch[4]; int main(void) { int i, n, tmp, j, sum, cnt; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { sum = 0, cnt = 0, j = 0, i = 2; for (int f = 0; f &amp;lt; n-2; ++f, ++j, ++i) { scanf(&amp;quot;%s%d&amp;quot;, ch, &amp;amp;tmp); node.</description>
    </item>
    
    <item>
      <title>sgu546 Ternary Password</title>
      <link>http://liuxueyang.github.io/posts/sgu546-ternary-password/</link>
      <pubDate>Thu, 18 Jul 2013 17:42:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/sgu546-ternary-password/</guid>
      <description>题目链接：http://acm.sgu.ru/problem.php?contest=0&amp;amp;problem=546 这题还好，１Ｙ，考虑情况周全，就没问题了，还好提交之前把想到的情况都测试了一遍．．
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; char s[202]; int n, a, b, a0[202], b0[202]; int main(void) { //freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); while (~scanf(&amp;quot;%d%d%d%s&amp;quot;, &amp;amp;n, &amp;amp;a, &amp;amp;b, s)) { int a1 = 0, b1 = 0; for (int i = 0;i &amp;lt; n; ++i) { if (s[i] == &#39;0&#39;) a0[a1] = i, a1++; else if (s[i] == &#39;1&#39;) b0[b1] = i, b1++; } if (a1 == a &amp;amp;&amp;amp; b1 == b) printf(&amp;quot;0\n%s\n&amp;quot;, s); else if (a+b&amp;gt;n) printf(&amp;quot;-1\n&amp;quot;); else { int cnt = 0, a2 = 0, b2 = 0; a2 = a1-a, b2 = b1-b; if (a1 &amp;lt; a) { for (int f = 0; f &amp;lt; b2 &amp;amp;&amp;amp; a1 &amp;lt; a; ++f) s[b0[f]] = &#39;0&#39;, cnt++, a1++, b1--; if (a1 &amp;lt; a) { for (int e = 0; e &amp;lt; n &amp;amp;&amp;amp; a1 &amp;lt; a; ++e) if (s[e] == &#39;2&#39;) s[e] = &#39;0&#39;, cnt++, a1++; } } if (b1 &amp;lt; b) { for (int f = 0; f &amp;lt; a2 &amp;amp;&amp;amp; b1 &amp;lt; b; ++f) s[a0[f]] = &#39;1&#39;, cnt++, b1++, a1--; if (b1 &amp;lt; b) { for (int e = 0; e &amp;lt; n &amp;amp;&amp;amp; b1&amp;lt;b; ++e) if (s[e] == &#39;2&#39;) s[e] = &#39;1&#39;, cnt++, b1++; } } if (a1 &amp;gt; a) { for (int f = 0; f &amp;lt; n &amp;amp;&amp;amp; a1 &amp;gt; a; ++f) if (s[f] == &#39;0&#39;) a1--, s[f] = &#39;2&#39;, cnt++; } if (b1 &amp;gt; b) { for (int f = 0; f &amp;lt; n &amp;amp;&amp;amp; b1 &amp;gt; b; ++f) if (s[f] == &#39;1&#39;) b1--, s[f] = &#39;2&#39;, cnt++; } printf(&amp;quot;%d\n%s\n&amp;quot;, cnt, s); } } return 0; }  只是我的方法貌似比较笨＝＝</description>
    </item>
    
    <item>
      <title>sgu551 Preparing Problem</title>
      <link>http://liuxueyang.github.io/posts/sgu551-preparing-problem/</link>
      <pubDate>Thu, 18 Jul 2013 17:39:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/sgu551-preparing-problem/</guid>
      <description>题目链接：http://acm.sgu.ru/problem.php?contest=0&amp;amp;problem=551 呵呵，题目读的没错，可惜理解错了．．＝＝
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #define LL long long using namespace std; int n, t1, t2; int gcd(int a, int b) { return b == 0 ? a : (gcd(b, a%b)); } int exg(int a, int b) { return a/gcd(a,b)*b; } int main(void) { //freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); while (~scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;t1, &amp;amp;t2)) { int k = exg(t1, t2), s = k/t1 + k/t2, One = n/s, r = n%s, base = One*k, Min = 0, cnt = 0, i, j; if (t1&amp;gt;t2) swap(t1,t2); //printf(&amp;quot;s = %d r = %d\n&amp;quot;, s, r); if (r) for (i = 1, j = 1; i+j &amp;lt;= s;) { if (cnt &amp;gt;= r) break; if (i * t1 &amp;lt; j * t2) Min=i*t1, i++, cnt++; else if(i*t1 &amp;gt; j*t2) Min=j*t2, j++, cnt++; else Min=j*t2, j++, i++, cnt+=2; if (cnt &amp;gt;= r) break; } if ( (i-1)*t1!</description>
    </item>
    
    <item>
      <title>uestc1888 Birthday Party 　　　组合数学，乘法原理</title>
      <link>http://liuxueyang.github.io/posts/uestc1888-birthday-party-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E4%B9%98%E6%B3%95%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 18 Jul 2013 17:26:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uestc1888-birthday-party-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E4%B9%98%E6%B3%95%E5%8E%9F%E7%90%86/</guid>
      <description>题目链接：http://acm.hust.edu.cn/vjudge/contest/view.action?cid=25539#problem/G 题目意思： 有n个人，每个人有一个礼物，每个人能拿自己礼物，n个人随机送礼物，给一个数字k,求出可以找到k个人，满足：这ｋ个人里面，第一个人把礼物给第二个人，第二个人把礼物给第三个人，以此类推，第ｋ个人把礼物给第１个人．求满足这个条件的概率． 组合数学： 满足条件的一组ｋ个人称为一个ｋ环，注意：可能有多个ｋ环！先考虑至少形成一个ｋ环的情况：A(n,k) * (n-1)^(n-k) / (k * (n-1)^(n)) == A(n, k) / (k * (n-1)^k) ；然后在考虑至少形成m个环的情况． 设至少形成m个环的概率是：f(m) = A(n, km)/(k^mm!(n-1)^(km)) 所以只需要递推m = 1 &amp;hellip;. m = n/k 然后可以发现：f(m)/f(m-1) = A(n, km) / (A(n, k(m-1))*k*m(n-1)^k)，因此可以根据计算出的f(1)求出f(2), f(3)．．．． 根据容斥：ans = f(1) - f(2) + f(3) - f(4) + &amp;hellip;. ORZ lyl的代码：
#include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;list&amp;gt; using namespace std; #define INF 0x3f3f3f3f const double eps=1e-9; int main ( int argc, char *argv[] ) { double ans, t; int i, k, n, tot, j; #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>usaco Milking Cows</title>
      <link>http://liuxueyang.github.io/posts/usaco-milking-cows/</link>
      <pubDate>Sun, 14 Jul 2013 18:03:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/usaco-milking-cows/</guid>
      <description>题目链接：http://cerberus.delos.com:791/usacoprob2?a=bv3dg9ejwKm&amp;amp;S=milk2 这题目不是线段树，直接模拟
/* ID: zypz4571 LANG: C++ TASK: milk2 */ #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; struct Node { int s, t; }a[5002]; bool cmp(const Node &amp;amp;a, const Node &amp;amp;b) { return a.s &amp;lt; b.s; } int main(void) { freopen(&amp;quot;milk2.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); freopen(&amp;quot;milk2.out&amp;quot;, &amp;quot;w&amp;quot;, stdout); int n; scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); for (int i = 0; i &amp;lt; n; scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a[i].s, &amp;amp;a[i].t),++i); sort(a,a+n,cmp); int Maxmilk=a[0].t-a[0].s, Maxidle=0, now = a[0].t, milk=Maxmilk, idle=0; for (int i = 1; i &amp;lt; n; ++i) { if (now &amp;gt;= a[i].</description>
    </item>
    
    <item>
      <title>usaco Section1.1 Broken Necklace</title>
      <link>http://liuxueyang.github.io/posts/usaco-section1.1-broken-necklace/</link>
      <pubDate>Sun, 14 Jul 2013 11:24:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/usaco-section1.1-broken-necklace/</guid>
      <description>题目链接：http://cerberus.delos.com:790/usacoprob2?a=75WI6aQtaO2&amp;amp;S=beads 1Y这道题目没什么，就是情况多一点，麻烦一点=_=
/* ID: zypz4571 LANG: C++ TASK: beads */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #define INF 0x3f3f3f3f #define mid int m=(l+r)/2 using namespace std; int main ( int argc, char *argv[] ) { freopen(&amp;quot;beads.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); freopen(&amp;quot;beads.out&amp;quot;, &amp;quot;w&amp;quot;, stdout); char a[360]; int n; bool b[360]; memset(b, false, sizeof(b)); scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);scanf(&amp;quot;%s&amp;quot;,a); int cnt = 0, i, j, k, Max = 0; for ( i= 0; i&amp;lt; n; ++i ) { cnt = 0; memset(b, false, sizeof(b)); j = i; if (a[j] == &#39;w&#39;) while (a[j] == &#39;w&#39; &amp;amp;&amp;amp; !</description>
    </item>
    
    <item>
      <title>vimrc配置文件_version1.0_&#43;pathogen, taglist, wordcomplete插件说明</title>
      <link>http://liuxueyang.github.io/posts/vimrc%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6_version1.0_&#43;pathogen-taglist-wordcomplete%E6%8F%92%E4%BB%B6%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Sat, 13 Jul 2013 06:43:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/vimrc%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6_version1.0_&#43;pathogen-taglist-wordcomplete%E6%8F%92%E4%BB%B6%E8%AF%B4%E6%98%8E/</guid>
      <description>为了表示对Ruchee的感谢，首先这是Ruchee的个人网站：http://www.ruchee.com/index.html，他的以前很多的代码都放到Git里面了，里面有链接。 看了整整一天，刚开始学习vim的时候就是用的Ruchee的vimrc脚本，现在终于可以自己写一点了，又认真看了一下Ruchee原来的脚本，虽然还有一些不太懂，但还是赶脚好腻害的样子。 然后自己又加了一点自己东西：——适用于mac, linux平台
&amp;quot;Copyright 2013 Xueyang Liu, all rights reserved. &amp;quot;www.cnblogs.com/liuxueyang/ &amp;quot;Hunan University &amp;quot; ********************SET******************** color lucius &amp;quot;color desert set nocompatible set guifont=Monaco:h16 set lines=30 columns=94 set nu numberwidth=5 set cindent set ai set tabstop=2 set shiftwidth=2 set mouse=a set autochdir se hlsearch incsearch se ruler set laststatus=2 set cmdheight=2 syntax on syntax enable filetype plugin indent on filetype indent on filetype plugin on &amp;quot;filetype on &amp;quot;set bg=dark &amp;quot; ********************MAP******************** let mapleader=&amp;quot;,&amp;quot; noremap &amp;lt;space&amp;gt; ve nnoremap &amp;lt;leader&amp;gt;ev :vsplit $MYVIMRC&amp;lt;cr&amp;gt; nnoremap &amp;lt;leader&amp;gt;sv :source $MYVIMRC&amp;lt;cr&amp;gt; nnoremap wt :WMToggle&amp;lt;cr&amp;gt; nnoremap &amp;lt;c-t&amp;gt; :NERDTree&amp;lt;cr&amp;gt; nnoremap &amp;lt;c-a&amp;gt; :Tlist&amp;lt;cr&amp;gt; &amp;quot;在某个单词上加上引号，括号 nnoremap &amp;lt;leader&amp;gt;&amp;quot; viw&amp;lt;esc&amp;gt;a&amp;quot;&amp;lt;esc&amp;gt;hbi&amp;quot;&amp;lt;esc&amp;gt;lel nnoremap &amp;lt;leader&amp;gt;&#39; viw&amp;lt;esc&amp;gt;a&#39;&amp;lt;esc&amp;gt;hbi&#39;&amp;lt;esc&amp;gt;lel nnoremap &amp;lt;leader&amp;gt;&amp;lt; viw&amp;lt;esc&amp;gt;a&amp;gt;&amp;lt;esc&amp;gt;&#39;&amp;lt;i&amp;lt;&amp;lt;esc&amp;gt;lw &amp;quot;~~~~~~~~~~~~~~~大风歌~~~~~~~~~~~~~~~ vnoremap \ U inoremap &amp;lt;c-d&amp;gt; &amp;lt;esc&amp;gt;ddi inoremap &amp;lt;c-u&amp;gt; &amp;lt;esc&amp;gt;veU inoremap jk &amp;lt;esc&amp;gt; inoremap &amp;lt;esc&amp;gt; &amp;lt;nop&amp;gt; &amp;quot;括号,引号自动补全 inoremap ( ()&amp;lt;esc&amp;gt;i inoremap ) &amp;lt;c-r&amp;gt;=ClosePair(&#39;)&#39;)&amp;lt;cr&amp;gt; inoremap { {}&amp;lt;esc&amp;gt;i inoremap } &amp;lt;c-r&amp;gt;=ClosePair(&#39;}&#39;)&amp;lt;cr&amp;gt; inoremap [ []&amp;lt;esc&amp;gt;i inoremap ] &amp;lt;c-r&amp;gt;=ClosePair(&#39;]&#39;)&amp;lt;cr&amp;gt; inoremap &amp;quot; &amp;quot;&amp;quot;&amp;lt;esc&amp;gt;i inoremap &#39; &#39;&#39;&amp;lt;esc&amp;gt;i onoremap p i( onoremap b /return&amp;lt;cr&amp;gt; &amp;quot; ********************OTHER******************** iabbrev @@ www.</description>
    </item>
    
    <item>
      <title>高斯消元</title>
      <link>http://liuxueyang.github.io/posts/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/</link>
      <pubDate>Thu, 11 Jul 2013 22:21:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/</guid>
      <description>输入线性方程组的维数，然后随即生成一定有解的线性方程组的增广矩阵，求出解，然后输出时间和方程组的解，以及和标准解的误差（其实就是和标准解的方差）。 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;ctime&amp;gt; using namespace std; const double eps=1e-9; const int MAX=20000; double ans[MAX]; int n; double **inputdata; double *result; /* 输出标准解 */ void printresult() { for(int i=0;i&amp;lt;n;i++) printf(&amp;quot;%.4lf &amp;quot;,result[i]); printf(&amp;quot;\n&amp;quot;); } /* 打印出生成的的增广矩阵 */ void printb() { for(int i=0;i&amp;lt;n;i++) printf(&amp;quot;%.4lf &amp;quot;,inputdata[i][n]); printf(&amp;quot;\n&amp;quot;); } /* 随机生成增广矩阵 */ void pro_inputdata() { int i,j,k; double res=0; printf(&amp;quot;please input the number of the element:\n&amp;quot;); scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); srand(time(0)); result=(double*)malloc(n*sizeof(double)); inputdata=(double**)malloc(n*sizeof(double)); for(i=0;i&amp;lt;n;i++) result[i]=(double)(rand()%10000)/1000.</description>
    </item>
    
    <item>
      <title>tyvj1022 - 进制转换 ——进制为负数</title>
      <link>http://liuxueyang.github.io/posts/tyvj1022---%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-%E8%BF%9B%E5%88%B6%E4%B8%BA%E8%B4%9F%E6%95%B0/</link>
      <pubDate>Mon, 08 Jul 2013 23:33:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/tyvj1022---%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-%E8%BF%9B%E5%88%B6%E4%B8%BA%E8%B4%9F%E6%95%B0/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1022
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cmath&amp;gt; long long int n, k, r; int a[100]; int main(void) { scanf(&amp;quot;%lld&amp;quot;,&amp;amp;n); int j=0; if(!n){printf(&amp;quot;0\n&amp;quot;);return 0;} while(n) {k=n/(-2); r=n-(-2)*k; if(r==-1) n=k+1,r=1; else n=k; a[j++]=r; } for(int k=j-1;k&amp;gt;=0;--k)printf(&amp;quot;%d&amp;quot;,a[k]);printf(&amp;quot;\n&amp;quot;); return 0; }  =_=</description>
    </item>
    
    <item>
      <title>tyvj1023 - 奶牛的锻炼 ——DP</title>
      <link>http://liuxueyang.github.io/posts/tyvj1023---%E5%A5%B6%E7%89%9B%E7%9A%84%E9%94%BB%E7%82%BC-dp/</link>
      <pubDate>Mon, 08 Jul 2013 23:31:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/tyvj1023---%E5%A5%B6%E7%89%9B%E7%9A%84%E9%94%BB%E7%82%BC-dp/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1023
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; int a[2002],f[2002][502]; int main(void) { //freopen(&amp;quot;in1.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin); int n, m; scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m); for(int i=1;i&amp;lt;=n;scanf(&amp;quot;%d&amp;quot;,a+i++)); f[0][0]=0,f[1][1]=a[1]; for(int i=1;i&amp;lt;=n;++i) for(int j=0;j&amp;lt;=m;++j) { if(!j) for(int k=1;k&amp;lt;=i;++k) f[i][0]=max(max(f[i-1][0],f[i-k][k]),f[i][0]); else f[i][j]=f[i-1][j-1]+a[i]; //printf(&amp;quot;%d &amp;quot;,f[i][j]); } printf(&amp;quot;\n%d\n&amp;quot;,f[n][0]); return 0; }  =_=</description>
    </item>
    
    <item>
      <title>tyvj1018 - 阶乘统计 ——暴力</title>
      <link>http://liuxueyang.github.io/posts/tyvj1018---%E9%98%B6%E4%B9%98%E7%BB%9F%E8%AE%A1-%E6%9A%B4%E5%8A%9B/</link>
      <pubDate>Sun, 07 Jul 2013 23:46:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/tyvj1018---%E9%98%B6%E4%B9%98%E7%BB%9F%E8%AE%A1-%E6%9A%B4%E5%8A%9B/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1018 范围只有20，在long long Int范围内。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; int main(void) { freopen(&amp;quot;in1.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); int n, k, h, a[10]; long long int s=1; scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;k); h=k; for(int i=1;i&amp;lt;=n;++i)s*=i; while (s%10==0) s/=10; while (k--) if(s) a[k]=s%10,s/=10; else break; for (int i=k+1;i&amp;lt;=h-1;++i)printf(&amp;quot;%d&amp;quot;,a[i]);printf(&amp;quot;\n&amp;quot;); return 0; }  =_=</description>
    </item>
    
    <item>
      <title>tyvj1017 - 冗余关系 ——并查集</title>
      <link>http://liuxueyang.github.io/posts/tyvj1017---%E5%86%97%E4%BD%99%E5%85%B3%E7%B3%BB-%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Sun, 07 Jul 2013 23:22:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/tyvj1017---%E5%86%97%E4%BD%99%E5%85%B3%E7%B3%BB-%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1017 并查集
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; int parent[1001],n,m; void init() {for(int i=1;i&amp;lt;=m;++i)parent[i]=-1; } int Find(int x) {int s; for(s=x;parent[s]&amp;gt;=0;s=parent[s]);while (s!=x) {int tmp=parent[x];parent[x]=s;x=tmp; }return s; } void Union(int R1,int R2) { int r1=Find(R1),r2=Find(R2),tmp=parent[r1]+parent[r2]; if (parent[r1]&amp;lt;parent[r2]) parent[r2]=r1,parent[r1]=tmp; else parent[r1]=r2,parent[r2]=tmp; } int main(void) { freopen(&amp;quot;in1.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin); int cnt=0;scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m); init(); while (n--) { int a,b; scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;a,&amp;amp;b); if(Find(a)==Find(b)) cnt++; else Union(a,b); } printf(&amp;quot;%d\n&amp;quot;,cnt); return 0; }  =_=</description>
    </item>
    
    <item>
      <title>tyvj1015 - 公路乘车  ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/tyvj1015---%E5%85%AC%E8%B7%AF%E4%B9%98%E8%BD%A6--%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Sun, 07 Jul 2013 21:14:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/tyvj1015---%E5%85%AC%E8%B7%AF%E4%B9%98%E8%BD%A6--%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1015 完全背包
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int c[11],f[101]; int main(void) { freopen(&amp;quot;in1.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin); int n,i,j;for(i=1;i&amp;lt;=10;scanf(&amp;quot;%d&amp;quot;,c+i++)) ;scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); for(i=1;i&amp;lt;=n;f[i++]=100000) ; for(i=1;i&amp;lt;=10;++i)for(j=i;j&amp;lt;=n;++j)f[j]=min(f[j],f[j-i]+c[i]); printf(&amp;quot;%d\n&amp;quot;,f[n]); return 0; }  0x3f3f3f3f可以memset-_-#</description>
    </item>
    
    <item>
      <title>6号赛车的故事  ——韩寒</title>
      <link>http://liuxueyang.github.io/posts/6%E5%8F%B7%E8%B5%9B%E8%BD%A6%E7%9A%84%E6%95%85%E4%BA%8B--%E9%9F%A9%E5%AF%92/</link>
      <pubDate>Sun, 07 Jul 2013 20:21:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/6%E5%8F%B7%E8%B5%9B%E8%BD%A6%E7%9A%84%E6%95%85%E4%BA%8B--%E9%9F%A9%E5%AF%92/</guid>
      <description>转自韩寒腾讯微博</description>
    </item>
    
    <item>
      <title>时间怎样地行走    ——迟子建</title>
      <link>http://liuxueyang.github.io/posts/%E6%97%B6%E9%97%B4%E6%80%8E%E6%A0%B7%E5%9C%B0%E8%A1%8C%E8%B5%B0----%E8%BF%9F%E5%AD%90%E5%BB%BA/</link>
      <pubDate>Sun, 07 Jul 2013 20:04:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E6%97%B6%E9%97%B4%E6%80%8E%E6%A0%B7%E5%9C%B0%E8%A1%8C%E8%B5%B0----%E8%BF%9F%E5%AD%90%E5%BB%BA/</guid>
      <description>时间怎样地行走 迟子建 墙上的挂钟，曾是我童年最爱着的一道风景。我对它有一种说不出的崇拜因为它掌管着时间，我们的作息似乎都受着它的支配。到了指定的时间，我们得起床上学，得做课间操，得被父母吆喝着去睡觉。虽然说有的时候我们还没睡够不想起床，在户外的月光下还没有戏耍够不想回屋睡觉，都必须因为时间的关系而听从父母的吩咐。他们理直气壮呵斥我们的话与挂钟息息相关：“都几点了，还不起床！”要么就是：“都几点了，还在外面疯玩，快睡觉去！”这时候，我觉得挂钟就是一个拿着烟袋磕着我们脑门的狠心的老头，又凶又倔，真想把他给掀翻在地，让它永远不行走。在我的想象中，它就是一个看不见形影的家长，严厉而又古板。但有时候它也是温情的，在除夕夜里，它的每一声脚步都给我们带来快乐，我们可以在子时钟声敲响后得到梦寐以求的压岁钱，想着用这钱可以买糖果来甜甜自己的嘴，真想在雪地上畅快地打几个滚。 我那时天真地以为时间是被一双神秘的大手放在挂钟里的。它每时每刻地行走着，走得不慌不忙，气定神凝，不会因为贪恋窗外鸟语花香的美景而放慢脚步，也不会因为北风肆虐大雪纷飞而加快脚步。它的脚，是世界上最能禁得起诱惑的脚，从来都是循着固定的轨迹行走。我喜欢听它前行的声音总是一个节，好像一首温馨的摇篮曲。时间在挂钟里，与我们一同经历着风霜雨雪、潮起潮落。 我上初中以后，手表就比较普及了。我看见时间躲在一个小小的圆盘里，在手腕上跳舞。它跳得静悄悄的，不像墙上的挂钟那么清脆悦耳，“滴答——滴答——”的声音不绝于耳。手表里的时间给我一种鬼鬼崇崇的感觉，少了几分气势和威严，所以明明到了上课时间，我还会磨蹭一两分钟再进教室，手表里的时间也就因此显得有些落寞。 后来，生活变得丰富多彩了，时间栖身的地方就多了。项链坠可以隐藏着时间，台历上镶嵌着时间，玩具里放置着时间，至于电脑和手提电话，只要我们一打开它们，率先映入眼帘的就有时间。时间如繁星一样到处闪烁着，它越来越多，也就越来越显得匆匆了。 十几年前的一天，我在北京第一次发现了时间的痕迹。我在梳头时发现一根白发，它在清晨的曙光中像一道明的雪一样刺痛了我的眼睛。我知道时间其实一直在我的头发里行走，只不过它这一次露出了痕迹而已。我还看见，时间在母亲的口腔里行走，她的牙齿脱落得越来越多。我明白时间让花朵绽放的时候，也会让人的眼角绽放出花朵——鱼尾纹。 时间让一棵青春的小树越来越枝繁叶茂，让车轮的辐条越来越沾染上锈链，让一座老屋逐渐驼了背。时间好似变戏法的魔术师，突然让一个活生生的人瞬间消失在他们辛勤劳作过的土地上，我的祖父、外祖父和父亲，就让时间给无声地接走了，再也看不到他们的脚印，只能在清冷的梦中见到他们依稀的身影。他们不在了，可时间还在，它总是持之以恒激情澎湃地行走着——在我们看不到的角落，在我们不经意走过的地方，在日月星辰中，在梦中。 我终于明白挂钟上的时间和手表里的时间只是时间的一个表象而已，它存在于更丰富的日常生活中。只要我们在行走，时间就会行走。我们和时间如同一对伴侣，相依相偎着，不朽的它会在我们不知不觉间，引领着我们一直走到地老天荒。 </description>
    </item>
    
    <item>
      <title>泥泞 ——迟子建</title>
      <link>http://liuxueyang.github.io/posts/%E6%B3%A5%E6%B3%9E-%E8%BF%9F%E5%AD%90%E5%BB%BA/</link>
      <pubDate>Sun, 07 Jul 2013 19:53:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E6%B3%A5%E6%B3%9E-%E8%BF%9F%E5%AD%90%E5%BB%BA/</guid>
      <description>泥泞 迟子建　北方的初春是肮脏的，这肮脏当然缘自于我们曾经热烈赞美过的纯洁无瑕的雪。在北方漫长的冬季里，寒冷催生了一场又一场的雪，它们自天庭伸开美丽的触角，纤柔地飘落到大地上，使整个北方沉沦于一个冰清玉洁的世界中。如果你在飞雪中行进在街头，看着枝条濡着雪绒的树，看着教堂屋顶的白雪，看着银色的无限延伸着的道路，你的内心便会洋溢着一股激情：为着那无与伦比的壮丽或者是苍凉。然而春风来了。春风使积雪融化，它们在消融的过程中容颜苍老、憔悴，仿佛一个即将撒手人寰的老妇人：雪在这时候将它的两重性毫无保留地暴露出来：它的美丽依附于寒冷，因而它是一种静止的美、脆弱的美；当寒冷已经成为西天的落霞，和风丽日映照它们时，它的丑陋才无奈地呈现。纯美之极的事物是没有的，因而我还是热爱雪。爱它的美丽、单纯，也爱它的脆弱和被迫的消失。当然，更热爱它们消融时给这大地制造的空前的泥泞。小巷里泥水遍布；排水沟因为融雪后污水的加入而增大流量，哗哗地响；燕子在潮湿的空气里衔着湿泥在檐下筑巢；鸡、鸭、鹅、狗将它们游荡小巷的爪印带回主人家的小院，使院子里印满无数爪形的泥印章，宛如月下松树庞大的投影；老人在走路时不小心失了手杖，那手杖被拾起时就成了泥手杖；孩子在小巷奔跑嬉闹时不慎将嘴里含着的糖掉到泥水中了，他便失神地望着那泥水呜呜地哭，而窥视到这一幕的孩子的母亲却快意地笑起来…… 这是我童年时常常经历的情景，它的背景是北方的一个小山村，时间当然是泥泞不堪的早春时光了。　我热爱这种浑然天成的泥泞。泥泞常常使我联想到俄罗斯这个伟大的民族，罗蒙诺索夫、柴可夫斯基、陀思妥耶夫斯基、托尔斯泰、蒲宁、普希金就是踏着泥泞一步步朝我们走来的。俄罗斯的艺术洋溢着一股高贵、博大、阴郁、不屈不挠的精神气息，不能不说与这种春日的泥泞有关。泥泞诞生了跋涉者，它给忍辱负重者以光明和力量，给苦难者以和平和勇气？一个伟大的民族需要泥泞的磨砺和锻炼，它会使人的脊梁永远不弯，使人在艰难的跋涉中懂得土地的可爱、博大和不可丧失，懂得祖国之于人的真正含义：当我们爱脚下的泥泞时，说明我们已经拥抱了一种精神。　如今在北方的城市所感受到的泥泞已经不像童年时那么深重了：但是在融雪的时节，我走在农贸市场的土路上，仍然能遭遇那种久违的泥泞。泥泞中的废纸、草屑、烂菜叶、鱼的内脏等等杂物若隐若现着，一股腐烂的气味扑入鼻息。这感觉当然比不得在永远有绿地环绕的西子湖畔撑一把伞在烟雨淳淳中耽于幻想来得惬意，但它仍然能使我陷入另一种怀想，想起木轮车沉重地辗过它时所溅起的泥珠，想起北方的人民跋涉其中的艰难的背影，想起我们曾有过的苦难和屈辱，我为双脚仍然能触摸到它而感到欣慰。　我们不会永远回头重温历史，我们也不会刻意制造一种泥泞让它出现在未来的道路上，但是，当我们在被细雨洗刷过的青石板路上走倦了，当我们面对着无边的落叶茫然不知所措时，当我们的笔面对白纸不再有激情而苍白无力时，我们是否渴望着在泥泞中跋涉一回呢？为此，我们真应该感谢雪，它诞生了寂静、单纯、一览无余的美，也诞生了肮脏、使人警醒给人力量的泥泞。因此它是举世无双的。 http://sanwenzx.com/jingdian/mingjia/2009/9283.html 这是高中语文阅读理解的一篇文章，当初就觉得很好，现在看还是很有感觉啊。</description>
    </item>
    
    <item>
      <title>tyvj1014 - 乘法游戏  ——记忆化搜索DP</title>
      <link>http://liuxueyang.github.io/posts/tyvj1014---%E4%B9%98%E6%B3%95%E6%B8%B8%E6%88%8F--%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2dp/</link>
      <pubDate>Sun, 07 Jul 2013 17:28:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/tyvj1014---%E4%B9%98%E6%B3%95%E6%B8%B8%E6%88%8F--%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2dp/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1014 f[i][j]表示区间［i，j］所得到的最小值。 不断地划分区间，把结果保存起来。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; long long int f[101][101];int a[101], i, j, n, INF=0x7f7f7f7f; void dfs(int l, int r) { if(r-l&amp;lt;=1) {f[l][r]=0; return;} if(f[l][r]!=INF) return; for(int i=l+1;i&amp;lt;=r-1;++i) dfs(1,i),dfs(i,r),f[l][r]=min(f[l][r],f[l][i]+f[i][r]+a[i]*a[l]*a[r]); } int main(void) { freopen(&amp;quot;in1.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin); scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);for(i=1;i&amp;lt;=n;scanf(&amp;quot;%d&amp;quot;,a+i++)) ;for(i=0;i&amp;lt;=n;++i)for(j=0;j&amp;lt;=n;++j)f[i][j]=INF;dfs(1,n);printf(&amp;quot;%lld\n&amp;quot;,f[1][n]); return 0; }  =_=</description>
    </item>
    
    <item>
      <title>tyvj1013 - 找啊找啊找GF  ——二维背包变种</title>
      <link>http://liuxueyang.github.io/posts/tyvj1013---%E6%89%BE%E5%95%8A%E6%89%BE%E5%95%8A%E6%89%BEgf--%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85%E5%8F%98%E7%A7%8D/</link>
      <pubDate>Sun, 07 Jul 2013 16:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/tyvj1013---%E6%89%BE%E5%95%8A%E6%89%BE%E5%95%8A%E6%89%BEgf--%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85%E5%8F%98%E7%A7%8D/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1013 好吧，这题没节操=_= 状态f[u,v,i]表示：消费u的人民币和v的人品同时泡到i个mm所需要的最少时间。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; int f[101][101][101], r[101], rp[101], t[101], rmb, RP, n, INF=0x7f7f7f7f; int main(void) { freopen(&amp;quot;in1.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin); scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);for(int i=1;i&amp;lt;=n;scanf(&amp;quot;%d%d%d&amp;quot;,r+i,rp+i,t+i),++i) ;scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;rmb,&amp;amp;RP); for(int i=0;i&amp;lt;=rmb;++i)for(int j=0;j&amp;lt;=RP;++j)for(int k=1;k&amp;lt;=n;++k)f[i][j][k]=INF; for(int i=1;i&amp;lt;=n;++i)for(int u=rmb;u&amp;gt;=r[i];--u)for(int v=RP;v&amp;gt;=rp[i];--v)for(int j=1;j&amp;lt;=i;++j) if(f[u][v][j-1]!=INF) f[u][v][j]=min(f[u][v][j],f[u-r[i]][v-rp[i]][j-1]+t[i]); for(int i=n;i&amp;gt;=0;--i)if(f[rmb][RP][i]!=INF){printf(&amp;quot;%d\n&amp;quot;,f[rmb][RP][i]);break;} return 0; }  为了使泡到的mm尽量多，所以要从后往前找合法的解，只要找到就输出，然后break; =_=</description>
    </item>
    
    <item>
      <title>tyvj1012 P1012 - 火柴棒等式  ——暴力枚举</title>
      <link>http://liuxueyang.github.io/posts/tyvj1012-p1012---%E7%81%AB%E6%9F%B4%E6%A3%92%E7%AD%89%E5%BC%8F--%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/</link>
      <pubDate>Sun, 07 Jul 2013 11:37:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/tyvj1012-p1012---%E7%81%AB%E6%9F%B4%E6%A3%92%E7%AD%89%E5%BC%8F--%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1012 可以发现：最大的数字绝对不超过999，只要枚举出0～999所有数字需要的火柴数，然后再枚举C和A，得到B＝C-A，看看三个数字的火柴数目是否等于n就可以了。
#include &amp;lt;cstdio&amp;gt; int a[10] = {6,2,5,5,4,5,6,3,7,6},b[1000],n,cnt; int main(void) { freopen(&amp;quot;in1.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin); cnt=0; scanf(&amp;quot;%d&amp;quot;,&amp;amp;n),n-=4;for(int i=0;i&amp;lt;10;++i)b[i]=a[i]; for(int i=10;i&amp;lt;=999;++i) b[i]=b[i/10]+b[i%10]; for(int i=0;i&amp;lt;=999;++i)if(b[i]&amp;lt;n) for(int j=0;j&amp;lt;=i;++j)if(b[i]+b[j]+b[i-j]==n)cnt++; printf(&amp;quot;%d\n&amp;quot;,cnt); return 0; }  还有一个比较快的思路，因为n最大是24，所以可以用上面的程序，把这24个数字都算出来，就是一个大小为24个数组，直接输出就可以。 写给自己看的。。=_=</description>
    </item>
    
    <item>
      <title>tyvj1011 - 传纸条  ——DP</title>
      <link>http://liuxueyang.github.io/posts/tyvj1011---%E4%BC%A0%E7%BA%B8%E6%9D%A1--dp/</link>
      <pubDate>Sun, 07 Jul 2013 11:32:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/tyvj1011---%E4%BC%A0%E7%BA%B8%E6%9D%A1--dp/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1011 状态转移方程： f[k,x1,x2] = max(f[k-1,x1,x2],f[k-1,x1-1,x2],f[k-1,x1-1,x2-1],f[k-1,x1,x2-1]) + a[y1,x1] + a[y2,x2]; f[k,x1,x2]表示，第K步的时候，一条路的横坐标是x1,另一条路的横坐标是x2的时候所得到的最优解。另外，还要考虑一下，当x1==x2的时候的情况，这个时候，只能允许一条路走到那个位置。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int a[51][51],f[100][51][51]; int main(void) { freopen(&amp;quot;in1.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin); int N,M; scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;M, &amp;amp;N);for(int i=1;i&amp;lt;=M;++i)for(int j=1;j&amp;lt;=N;++j)scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i][j]); for(int k=1;k&amp;lt;=M+N-3;++k)for(int x1=1;x1&amp;lt;=min(N,k+1);++x1)for(int x2=1;x2&amp;lt;=min(N,k+1);++x2) { f[k][x1][x2]=max(max(f[k-1][x1][x2],f[k-1][x1-1][x2]),max(f[k-1][x1][x2-1],f[k-1][x1-1][x2-1])); if (x1==x2)f[k][x1][x2]+=a[k-x1+2][x1]; else f[k][x1][x2]+=(a[k-x1+2][x1]+a[k-x2+2][x2]); } printf(&amp;quot;%d\n&amp;quot;,f[M+N-3][N][N-1]); return 0; }  昨天看了一篇文章，才发现，其实，题解是写给自己看的-_-#</description>
    </item>
    
    <item>
      <title>tyvj1004 滑雪</title>
      <link>http://liuxueyang.github.io/posts/tyvj1004-%E6%BB%91%E9%9B%AA/</link>
      <pubDate>Sat, 06 Jul 2013 15:06:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/tyvj1004-%E6%BB%91%E9%9B%AA/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1004 记忆化搜索
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int m[102][102], dp[102][102], r, C; int dfs(int x, int y) { if (dp[x][y] &amp;gt; 0) return dp[x][y]; dp[x][y]=1; int a,b,c,d; a=b=c=d=0; if (x-1&amp;gt;=1 &amp;amp;&amp;amp; m[x-1][y] &amp;lt; m[x][y]) a = dfs(x-1,y); if (x+1&amp;lt;=r &amp;amp;&amp;amp; m[x+1][y] &amp;lt; m[x][y]) b = dfs(x+1,y); if (y-1&amp;gt;=1 &amp;amp;&amp;amp; m[x][y-1] &amp;lt; m[x][y]) c = dfs(x,y-1); if (y+1&amp;lt;=C &amp;amp;&amp;amp; m[x][y+1] &amp;lt; m[x][y]) d = dfs(x,y+1); dp[x][y] = max(max(a,b),max(c,d))+1; return dp[x][y]; } int main(void) { int Max; freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>《一个人的村庄》 ——刘亮程</title>
      <link>http://liuxueyang.github.io/posts/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9D%91%E5%BA%84-%E5%88%98%E4%BA%AE%E7%A8%8B/</link>
      <pubDate>Thu, 04 Jul 2013 13:27:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9D%91%E5%BA%84-%E5%88%98%E4%BA%AE%E7%A8%8B/</guid>
      <description>一个人的村庄： 剩下的事情　他们都回去了，我一个留在野地上看守麦垛。得有一个月时间他们才能忙完村里的活，腾出手回来打麦子。野地离村子有大半天的路，也就是说，一个人不能在一天内往返一次野地。这是大概两天的路程，你硬要一天走完，说不定你走到什么地方，天突然黑了，剩下的路可就不好走了。谁都不想走到最后，剩下一截子黑路。是不是？　紧张的麦收结束了。同样的劳动，又在其他什么地方重新开始，这我能想得出。我知道村庄周围有几块地。他们给我留下够吃一个月的面和米，留下不够炒两顿菜的小半瓶清油。给我安排活儿的人，临走时又追加了一句：别老闲着望天，看有没有剩下的活儿主动干干。　第二天，我在麦茬地走了一圈，发现好多活儿没有干完，麦子没割完，麦捆没有拉完。可是麦收结束了，人都回去了。　在麦地南边，扔着一大捆麦子。显然是拉麦捆的人故意漏装的。地西头则整齐地长着半垅麦子。即使割完的麦垅，也在最后剩下那么一两镰，不好看地长在那里。似乎人干到最后已没有一丝耐心和力气。　我能想到这个剩下半拢麦子的人，肯定是最后一个离开地头的。在那个下午的斜阳里；没割倒的半拢麦子，一直望着扔下它们的那个人，走到麦地另一头，走进或蹲或站的一堆人里，再也认不出来。　麦地太大。从一头几乎望不到另一头。割麦的人一人把一城，不抬头地往前赶，一直割到天色渐晚，割到四周没有了镰声，抬起头，发现其他人早割完回去了，剩下他孤零零的一场。他有点急了，弯下腰猛割几镰，又茫然地停住，地里没一个人。干没干完都没人管了。没人知道他没干完，也没人知道他干完了。验收这件事的人回去了。他一下泄了气，瘫坐在麦茬上，楞了会儿神：球，不干了。　我或许能查出这个活儿没干完的人。　我已经知道他是谁。　但我不能把他喊回来，把剩下的麦子割完。这件事已经结束，更紧迫的劳动在别处开始。剩下的事情不再重要。　以后几天，我干着许多人干剩下的事情。一个人在空荡荡的麦地里转来转去。我想许多轰轰烈烈的大事之后，都会有一个收尾的人，他远远地跟在人们后头，干着他们自以为干完的事情。许多事情都一样，开始干的人很多，到了最后，便成了某一个人的。　远离村人　我每天的事：早晨起来望一眼麦垛。总共五大垛，一溜排开。整个白天可以不管它们。到了下午，天黑之前，再朝四野里望一望，看有无可疑的东西朝这边移动。　这片大野隐藏着许多东西。一个人，五垛麦子，也是其中的隐匿者，谁也不愿让谁发现。即使是树，也都蹲着长，躯干一曲再曲，枝桠匐着地伸展；我从没在荒野上看见一棵像杨树一样高扬着头、招摇而长的植物。有一种东西压着万物的头，也压抑着我。　有几个下午我注意到西边的荒野中有一个黑影。在不断地变大。我看不清那是什么东西，它孤独地蹲在那里；让我几个晚上没睡好觉。若有个东西在你身旁越变越小最后消失了，你或许一点不会在意。有个东西在你身边突然大起来，变得巨大无比，你便会感到惊慌和恐惧。　早晨天刚亮我便爬起来，看见那个黑影又长大了一些。再看麦垛，似乎一夜间矮了许多。我有点担心，扛着锨小心翼翼地走过去，穿过麦地走了一阵，才看清楚，是一棵树。一棵枯死的老树突然长出许多枝条和叶子。我围着树转了一圈。许多叶子是昨晚上才长出来的，我能感觉到它的枝枝叶叶还在长，而且会长得更加蓬蓬勃勃。我想这棵老树的某一条根，一定扎到了土地深处的一个旺水层。　能让一棵树长得粗壮兴旺的地方，也一定会让一个人活得像模像样。往回走时，我暗暗记住了这个地方。那时，我刚刚开始模糊地意识到，我已经放任自己像植物一样去随意生长。我的胳膊太细，腿也不粗，胆子也不大，需要长的东西很多。多少年来我似乎忘记了生长。　随着剩下的活儿一点一点地干完，莫名的空虚感开始笼罩着草棚，活儿干完了，镰刀和铁锨扔到一边。孤单成了一件事情。寂寞和恐惧成了一件大事情。　我第一次感到自己是一个，而它们&amp;ndash;成群的、连片的、成堆的对着我。我的群落在几十里外的太平渠村里。此时此刻，我的村民帮不了我，朋友和亲人帮不了我。　我的寂寞和恐惧从村里带来的。　每个人最后都是独自面对剩下的寂寞和恐惧，无论在人群中还是在荒野上。那是他一个人的。　就像一粒虫、一棵草在它浩荡的群落中孤单地面对自己的那份欢乐和痛苦。其他的虫、草不知道。　一棵树枯死了，提前进入了比生更漫长的无花无叶的枯木期。其他的树还活着，枝繁叶茂。阳光照在绿叶上，也照在一棵柏树上。我们看不见一棵柏树在阳光中生长着什么。它埋在地深处的根在向什么地方延伸。死亡以后的事情，我们不知道。　一个人死了，我们把它搁过去&amp;ndash;埋掉。　我们在坟墓旁边往下活。活着活着，就会觉得不对劲：这条路是谁留下的。那件事谁做过了。这句话谁说过。那个女人谁爱过&amp;hellip;&amp;hellip;　我在村人中生活了几十年，什么事都经过了，再呆下去，也不会有啥新鲜事。剩下的几十年，我想在花草中度过，在虫鸟水土中度过。我不知道这样行不行，或许村里人会把我喊回去，让我娶个女人生养孩子。让我翻地，种下一年的麦子。他们不会让我闲下来，他们必做的事情，也必然是我的事情。他们不会知道，在我心中，这些事情早就结束了。　如果我还有什么剩下要做的事情，那就是一棵草的事情，一粒虫的事情，一片云的事情。　我在野地上还有十几天时间，也可能更长。我正好远离村人，做点自己的事情。　风把人刮歪　刮了一夜大风，我在半夜被风喊醒。风在草棚和麦垛上发出恐怖的怪叫，类似女人不舒畅的哭喊。这些突兀地出现在荒野中的草棚麦垛，绊住了风的腿，扯住了风的衣裳，缠住了风的头发，让它追不上前面的风。她撕扯，哭喊。喊得满天地都是风声。　我把头伸出草棚，黑暗中隐约有几件东西在地上滚动，滚得极快，一晃就不见了。是风把麦垛刮走了。我不清楚刮走了多少，也只能看着它刮走。我比一捆麦大不了多少，一出去可能就找不见自己了。风朝着村子那边刮。如果风不在中途拐弯，一捆一捆的麦子会在风中跑回村子。明早村人醒来，看见了一捆捆麦子躲在墙根，像回来的家畜一样。　每年都有几场大风经过村庄。风把人刮歪。又把歪长的树刮直。风从不同方向来，人和草木往哪边斜不由自主。能做到的只是在每一场风后，把自己扶直。一棵树在各种各样的风中变得扭曲，古里古怪。你几乎可以看出它沧桑躯干上的哪个弯是南风吹的，哪个拐是北风刮的。但它最终高大粗壮地立在土地上，无论南风北风都无力动摇它。　我们村边就有几棵这样的大树，村里也有几个这样的人。我太年轻，根扎得不深，躯干也不结实。担心自己会被一场大风刮跑，像一棵草一片树叶，随风千里，飘落到一个陌生地方。也不管你喜不喜欢，愿不愿意，风把你一扔就不见了。你没地方去找风的麻烦，刮风的时候满世界都是风，风一停就只剩下空气。天空若无其事，大地也像什么都没发生。只有你的命运被改变了，莫名其妙地落在另一个地方。你只好等另一场相反的风把自己刮回去。可能一等多年，再没有一场能刮起你的大风。你在等待飞翔的时间里不情愿地长大，变得沉重无比。　去年，我在一场风中看见很久以前从我们家榆树上刮走的一片树叶，又从远处刮回来。它在空中翻了几个跟头，摇摇晃晃地落在窗台上。那场风刚好在我们村里停住，像是猛然刹了车。许多东西从天上往下掉，有纸片&amp;ndash;写字的和没写字的纸片、布条、头发和毛，更多的是树叶。我在纷纷下落的东西中认出了我们家榆树上的一片树叶。我赶忙抓住它，平放在手中。这片叶子的边缘已有几处损伤，原先背阴的一面被晒得有些发白&amp;ndash;它在什么地方经受了什么样的阳光？另一面粘着些褐黄的黏土。我不知道它被刮了多远又被另一场风刮回来，一路上经过了多少地方，这些地方都是我从没去过的。它飘回来了，这是极少数的一片叶子。　风是空气在跑。一场风一过，一个地方原有的空气便跑光了，有些气味再闻不到，有些东西再看不到&amp;ndash;昨天弥漫村巷的谁家炒菜的肉香，昨晚被一个人独享的女人的体香，下午晾在树上忘收的一块布，早上放在窗台上写着几句话的一张纸。风把一个村庄酝酿许久的，被一村人吸进呼出弄出特殊味道的一窝子空气，整个地搬运到百里千里外的另一个地方。　每一场风后，都会有几朵我们不认识的云，停留在村庄上头，模样怪怪的，颜色生生的，弄不清啥意思。短期内如果没风，这几云就会?动不动赖在头顶，不管我们喜不喜欢，我们看顺眼的云，在风中跑得一朵都找不见。　风一过，人忙起来，很少有空看天。偶尔看几眼，也能看顺眼，把它认成我们村的云，天热了盼它遮遮阳，地旱了盼它下点雨。地果真就旱了，一两个月没水，庄稼一片片蔫了。头顶的几朵云，在村人苦苦的期盼中果真有了些雨意，颜色由雪白变铅灰再变墨黑。眼看要降雨了，突然一阵南风，这些饱含雨水的云跃跌撞撞，飞速地离开了村庄，在荒无人烟的南梁上，哗啦啦下了一夜雨。　我们望着头顶腾空的晴朗天空，骂着那些养不乖的野云。第二天全村人开会，做了一个严厉的决定：以后不管南来北往的云，一律不让它在我们村庄上头停，让云远远滚蛋。我们不再指望天上的水，我们要挖一条穿越戈壁的长渠。　那一年村长是胡木，我太年轻，整日缩着头，等待机会来临。　我在一场南风中闻见浓浓的鱼腥味。遥想某个海边渔村，一张大网罩着海，所有的鱼被网上岸，堆满沙滩。海风吹走鱼腥，鱼被留下来。　另一场风中我闻见一群女人成熟的气息，想到一个又一个的鲜美女子，在离我很远处长大成熟，然后老去。我闲吊的家什朝着她们，举起放下，鞭长莫及。　各种各样的风经过了村庄。屋顶上的土，吹光几次，住在房子里的人也记不清楚。无论南墙北墙东墙西墙都被风吹旧，也都似乎为一户户的村人挡住了南来北往的风。有些人不见了，更多的人留下来。什么留住了他们？　什么留住了我？　什么留住了风中的麦垛？　如果所有粮食在风中跑光，所有的村人，会不会在风停之后远走他乡，留一座空荡荡的村庄。　早晨我看见被风刮跑的麦捆，在半里外，被几棵铃铛刺拦住。　这些一墩一墩，长在地边上的铃挡刺，多少次挡住我们的路，挂烂手和衣服，也曾多少次被我们愤怒的撅头连根挖除，堆在一起一火烧掉。可是第二年它们又出现在那里。　我们不清楚铃档刺长在大地上有啥用处。它浑身的小小尖刺，让企图吃它的嘴，折它的手和践它的蹄远离之后，就闲闲地端扎着，刺天空，刺云，刺空气和风。现在它抱住了我们的麦捆，没让它在风中跑远。我第一次对铃挡刺深怀感激。　也许我们周围的许多东西，都是我们生活的一部分，生命的一部分，关键时刻挽留住我们。一株草，一棵树，一片云，一只小虫。它替匆忙的我们在土中扎根，在空中驻足，在风中浅唱&amp;hellip;&amp;hellip;　任何一株草的死亡都是人的死亡。　任何一棵树的夭折都是人的夭折。　任何一粒虫的鸣叫也是人的鸣叫。　对一朵花微笑　我一回头，身后的草全开花了。一大片。好像谁说了一个笑话，把一滩草惹笑了。　我正躺在山坡上想事情。是否我想的事情&amp;ndash;一个人脑中的奇怪想法让草觉得好笑，在微风中笑得前仰后合。有的哈哈大笑，有的半掩芳唇，忍俊不禁。*近我身边的两朵，一朵面朝我，张开薄薄的粉红花瓣，似有吟吟笑声入耳；另一朵则扭头掩面，仍不能遮住笑颜。我禁不住也笑了起来。先是微笑，继而哈哈大笑。　这是我第一次在荒野中，一个人笑出声来。　还有一次，我在麦地南边的一片绿草中睡了一觉。我太喜欢这片绿草了，墨绿墨绿，和周围的枯黄野地形成鲜明对比。　我想大概是一个月前，浇灌麦地的人没看好水，或许他把水放进麦田后睡觉去了。水漫过田埂，顺这条干沟漫漶而下。枯萎多年的荒草终于等来一次生机。那种绿，是积攒了多少年的，一如我目光中的饥渴。我虽不能像一头牛一样扑过去，猛吃一顿，但我可以在绿草中睡一觉。和我喜爱的东西一起唾，做一个梦，也是满足。　一个在枯黄田野上劳忙半世的人，终于等来草木青青的一年。一小片。草木会不会等到我出人头地的一天？　这些简单地长几片叶、伸几条枝、开几瓣小花的草木，从没长高长大、没有茂盛过的草木，每年每年，从我少有笑容的脸和无精打采的行走中，看到的是否全是不景气？　我活得太严肃，呆板的脸似乎对生存已经麻木，忘了对一朵花微笑，为一片新叶欢欣和激动。这不容易开一次的花朵，难得长出的一片叶子，在荒野中，我的微笑可朗是对一个卑小生命的欢迎和鼓励。就像青青芳草让我看到一生中那些还未到来的美好前景。　以后我觉得，我成了荒野中的一个。真正进入一片荒野其实不容易，荒野旷敞着，这个巨大的门让你努力进入时不经意已经走出来，成为外面人。它的细部永远对你紧闭着。　走进一株草、一滴水、一粒小虫的路可能更远。弄懂一棵草，并不仅限于把草喂到嘴里嚼嚼，尝尝味道。挖一个坑，把自己栽进去，浇点水，直楞楞站上半天，感觉到的可能只是腿酸脚麻和腰疼，并不能断定草木长在土里也是这般情景。人没有草木那样深的根，无法知道土深处的事情。人埋在自己的事情里，埋得暗无天日。人把一件件事情干完，干好，人就渐渐出来了。　我从草木身上得到的只是一些人的道理，并不是草木的道理。我自以为弄懂了它们，其实我弄懂了自己。我不懂它们。　走向虫子　一只八条腿的小虫，在我的手指上往前爬，爬得极慢，走走停停，八只小爪踩上去痒痒的。停下的时候，就把针尖大的小头抬起往前望。然后再走。我看得可笑。它望见前面没路了吗？竟然还走。再走一小会儿，就是指甲盖，指甲盖很光滑，到了尽头，它若悬崖勒不住马，肯定一头栽下去。我正为这粒小虫的短视和盲目好笑，它已过了我的指甲盖，到了指尖，头一低，没掉下去，竟从指头底部慢慢悠悠向手心爬去了。　这下该我为自己的眼光羞愧了，我竞没看见指头底下还有路。走向手心的路。　人的自以为是使人只能走到人这一步。　虫能走到哪里？我除了知道小虫一辈子都走不了几百米，走不出这片草滩以外，我确实不知道虫走到了哪里。　一次我看见一只蜣螂滚着一颗比它大好几倍的粪蛋，滚到一个半坡上。蜣螂头抵着地，用两只后腿使劲往上滚，费了很大劲才滚动了一点点。而且，只要蜣螂稍一松劲，粪蛋有可能再滚下去。我看得着急，真想伸手帮它一把，却不知蜣螂把它弄到哪。朝四周看了一圈也没弄清哪是蜣螂的家，是左边那棵草底下，还是右边那几块土坷垃中间。假如弄明白的话，我一伸手就会把这个对蜣螂来说沉重无比的粪蛋轻松拿起来，放到它的家里。我不清楚蜣螂在滚这个粪蛋前，是否先看好了路，我看了半天，也没看出朝这个方向滚去有啥去处。上了这个小坡是一片平地，再过去是一个更大的坡，坡上都是草，除非从空中运，或者蜣螂先铲草开一条路，否则粪蛋根本无法过去。　或许我的想法天真，蜣螂根本不想把粪蛋滚到哪去。它只是做一个游戏，用后腿把粪蛋滚到坡顶上，然后它转过身，绕到另一边，用两只前爪猛一推，粪蛋骨碌碌滚了下去，它要看看能滚多远，以此来断定是后腿劲大还是前腿劲大。谁知道呢？反正我没搞清楚，还是少管闲事。我已经有过教训。　那次是一只蚂蚁，背着一条至少比它大二十倍的干虫，被一个土块挡住。蚂蚁先是自己爬上土块，用嘴咬住干虫往上拉，试了几下不行，又下来钻到干虫下面用头顶，竟然顶起来，摇摇晃晃，眼看顶上去了，却掉了下来，正好把蚂蚁碰了个仰面朝天。蚂蚁一骨碌爬起来，想都没想，又换了种姿势，像那只蜣螂那样头顶着地，用后腿往上举。结果还是一样。但它一刻不停，动作越来越快，也越来越没效果。　我猜想这只蚂蚁一定是急于把干虫搬回洞去。洞里有多少孤老寡小在等着这条虫呢。我要能帮帮它多好。或者，要是再有一只蚂蚁帮忙，不就好办多了吗？正好附近有一只闲转的蚂蚁，我把它抓住，放在那个土块上，我想让它站在上面往上拉，下面的蚂蚁正挤命往上顶呢，一拉一顶，不就上去了吗？　可是这只蚂蚁不愿帮忙，我一放下，它便跳下土块跑了。我又把它抓回来；这次是放在那只忙碌的蚂蚁的旁边，我想是我强迫它帮忙，它生气了。先让两只蚂蚁见见面，商量商量，那只或许会求这只帮忙，这只先说忙，没时间。那只说，不白帮，过后给你一条虫腿。这只说不行，给两条。一条半。那只还价。　我又想错了。那只忙碌的蚂蚁好像感到身后有动静，一回头看见这只，二话没说，扑上去就打。这只被打翻在地，爬起来仓皇而逃。也没看清咋打的，好像两只牵在一起，先是用口咬，接着那只腾出一只前爪，抡开向这只脸上扇去，这只便倒地了。　那只连口气都不喘，回过身又开始搬干虫。我真看急了，一伸手，连干虫带蚂蚁一起扔到土块那边。我想蚂蚁肯定会感激这个天降的帮忙。没想它生气了，一口咬住干虫，拼命使着劲，硬要把它再搬到土块那边去。　我又搞错了。也许蚂蚁只是想试试自己能不能把一条干虫搬过土块，我却认为它要搬回家去。真是的，一条干虫，我会搬它回家吗？　也许都不是。我这颗大脑袋，压根不知道蚂蚁那只小脑袋里的事情。　孤独的声音　有一种鸟，对人怀有很深的敌意。我不知道这种鸟叫什么。它们常站在牛背上捉虱子吃，在羊身上跳来跳去，一见人便远远飞开。　还爱欺负人，在人头上拉鸟屎。　它们成群盘飞在人头顶上，发出悦耳的叫声。人陶醉其中，冷不防，一泡鸟屎落在头上。人莫名其妙，抬头看天上，没等看清，又一泡鸟屎落在嘴上或鼻梁上。人生气了，捡一个土块往天上扔，鸟便一飞不见了。　还有一种鸟喜欢亲近人，对人说鸟语。　那天我扛着锨站在埂子上，一只鸟飞过来，落在我的锨把上，我扭头看着它，是只挺大的灰鸟。我一伸手就能抓住它。但我没伸手。灰鸟站稳后便对着我的耳朵说起鸟语，声音很急切，一句接一句，像在讲一件事；一种道理。我认真地听着，一动不动。灰鸟不停地叫了半个小时，最后声音沙哑地飞走了。　以后几天我又在别处看见这只鸟，依旧单单的一只。有时落在土块上，有时站在一个枯树枝上，不住地叫。还是给我说过的那些鸟语。只是声音更沙哑了。　离开野地后，我再没见过和那只灰鸟一样的鸟。这种鸟可能就剽下那一只了，它没有了同类，希望找一个能听懂它话语的生命。它曾经找到了我，在我耳边说了那么多动听的鸟语。可我，只是个种地的农民，没在天上飞过，没在高高的树枝上站过。我怎会听懂鸟说的事倩呢？　不知那只鸟最后找到知音了没有。听过它孤独鸟语的一个人，却从此默默无声。多少年后，这种孤独的声音出现在他的声音中。　最大的事情　我在野地只呆一个月(在村里也就住几十年)，一个月后，村里来一些人，把麦子打掉，麦草扔在地边。我们一走，不管活儿干没干完，都不是我们的事情了。　老鼠会在仓满洞盈之后，重选一个地方打新洞。也许就选在草棚旁边，或者草垛下面。草棚这儿地势高，干爽，适合人筑屋鼠打洞。麦草垛下面隐蔽、安全，麦秆中少不了有一些剩余的麦穗麦粒足够几代老鼠吃。　鸟会把巢筑在草棚上，在长出来的那截木头上，涂满白色鸟粪。　野鸡会从门缝钻进来，在我们睡觉的草铺上，生几枚蛋，留一地零乱羽毛。　这些都是给下一年来到的人们留下的麻烦事情。下一年，一切会重新开始。剩下的事将被搁在一边。　如果下一年我们不来。下下一年还不来。　如果我们永远地走了，从野地上的草棚，从村庄，从远远近近的城市。如果人的事情结束了，或者人还有万般未竟的事业但人没有了。再也没有了。　那么，我们干完的事，将是留在这个世界上的&amp;ndash;最大的事情。　别说一座钢铁空城、一个砖瓦树落。仅仅是我们弃在大地上的一间平常的土房子，就够它们多少年收拾。　草大概用五年时间，长满被人铲平踩瓷实的院子。草根蛰伏在土里，它没有死掉，一直在土中窥听地面上的动静。一年又一年，人的脚步在院子里来来去去，时缓时快，时轻时沉。终于有一天，再听不见了。草根试探性地拱破地面，发一个芽，生两片叶，迎风探望一季，确信再没锨来铲它，脚来踩它，草便一棵一棵从土里钻出来。这片曾经是它们的土地已面目全非，且怪模怪样地耸着一间土房子。　草开始从墙缝往外长，往房顶上长。　而房顶的大木梁中，几只蛀虫正悄悄干着一件大事情。它们打算用八十七年，把这棵木梁蛀空。然后房顶塌下来。　与此同时，风四十年吹旧一扇门上的红油漆。雨八十年冲掉墙上的一块泥皮。　厚实的墙基里，一群蝼蚁正一小粒一小粒往外搬土。它们把巢筑在墙基里，大蝼蚁在墙里死去，小蝼蚁又在墙里出生。这个过程没有谁能全部经历，它太漫长，大概要一千八百年，墙根就彻底毁了。曾经从土里站起来，高出大地的这些土，终归又倒塌到泥土里。　但要完全抹平这片土房子的痕迹，几乎是不可能的。　不管多大的风，刮平一道田埂也得一百年工夫；人用日扔掉的一只瓷碗，在土中埋三千年仍纹丝不变；而一根扎入土地的钢筋，带给土地的将是永久的刺痛。几乎没有什么东西能够消磨掉它。　除了时间。　时间本身也不是无限的。　所谓永恒，就是消磨一件事物的时间完了，但这件事物还在。　时间再没有时间。　狗这一辈子　一条狗能活到老，真是件不容易的事。太厉害不行，太懦弱不行，不解人意、太解人意了均不行。总之，稍一马虎便会被人炖了肉剥了皮。狗本是看家守院的，更多时候却连自己都看守不住。　活到一把子年纪，狗命便相对安全了，倒不是狗活出了什么经验。尽管一条老狗的见识，肯定会让一个走遍天下的人吃惊。狗却不会像人，年轻时咬出点名气，老了便可坐享其成。狗一老，再无人谋它脱毛的皮，更无人敢问津它多病的肉体，这时的狗很像一位历经沧桑的老人，世界已拿它没有办法，只好撒手，交给时间和命。　一条熬出来的狗，熬到拴它的铁链朽了，不挣而断。养它的主人也入暮年，明知这条狗再走不到哪里，就随它去吧。狗摇摇晃晃走出院门，四下里望望，是不是以前的村庄已看不清楚。狗在早年捡到过一根干骨头的沙沟梁转转；在早年恋过一条母狗的乱草滩转转；遇到早年咬过的人，远远避开，一副内疚的样子。其实人早好了伤疤忘了疼。有头脑的人大都不跟狗计较，有句俗话：狗咬了你你还能去咬狗吗？与狗相咬，除了啃一嘴狗毛你又能占到啥便宜。被狗咬过的人，大都把仇记恨在主人身上，而主人又一古脑把责任全推到狗身上。一条狗随时都必须准备着承受一切。　在乡下，家家门口拴一条狗，目的很明确：把门。人的门被狗把持，仿佛狗的家。来人并非找狗，却先要与狗较量一阵，等到终于见了主人，来时的心境已落了大半，想好的话语也吓得忘掉大半。狗的影子始终在眼前窜悠，答问间时闻狗吠，令来人惊魂不定。主人则可从容不迫，坐察其来意。这叫未与人来先与狗往。　有经验的主人听到狗叫，先不忙着出来，开个门缝往外瞧瞧。若是不想见的人，比如来借钱的，讨债的，寻仇的&amp;hellip;&amp;hellip;便装个没听见。狗自然咬得更起劲。来人朝院子里喊两声，自愧不如狗的嗓门大，也就缄默。狠狠踢一脚院门，骂声&amp;rdquo;狗日的&amp;rdquo;，走了。　若是非见不可的贵人，主人一趟子跑出来，打开狗，骂一句&amp;rdquo;瞎了狗眼了&amp;rdquo;，狗自会没趣地躲开。稍慢一步又会挨棒子。狗挨打挨骂是常有的事，一条狗若因主人错怪便赌气不咬人，睁一眼闭一眼，那它的狗命也就不长了。　一条称职的好狗，不得与其他任何一个外人混熟。在它的狗眼里，除主人之外的任何面孔都必须是陌生的、危险的。更不得与邻居家的狗相往来。需要交配时，两家狗主人自会商量好了，公母牵到一起，主人在一旁监督着。事情完了就完了。万不可藕断丝连，弄出感情，那样狗主人会妒嫉。人养了狗，狗就必须把所有的爱和忠诚奉献给人，而不应该给另一条狗。　狗这一辈子像梦一样飘忽，没人知道狗是带着什么使命来到人世。　人一睡着，村庄便成了狗的世界，喧嚣一天的人再无话可说，土地和人都乏了。此时狗语大作，狗的声音在夜空飘来荡去，将远远近近的村庄连在一起。那是人之外的另一种声音，飘忽、神秘。莽原之上，明月之下，人们熟睡的躯体是听者，土墙和土墙的影子是听者，路是听者。年代久远的狗吠融入空气中，已经成寂静的一部分。　在这众狗狺狺的夜晚，肯定有一条老狗，默不作声。它是黑夜的一部分，它在一个村庄转悠到老，是村庄的一部分，它再无人可咬，因而也是人的一部分。这是条终于可以冥然入睡的狗，在人们久不再去的僻远路途，废弃多年的荒宅旧院，这条狗来回地走动，眼中满是人们多年前的陈事旧影。　我改变的事物　我年轻力盛的那些年，常常扛一把铁锨，像个无事的人，在村外的野地上闲转。我不喜欢在路上溜达，那个时候每条路都有一个明确去处，而我是个毫无目的的人，不希望路把我带到我不情愿的地方。我喜欢一个人在荒野上转悠，看哪不顺眼了，就挖两锨。那片荒野不是谁的，许多草还没有名字，胡乱地长着，我也胡乱地生活着，找不到值得一干的大事。在我年轻力盛的时候，那些很重很累人的活都躲得远远的，不跟我交手，等我老了没力气时又一件接一件来到生活中，欺负一个老掉的人。这也许就是命运。　有时，我会花一晌午工夫，把一个跟我毫无关系的土包铲平，或在一片平地上无辜地挖一个大坑。我只是不想让一把好锨在我肩上白白生锈。一个在岁月中虚度的人，再搭上一把锨、一幢好房子，甚至几头壮牲口，让它们陪你虚晃荡一世，那才叫不道德呢。当然，在我使唤坏好几把铁锨后，也会想到村里老掉的一些人，没见他们干出啥大事便把自己使唤威这副样子，腰也弯了，骨头也散架了。　几年后当我再经过这片荒地，就会发现我劳动过的地上有了些变化，以往长在土包上的杂草现在下来了，和平地上的草挤在一起，再显不出谁高谁低；而我挖的那个大坑里，深陷着一窝子墨绿。这时我内心的激动别人是无法体会的&amp;ndash;我改变了一小片野草的布局和长势。就因为那么几锨，这片荒野的一个部位发生变化了，每个夏天都落到土包上的雨，从此再找不到这个土包；每个冬天也会有一些雪花迟落地一会儿&amp;ndash;我挖的这个坑增大了天空和大地间的距离。对于跑过这片荒野的一头驴来说，这点变化也许算不了什么，它在荒野上随便撒泡尿也会冲出一个不小的坑来。而对于世代生存在这里的一只小虫，这点变化可谓地覆天翻，有些小虫一辈子都走不了几米，在它的领地随便挖走一锨土，它都会永远迷失。　有时我也会钻进谁家的玉米地，蹲上半天再出来。到了秋天就会有一两株玉米，鹤立鸡群般耸在一片平庸的玉米地中。这是我的业绩，我为这户人家增收了几斤玉米。哪天我去这家借东西，碰巧赶上午饭，我会毫不客气地接过女主人端来的一碗粥和一块玉米饼子。　我是个闲不住的人，却永远不会为某一件事去忙碌。村里人说我是个&amp;rdquo;闲锤子&amp;rdquo;，他们*一年年的丰收改建了家园，添置了农具和衣服。我还是老样子，他们不知道我改变了什么。　一次我经过沙沟梁，见一棵斜长的胡杨树，有碗口那么粗吧，我想它已经歪着身子活了五六年了。树总是一个姿势做到底，原地踏步一辈子，往前走半步都是要命的事。我找了根草绳，拴在邻近的一棵树上，费了很大劲把这棵树拉直了，干完这件事我就走了。两年后我回来的时候，一眼就看见那棵歪斜的胡杨已经长直了，既挺拔又壮实。拉直它的那棵树却变歪了。我改变了两棵树的长势，而现在，谁也改变不了它们了。　我把一棵树上的麻雀赶到另一棵树上，把一条渠里的水引进另一条渠。我相信我的每个行为都不同寻常地充满意义。我是这样一个平常的人，住在这样一个小村庄里，注定要这样闲逛一辈子。我得给自己找点闲事，找个理由活下去。　我在一头牛屁股上拍了一锨，牛猛窜几步，落在最后的这头牛一下子到了牛群最前面，碰巧有个买牛的人，这头牛便被选中了。对牛来说，这一锨就是命运。我赶开一头正在交配的黑公羊，让一头急得乱跳的白公羊爬上去，这对我只是个小动作，举手之劳。羊的未来却截然不同了，本该下黑羊的这只母羊，因此只能下只白羊羔了。黑公羊肯定会恨我的，我不在乎。羊迟早是人的腹中物，恨我的那只羊的肉和感激我的那只羊的肉，嚼到嘴里会一样香。在羊的骨髓里你吃不出那种叫爱和恨的东西，只有营养和油脂。　当我五十岁的时候，我会很自豪地目睹因为我而成了现在这个样子的大小事物，在长达一生的时间，我有意无意地改变了它们，让本来黑的变成白，本来向东的去了西边&amp;hellip;&amp;hellip;而这一切，只有我一个人清楚。　我扔在路旁的那根木头，没有谁知道它挡住了什么。它不规则地横在那里，是一种障碍，一段时光中的堤坝，又像是一截指针，一种命运的暗示。每天都会有一些村民坐在木头上，闲扯一个下午。也有几头牲口拴在木头上，一个晚上去不了别处。因为这根木头，人们坐到了一起，扯着闲话商量着明天、明年的事。因此，第二天就有人扛一架工具上南梁坡了，有人骑一匹快马上胡家海子了&amp;hellip;&amp;hellip;而在这个下午之前，人们都没想好该去干什么。没这根木头生活可能会是另一个样子。坐在一问房子里的板凳上和坐在路边的一根木头上商量出的事肯定是完全不同的两种结果。　多少年后当眼前的一切成为结局，时间改变了我，改变了村里的一切。整个老掉的一代人，坐在黄昏里感叹岁月流逝、沧桑巨变。没人知道有些东西是被我改变的。在时间经过这个小村庄的时候，我帮了时间的忙，让该变的一切都有了变迁。我老的时候，我会说：我是在时光中老的。　人畜共居的村庄　有时想想，在黄沙梁做一头驴，也是不错的。只要不年纪轻轻就被人宰掉，拉拉车，吃吃草，亢奋时叫两声，平常的时候就沉默，心怀驴胎，想想眼前嘴前的事儿。只要不懒，一辈子也挨不了几鞭。况且现在机器多了，驴活得比人悠闲，整日在村里村外溜达，调情撒欢。不过，闲得没事对一头驴来说是最最危险的事。好在做了驴就不想这些了，活一日乐一日，这句人话，用在驴身上才再合适不过。　做一条小虫呢，在黄沙梁的春花秋草间，无忧无虑把自己短暂快乐的一生挥霍完。虽然只看见漫长岁月悠悠人世间某一年的光景，却也无憾。许多年头都是一样的，麦子青了黄，黄了青，变化的仅仅是人的心境。　做一条狗呢？　或者做一棵树，长在村前村后都没关系，只要不开花，不是长得很直，便不会挨斧头。一年一年地活着。叶落归根，一层又一层，最后埋在自己一生的落叶里，死和活都是一番境界。　如此看来，在黄沙梁做一个人，倒是件极普通平凡的事。大不必因为你是人就趾高气扬，是狗就垂头丧气。在黄沙梁，每个人都是名人，每个人都默默无闻。每个牲口也一样，就这么小小的一个村庄，谁还能不认识谁呢。谁和谁多少不发生点关系，人也罢牲口也罢。　你敢说张三家的狗不认识你李四。它只叫不上你的名字&amp;ndash;它的叫声中有一句可能就是叫你的，只是你听不懂。也从不想去弄懂一头驴子，见面更懒得抬头打招呼，可那驴却一直惦记着你，那年它在你家地头吃草，挨过你一锨。好狠毒的一锨，你硬是让这头爱面子的驴死后不能留一张完整的好皮。这么多年它一直在瞅机会给你一蹄子呢。还有路边泥塘中的那两头猪，一上午哼哼叽叽，你敢保证它们不是在议论你们家的事。猪夜夜卧在窗根，你家啥事它不清楚。　对于黄沙梁，其实你不比一只盘旋其上的鹰看得全面，也不会比一匹老马更熟悉它的路。人和牲畜相处几千年，竞没找到一种共同语言，有朝一日坐下来好好谈谈。想必牲口肯定有许多话要对人说，尤其人之间的是是非非，牲口肯定比人看得清楚。而人，除了要告诉牲口&amp;rdquo;你必须顺从&amp;rdquo;外，肯定再不愿与牲口多说半句。　人畜共居在一个小村庄里，人出生时牲口也出世，傍晚人回家牲口也归圈。弯曲的黄土路上，不是人跟着牲口走便是牲口跟着人走。　人踩起的尘土落在牲口身上。　牲口踩起的尘土落在人身上。　家和牲口棚是一样的土房，墙连墙窗挨窗。人忙急了会不小心钻进牲口棚，牲口也会偶尔装糊涂走进人的居室。看上去你们似亲戚如邻居，却又根本不是那么回事，日子久了难免把你们认成一种动物。　比如你的腰上总有股用不完的牛劲；你走路的架势像头公牛，腿*得很开，走路一摇三摆；你的嗓音中常出现狗叫鸡鸣；别人叫你&amp;rdquo;瘦狗&amp;rdquo;是因为你确实不像瘦马瘦骡子；多少年来你用半匹马的力气和女人生活和爱情。你的女人，是只老鸟了还那样依人。　数年前的一个冬天，你觉得一匹马在某个黑暗角落盯你。你有点怕，它做了一辈子牲口，是不是后悔了，开始揣摸人。那时你的孤独和无助确实被一匹马看见了。周围的人，却总以为你是快乐的，像一只无忧无虑的夏虫，一头乐不知死的驴子、猪&amp;hellip;&amp;hellip;　其实这些活物，都是从人的灵魂里跑出来的。上帝没让它们走远，永远和人呆在一起，让人从这些动物身上看清自己。　而人的灵魂中，其实还有一大群惊世的巨兽被禁锢着，如藏龙如伏虎。它们从未像狗一样咬脱锁链，跑出人的心宅肺院。偶尔跑出来，也会被人当疯狗打了，消灭了。　在人心中活着的，必是些巨蟒大禽。　在人身边活下来的，却只有这群温顺之物了。　人把它们叫牲口，不知道它们把人叫啥。　村东头的人和村西头的人 一般来说，南方人和北方人的相貌及性情差异是显而易见的。住在村东头的人和住在村西头的人有啥不同便少有人知了。村庄是这个世界上最小的地方，一般的村子户不过百，人不足千，东西跨度也就几百米，那头咳嗽一声这头也能听得清清楚楚。这样的弹丸之地竟也有东西人之分，听起来你会觉得可笑。　住在村东头的人，被早晨的第一缕阳光照醒。这是一天的头茬子阳光，鲜嫩、洁净，充满生机。做早饭的女人，收拾农具的男人，沫浴在一片曙光中，这顿鲜美的&amp;rdquo;阳光早餐&amp;rdquo;不是哪个地方的人都能随意享受。阳光对于人的喂养就像草对于牲畜。光线的质量直接决定着人的内心及前途的光亮程度。而当阳光漫过一个房顶又一个房顶到达村西头，光线中已沾染了太多的烟尘、人声和鸡鸣狗叫，成为世俗的东西。　早晨村东头的屋影；树影、烟影、人畜影层层叠叠压向村西头。早晨的影子是残梦；是梦幻与现实的暖昧与交替。这种影子里长大的人，忧郁、怀疑、好妄想。午后村西头的影子正好反过来压向村东头。午后的影子是疲惫，是一整天勤劳带来的收获与遗憾，是先到的夜晚。坐在这种阴影里吃饭的人们；咀嚼生活的自足与艰辛。早熟，早恋，早有所成。　住在村东头的男人，早晨面朝太阳，一泡激尿撒出三米远两丈高。这是憋了一夜的老尿，之所以憋一夜不在三五更放掉，就是为了一大早地晒晒太阳。越是见不得阳光的东西就越是需要阳光，撒尿是个多好的正当理由，它让这个无期监禁的&amp;rdquo;家伙&amp;rdquo;偶尔出来放放风见见阳光。村东头的男人，无论高矮胖瘦皆悍劲阳刚。　水往东边流，一渠水村西人洗过衣服村东人洗，虽说水过百米自然清，百米外的清水肯定已不是以前的水；风向西边刮，村东头的尘土刮到村西头，村西的尘土又刮到更西边另一个村庄的东头。　村东头的人以为太阳落尽时，太阳才落到村西头的房子后面，几栋矮土房足够遮挡人的眼光和观念。就像村西人以为太阳还未出来时，村东人已饮足了早晨的头茬子阳光。村西人的黄昏漫长；夜相对短些。村东人的黎明早，昼相应长些。前后一算又是一样的。先醒的人先睡着。误差极微小，才不易觉察地影响着人。　一个人日复一日、年复一年地被太阳先照那么一阵，一个人夜夜早睡早醒，早早下到地里，四寂无人地先干那么一阵。　另一个人总是最后目睹日头落尽，看着人全回村，牲口都归圈。尔后关好院门。只有他知道一天真的完了。他最后一个端起饭碗，最后一个点灯又最后一个把灯吹灭。半村人鼾声大震时，另半村人正醒着。　这样的两种人像不像生活在两个不同时代，他们气质、禀性中的不同东西肯定比相同的东西多得多。　人虽非草木，家却是根，把人牢牢拴在一处。人可以走东窜西，跑南奔北。大部分时间却还是在家里度过。家的位置对人一生有多重要。家安在盐碱滩，你的脚就一辈子返潮。家住沙沟梁，有风无风你都得把眼眯缝上。不同的生活方位造就着不同的人。几步之外，另有乾坤。村人早就知道这个道理。所以他们在活得不对劲时，要想方设法搬搬房子，这比搬动其他更容易些。树挪死，人挪活嘛。1994年7月　永远欠一顿饭　现在我还不知道那顿没吃饱的晚饭对我今后的人生有多大影响。人是不可以敷衍自己的。尤其是吃饭，这顿没吃饱就是没吃饱，不可能下一顿多吃点就能补偿。没吃饱的这顿饭将作为一种欠缺空在一生里，命运迟早会抓住这个薄弱环节击败我。　那一天我忙了些什么现在一点也记不清了，只记得天黑时又饥又累回到宿舍，胡乱地啃了几口干馕便躺下了，原想休息一会儿出去好好吃顿饭。谁知一躺下便睡了过去，醒来时已经是第二天早晨。　我就这样给自己省了一顿饭钱。这又有什么用呢？即使今天早晨我突然暴富，腰缠千万，我也只能为自己备一顿像样点的早餐。却永远无法回到昨天下午，为那个又饿又累的自己买一盘菜一碗汤面。　过去了就是过去了。但这笔欠账却永远记在生命中。也许就因为这顿饭没吃饱，多少年后的一次劫难逃生中，我差半步没有摆脱厄运。正因为这顿没吃饱的饭，以后多少年我心虚、腿软、步履艰难，因而失去许多机遇，许多好运气，让别人抢了先。　人们时常埋怨生活，埋怨社会，甚至时代。总认为是这些大环境造成了自己多舛的命运。其实，生活中那些常被忽视的微小东西对人的作用才是最巨大的。也许正是它们影响了你，造就或毁掉了你，而你却从不知道。　你若住在城市的楼群下面，每个早晨本该照在你身上的那束阳光，被高楼层层阻隔，你在它的阴影中一个早晨一个早晨地过着没有阳光的日子。你有一个妻子，但她不漂亮；有一个儿子，但你不喜欢他。你没有当上官，没有挣上钱，甚至没有几个可以来往的好朋友。你感觉你欠缺得太多太多，但你从没有认真地去想想，也许你真正欠缺的，正是每个早晨的那一束阳光，有了这束阳光，也许一切就都有了。　你的妻子因为每个早晨都能临窗晒会儿太阳，所以容颜光彩而亮丽，眉不萎，脸不皱，目光含情；你的儿子因为每个早晨都不在阴影里走动，所以性情晴朗可人，发育良好，没有怪僻的毛病；而你，因为每个早晨都面对蓬勃日出，久而久之，心仔大志，向上进取，所以当上官，发了财。　你若住在城市的高烟囱下面；那些细小的、肉眼看不见的烟灰煤粒常年累月侵蚀你，落到皮肤上，吸进肺腑里，吃到肠胃中，于是你年纪不大就得了一种病，生出一种怪脾气，见谁都生气，看啥都不顺眼，干啥都不舒服。其实，是你自己不舒服，你比别人多吃了许多煤沫子，所以成了现在这个样子。你怪领导给你穿小鞋，同事对你不尊敬，邻居对你冷眼相看，说三道四。你把这一切最终归罪于社会，怨自己生不逢时，却不知道抬头骂一句：狗日的，烟尘。它影响了你，害了你，你却浑然不觉。　人们总喜欢把自己依赖在强大的社会身上，耗费毕生精力向社会索取。而忘记了营造自己的小世界，小环境。其实，得到幸福和满足是非常容易的事情，只要你花一会儿时间，探净窗玻璃上的尘土，你就会得到一屋子的明娓阳光，享受很多天的心情舒畅；只要稍动点手。填平回家路上的那个小坑，整个一年甚至几年你都会平平安安到家，再不会栽跟头，　走在路上尽可以想些高兴的事情，想得入神，而不必担心路不平。　还有吃饭，许多人有这个条件，只要稍加操持便能美美款待自己一番。但许多人不这样去做，他们用这段时间下馆子去找挨宰，找气受，找传染病，尔后又把牢骚和坏脾气带到生活中，工作申。　但还是有许许多多的人懂得每顿饭对人生的重要性。他们活得仔细认真，把每顿饭都当一顿饭去吃，把每句话都当一句话去说，把每口气都当了口气去呼吸。他们不敷衍生活，生活也不敷衍他们，他们过得一个比一个好。　我刚来乌市时，有一个月时间，借住在同事的宿舍里，对门的两位小姐，也跟我一样，趁朋友不在，借住几天。　每天下班后，我都看到她们买回好多新鲜蔬菜，有时还买一条鱼，我所见她们又说又笑地做饭，禁不住凑过去和她们说笑几句。　她们从不请我吃她们做的饭，饭做好便自顾自地吃起来，连句&amp;rdquo;吃点饭吧&amp;rdquo;这样的客气话也不说一句。也许她们压根就没把我当外人，而我还一直抱着到城市来做客的天真想法，希望有人对我客气一下。她们多懂得爱护自己啊，生伯我吃掉一口她们就会少吃一口，少吸收一点营养，少增加一点热量，第二天她们在生活和事业上与人竞争时就会少一点体力，缺一点智力，她们生活的认真劲儿真让我感动。虽然只暂住几天，却几乎买齐了所有佐料，瓶瓶罐罐摆了一窗台，把房间和过道扫得干干净净，住到哪就把哪当成家。而我来乌市都几个月了，还四处漂泊，活得潦倒又潦草。常常用一些简单的饭食糊弄自己，从不知道扫一扫地，把被子叠得整整齐齐，总抱着一种临时的想法在生活：住几天就走，工作几年就离开，爱几个月便分手&amp;hellip;&amp;hellip;一直到生活几十年就离世。　我想，即使我不能把举目无亲的城市认作故土，也至少应该把借住的这闺房子当成家，生活再匆忙，工作再辛苦，一天也要挤出点时间来，不慌不忙地做顿饭，生活中也许有许多不如意，但我可以做一顿如意的饭菜&amp;ndash;为自已。也许我无法改变命运，但随时改善一下生活，总是可以的，只要一顿好饭，一句好话，一个美好的想法便可完全改变人的心情，这件简单易做的事，唾手可得的幸福我都不知道去做，还追求什么大幸福呢？　城市牛哞　我是在路过街心花园时，一眼看见花园中冒着热气的一堆牛粪的。在城市能见到这种东西我有点不敢相信，城市人怎么也对牛粪感起兴趣？我翻进花园，抓起一把闻了闻，是正宗的乡下牛粪，一股熟悉的遥远乡村的气息扑鼻而来，沁透心肺。那些在乡下默默无闻的牛，苦了一辈子最后被宰掉的牛，它们知不知道自己的牛粪被运到城市，作为上好肥料养育着城里的花草树木。它们知道牛圈之外有一个叫乌鲁木齐的城市吗？　一次我在街上看到从乡下运来的一卡车牛，它们并排横站在车厢里，像一群没买到坐票的乘客，东张西望，目光天真而好奇。我低着头，不敢看它们。我知道它们是被运来干啥的，在卡车缓缓开过的一瞬，我听到熟悉的一声牛哞，紧接着一车牛的眼睛齐刷刷盯住了我：它们认出我来了&amp;hellip;&amp;hellip;这不是经常扛一把铁锨在田间地头转悠的那个农民吗，他不好好种地跑到城里干啥来了。瞧他挟一只黑包在人群中奔波的样子，跟在乡下时挟一条麻袋去偷玉米是一种架势。我似乎听到牛议论我，我羞愧得抬不起头。　这些牛不是乘车来逛街的。街上没有牛需要的东西，也没有牛要干的活。城市的所有工作被一种叫市民的承榄了，他们不需要牲畜。牛只是作为肉和皮子被运到城市。他们为了牛肉的新鲜才把活牛运到城里。一头牛从宰杀到骨肉被分食，这段时间体现了一个城市的胃口和消化速度。早晨还活蹦乱跳的一头牛，中午已摆上市民的餐桌，进入肠胃转化成热量和情欲。　而牛知不知道它们的下场呢？它们会不会正天真地想，是人在爱护它们抬举它们呢。它们耕了一辈子地，拉了一辈子车，驮了一辈子东西，立下大功劳了。人把它们当老工人或劳动模范一样尊敬和爱戴，从千万头牛中选出些代表，免费乘车到城里旅游一趟，让它们因这仅有的一次荣耀而忘记一辈子的困苦与屈辱，对熬煎了自己一生的社会和生活再没有意见，无怨无悔。　牛会不会在屠刀搭在脖子上时还做着这样的美梦呢？　我是从装满牛的车厢跳出来的那一个。是冲断缰绳跑掉的那一个。　是挣脱屠刀昂着鲜红的血脖子远走他乡的那一个。　多少次我看着比人高大有力的牛，被人轻轻松松地宰掉，它们不挣扎，不逃跑，甚至不叫一声，似乎那一刀捅进去很舒服。我在心里一次次替它们逃跑，用我的两只脚，用我远不如牛的那点力气，替千千万万头牛在逃啊逃，从一个村庄到另一个村庄，最终逃到城市，躲在熙熙攘攘的人群中，让他们再认不出来。我尽量装得跟人似的，跟一个城里人似的说话、做事和走路。但我知道我和他们是两种动物。我沉默无语，偶尔在城市的喧嚣中发出一两声沉沉牛哞，惊动周围的人。他们惊异地注视着我，说我发出了天才的声音。我默默地接受着这种赞誉，只有我知道这种声音曾经遍布大地，太普通、太平凡了。只是发出这种声音的喉管被人们一个个割断了。多少伟大生命被人们当食物吞噬。人们用太多太珍贵的东西喂了肚子。浑厚无比的牛哞在他们的肠胃里翻个滚，变作一个咯或一个屁被排掉&amp;ndash;工业城市对所有珍贵事物的处理方式无不类似于此。　那一天，拥拥挤挤的城里人来来往往，汉人注意到坐在街心花园的一堆牛粪上一根接一根抽烟的我，他们顶多把我当成给花园施肥的工人或花匠。我已经把自己伪装得不像农民。几个月前我扔掉铁锨和锄头跑到城市，在一家文化单位打工。我遇到许多才华横溢的文人，他们家里摆着成架成架的书，读过古今中外的所有名著。被书籍养育的他们，个个满腹经纶。我感到惭愧，感到十分窘迫。我的家里除了成堆的苞谷棒子，便是房前屋后的一堆堆牛粪，我唯一的养分便是这些牛粪。小时候在牛粪堆上玩耍，长大后又担着牛粪施肥。长年累月地熏陶我的正是弥漫在空气中的牛粪味儿。我不敢告诉他们，我就是在这种熏陶中长大、并混到文人作家的行列中。　这个城市正一天天长高，但我感到它是脆弱的、苍白的，我会在适当的时候给城市上点牛粪，我是个农民，只能用农民的方式做我能做到的，尽管无济于事。我也会在适当时候邀请我的朋友们到一堆牛粪上采坐坐，他们饱食了现代激素，而人类最本原的底肥是万不可少的。没这种底肥的人如同无本之木，是结不出硕大果实的。　好在城市人已经认识到牛粪的价值。他们把雪白雪白的化肥卖给农民，又廉价从农民手中换来珍贵无比的牛粪养育花草树木。这些本该养育伟大事物的贵重养料，如今也只能育肥城市人的闲情逸致了。1995年7月　父亲　我们家搬进这个院子的第二年，家里的重活开始逐渐落到我们兄弟几个身上，父亲过早地显出了老相，背稍重点的东西便显得很吃力，嘴里不时嘟囔一句：我都５０岁的人了，还出这么大力气。　他觉得自己早该闲坐到墙根晒太阳了。　母亲却认为他是装的。他看上去那么高大壮实，一只胳膊上的劲，比我们浑身的劲都大得多。一次他发脾气，一只手一拨，老三就飞出去３米。我见他发过两次火，都是对着老三、老四。我和大哥不怎么怕他，时常不听他的话。我们有自己的想法。我们一到这个家，他便把一切权力交给了母亲。家里买什么不买什么，都是母亲说了算。他看上去只是个干活的人，和我们一起起早贪黑。每天下地都是他赶车，坐在辕木上，很少挥鞭子。他嫌我们赶不好，只会用鞭子打牛，跑起来平路颠路不分。他试着让我赶过几次车。往前走叫&amp;rdquo;呔球&amp;rdquo;。往左拐叫&amp;rdquo;嗷&amp;rdquo;。往右拐叫&amp;rdquo;唷&amp;rdquo;。往后退叫&amp;rdquo;缩&amp;rdquo;。我一慌就叫反。一次右边有个土疙瘩，应该喊&amp;rdquo;嗷&amp;rdquo;让牛向左拐绕过去。我却喊成&amp;rdquo;唷&amp;rdquo;。牛愣了一下，突然停住，扭头看着我。我一下不好意思，&amp;rdquo;嗷、嗷&amp;rdquo;了好几声。　我一个人赶车时就没这么紧张。其实根本用不着多操心，牛会自己往好路上走，遇到坑坎会自觉躲过。它知道车轱辘碰到疙瘩陷进坑里都会让自己多费劲。　我们在太平渠使唤老了３头牛。有一头是黑母牛，我们到这个家时它已不小岁数了，走路肉肉的，没一点脾气。父亲说它８岁了。８岁，跟我同岁，还是个孩子呢。可牛只有十几岁的寿命，活到这个年龄就得考虑卖还是宰。黑母牛给我印象最深的是那副木讷神情。鞭子抽在身上也没反应。抽急了猛走几步，鞭子一停便慢下来，缓缓悠悠地挪着步子。父亲已经适应了这个慢劲。我们不行，老想快点走到想去的地方，担心去晚了柴被人砍光草被人割光。一见飞奔的马车牛车擦身而过，便禁不住抡起鞭子，&amp;rdquo;呔球、呔球&amp;rdquo;地叫喊一阵。可是没用，鞭子抽在它身上就像抽在地上一样，只腾起一股白土。黑母牛身上纵纵横横地爬满了鞭痕。我们打它时一点都不心疼。我们似乎觉得，它已经不知道疼，再多抽几鞭就像往柴垛上多撂几把柴一样地无所谓了。它干的最重的活就是拉柴禾，来回几十公里。遇到上坡和难走的路，我们也会帮着拉，肩上套根绳子，身体前倾着，那时牛会格外用力，我们和牛，就像一对兄弟。实在拉不动时，牛便伸长脖力，晃着头，哞哞地叫几声，那神情就像父亲背一麻袋重东西，边喘着气边埋怨：我都快５０岁的人了，还出这么大力气。　父亲一生气就嘟囔个不停。我们经常惹他生气。他说东，我们说西。有一段时间我们故意和他对着干，他生了气就跟母亲嘟囔，母亲因此也生气。在这个院子里我们有过一段很不愉快的日子。后来我们渐渐地长大懂事了，但父亲也渐渐地老了。　我一直觉得我不太了解父亲，对这个和我们生活在一起叫他作父亲的男人，我有一种难言的陌生。他会说书，讲故事，在那些冬天的长夜里，我们围着他听。母亲在油灯旁纳鞋底。听着那些陌生的故事，感觉很远处的天，一片一片地亮了。我不知道父亲在这个家里过得快乐不快乐，幸福不幸福。他把我们一家人接进这个院子后悔吗？现在他和母亲还有我最小的妹妹和妹夫一起住在沙湾县城。早几年他喜欢抽烟，吃晚饭时喝两盅酒。他从不多喝，再热闹的酒桌上也是喝两盅便早早离开。我去看他时，常带点烟和酒。他打开烟盒，自己叼一根，又递给我一根烟&amp;mdash;许多年前他第一次递给我烟时也是这个动作，手臂半曲着，伸一下又缩一下，脸上堆着不自然的笑，我不知所措。现在他已经戒烟，酒也喝得更少了。我不知道该给他带去些什么。每次回去我都在他身边，默默地坐一会儿。依旧没什么要说的话。他偶尔问一句我的生活和工作，就像许多年前我拉柴回到家，他问一句&amp;rdquo;牛拴好了吗？&amp;rdquo;我答一句，又是长时间的沉默。　鸟叫　我听到过一只鸟在半夜的叫声。　我睡在牛圈棚顶的草垛上。整个夏天我们都往牛圈棚顶上垛干草，草垛高出房顶和树梢。那是牛羊一个冬天的食草。整个冬天，圈棚上的草会一天天减少。到了春天，草芽初露，牛羊出圈遍野里追青逐绿，棚上的干草便所剩无几，露出粗细歪直的梁柱来，那时候上棚，不小心就会一脚踩空，掉进牛圈里。　而在夏末秋初的闷热夜晚，草棚顶上是绝好的凉快处，从夜空吹下来的风，丝丝缕缕，轻拂着草垛顶部。这个季节的风吹刮在高空里，可以看到云堆飘移，却不见树叶摇动。　那些夜晚我很少睡在房子里。有时铺一些草睡在地头看苞谷。有时垫一个褥子躺在院子里的牛车上，旁边堆着新收回来的苞谷或棉花。更多的时候我躺在草垛上，胡乱地想着些事情便睡着了。醒来不知是哪一天早晨，家里发生了一些事，一只鸡不见了，两片树叶黄落到窗台上，堆在院子里的苞谷棒子少了几根，又好像一根没少；什么事都没有发生，一切都和往日一模一样，一家人吃饭，收拾院子，套车，扛农具下地&amp;hellip;&amp;hellip;天黑后我依旧爬上草垛，胡乱地想着些事情然后睡觉。　那个晚上我不是让鸟叫醒的。我刚好在那个时候，睡醒了。天有点凉。我往身上加了些草。　这时一只鸟叫了。　&amp;rdquo;呱&amp;rdquo;　独独的一声。停了片刻，又&amp;rdquo;呱&amp;rdquo;的一声。是一只很大的鸟，声音粗哑，却很有穿透力。有点像我外爷的声音。停了会儿，又&amp;rdquo;呱&amp;rdquo;、&amp;rdquo;呱&amp;rdquo;两声。　整个村子静静的、黑黑的，只有一只鸟在叫。　我有点怕，从没听过这样大声的鸟叫。　鸟声在村南边隔着三四幢房子的地方，那儿有一棵大榆树，还有一小片白杨树。我侧过头看见那片黑糊糊的树梢像隆起的一块平地，似乎上面可以走人。　过了一阵，鸟叫又突然从西边响起，离得很近，听声音好像就在斜对面韩三家的房顶上。鸟叫的时候，整个村子回荡着鸟声，不叫时便啥声音都没有了，连空气都没有了。　我在第七声鸟叫之后，悄悄地爬下草垛。我不敢再听下一声，好像每一声鸟叫都刺进我的身体里，浑身的每块肉每根骨头都被鸟叫惊醒。我更担心鸟飞过来落到草垛上。　我顺着草垛轻轻滑落到棚沿上，抱着一根伸出来的椽头吊了下来。在草垛顶上坐起身的那一瞬，我突然看见我们家的房顶，觉得那么远，那么陌生，黑黑地摆在眼底下，那截烟囱，横堆在上面的那些木头，模模糊糊的，像是梦里的一个场景。　这就是我的家吗？是我必需要记住的&amp;mdash;哪一天我像鸟一样飞回来，一眼就能认出的我们家朝天仰着的&amp;mdash;那个面容吗？在这个屋顶下面的大土炕上，此刻睡着我的后父、母亲、大哥、三个弟弟和两个小妹。他们都睡着了，肩挨肩地睡着了。只有我在高处看着黑黑的这幢房子。　我走过圈棚前面的场地时，栓在柱子上的牛望了我一眼，它应该听到了鸟叫。或许没有。它只是睁着眼睡觉。我正好从它眼睛前面走过，看见它的眼珠亮了一下，像很远的一点星光。我顺着墙根摸到门边上，推了一下门，没推动，门从里面顶住了，又用力推了一下，顶门的木棍往后滑了一下，门开了条缝，我伸手进去，取开顶门棍，侧身进屋，又把门顶住。　房子里什么也看不见，却什么都清清楚楚。我轻脚绕开水缸、炕边上的炉子，甚至连脱了一地的鞋都没踩着一只，沿着炕沿摸过去，摸到*墙的桌子，摸到了最里头了。我脱掉衣服，在顶西边的炕角上悄悄睡下。　这时鸟又叫了一声。像从我们屋前的树上叫的，声音刺破窗户，整个地撞进屋子里。我赶紧蒙住头。　没有一个人被惊醒。　之后鸟再没叫，可能飞走了。过了好大一阵，我掀开蒙在头上的被子，房子里突然亮了一些。月亮出来了，月光透过窗户斜照进来。我侧过身，清晰地看见枕在炕沿上的一排人头。有的侧着，有的仰着，全都熟睡着。　我突然孤独害怕起来，觉得我不认识他们。　第二天中午，我说，昨晚上一只鸟叫得声音很大，像我外爷的声音一样大，太吓人了。家里人都望着我。一家人的嘴忙着嚼东西，没人吭声。只有母亲说了句：你又做梦了吧。我说不是梦，我确实听见了，鸟总共叫了８声。最后飞走了。我没有把话说出来，只是端着碗发呆。　不知太平渠还有谁在那个晚上听到鸟叫了。　那只是一只鸟的叫声。我想。那只鸟或许睡不着，独自在黑暗的天空中漫飞，后来飞到太平渠上空，叫了几声。　它把孤独和寂寞叫出来了。我一声没吭。　更多的鸟在更多的地方，在树上，在屋顶，在天空下，它们不住地叫。尽管鸟不住地叫，听到鸟叫的人，还是极少的。鸟叫的时候，有人在睡觉，有人不在了，有人在听人说话&amp;hellip;&amp;hellip;很少有人停下来专心听一只鸟叫。人不懂鸟在叫什么。那年秋天，鸟在天空聚会，黑压压一片，不知有几千几万只。鸟群的影子遮挡住阳光，整个村子笼罩在阴暗中。鸟粪像雨点一样洒落下来，打在人的脸上、身上，打在树木和屋顶上。到处是斑斑驳驳的白点。人有些慌了，以为要出啥事。许多人聚到一起，胡乱地猜测着。后来全村人聚到一起，谁也不敢单独呆在家里。鸟在天上乱叫，人在地下胡说。谁也听不懂谁。几乎所有的鸟都在叫，听上去各叫各的，一片混乱，不像在商量什么、决定什么，倒像在吵群架，乱糟糟的，从没有停住嘴，听一只鸟独叫。人正好相反，一个人说话时，其他人都住嘴听着，大家都以为这个人知道鸟为啥聚会。这个人站在一个土疙瘩上，把手一挥，像刚从天上飞下来似的，其他人愈加安静了。这个人清清嗓子，开始说话。他的话语杂在鸟叫中，才听还像人声，过一会儿像是鸟叫了。其他人&amp;rdquo;轰&amp;rdquo;地一声开始乱吵，像鸟一样各叫各地起来。天地间混杂着鸟语人声。　这样持续了约摸一小时，鸟群散去，阳光重又照进村子。人抬头看天，一只鸟也没有了。鸟不知散落到了哪里，天空腾空了。人看了半天，看见一只鸟从西边天空孤孤地飞过来，在刚才鸟群盘旋的地方转了几圈，叫了几声，又朝西边飞走了。　可能是只来迟了没赶上聚会的鸟。　还有一次，一群乌鸦聚到村东头开会，至少有几十只，大部分落在路边的老榆树上，树上落不下的，黑黑地站在地上，埂子上，和路上。人都知道乌鸦一开会，村里就会死人，但谁都不知道谁家人会死。整个西边的村庄空掉了，人都拥到了村东边，人和乌鸦离得很近，顶多有一条马路宽的距离。那边，乌鸦黑乎乎地站了一树一地；这边，人群黑压压地站了一渠一路。乌鸦呱呱地乱叫，人群一声不吭，像极有教养的旁听者，似乎要从乌鸦聚会中听到有关自家的秘密和内容。　只有王占从人群中走出来，举着个枝条，喊叫着朝乌鸦群走过去。老榆树旁是他家的麦地。他怕乌鸦踩坏麦子。他挥着枝条边走边&amp;rdquo;啊啊&amp;rdquo;地喊，听上去像另一只乌鸦在叫，都快走到跟前了，却没一只乌鸦飞起来，好像乌鸦没看见似的。王占害怕了，树条举在手里，愣愣地站了半天，掉头跑回到人群里。　正在这时，&amp;rdquo;咔嚓&amp;rdquo;一声，老榆树的一个横枝被压断了，几百只乌鸦齐齐摔下来，机灵点的掉到半空飞起来，更多的掉在地上，或在半空乌鸦碰着乌鸦，惹得人群一阵哄笑。还有一只摔断了翅膀，鸦群飞走后那只乌鸦孤零零地站在树下，望望天空，又望望人群。　全村人朝那只乌鸦围了过去。　那年村里没有死人。那棵老榆树死掉了。乌鸦飞走后树上光秃秃的，所有树叶都被乌鸦踏落了。第二年春天，也没再长出叶子。　&amp;rdquo;你听见那天晚上有只鸟叫了？是只很大的鸟，一共叫了八声。&amp;rdquo;　以后很长时间，我都想找到一个在那天晚上听到鸟叫的人。我问过住在村南头的王成礼和孟二。还问了韩三。第七声鸟叫就是从韩三家房顶上传来的，他应该能听见。如果太平渠真的没人听见，那只鸟就是叫给我一个人听的。我想。　我最终没有找到另一个听见鸟叫的人。以后许多年，我忙于长大自己，已经淡忘了那只鸟的事。它像童年经历的许多事情一样被推远了。可是，在我快４０岁的时候，不知怎的，又突然想起那几声鸟叫来。有时我会情不自禁地张几下嘴，想叫出那种声音，又觉得那不是鸟叫。也许我记错了。也许，只是一个梦，根本没有那个夜晚，没有草垛上独睡的我，没有那几声鸟叫。也许，那是我外爷的声音，他寂寞了，在夜里喊叫几声。我很小的时候，外爷粗大的声音常从高处撞下来，我常常被吓住，仰起头，看见外爷宽大的胸脯和满是胡子的大下巴，有时他会塞一个糖给我，有时会再大喊一声，撵我们走开，到别处玩去！外爷极爱干净，怕我们弄脏他的房子，我们一走开他便拿起扫把扫地。　现在，这一切了无凭据。那个牛圈不在了。高出树梢屋顶的那垛草早被牛吃掉，圈棚倒塌，曾经把一个人举到高处的那些东西消失了。再没有人从这个高度，经历他所经历的一切。 http://sanwenzx.</description>
    </item>
    
    <item>
      <title>uva 11020 - Efficient Solutions ——平衡BST</title>
      <link>http://liuxueyang.github.io/posts/uva-11020---efficient-solutions-%E5%B9%B3%E8%A1%A1bst/</link>
      <pubDate>Thu, 04 Jul 2013 00:25:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva-11020---efficient-solutions-%E5%B9%B3%E8%A1%A1bst/</guid>
      <description>链接：http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=1961 训练指南page228
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;set&amp;gt; using namespace std; struct Point { int a, b; bool operator &amp;lt; (const Point &amp;amp; other) const { return (a &amp;lt; other.a) || (a == other.a &amp;amp;&amp;amp; b &amp;lt; other.b); } }; multiset&amp;lt;Point&amp;gt; S; multiset&amp;lt;Point&amp;gt;::iterator it; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;11020.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif // ONLINE_JUDGE int T; scanf(&amp;quot;%d&amp;quot;, &amp;amp;T); for (int i = 1; i &amp;lt;= T; ++i) { printf(&amp;quot;Case #%d:\n&amp;quot;, i); int n, a, b; scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); S.</description>
    </item>
    
    <item>
      <title>Codeforces Round #190 (Div. 2)  B. Ciel and Flowers</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-#190-div.-2--b.-ciel-and-flowers/</link>
      <pubDate>Wed, 03 Jul 2013 14:14:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-round-#190-div.-2--b.-ciel-and-flowers/</guid>
      <description>链接：http://codeforces.com/contest/322/problem/B 这题做错了。没考虑周全。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; int main(void) { int r, g, b; while (~scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;r, &amp;amp;g, &amp;amp;b)) { int x = r % 3, y = g % 3, z = b % 3, Max = max(x, max(y, z)), cnt =r/3+g/3+b/3; if (Max == 1) { if (x == y &amp;amp;&amp;amp; y == z &amp;amp;&amp;amp; x == 1) cnt++; } if (Max == 2) { if (x + y + z == 4) { if (x*y*z) cnt++; else if (!</description>
    </item>
    
    <item>
      <title>hdu3308  线段树——区间合并</title>
      <link>http://liuxueyang.github.io/posts/hdu3308--%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</link>
      <pubDate>Wed, 03 Jul 2013 14:10:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu3308--%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</guid>
      <description>更新一个点； 求某个区间的最长连续上升序列； 链接：http://acm.hdu.edu.cn/showproblem.php?pid=3308
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define maxn 100009 #define mid int m=(l+r)&amp;gt;&amp;gt;1 int num[maxn], lsum[maxn&amp;lt;&amp;lt;2], rsum[maxn&amp;lt;&amp;lt;2], msum[maxn&amp;lt;&amp;lt;2], n, m, p, v, a, b; void pushup(int o, int l, int r) { mid; if (num[m] &amp;lt; num[m+1]) { lsum[o] = (lsum[o&amp;lt;&amp;lt;1] == m+1-l) ? (m+1-l+lsum[o&amp;lt;&amp;lt;1|1]) : lsum[o&amp;lt;&amp;lt;1]; rsum[o] = (rsum[o&amp;lt;&amp;lt;1|1] == r-m) ? (r-m+rsum[o&amp;lt;&amp;lt;1]) : rsum[o&amp;lt;&amp;lt;1|1]; msum[o] = max(max(msum[o&amp;lt;&amp;lt;1], msum[o&amp;lt;&amp;lt;1|1]), lsum[o&amp;lt;&amp;lt;1|1] + rsum[o&amp;lt;&amp;lt;1]); } else lsum[o] = lsum[o&amp;lt;&amp;lt;1], rsum[o] = rsum[o&amp;lt;&amp;lt;1|1], msum[o] = max(msum[o&amp;lt;&amp;lt;1], msum[o&amp;lt;&amp;lt;1|1]); } void build(int o, int l, int r) { if (l == r) {lsum[o]= rsum[o] = msum[o] = 1; return;} mid; build(o&amp;lt;&amp;lt;1, l, m), build(o&amp;lt;&amp;lt;1|1, m+1, r), pushup(o, l, r); } void update(int o, int l, int r) { if (l == r) {num[p] = v; return;} mid; if (p &amp;lt;= m) update(o&amp;lt;&amp;lt;1, l, m); else update(o&amp;lt;&amp;lt;1|1, m+1, r); pushup(o, l, r); } int query(int o, int l, int r) { if (a &amp;lt;= l &amp;amp;&amp;amp; b &amp;gt;= r) return msum[o]; mid; int ret = 0; if (a &amp;lt;= m) ret = max(ret, query(o&amp;lt;&amp;lt;1, l, m)); if (b &amp;gt; m) ret = max(ret, query(o&amp;lt;&amp;lt;1|1, m+1, r)); if (num[m] &amp;lt; num[m+1]) ret = max(ret, min(m-a+1, rsum[o&amp;lt;&amp;lt;1])+min(b-m, lsum[o&amp;lt;&amp;lt;1|1])); return ret; } int main(void) { int t, n, m; char ch[5]; scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); while (t--) { scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m); for (int i = 1; i &amp;lt;= n; scanf(&amp;quot;%d&amp;quot;, num+i++)); build(1, 1, n); while (m--) { scanf(&amp;quot;%s%d%d&amp;quot;, ch, &amp;amp;a, &amp;amp;b); a++, b++; if (ch[0] == &#39;Q&#39;) printf(&amp;quot;%d\n&amp;quot;, query(1, 1, n)); else p = a, v = b-1, update(1, 1, n); } } return 0; }  。。</description>
    </item>
    
    <item>
      <title>线段树，区间更新</title>
      <link>http://liuxueyang.github.io/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Wed, 03 Jul 2013 14:08:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E6%9B%B4%E6%96%B0/</guid>
      <description>把一个区间内的值全部修改为一个确定值； 计算某个区间内的最大值，最小值，和。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; #define INF 0x7f7f7f7f #define Max 600000 long long a[Max], setv[Max], minv[Max], maxv[Max], sumv[Max], _max, _min, _sum, v; int y1,y2; bool flagv[Max]; inline void maintain(int o, int L, int R) { if (flagv[o]) minv[o] = maxv[o] = setv[o], sumv[o] = (R-L+1)*setv[o]; else if (R &amp;gt; L) minv[o] = min(minv[o*2], minv[o*2+1]), maxv[o] = max(maxv[o*2], maxv[o*2+1]), sumv[o] = sumv[o*2] + sumv[o*2+1]; } void build(int o, int L, int R) { if (L == R) scanf(&amp;quot;%lld&amp;quot;, a+o), minv[o] = maxv[o] = sumv[o] = setv[o] = a[o]; else {int M = L + (R-L)/2; build(o&amp;lt;&amp;lt;1, L, M), build(o*2+1, M+1, R), maintain(o, L, R);} flagv[o] = false; } inline void pushdown(int o) { if (flagv[o]) setv[o&amp;lt;&amp;lt;1] = setv[o&amp;lt;&amp;lt;1|1] = setv[o], flagv[o&amp;lt;&amp;lt;1] = flagv[o&amp;lt;&amp;lt;1|1] = true, flagv[o] = false; } void update(int o, int L, int R) { if (y1 &amp;lt;= L &amp;amp;&amp;amp; y2 &amp;gt;= R) setv[o] = v, flagv[o] = true; else { int M = L + (R-L)/2; pushdown(o); if (y1 &amp;lt;= M) update(o&amp;lt;&amp;lt;1, L, M); else maintain(o&amp;lt;&amp;lt;1, L, M); if (y2 &amp;gt; M) update(o&amp;lt;&amp;lt;1|1, M+1, R); else maintain(o&amp;lt;&amp;lt;1|1, M+1, R); } maintain(o, L, R); } void query(int o, int L, int R) { if (flagv[o]) _sum += setv[o]*(min(y2, R) - max(y1, L) + 1), _min = min(_min, setv[o]), _max = max(_max, setv[o]); else if (y1 &amp;lt;= L &amp;amp;&amp;amp; y2 &amp;gt;= R) _sum += sumv[o], _min = min(_min, minv[o]), _max = max(_max, maxv[o]); else {int M = L + (R-L)/2; if (y1 &amp;lt;= M) query(o&amp;lt;&amp;lt;1, L, M); if (y2 &amp;gt; M) query(o&amp;lt;&amp;lt;1|1, M+1, R);} } int main(void) { freopen(&amp;quot;input.</description>
    </item>
    
    <item>
      <title>vim 被墙</title>
      <link>http://liuxueyang.github.io/posts/vim-%E8%A2%AB%E5%A2%99/</link>
      <pubDate>Thu, 27 Jun 2013 21:49:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/vim-%E8%A2%AB%E5%A2%99/</guid>
      <description>我只能说，呵呵。还好这货可以进。 http://vim.wendal.net/ </description>
    </item>
    
    <item>
      <title>ubuntu12.04 修复Grub2</title>
      <link>http://liuxueyang.github.io/posts/ubuntu12.04-%E4%BF%AE%E5%A4%8Dgrub2/</link>
      <pubDate>Thu, 27 Jun 2013 20:39:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/ubuntu12.04-%E4%BF%AE%E5%A4%8Dgrub2/</guid>
      <description>电脑双系统，但是把win7重装了之后，会发现grub坏了，只能进入win7。 遇到过好几次，虽然每次都成功解决问题了，但是都花费了不少时间。 所以，总结一下，基本是从网上找到的方法，有的行不通，有的可以。就我的尝试，总结了一下对我的电脑来说，比较有效的方法。 首先说明：我的boot分区没有单独分区！ 第一步： 用光盘进入Ubuntu LiveCD，打开终端，
sudo fdisk -l  找到 id 是83的那行，可惜我的有两个：/dev/sda3 和 /dev/sda8 。一般的应该有一行的……囧，可能是装系统的时候没搞好o(╯□╰)o 后来尝试发现，用 /dev/sda3 才是正确的。记住这个号码，考虑到一般性，这里记为/dev/sdaX 第二步：sudo -i 获得root权限 mkdir /media/tempdir   挂载：
mount /dev/sdaX /media/tempdir grub-install --root-directory=/media/tempdir /dev/sda   第三步：重启，可能会进入到 grub rescue 界面。 输入set，查看相应的设置。然后修改：
set prefix=(hd0,msdos3)/boot/grub set root=hd0,msdos3 insmod normal normal   然后就发现进入原来的grub启动界面了。进入Ubunt系统 第四步：打开终端， 重启，收工。
sudo update-grub sudo grub-install /dev/sda   注：参考网站 http://forum.ubuntu.org.cn/viewtopic.php?f=139&amp;amp;t=348503 http://hi.baidu.com/radio585/item/87462cf98bc70f1ae3e3bdab http://www.linuxidc.com/Linux/2012-06/61983p2.htm http://forum.ubuntu.org.cn/viewtopic.php?t=297514 为了以后方便，我这些网页里的内容做成文件的格式留在这里，省的以后再搞。。=_= http://s.yunio.com/Ee6n8z  为了上传方便，这货是.rar格式的。可以先把文件在win下解压，拷到U盘里面，然后用LiveCD进入Ubuntu再看，文件时图片和.pdf，Ubuntu兼容。 上面那个链接貌似失效了……囧。追加一个百度网盘：http://pan.baidu.com/share/link?shareid=1185935304&amp;amp;uk=322048121</description>
    </item>
    
    <item>
      <title>点头1010 只包含因子2 3 5的数</title>
      <link>http://liuxueyang.github.io/posts/%E7%82%B9%E5%A4%B41010-%E5%8F%AA%E5%8C%85%E5%90%AB%E5%9B%A0%E5%AD%902-3-5%E7%9A%84%E6%95%B0/</link>
      <pubDate>Sat, 15 Jun 2013 17:24:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E7%82%B9%E5%A4%B41010-%E5%8F%AA%E5%8C%85%E5%90%AB%E5%9B%A0%E5%AD%902-3-5%E7%9A%84%E6%95%B0/</guid>
      <description>题目链接：http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1010 题目思路： 想想怎么打表吧，还有，只需要存下满足要求的数字，要求的数字可以表示为：(2^x*3^y*5^z)，然后可以发现：2^60&amp;gt;10^18，所以，枚举的上限是60*60*60，大约是216000，实际上，只有1万多。枚举的方法就是以前做过的题目了：http://poj.org/problem?id=1338 然后就是二分查找，边界比较纠结。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdlib&amp;gt; #define LL long long #define MAXN 216000+10 #define min(a,b) ((a)&amp;lt;(b)?(a):(b)) LL a[MAXN]; int main(void) { int i, j, k, p; i = j = k = 0; a[0] = 1; for (p = 1; p &amp;lt;= 12690; ++p) { a[p] = min(a[i]*2, min(a[j]*3, a[k]*5)); if (a[p] == a[i] * 2) ++i; if (a[p] == a[j] * 3) ++j; if (a[p] == a[k] * 5) ++k; } int T; scanf(&amp;quot;%d&amp;quot;,&amp;amp;T); while (T--) { LL n; scanf(&amp;quot;%I64d&amp;quot;, &amp;amp;n); int low = 1, high = 12690, mid, last; LL goal; goal = n; while (low &amp;lt; high) { mid = low + (high - low) / 2; if (a[mid] &amp;lt; goal) low = mid + 1; else if (a[mid] &amp;gt; goal) high = mid - 1; else {last = mid; break;} } if (high == low) { last = high; } else if (low &amp;gt; high) last = low; if (goal == 1) last = 1; if (a[last] &amp;lt; goal) last++; printf(&amp;quot;%I64d\n&amp;quot;, a[last]); } return 0; }  输入输出原来要用%I64d，这个WA了两次……A了之后竟然是第一名，呵呵，可能大家都没有手写二分，都用的STL吧。</description>
    </item>
    
    <item>
      <title>准备期末考试 博客不更了</title>
      <link>http://liuxueyang.github.io/posts/%E5%87%86%E5%A4%87%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95-%E5%8D%9A%E5%AE%A2%E4%B8%8D%E6%9B%B4%E4%BA%86/</link>
      <pubDate>Sat, 08 Jun 2013 18:48:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%87%86%E5%A4%87%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95-%E5%8D%9A%E5%AE%A2%E4%B8%8D%E6%9B%B4%E4%BA%86/</guid>
      <description>今天高考结束了……大家都考得挺好的吧，祝福他们。 高考结束后，马上又将会有这么一群孩子，迫不及待的扔下书包，去聚餐，通宵上网，旅行，KTV，闲逛，狂欢……认为自己终于解放了……殊不知，你们离开的，就是天堂。 认真准备期末考试，虽然还是有的时候忍不住会写代码，囧。昨天CF做得真的挫了。这就是一周不写程序的后果，呵呵。坚决不写程序了，准备考试！实在无聊看看python，haskell什么的……</description>
    </item>
    
    <item>
      <title>Codeforces Round #187 (Div. 2) B. Sereja and Array</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-#187-div.-2-b.-sereja-and-array/</link>
      <pubDate>Sat, 08 Jun 2013 18:38:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-round-#187-div.-2-b.-sereja-and-array/</guid>
      <description>题目链接：http://codeforces.com/contest/315/problem/B 开始以为线段树，汗……原来是道水题
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;queue&amp;gt; using namespace std; typedef struct Po { int d, a; }Po; Po p[100000+10]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;187b.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif int n, m; scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m); for (int i = 1; i &amp;lt;= n; ++i) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;p[i].a); p[i].d = 0; } int D = 0, t, s; for (int i = 0; i &amp;lt; m; ++i) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); if (t == 1) { int st, en; scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;st, &amp;amp;en); p[st].</description>
    </item>
    
    <item>
      <title>Codeforces Round #187 (Div. 2) A. Sereja and Bottles</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-#187-div.-2-a.-sereja-and-bottles/</link>
      <pubDate>Sat, 08 Jun 2013 18:35:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-round-#187-div.-2-a.-sereja-and-bottles/</guid>
      <description>题目链接：http://codeforces.com/contest/315/problem/A 这到题目比赛的时候过了，赛后WA了……虽然很简单，但是还是没想太清楚
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; #define MAX 103 int a[MAX], b[MAX]; int main(void) { int n; #ifndef ONLINE_JUDGE freopen(&amp;quot;187a.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { for (int i = 0; i &amp;lt; n; ++i) scanf(&amp;quot;%d%d&amp;quot;, a+i, b+i); int cnt = 0; for (int i = 0; i &amp;lt; n; ++i) { bool flag = false; for (int j = 0; j &amp;lt; n; ++j) { if (i!</description>
    </item>
    
    <item>
      <title>NYOJ5 Binary String Matching ——KMP</title>
      <link>http://liuxueyang.github.io/posts/nyoj5-binary-string-matching-kmp/</link>
      <pubDate>Mon, 03 Jun 2013 01:38:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/nyoj5-binary-string-matching-kmp/</guid>
      <description>题目链接：http://acm.nyist.net/JudgeOnline/problem.php?pid=5 题目思路： 典型的KMP，关键就是修改一下，找到了模式串p之后，继续从大的串s里面模式串开始的位置的下一个位置开始找下一个。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; char p[1000], s[1000]; int next[1000]; void getnext() { int i = 0, j = -1, len = strlen(p); next[0] = -1; while (i &amp;lt; len - 1) { if (j == -1 || p[j] == p[i]) { j++; i++; next[i] = j; } else j = next[j]; } } int kmp() { int i = -1, j = -1, lenp = strlen(p), lens = strlen(s); getnext(); int num = 0; while (i &amp;lt; lens) { if (j == -1 || s[i] == p[j]) {++i; ++j;} else j = next[j]; if (j == lenp) {i-=j; j = -1; num++;} } return num; } int main(void) { int n; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) while (n--){ scanf(&amp;quot;%s%s&amp;quot;, p, s); printf(&amp;quot;%d\n&amp;quot;, kmp()); } return 0; }  复习了一下KMP，很有意思~ 看到了一个STL的方法，碉堡了…… #include &amp;lt;cstdio&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; string s, p; int main(void) { int n; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { while (n--) { cin &amp;gt;&amp;gt; p &amp;gt;&amp;gt; s; int num = 0; unsigned ans = 0; ans = s.</description>
    </item>
    
    <item>
      <title>KMP示例程序</title>
      <link>http://liuxueyang.github.io/posts/kmp%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Mon, 03 Jun 2013 01:28:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/kmp%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/</guid>
      <description>输入： 数字N，然后是N组数据，每一组数据第一行是模式串p，第二行是一个大的字符创s，如果在s里面出现了p，那么输出p第一次出现的位置，否则输出No #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; char p[1000], s[1000]; int next[1000]; void getnext() { int i = 0, j = -1, len = strlen(p); next[0] = -1; while (i &amp;lt; len - 1) { if (j == -1 || p[j] == p[i]) { j++; i++; next[i] = j; } else j = next[j]; } } int kmp() { int i = -1, j = -1, lenp = strlen(p), lens = strlen(s); getnext(); while (j !</description>
    </item>
    
    <item>
      <title>hdu1420 Prepared for New Acmer ——快速幂</title>
      <link>http://liuxueyang.github.io/posts/hdu1420-prepared-for-new-acmer-%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Sat, 01 Jun 2013 19:33:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1420-prepared-for-new-acmer-%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1420 题目大意： 中文题。 题目思路： 赤裸裸的快速幂。呵呵
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; #define LL long long LL m; LL Po(LL a, LL b) { LL ans = 1; while (b) { if (b&amp;amp;1) { ans = (ans * a) % m; b--; } b /= 2; a = a * a % m; } return ans; } int main(void) { LL n, a, b; #ifndef ONLINE_JUDGE freopen(&amp;quot;1420.</description>
    </item>
    
    <item>
      <title>hdu1257 最少拦截系统 ——DP么？</title>
      <link>http://liuxueyang.github.io/posts/hdu1257-%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F-dp%E4%B9%88/</link>
      <pubDate>Sat, 01 Jun 2013 18:43:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1257-%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F-dp%E4%B9%88/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1257 题目大意： 中文的…… 题目思路： 人家说是DP，求最长不升子序列的个数。好吧……我不是那么做的。 我的思路是，从前往后扫一遍，访问过的标记为true，记录一下个数就ＯＫ了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int b[1000]; bool a[1000]; int main(void) { int n; #ifndef ONLINE_JUDGE freopen(&amp;quot;1257.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { int i, j, cnt = 0; for (i = 0; i &amp;lt; n; ++i) scanf(&amp;quot;%d&amp;quot;, b+i); memset(a, false, sizeof(a)); for (i = 0; i &amp;lt; n; ++i) { while (a[i]) ++i; if (i == n) break; if (!</description>
    </item>
    
    <item>
      <title>Codeforces Round #185 (Div. 2) B. Archer</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-#185-div.-2-b.-archer/</link>
      <pubDate>Fri, 31 May 2013 11:10:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-round-#185-div.-2-b.-archer/</guid>
      <description>题目链接：http://codeforces.com/problemset/problem/312/B 题目大意： 很简短，不解释了。 题目思路： 开始怎么也读不懂题意，以为求期望呢，想不开……后来问了别人才知道，原来就是求概率，也没说多少个回合，所以就是求极限…… 所以，这货就是一道很简洁的概率题，推个公式就好了。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; int main(void) { int a, b, c, d; double p1, p2, ans; scanf(&amp;quot;%d%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c, &amp;amp;d); p1 = 1.0*a/b; p2 = 1.0*c/d; ans = p1/(1-(1-p1)*(1-p2)); printf(&amp;quot;%.12f\n&amp;quot;, ans); return 0; }   开始为什么怎么也读不懂捏？果然是理解能力差么？ 这题几天前做的，忘了总结一下了。</description>
    </item>
    
    <item>
      <title>Codeforces Round #186 (Div. 2) C. Ilya and Matrix</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-#186-div.-2-c.-ilya-and-matrix/</link>
      <pubDate>Fri, 31 May 2013 11:04:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-round-#186-div.-2-c.-ilya-and-matrix/</guid>
      <description>题目链接：http://codeforces.com/problemset/problem/313/C 题目大意： 还是看原题吧，意思不难懂。 题目思路： 开始一直没有想法，后来听一然酱讲了才好不容易搞懂，赶脚好神奇。 构造的思路应该算贪心，先把前4大的数字排列到最先划分的4个方格里面，然后再依次把后面比较大的数字依次填充到这四个方格里空着的小格子里面，直到所有的格子填满为止，为什么这个思路是正确的呢？还是模拟一下4*4的格子就差不多理解了吧。 但是关键是怎么算出递归得到的结果？一然酱的思路很巧妙，先把数字逆序排列，再把前序和算出来，目的是方便后面的求和，然后从递归的最底层开始考虑。最底层肯定是所有的数字都包括，也就是前N个数字的和，再往上走，就是前N/4个数字的和，直到N&amp;lt;1为止。碉堡了…… #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; #define LL long long int const int MAX = 1000000*2+10; LL a[MAX], ans, n; bool cmp2(LL a, LL b) { return a &amp;gt; b; } int main(void) { while (~scanf(&amp;quot;%I64d&amp;quot;, &amp;amp;n)) { int i; for (i = 0; i &amp;lt; n; ++i) scanf(&amp;quot;%I64d&amp;quot;, a+i); sort(a, a+n, cmp2); for (i = 1; i &amp;lt; n; ++i) a[i] += a[i-1]; ans = 0; while (n &amp;gt;= 1) { ans += a[n-1]; n = n &amp;gt;&amp;gt; 2; } printf(&amp;quot;%I64d\n&amp;quot;, ans); } return 0 ; }   然后就是注意一下类型用LL…… 这回跟一然酱去网吧做CF，感触颇深，看人家神牛怎么做比赛的，给跪……谢谢一然酱~ </description>
    </item>
    
    <item>
      <title>Codeforces Round #185 (Div. 1) A. The Closest Pair</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-#185-div.-1-a.-the-closest-pair/</link>
      <pubDate>Thu, 30 May 2013 00:05:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforces-round-#185-div.-1-a.-the-closest-pair/</guid>
      <description>题目链接：http://codeforces.com/problemset/problem/311/A 题目大意： 题目很短，不解释了。^_^ 题目思路： 开始感觉很难，没思路。看了解题报告，发现原来是道水题嘛。程序里面有个break语句，要让循环次数达到最大，并且循环次数容易计算，只需要让这个break;永远不会执行就可以了。也就是说，可以让p[j].x - p[i].x &amp;gt;= d 永远不成立，只需要让p[j].x - p[i].x总等于0就可以了！因为题目让生成任意一组符合条件的数据嘛，所以，可以让产生的所有的点的横坐标都是一样的就可以了。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; #define LL long long int main(void) { #ifndef ONLINE_JUDGE //freopen(&amp;quot;185_c.in1&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif LL n, k; scanf(&amp;quot;%I64d%I64d&amp;quot;, &amp;amp;n, &amp;amp;k); if (n*(n-1)/2 &amp;lt;= k){ printf(&amp;quot;no solution\n&amp;quot;); } else { for (int i = 0; i &amp;lt; n; ++i) { printf(&amp;quot;1 %d\n&amp;quot;, i); } } return 0; }  很简单的思路，当初为什么没有想到？</description>
    </item>
    
    <item>
      <title>The Unique MST ——最小生成树的唯一性</title>
      <link>http://liuxueyang.github.io/posts/the-unique-mst-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7/</link>
      <pubDate>Sun, 26 May 2013 23:58:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/the-unique-mst-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7/</guid>
      <description>题目链接：http://acm.hust.edu.cn/vjudge/contest/view.action?cid=24534#problem/C 题目大意： 判断最小生成树是否唯一。 题目思路： 对于如果有一条边A在最小生成树里面，并且存在和这条边权值一样的另外一条边B，那么再次求最小生成树的时候，把A去掉，看看求出的最小生成树是不是和原来的最小生成树权值一样。如果一样，就是不唯一，否则就刚才去掉的加进来，然后再找下一条这样的边。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define MAXN 110 #define MAXM 5009 typedef struct edge { int u, v, w, used, del, equal; bool operator &amp;lt; (const edge &amp;amp;other) const { return w &amp;lt; other.w; } }edge; edge edges[MAXM]; int parent[MAXN]; bool first; int n, m, i, j; void init() { for (i = 1; i &amp;lt;= n; ++i) parent[i] = -1; } int find(int x) { int s; for (s = x; parent[s] &amp;gt;= 0; s = parent[s]) ; while (s !</description>
    </item>
    
    <item>
      <title>Constructing Roads ——最小生成树</title>
      <link>http://liuxueyang.github.io/posts/constructing-roads-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <pubDate>Sun, 26 May 2013 23:52:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/constructing-roads-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <description>题目链接：http://acm.hust.edu.cn/vjudge/contest/view.action?cid=24534#problem/B 题目大意： 给邻接矩阵，和已经建立好的几条边。求最小生成树权值。 题目思路： 方法就是把已将建立好的边的权值赋值为0即可。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define MAXN 110 #define MAXM 5009 typedef struct edge { int u, v, w; bool operator &amp;lt; (const edge &amp;amp;other) const { return w &amp;lt; other.w; } }edge; edge edges[MAXM]; int parent[MAXN]; int n, m, i, j; void init() { for (i = 1; i &amp;lt;= n; ++i) parent[i] = -1; } int find(int x) { int s; for (s = x; parent[s] &amp;gt;= 0; s = parent[s]) ; while (s !</description>
    </item>
    
    <item>
      <title>Agri-Net ——最小生成树</title>
      <link>http://liuxueyang.github.io/posts/agri-net-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <pubDate>Sun, 26 May 2013 23:50:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/agri-net-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <description>题目链接：http://acm.hust.edu.cn/vjudge/contest/view.action?cid=24534#problem/A 题目大意： 给定无向图，邻接矩阵。求最小生成树权值。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define MAXN 110 #define MAXM 5009 typedef struct edge { int u, v, w; bool operator &amp;lt; (const edge &amp;amp;other) const { return w &amp;lt; other.w; } }edge; edge edges[MAXM]; int parent[MAXN]; int n, m, i, j; void init() { for (i = 1; i &amp;lt;= n; ++i) parent[i] = -1; } int find(int x) { int s; for (s = x; parent[s] &amp;gt;= 0; s = parent[s]) ; while (s !</description>
    </item>
    
    <item>
      <title>hdu1176 免费馅饼 ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu1176-%E5%85%8D%E8%B4%B9%E9%A6%85%E9%A5%BC-dp/</link>
      <pubDate>Sat, 25 May 2013 17:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1176-%E5%85%8D%E8%B4%B9%E9%A6%85%E9%A5%BC-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1176 题目大意： 中文题…… 题目思路： 类似于 Triangle 。d[i][j] 表示 i 时间在 j 位置的所得到的价值。然后就像 Triangle 一样从下往上递推。最终求在0秒的时候，在5位置上的值。 ＷＡ了两次，当初求的是0秒的时候，所有位置上的最大值，，这显然是不对的。因为起始位置是5啊。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; const int MAX = 100000+10; int a[MAX][11], d[MAX][11]; void init() { int m, i, j, x, t, tMax = -1; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;m) &amp;amp;&amp;amp; m) { memset(a, 0, sizeof(a)); memset(d, 0, sizeof(d)); for (i = 0; i &amp;lt; m; ++i) { scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;x, &amp;amp;t); if (tMax &amp;lt; t) tMax = t; a[t][x]++; } for (i = 0; i &amp;lt;= 10; ++i) d[tMax][i] = a[tMax][i]; for (i = tMax-1; i&amp;gt;= 0; --i) { for (j = 0; j &amp;lt;= 10; ++j) { if (j == 0) { d[i][j] = max(d[i+1][j], d[i+1][j+1]) + a[i][j]; continue; } else if (j == 10) { d[i][j] = max(d[i+1][j], d[i+1][j-1]) + a[i][j]; continue; } d[i][j]=max(d[i+1][j], max(d[i+1][j+1], d[i+1][j-1]))+a[i][j]; } } printf(&amp;quot;%d\n&amp;quot;, d[0][5]); } } int main(void) { init(); return 0; }  很多题目都是相通的</description>
    </item>
    
    <item>
      <title>poj1018 Communication System ——贪心&#43;枚举</title>
      <link>http://liuxueyang.github.io/posts/poj1018-communication-system-%E8%B4%AA%E5%BF%83&#43;%E6%9E%9A%E4%B8%BE/</link>
      <pubDate>Sat, 25 May 2013 06:16:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1018-communication-system-%E8%B4%AA%E5%BF%83&#43;%E6%9E%9A%E4%B8%BE/</guid>
      <description>题目链接：http://poj.org/problem?id=1018 题目大意： 有n种设备，每种设备有mi个选择，每种设备选择一个，每个设备都有一个带宽值和价钱，要求每种设备选择一个，最终选择的n个设备里面，带宽B是这n个设备里面所有带宽的最小值吗，价钱P为这n个设备价钱的和，求B/P的最大值。 题目思路： 这题开始没读懂题意，后来搜的题意之后才明白。然后没有思路……看了人家的思路，貌似懂了……然后就开始写，写跪了……开始的方法是，求出所有这n种设备里面每种设备的带宽的最小值，依次枚举这些最小值就可以了。总是WA…… 昨天纠结一晚上，今天早上又想了一下，发现原来的想法是有问题的，应该一直枚举到所有n中设备里面每种带宽的最大值的最小值。第一：保证这n种设备每一种都可以选上。第二：虽然枚举的B值比原来大了，所得到的的价钱不小于我原来的做法所得到的的价钱，但是，重点来了：B也增大了啊！有木有！所以，这就是我当初没有想到的！ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define MAXN 0x7fffffff #define MINN -MAXN const int MAX = 100+10; typedef struct node { int p, b, cnt; bool operator &amp;lt; (const node &amp;amp; other ) const { if (p != other.p) return p &amp;lt; other.p; else return b &amp;lt; other.b; } }node; typedef struct sys { node de[MAX]; int Min, Max, cnt; bool operator &amp;lt; (const sys &amp;amp;other) const { return Min &amp;lt; other.</description>
    </item>
    
    <item>
      <title>设置zsh为系统默认shell</title>
      <link>http://liuxueyang.github.io/posts/%E8%AE%BE%E7%BD%AEzsh%E4%B8%BA%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4shell/</link>
      <pubDate>Fri, 24 May 2013 18:47:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E8%AE%BE%E7%BD%AEzsh%E4%B8%BA%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4shell/</guid>
      <description>whereis zsh 就会显示zsh的路径，一般是 /bin/zsh 然后输入 chsh -s /bin/zsh 会提示输入密码，然后重新登录就好了～ 同样，如果设置其它的shell，也是类似的做法。</description>
    </item>
    
    <item>
      <title>hdu2069 Coin Change ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu2069-coin-change-dp/</link>
      <pubDate>Fri, 24 May 2013 11:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu2069-coin-change-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2069 题目大意： 给一个数字，用1, 5, 10， 25, 50 这五种硬币，最多用100枚，有多少种组合方式。 题目思路： 这道题和之前的题目不同，有了硬币个数的限制，所以需要加上一维表示硬币的个数就可以了。d[i][j]表示价值为 i 的最多用 j 枚硬币有多少中组合方式。很多人用母函数做，感觉DP做简单多了…… 参考博客：http://www.cnblogs.com/qiufeihai/archive/2012/09/11/2680840.html
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; const int MAX = 250+10; int d[MAX][MAX], n, a[5] = {1, 5, 10, 25, 50}; void solve() { while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { int i, j, k; memset(d, 0, sizeof(d)); d[0][0] = 1; for (k = 0; k &amp;lt; 5; ++k) { for (j = 1; j &amp;lt;= 100; ++j) { for (i = a[k]; i &amp;lt;= n; ++i) { d[i][j] += d[i-a[k]][j-1]; } } } int sum(0); for (i = 0; i &amp;lt;= n; ++i) { sum += d[n][i]; } printf(&amp;quot;%d\n&amp;quot;, sum); } } int main(void) { solve(); return 0; }  　还有要注意一点，初始化要d[0][0] = 1 因为题目中说：Note that we count that there is one way of making change for zero cent.</description>
    </item>
    
    <item>
      <title>2013年5月23日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8823%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Thu, 23 May 2013 23:46:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8823%E6%97%A5-%E6%99%B4/</guid>
      <description>最近长沙的天气啊，不是下雨就是下雨……无语O__O&amp;rdquo;… 今天晚上终于去跑步了，穿上跑鞋，还有差不多半年没有穿过的棒球队队服，去跑步吧~ 开始感觉不错，节奏还不错，跑得略快，到一半的时候，感觉有点吃不消啊，还好后来放慢速度，把节奏调整好了，继续跑着，又是一个月明风清的晚上，湘江边对面的灯光很美，就那么不快不慢地跑着，多好，人生一大幸事啊。夏天来了，汗水，激情，奋斗，梦想，青春，就是这样的吧，加油 最后还是跑完全程5K了。虽然也许永远也达不到高中的时候48分钟跑完10K的那种状态了，但是跑步也不全是为了速度或者成绩，高兴就行了，实力是在不知不觉中增长的。 说好了晚上回宿舍就补作业不写程序的，结果……不知不觉写了一晚上的程序，，然后就跑步去了，，回来就十点半了……又写了会儿程序，，就到现在了……果然还是没写作业啊……要交作业了还没有预习完有木有……果然是要通宵补作业了么…… 学习时间可以少，但是效率一定要高！ 身边总有些人在无私地帮助我，鼓励我，谢谢你们~</description>
    </item>
    
    <item>
      <title>hdu1398 Square Coins ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu1398-square-coins-dp/</link>
      <pubDate>Thu, 23 May 2013 23:20:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1398-square-coins-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1398 题目大意： 给一个数字，不大于300，求有多少种用完全平方数表示这个数字的方法 题目思路： 方法跟hdu1283一样一样的……只需要把那道题目的代码稍微改一下就可以过了 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n) &amp;amp;&amp;amp; n) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &amp;lt;= floor(sqrt(n)); ++i) { for (j = i*i; j &amp;lt;= n; ++j) { d[j] += d[j-i*i]; } } printf(&amp;quot;%lld\n&amp;quot;, d[n]); } } int main(void) { solve(); return 0; }   因为题目的范围很小嘛，只有300。 </description>
    </item>
    
    <item>
      <title>hdu1284 钱币兑换问题 ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu1284-%E9%92%B1%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-dp/</link>
      <pubDate>Thu, 23 May 2013 20:39:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1284-%E9%92%B1%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1284 题目大意： 中文题…… 题目思路： 只有3个硬币，范围是32768，可以一个一个枚举硬币，如果只放价值为1的硬币，从d[1]递推到d[n]；如果再加上价值为2的硬币，那么就从d[2]递推到d[n]；在加上价值为3的硬币，就从d[3]递推到d[n].递推公式是d[j] = d[j] + d[j-i]； d[j]表示j有几种只用1，2, 3这三个数字的拆分方法，i 就是硬币的价值。 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &amp;lt;= 3; ++i) { for (j = i; j &amp;lt;= n; ++j) { d[j] += d[j-i]; } } printf(&amp;quot;%lld\n&amp;quot;, d[n]); } } int main(void) { solve(); return 0; }   参考博客：http://www.</description>
    </item>
    
    <item>
      <title>hdu1028 Ignatius and the Princess III ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu1028-ignatius-and-the-princess-iii-dp/</link>
      <pubDate>Thu, 23 May 2013 19:48:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1028-ignatius-and-the-princess-iii-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1028 题目大意：　整数拆分，给一个整数n,求它有多少种拆分方法。 题目思路： 做法一： d[i][j]表示把整数 i 拆成最多 j 个数字所具有的方法数。那么 if (i &amp;gt;ｊ)　d[i][j] = d[i-j][j] + d[i][j-1]; 意思就是如果i&amp;gt;j，那么有两种方式：一种是先把i里面分理处j个1，然后再把i-j拆成最多i-j个数字；另一种是把i拆分成最多j-1个数字。 if (i &amp;lt; j) d[i][j] = d[i][i]; 意思就是如果i&amp;lt;j，那么这种情况和把数字i最多拆成i个数字的是一样的。 if (i == j) d[i][j] = d[i][j-1] + 1; 意思就是如果i==j，那么可以把数字i拆分成j-1个数字，也可以把数字i拆分成i个1（这个就是那个1的意义） #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; #define LL long long int d[140][140], n; void init() { while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { int i, j; memset(d, 0, sizeof(d)); for (i = 0; i &amp;lt;= n; ++i) d[i][1] = d[1][i] = 1; for (i = 2; i &amp;lt;= n; ++i) { for (j = 1; j &amp;lt;= n; ++j) { if (i &amp;gt; j) d[i][j] = d[i-j][j] + d[i][j-1]; else if (i == j) d[i][j] = 1 + d[i][j-1]; else d[i][j] = d[i][i]; } } cout &amp;lt;&amp;lt; d[n][n] &amp;lt;&amp;lt; endl; } } int main(void) { init(); return 0 ; }   剩下的就是考虑一下边界，比如当 i 或者 j 等于1的时候，显然都是只有一种拆分情况。 做法二： 借用hdu1284这道题的方法，也可以做这道题目，因为n的范围是120嘛,两个算法的复杂度都是O(n^2)的，当然可以了。只需要把hdu1284的代码里面把3改成n，这题就过了…… #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &amp;lt;= n; ++i) { for (j = i; j &amp;lt;= n; ++j) { d[j] += d[j-i]; } } printf(&amp;quot;%lld\n&amp;quot;, d[n]); } } int main(void) { solve(); return 0; }   优化到了一维数组，这个方法碉堡了…… 参考博客：http://www.</description>
    </item>
    
    <item>
      <title>hdu1394 Minimum Inversion Number ——线段树</title>
      <link>http://liuxueyang.github.io/posts/hdu1394-minimum-inversion-number-%E7%BA%BF%E6%AE%B5%E6%A0%91/</link>
      <pubDate>Thu, 23 May 2013 18:25:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1394-minimum-inversion-number-%E7%BA%BF%E6%AE%B5%E6%A0%91/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1394 题目大意： 给定一个0到ｎ-1的数字组成的序列，它的逆序数，然后把第一个数字放到末尾，得到一个新的序列，再求逆序数，再把新序列的第一个数字放到末尾，一直这样做，求所有这些序列的逆序数的最小值。 题目思路： 可以先求出起初的序列的逆序数。然后根据逆序数的定义，把一个数字从开头移动到末尾，逆序数的改变量是什么？求出这个改变量，然后剩下的所有序列的逆序数就都求出来了。 这样考虑：一个数字 ｂ[i] 在开头，比它大的数字有 ｂ[i] 个，也就是说和这个数字组成了 ｂ[i] 个逆序，把它放到最后，这个数字可以组成 n-1-ｂ[i] 个逆序，所以逆序数的增量是 n - 1 - ｂ[i] - ｂ[i] ，这样就可以根据原来的序列的逆序数求出剩下的所有序列的逆序数了～
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; const int MAX = 5000+10; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 int a[MAX&amp;lt;&amp;lt;2], b[MAX], n; void pushup(int rt) { a[rt] = a[rt&amp;lt;&amp;lt;1] + a[rt&amp;lt;&amp;lt;1|1]; } void build(int l, int r, int rt) { if (l == r) {a[rt] = 0; return;} int m = (l + r) &amp;gt;&amp;gt; 1; build(lson); build(rson); pushup(rt); } void update(int p, int l, int r, int rt) { if (l == r) {a[rt]++; return;} int m = (l + r) &amp;gt;&amp;gt; 1; if (p &amp;lt;= m) update(p, lson); else update(p, rson); pushup(rt); } int query(int L, int R,int l, int r, int rt) { if (L &amp;lt;= l &amp;amp;&amp;amp; R &amp;gt;= r) {return a[rt];} int m = (l + r) &amp;gt;&amp;gt; 1, ret = 0; if (L &amp;lt;= m) ret += query(L, R, lson); if (R &amp;gt; m) ret += query(L, R, rson); return ret; } void init() { while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { int i, sum = 0, ans; build(0, n - 1, 1); for (i = 0; i &amp;lt; n; ++i) { scanf(&amp;quot;%d&amp;quot;, b+i); sum += query(b[i]+1, n-1, 0, n-1, 1); update(b[i], 0, n-1, 1); } ans = sum; for (i = 0; i &amp;lt; n; ++i) { sum += (n-1-2*b[i]); if (sum &amp;lt; ans) ans = sum; } printf(&amp;quot;%d\n&amp;quot;, ans); } } int main(void) { init(); return 0; }  这题是线段树的单点更新</description>
    </item>
    
    <item>
      <title>poj2299 Ultra-QuickSort ——线段树</title>
      <link>http://liuxueyang.github.io/posts/poj2299-ultra-quicksort-%E7%BA%BF%E6%AE%B5%E6%A0%91/</link>
      <pubDate>Thu, 23 May 2013 14:40:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj2299-ultra-quicksort-%E7%BA%BF%E6%AE%B5%E6%A0%91/</guid>
      <description>题目链接：http://poj.org/problem?id=2299 题目大意： 给n个任意的数字，把他们排序，求最少的交换次数。 题目思路： 开始没想法。后来zjl一说才知道。原来就是求逆序数！每一个数字前面有多少比它小的，这个数字就至少要交换多少次。所以，只需要求这列数字的逆序数就可以！好神奇 还有一个，就是每个数字的范围比较大，开始我还在想开数组貌似放不下，后来zjl说离散化……好吧，果然，我肿么没想到o(╯□╰)o感觉挺自然的想法啊…… 剩下的就是原来做过的题目了……甚至比原来做过的还简单 最后一个问题就是，最后的结果应该是long long 的，稍微算一下就知道，最大值(2*10^11)超过了4个字节的整型范围(4 * 10^9)，long long 范围是(1*10^19)，所以输出要按照long long 输出……这个问题以后一定要注意，判断一下数字的范围！别傻乎乎地就用int…… //#define LOCAL #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 500000+10; typedef struct node { int val, index; bool operator &amp;lt; (const node &amp;amp; other) const { return val &amp;lt; other.</description>
    </item>
    
    <item>
      <title>入门经典 7.1.1 除法</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-7.1.1-%E9%99%A4%E6%B3%95/</link>
      <pubDate>Wed, 22 May 2013 18:32:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-7.1.1-%E9%99%A4%E6%B3%95/</guid>
      <description>开始没思路，但是仔细思考一下，发现可以枚举，然后找一下上界和下界，可以知道范围并不大。我的枚举量是将近50000的样子，书上说枚举量可以降低到10000……没懂，再想一下
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;map&amp;gt; using namespace std; map&amp;lt;int, bool&amp;gt; mymap; void solve(int i) { while (i) { mymap[i%10] = true; i /= 10; } } void init() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { for (i = 1200; i &amp;lt; 50000; ++i) { if ((i*n)/10000 == 0 || (i*n)/10000 &amp;gt;= 10) continue; mymap.clear(); solve(i); solve(i * n); if (i/10000 == 0) mymap[0] = true; for (j = 0; j &amp;lt; 10; ++j) { if (!</description>
    </item>
    
    <item>
      <title>uva11078 Open Credit System</title>
      <link>http://liuxueyang.github.io/posts/uva11078-open-credit-system/</link>
      <pubDate>Tue, 21 May 2013 18:26:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva11078-open-credit-system/</guid>
      <description>题目链接：http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=2019 题目大意： 给一个长度为n的序列，求Ai - Aj (i &amp;lt; j)的最大值。序列的长度最大是10^5 题目思路： 动态维护某一个数字之前的最大值，不断更新之。同时不断更新结果ans，更新的方法是ans和当前数字之前的最大值与这个数字作差，取其中的最大值。时间复杂度O(N),空间复杂度O(1)
#include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; void solve() { int t; scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); while (t--) { int n; scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); int a, b; scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b); int i, Max = max(a,b), ans = a - b; for (i = 0; i &amp;lt; n - 2; ++i) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;b); ans = max(ans, Max - b); Max = max(Max, b); } printf(&amp;quot;%d\n&amp;quot;, ans); } } int main(void) { //freopen(&amp;quot;11078.</description>
    </item>
    
    <item>
      <title>uva11462 Age Sort ——计数排序</title>
      <link>http://liuxueyang.github.io/posts/uva11462-age-sort-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 21 May 2013 17:00:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva11462-age-sort-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</guid>
      <description>题目链接：http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=2457 题目大意： 给很多个范围在１到１００之内的数字，数量最多有2*10^6个，排序输出。 题目思路： 数组很大，超内存。不能快排。所以采用计数排序
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; int a[120]; void solve() { int n, tmp, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { if (!n) break; memset(a, 0, sizeof(a)); for (i = 0; i &amp;lt; n; ++i) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;tmp); a[tmp]++; } bool mrk = true; for (i = 1; i &amp;lt;= 100; ++i) { for (j = 0; j &amp;lt; a[i]; ++j) { if (!</description>
    </item>
    
    <item>
      <title>USACO Friday the Thirteenth ——水题</title>
      <link>http://liuxueyang.github.io/posts/usaco-friday-the-thirteenth-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Tue, 21 May 2013 14:40:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/usaco-friday-the-thirteenth-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://cerberus.delos.com:790/usacoprob2?a=EYxUgMg3whp&amp;amp;S=friday 题目大意： 意思比较简单。求1900年到1900+N年的每个月的13号落在了星期几。输出13号落在一个星期的每一天的次数。 题目思路： 方法一： 有个蔡勒公式： 这个公式可以根据某天的日期，算出这一天是星期几，套用一下就行了。 公式中的符號含義如下： ——选自维基百科 /* ID: zypz457 LANG: C++ TASK: friday */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; int n; int cnt[7]; int cal(int y, int m, int d) { int month = m, c; if (month == 1) { month = 13; y--; } else if (month == 2) { month = 14; y--; } else {month = m;} m = month; c = y/100; y = y%100; int ans = (y + y/4 + floor(c/4) -2*c + floor(26*(m+1)/10) + d - 1); ans = (ans%7 + 7) % 7; return ans; } void solve() { scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); memset(cnt, 0, sizeof(cnt)); int y, j, i, month, ans; for (i = 0; i &amp;lt; n; ++i) { y = i + 1900; for (j = 1; j &amp;lt;= 12; ++j) { ans = cal(y, j, 13); cnt[ans]++; } } printf(&amp;quot;%d &amp;quot;, cnt[6]); for (i = 0; i &amp;lt; 5; ++i) printf(&amp;quot;%d &amp;quot;, cnt[i]); printf(&amp;quot;%d\n&amp;quot;, cnt[5]); } int main(void) { freopen(&amp;quot;friday.</description>
    </item>
    
    <item>
      <title>USACO Greedy Gift Givers ——水题</title>
      <link>http://liuxueyang.github.io/posts/usaco-greedy-gift-givers-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Tue, 21 May 2013 13:05:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/usaco-greedy-gift-givers-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://cerberus.delos.com:790/usacoprob2?S=gift1&amp;amp;a=nR34fDHld4J 题目大意：http://blog.sina.com.cn/s/blog_63d0cab00100h1rx.html 赶脚这货考的是英语……
/* ID: zypz457 LANG: C++ TASK: gift1 */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;map&amp;gt; using namespace std; int n; map&amp;lt;string, int&amp;gt; mymap; int wei[15][2]; string name[20]; void init() { int i; freopen(&amp;quot;gift1.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); freopen(&amp;quot;gift1.out&amp;quot;, &amp;quot;w&amp;quot;, stdout); memset(wei, 0, sizeof(wei)); scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); for (i = 0; i &amp;lt; n; ++i) { cin &amp;gt;&amp;gt; name[i]; mymap[name[i]] = i; } string str, str1; while (cin &amp;gt;&amp;gt; str) { int cnt, id, recid, i; id = mymap[str]; scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;wei[id][0], &amp;amp;cnt); for (i = 0; i &amp;lt; cnt;++i) { cin &amp;gt;&amp;gt; str1; recid = mymap[str1]; int tmp = wei[id][0] / cnt; wei[id][0] = tmp * cnt; wei[recid][1] += tmp; } } } void solve() { int i; for (i = 0; i &amp;lt; n; ++i) { cout &amp;lt;&amp;lt; name[i] &amp;lt;&amp;lt; &#39; &#39; &amp;lt;&amp;lt; -wei[i][0]+wei[i][1]&amp;lt;&amp;lt;&#39;\n&#39;; } } int main(void) { init(); solve(); return 0; }  题目意思难理解，英语要好。 直接搜的翻译，开始真没看懂题意，当初感觉是有多难，看了翻译才发现……呵呵</description>
    </item>
    
    <item>
      <title>USACO Your Ride Is Here ——水题</title>
      <link>http://liuxueyang.github.io/posts/usaco-your-ride-is-here-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Tue, 21 May 2013 11:47:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/usaco-your-ride-is-here-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://cerberus.delos.com:790/usacoprob2?a=nR34fDHld4J&amp;amp;S=ride 人家说USACO的题目适合入门……我还是先刷这个吧…… 这道题目主要是学了一下USACO里面的文件输入输出格式
/* ID: zypz457 TASK: ride LANG: C++ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;fstream&amp;gt; using namespace std; int main(void) { ifstream fin(&amp;quot;ride.in&amp;quot;); ofstream fout (&amp;quot;ride.out&amp;quot;); char a[10], b[10]; while (fin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b) { int sum1, sum2, i, len1, len2; len1 = strlen(a); len2 = strlen(b); sum1 = sum2 = 1; for (i = 0; i &amp;lt; len1; ++i) { sum1 = (sum1*(a[i]-&#39;A&#39;+1))%47; } for (i = 0; i &amp;lt; len2; ++i) { sum2 = (sum2*(b[i]-&#39;A&#39;+1))%47; } /* if (sum1 == sum2) fprintf(fout, &amp;quot;GO\n&amp;quot;); else fprintf(fout, &amp;quot;STAY\n&amp;quot;); * */ if(sum1 == sum2) fout &amp;lt;&amp;lt; &amp;quot;GO\n&amp;quot;; else fout &amp;lt;&amp;lt; &amp;quot;STAY\n&amp;quot;; } return 0; }  不用每次交题目都复制了倒是……但是格式要求挺严格的……还要有注释。。。 好吧，读文件神马的不用那么麻烦……按照原来的习惯写就行。 /* ID: zypz457 TASK: ride LANG: C++ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int main(void) { freopen(&amp;quot;ride.</description>
    </item>
    
    <item>
      <title>NYOJ16 矩形嵌套 ——DP入门题</title>
      <link>http://liuxueyang.github.io/posts/nyoj16-%E7%9F%A9%E5%BD%A2%E5%B5%8C%E5%A5%97-dp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 20 May 2013 21:34:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/nyoj16-%E7%9F%A9%E5%BD%A2%E5%B5%8C%E5%A5%97-dp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.nyist.net/JudgeOnline/problem.php?pid=16 题目大意： 中文题…… 题目思路： 方法一： 先按照长和宽进行二级排序，然后转化成最长上升子序列求解。时间复杂度O(N^2)，数据范围1000.
#include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; const int MAX = 1000+10; typedef struct node { int x, y; bool operator &amp;lt; (const node &amp;amp;other) const { if (x != other.x) { return x &amp;lt; other.x; } else return y &amp;lt; other.y; } }node; node ma[MAX]; int n, maxlen[MAX]; void init() { int i, a, b; scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); for (i = 0; i &amp;lt; n; ++i) { scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b); if (a &amp;gt; b) swap(a,b); ma[i].</description>
    </item>
    
    <item>
      <title>poj1163 The Triangle ——DP入门题</title>
      <link>http://liuxueyang.github.io/posts/poj1163-the-triangle-dp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 20 May 2013 16:42:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1163-the-triangle-dp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1163 题目思路： 从三角形的底部开始考虑
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; const int MAX = 100; int a[MAX][MAX], dp[MAX][MAX]; int main(void) { //freopen(&amp;quot;1163.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); int n,i,j; scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); for (i = 0; i &amp;lt; n; ++i) { for (j = 0; j &amp;lt; i+1; ++j) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;a[i][j]); } } memset(dp, 0, sizeof(dp)); for (i = 0; i &amp;lt; n; ++i) dp[n-1][i] = a[n-1][i]; for (i = n - 2; i &amp;gt;= 0; --i) { for (j = 0; j &amp;lt; n - 1; ++j) { dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + a[i][j]; } } printf(&amp;quot;%d\n&amp;quot;, dp[0][0]); return 0; }  还是从最简单的开始做起吧 另外一种写法： #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; const int MAX = 100; int a[MAX][MAX], dp[MAX][MAX], n; int f(int i, int j) { if (dp[i][j] &amp;gt;= 0) return dp[i][j]; else { if (i == n-1) dp[i][j] = a[i][j]; else dp[i][j] = a[i][j] + max(dp[i+1][j], dp[i+1][j+1]); return dp[i][j]; } } int main(void) { int i,j; scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); for (i = 0; i &amp;lt; n; ++i) { for (j = 0; j &amp;lt; i+1; ++j) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;a[i][j]); } } memset(dp, -1, sizeof(dp)); for (i = 0; i &amp;lt; n; ++i) dp[n-1][i] = a[n-1][i]; for (i = n-1; i &amp;gt;= 0; --i) for (j = 0; j &amp;lt; i+1; ++j) f(i, j); printf(&amp;quot;%d\n&amp;quot;, dp[0][0]); return 0; }   这就是所谓的记忆化搜索 </description>
    </item>
    
    <item>
      <title>csu1290 Random Integers ——DP入门题&amp;&amp;比赛残留题</title>
      <link>http://liuxueyang.github.io/posts/csu1290-random-integers-dp%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/</link>
      <pubDate>Sun, 19 May 2013 17:07:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/csu1290-random-integers-dp%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/</guid>
      <description>题目链接：http://122.207.68.93/OnlineJudge/problem.php?id=1290 题目大意： 从K个不同的数字里面有放回地随机选N次，求选到的不同的数字的种类的期望。 题目思路： 这题不能用概率公式推导。因为有很多项的阶乘，应该会超double范围。应该用DP做。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; const int MAX=1000+10; double dp[MAX][MAX]; int main(void) { int i, j, k, t; double N, K; scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); while (t--) { scanf(&amp;quot;%lf%lf&amp;quot;, &amp;amp;K, &amp;amp;N); double sum = 0.0; for (i = 0; i &amp;lt;= N; ++i) for (j = 0; j &amp;lt;= K; ++j) dp[i][j] = 0.0; dp[0][0] = 1.0; for (i = 1; i &amp;lt;= N; ++i){ for (j = 1; j &amp;lt;= K; ++j){ dp[i][j]=dp[i-1][j-1]*(K-j+1)/K + dp[i-1][j]*(j/K); //sum += (j*dp[i][j]); } } for (i = 1; i &amp;lt;= K; ++i) { sum += (i * dp[(int)N][i]); } printf(&amp;quot;%.</description>
    </item>
    
    <item>
      <title>poj3070 Fibonacci ——矩阵快速幂</title>
      <link>http://liuxueyang.github.io/posts/poj3070-fibonacci-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Sun, 19 May 2013 01:38:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj3070-fibonacci-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>题目链接：http://poj.org/problem?id=3070 题目大意： 求第N项的Fibonacci数的后四位。 题目思路： 根据公式： 用矩阵快速幂就OK，模板题……但还是TLE了一次，原因是题目要求输入-1结束，我没看到……o(╯□╰)o
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; const int MAX = 2; const int M = 10000; typedef struct { int m[MAX][MAX]; }Matrix; Matrix a, per; int n; void init() { int i , j; for (i = 0; i &amp;lt; n; ++i) { for (j = 0; j &amp;lt; n; ++j) { per.m[i][j] = (i == j); } } a.</description>
    </item>
    
    <item>
      <title>WPS for Ubuntu!</title>
      <link>http://liuxueyang.github.io/posts/wps-for-ubuntu/</link>
      <pubDate>Sat, 18 May 2013 19:28:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/wps-for-ubuntu/</guid>
      <description>好兴奋！终于可以在Ubunt下面看word和ppt了～ 虽然WPS for Linux貌似还不那么稳定，但是刚安装好感觉还不错，目前感觉很爽！ 下载地址：http://community.wps.cn/download/ 下载的时候下载deb包，然后用软件中心安装就ＯＫ 然后安装好后，发现少字体，只需要安装上那些字体就行了，地址：http://bbs.wps.cn/thread-22355435-1-1.html wps的论坛，看9楼神贴。金山快盘里面的下载地址http://www.kuaipan.cn/file/id_19418406138675408.htm 依然是用软件中心安装字体，好兴奋～</description>
    </item>
    
    <item>
      <title>ubuntu下歌词显示软件</title>
      <link>http://liuxueyang.github.io/posts/ubuntu%E4%B8%8B%E6%AD%8C%E8%AF%8D%E6%98%BE%E7%A4%BA%E8%BD%AF%E4%BB%B6/</link>
      <pubDate>Sat, 18 May 2013 18:56:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/ubuntu%E4%B8%8B%E6%AD%8C%E8%AF%8D%E6%98%BE%E7%A4%BA%E8%BD%AF%E4%BB%B6/</guid>
      <description>软件的名字是：osd-lyrics https://code.google.com/p/osd-lyrics/ 感觉很不错，支持ＶＬＣ 安装方法：https://code.google.com/p/osd-lyrics/wiki/InstallUbuntu</description>
    </item>
    
    <item>
      <title>zoj2136 &amp;&amp; poj2533 Longest Ordered Subsequence ——最长上升子序列经典DP</title>
      <link>http://liuxueyang.github.io/posts/zoj2136--poj2533-longest-ordered-subsequence-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E7%BB%8F%E5%85%B8dp/</link>
      <pubDate>Thu, 16 May 2013 12:44:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj2136--poj2533-longest-ordered-subsequence-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E7%BB%8F%E5%85%B8dp/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1136  http://poj.org/problem?id=2533 题目大意：RT 题目思路： maxlen[j]表示，到j位置，最长的上升子序列的长度。时间复杂度O（N^2），数据范围是1000 参考解题报告：http://www.slyar.com/blog/longest-ordered-subsequence.html zoj:
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int str[1000], maxlen[1001], p[1001]; int main(void){ #ifdef LOCAL freopen(&amp;quot;lis.</description>
    </item>
    
    <item>
      <title>ural1057 Amount of Degrees ——数位DP</title>
      <link>http://liuxueyang.github.io/posts/ural1057-amount-of-degrees-%E6%95%B0%E4%BD%8Ddp/</link>
      <pubDate>Wed, 15 May 2013 16:30:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/ural1057-amount-of-degrees-%E6%95%B0%E4%BD%8Ddp/</guid>
      <description>题目链接：http://acm.timus.ru/problem.aspx?space=1&amp;amp;num=1057 题目大意： 意思就是给一个区间[x, y]，求这个区间内有多少个恰好可以被k个b的不同次幂的数之和表示出来的数字的个数。 题目思路： 只需要求区间[0, m]内的恰好可以被k个b的不同次幂的数之和表示出来的数字的个数，定义这个函数是solve(m, k, b)。题目要求的就是：solve(y, k, b) - solve(x - 1, k, b)。 思路就是，转化成二进制考虑。把这个区间内的某个数字表示成b进制，要求的数字是转化成b进制之后，每一位的数字均为0或者1，这样的数字。 画一棵完全二叉树，根节点是0，左子节点是0，右子节点是1，高度从0开始记起，整棵树的根节点不用。则f[i][j]表示，高度为i的二叉树里面恰好含有j个1的数字的个数。那么就有： f[i][j] = f[i-1][j-1] + f[i-1][j] 意思就是高度为i的树包含的数字里面，符合条件的数字的数目等于左右两棵子树的和。 当然数组f[i&amp;hellip;n][0]都要初始化为1，因为长度为i&amp;hellip;n的并且含有0个1的数字的个数总为1. 参考解题报告：http://hi.baidu.com/zyz913614263/item/a0215c20efefa01f42634a12
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int f[32][32]; int solve(int n, int k, int b) { int a[32], sum, cnt, i, j; sum = 0; cnt = 0; i = 0; while (n) { a[++i] = n%b; n /= b; } for (j = i; j &amp;gt;= 1 &amp;amp;&amp;amp; cnt &amp;lt;= k; --j) { if (a[j] &amp;gt; 1) { sum += f[j][k-cnt]; break; } else if (a[j] == 1) { sum += f[j-1][k-cnt]; cnt++; } if (j == 1 &amp;amp;&amp;amp; cnt == k) sum++; } return sum; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;ural1057.</description>
    </item>
    
    <item>
      <title>uva133 The Dole Queue 循环队列模拟</title>
      <link>http://liuxueyang.github.io/posts/uva133-the-dole-queue-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Tue, 14 May 2013 11:01:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva133-the-dole-queue-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F/</guid>
      <description>题目链接：http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=69 题目大意： 1到n按照逆时针的顺序围成一个环，一个人逆时针从1开始数k个数字，另一个人顺时针从n开始数m个数字，每次两个人最终数到的数字输出，并且把他们从原来的环里面删除，如果两个人数到的数字不同，输出一对，如果相同，输出这个数字。不管重复上面的做法，直到n个数字全部被删除。 题目思路： 模拟题，代码弱，写了很久，写不出来，就是感觉比较麻烦，看了人家的代码，做法很好！http://blog.csdn.net/actoy/article/details/8747826
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;uva133.</description>
    </item>
    
    <item>
      <title>uva127 ``Accordian&#39;&#39; Patience ——链表模拟题</title>
      <link>http://liuxueyang.github.io/posts/uva127-accordian-patience-%E9%93%BE%E8%A1%A8%E6%A8%A1%E6%8B%9F%E9%A2%98/</link>
      <pubDate>Mon, 13 May 2013 19:10:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva127-accordian-patience-%E9%93%BE%E8%A1%A8%E6%A8%A1%E6%8B%9F%E9%A2%98/</guid>
      <description>题目链接：http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=103&amp;amp;page=show_problem&amp;amp;problem=63 题目大意：神牛讲的很清楚~http://blog.csdn.net/camelwombat/article/details/5949508 感觉还是首先要读懂题目意思，这个也是有难度的 题目思路： 用数组模拟链表，考的是代码能力，关键是逻辑关系搞清楚，然后再敲，再就是细节问题，代码有一点小错就需要调很久。 参考这位神牛的思路写的……http://blog.csdn.net/goomaple/article/details/7802686
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; typedef struct node{ int len; char rank[54], suit[54]; }node; node card[54]; void eachmove(int pos, int step) { int Len = card[pos-step].</description>
    </item>
    
    <item>
      <title>2013年5月13日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8813%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Mon, 13 May 2013 02:18:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8813%E6%97%A5-%E6%99%B4/</guid>
      <description>今天，，，好吧……是昨天。。。西班牙语课很有收获啊，慢慢入门了~ 上完课急急忙忙地去做了一下所谓的校赛，发现如果没有书，单凭自己做，还是有很多基础的东西敲不出来啊，呵呵，知道为什么这么弱了。 晚上去跑步了，状态还不错，至少跑完全程了，5km不多不少。回公寓的时候，见识到了传说中猛于虎的城管，跟卖夜宵的小贩打起来了，同样的情景见过无数次了，就在公寓门口，唉，这些社会的阴暗面…………谁都不容易，不说了。 洗洗睡吧，明天有课。好好奋斗。 很久之前就很喜欢的一个视频：
　Tell me why</description>
    </item>
    
    <item>
      <title>poj1272 棋盘问题 ——DFS入门题</title>
      <link>http://liuxueyang.github.io/posts/poj1272-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 13 May 2013 01:52:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1272-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1321 题目大意： 中文题，省了…… 题目思路： 感觉搜索题目还是要多做，很多东西都是开始看起来很复杂，其实根本就没有那么复杂，比如说这道，实际上就比较基础，可是，自己还是做不出来……o(╯□╰)o 这道题目需要注意的一点就是：先DFS一行，然后要注意，要考虑当前行不放，直接DFS下一行！这个情况赶脚还是比较不容易想到的，虽然做完之后感觉也挺自然啊，可是……当初为毛想不到。。。就是思维的问题吧……代码看的是这位仁兄的：http://fuliang.iteye.com/blog/398700ＴＨＸ……＾＿＾
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 10; char m[MAX][MAX];int cnt, n, k, sum; bool p[MAX]; bool judge(int i, int j) { if (p[j] == false &amp;amp;&amp;amp; m[i][j] == &#39;#&#39;) return true; else return false; } void dfs(int x) { if (sum == k) {cnt++; return;} if (x &amp;gt;= n) return; int i; for (i = 0; i &amp;lt; n; ++i) { if (judge(x, i)) { p[i] = true; sum++; dfs(x+1); p[i] = false; sum--; } } dfs(x + 1); } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;poj1321.</description>
    </item>
    
    <item>
      <title>hdu1272 小希的迷宫 ——并查集无向图判环</title>
      <link>http://liuxueyang.github.io/posts/hdu1272-%E5%B0%8F%E5%B8%8C%E7%9A%84%E8%BF%B7%E5%AE%AB-%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%97%A0%E5%90%91%E5%9B%BE%E5%88%A4%E7%8E%AF/</link>
      <pubDate>Sun, 12 May 2013 23:44:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1272-%E5%B0%8F%E5%B8%8C%E7%9A%84%E8%BF%B7%E5%AE%AB-%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%97%A0%E5%90%91%E5%9B%BE%E5%88%A4%E7%8E%AF/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1272 题目大意： 给一个无向图，判断是不是有环，有就输出No，否则输出Yes 题目思路： 用并查集，开始还天真地以为要用拓扑排序，好吧……虽然那个也可以做，可是为什么不用简单的方法呢？
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 100000+10; int parent[MAX]; bool flag; void init() { for (int i = 1; i&amp;lt;=MAX; ++i) parent[i] = -1; } int find(int x) { int s; for (s = x; parent[s] !</description>
    </item>
    
    <item>
      <title>hdu1028 Ignatius and the Princess III &amp;&amp; hdu2082 找单词 &amp;&amp; poj1664 放苹果 &amp;&amp; noj1046 正整数划分问题——整数划分</title>
      <link>http://liuxueyang.github.io/posts/hdu1028-ignatius-and-the-princess-iii--hdu2082-%E6%89%BE%E5%8D%95%E8%AF%8D--poj1664-%E6%94%BE%E8%8B%B9%E6%9E%9C--noj1046-%E6%AD%A3%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86/</link>
      <pubDate>Sun, 12 May 2013 20:37:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1028-ignatius-and-the-princess-iii--hdu2082-%E6%89%BE%E5%8D%95%E8%AF%8D--poj1664-%E6%94%BE%E8%8B%B9%E6%9E%9C--noj1046-%E6%AD%A3%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86/</guid>
      <description>这种问题有两种做法，DP和母函数。 hdu1028 Ignatius and the Princess III 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1028 DP做法：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu1028.</description>
    </item>
    
    <item>
      <title>2013年5月11日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8811%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Sat, 11 May 2013 23:33:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8811%E6%97%A5-%E6%99%B4/</guid>
      <description>10日 晴 晚上去跑步了，起跑的时候竟然有一种狂喜的感觉，停跑半个月了，今天第一次跑，兴奋中……哈哈，开始感觉节奏还保持地不错，天气也不错，凉快，这么好的天气憋在宿舍里面绝对是对生命的一种浪费啊！快到终点的时候，直接冲刺了大约500米的样子，虽然完全打乱了节奏，但还是很爽的感觉，^_^然后后来完全没有节奏了，，也没关系，边走边跑着回来了~ 11日 晴 又是一个大晴天，前几天一直下雨，甚至有暴雨，这两天终于晴了。一天就刷了一下水题，没什么收获，概率论也木有复习……图书馆人超多，刚进去就出来了，，回机房做题，一整天效率太低了有木有！晚上实在没有心情去跑步了，加上今晚湘江边有烟花，一想到放完烟花后的烟雾，还是算了。。明天再跑吧o(╯□╰)o</description>
    </item>
    
    <item>
      <title>2013年5月11日zoj比赛残留题 zoj5000 Density of Power Network &amp;&amp; zoj5002 Friends</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8811%E6%97%A5zoj%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98-zoj5000-density-of-power-network--zoj5002-friends/</link>
      <pubDate>Sat, 11 May 2013 20:21:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8811%E6%97%A5zoj%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98-zoj5000-density-of-power-network--zoj5002-friends/</guid>
      <description>两道水题。直接暴力。数据范围都不大，还没有过，等哪天zoj把题目挂出来了再交。 Density of Power Network 题目链接：http://acm.zju.edu.cn/onlinejudge/showContestProblem.do?problemId=5000
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int edge[502][502], a[502], b[502]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;zoj5000.</description>
    </item>
    
    <item>
      <title>2013年5月11日 zoj比赛三道水题：zoj4998 Break Standard Weight &amp;&amp; zoj5004 Hard to Play &amp;&amp; zoj5006 Java Beans</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8811%E6%97%A5-zoj%E6%AF%94%E8%B5%9B%E4%B8%89%E9%81%93%E6%B0%B4%E9%A2%98zoj4998-break-standard-weight--zoj5004-hard-to-play--zoj5006-java-beans/</link>
      <pubDate>Sat, 11 May 2013 18:29:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8811%E6%97%A5-zoj%E6%AF%94%E8%B5%9B%E4%B8%89%E9%81%93%E6%B0%B4%E9%A2%98zoj4998-break-standard-weight--zoj5004-hard-to-play--zoj5006-java-beans/</guid>
      <description>都是水题，特别水的内种，题目意思、思路神马滴就不说了…… Break Standard Weight 题目链接：http://acm.zju.edu.cn/onlinejudge/showContestProblem.do?problemId=4998 范围只有100，并且只有3个数字，直接枚举，代码好挫……o(╯□╰)o 只有一个需要注意的地方，就是绝对值为0的时候要考虑到！因为如果绝对值为0，那么根本就称不出什么重量来。。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; map&amp;lt;int, bool&amp;gt;mymap; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;zoj4998.</description>
    </item>
    
    <item>
      <title>Dijkstra算法示例程序_1</title>
      <link>http://liuxueyang.github.io/posts/dijkstra%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_1/</link>
      <pubDate>Sat, 11 May 2013 10:32:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/dijkstra%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_1/</guid>
      <description>好几天不写程序的结果就是以前的东西都忘得差不多了……o(╯□╰)o
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 20; int S[MAX], dist[MAX], path[MAX], edge[MAX][MAX]; int n; void Dijkstra(int v0) { int i, j, k; for (i = 0; i &amp;lt;n ; ++i) { dist[i] = edge[v0][i]; S[i] = 0; if (i !</description>
    </item>
    
    <item>
      <title>hdu2577 How to Type ——DP入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu2577-how-to-type-dp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Fri, 10 May 2013 20:49:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu2577-how-to-type-dp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2577 题目大意： 一个人打字，有小写字母，有大写字母，并且要求打完字以后要把CapsLock键关掉。求最少的按键次数。 题目思路： dp[i][0]表示打到第 i 个字母的时候，CapsLock键是关着的；　dp[i][1]表示打到第 i 个字母的时候，CapsLock键是开着的； 然后就是判断下一个字母是大写字母还是小写字母，如果是小写字母，dp[i+1][0] = min(dp[i][0] + 1, dp[i][1] + 2); 表示，要求下一个状态CapsLock关着，那么前一个状态如果是关着的，直接打字母就可以了，所以只需要加1，如果是开着的，就要先把CapsLock关掉，然后再打字母，所以需要加2. 其他的情况类似。参考的是这个人的代码：http://www.cnblogs.com/mengxm-lincf/archive/2011/06/07/2074489.html #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int dp[110][2]; char ch[110]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu2577.</description>
    </item>
    
    <item>
      <title>zoj3702 Gibonacci number ——找规律</title>
      <link>http://liuxueyang.github.io/posts/zoj3702-gibonacci-number-%E6%89%BE%E8%A7%84%E5%BE%8B/</link>
      <pubDate>Tue, 07 May 2013 23:31:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj3702-gibonacci-number-%E6%89%BE%E8%A7%84%E5%BE%8B/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3702 题目大意： 给一个数列，第一项是1，给第 i 项，这个数列满足斐波那契数列的那种性质。问是不是存在，如果存在输出第 j 项，否则输出 -1 题目思路： 找规律，这个数列每一项和原来的斐波那契数列的差值是原来的斐波那契数列的倍数。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; #define LL long long int LL f[30], g[30]; int main(void){ int i , j , k; f[0] = f[1] = 1; for (i = 2; i &amp;lt; 23; ++i) { f[i] = f[i-2] + f[i-1]; } LL I, J, GI; int t; scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); while (t--) { cin &amp;gt;&amp;gt; I &amp;gt;&amp;gt; GI &amp;gt;&amp;gt; J; LL d = GI - f[I]; if (d &amp;lt; 0 || d % f[I-1] !</description>
    </item>
    
    <item>
      <title>zoj3696  Alien&#39;s Organ ——概率题</title>
      <link>http://liuxueyang.github.io/posts/zoj3696--aliens-organ-%E6%A6%82%E7%8E%87%E9%A2%98/</link>
      <pubDate>Tue, 07 May 2013 23:27:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj3696--aliens-organ-%E6%A6%82%E7%8E%87%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3696 题目大意： 就是一个东西，随机产生器官，一天产生的数量的期望是x,求一天内产生个数小于等于N的概率 题目思路： 泊松分布。概率论得好好学。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;math.h&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; double la; double cal(double k) { double l = 1; for (int i = 1; i &amp;lt;= k; ++i) { l = l * i; } double re = pow(la, k) / l * exp(-la); return re; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;a.</description>
    </item>
    
    <item>
      <title>poj1122&amp;&amp;zoj1053 FDNY to the Rescue! ——最短路入门题_Dijkstra算法</title>
      <link>http://liuxueyang.github.io/posts/poj1122zoj1053-fdny-to-the-rescue-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 06 May 2013 19:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1122zoj1053-fdny-to-the-rescue-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1122　http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=53 题目大意： 给定一个有向图，一个终点S，求多个点到这个点S的最短距离和对应的路径，把最短路排序后输出。 题目思路： 点的范围是20.可以一个一个用Dijkstra。。唯一的新意就是有多个点还需要按照路径长度排序，同时还要输出对应的路径，考的就是代码能力。用结构体存就可以。注意是有向图，开始就以为是无向图，怎么算最短路都不对。。赶脚这题不难，没什么思维难度，但是做OJ上这题的人却比较少，可能有一个原因，题目比较长，然后读完题目之后觉得没什么意思就不做了。。很简单的一个东西搞这么长的题目，也许就是考的读题吧。。貌似如果不是看的书上的翻译，我也没耐心读题。。。唉，读题确实是关键的一关。 然后这道题目，Poj上是单case，比较好过，然后数据也貌似比较弱，因为是单case，所以有一个输入的细节就特别好处理。开始Poj一下就过了，还沾沾自喜，结果把单case换成多case的时候，在zoj上交就Segmentation Fault……原来我最初处理输入个数不确定的数字的时候用了 while(~scanf())这种方法，很显然，这货只适用于单case。然后就想，该怎么处理这种输入数字个数不确定的输入呢？看了网上的一个思路，http://blog.csdn.net/yzldw333/article/details/7858172 哈哈，原来这么简单，就是以前做过的么，按照字符串处理就行了，，，好吧，，原来自己就是怕麻烦，这种方法想都没想。。然后就改了，，还是Segmentation Fault……继续调试，查错。。忍不住看了一下别人的代码，http://www.cnblogs.com/372465774y/archive/2012/11/19/2777552.html 一个注释提示了我，“这题给的字符真的是：t &amp;lsquo; &amp;rsquo;”好吧……我还真没注意到，虽然读题的时候注意到了，但是写代码的时候就想当然地只考虑空格，，像以前那样……思维定式啊。。然后就过了。。 Segmentation Fault的原因是访问了非法内存，在新的OJ上如果用的是Linux的话，归在Runtime Error一类里面。多谢zsl！ Poj代码：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 20; int edge[MAX][MAX], n, dist[MAX], path[MAX], end; bool S[MAX]; typedef struct Fire { int street[MAX], len, start, E; bool operator &amp;lt; (const Fire &amp;amp;other) const { return len &amp;lt; other.</description>
    </item>
    
    <item>
      <title>zoj2750 Idiomatic Phrases Game ——最短路入门题_Dijkstra算法</title>
      <link>http://liuxueyang.github.io/posts/zoj2750-idiomatic-phrases-game-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 05 May 2013 22:43:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj2750-idiomatic-phrases-game-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1750 题目大意： 成语接龙游戏。给定n个单词，每个单词前面先给一个权值，表示由这个单词找到下一个单词所需要花费的时间。问从第一个单词至少要花多少时间才能找到最后一个单词。如果不能找到，输出-1 题目思路： 如果一个单词的最后一个字和另一个成语的第一个字一样的话。那么就可以连一个有向边。就是求一个最短路。注意：题目中说成语至少三个字，别想当然地以为成语就是4个字的……开始没注意到，后来才改的。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MINN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 1000+10; int dist[MAX], S[MAX], n, wei[MAX], edge[MAX][MAX]; char start[MAX][10], end[MAX][10], ch[50]; void Dijkstra(int u0) { int i, j; for (i = 1; i &amp;lt;= n; ++i) { S[i] = 0; dist[i] = edge[u0][i]; } S[u0] = 1; dist[u0] = 0; int u; for (i = 1; i &amp;lt; n; ++i) { int Min = MAXN; u = 1; for (j = 1; j &amp;lt;= n; ++j) { if (S[j] == 0 &amp;amp;&amp;amp; dist[j] &amp;lt; Min) { Min = dist[j]; u = j; } } S[u] = 1; for (j = 1; j &amp;lt;= n; ++j) { if (S[j] == 0 &amp;amp;&amp;amp; edge[u][j] !</description>
    </item>
    
    <item>
      <title>poj1135&amp;&amp;zoj1298 Domino Effect ——最短路入门题_Dijkstra算法</title>
      <link>http://liuxueyang.github.io/posts/poj1135zoj1298-domino-effect-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 05 May 2013 03:18:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1135zoj1298-domino-effect-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1135　http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=298 题目大意： 有n个多米诺骨牌，有m条边，推倒第1张牌，以这个点为端点边上的的牌同时倒，问最后倒下的那张牌是哪张，并且求出时间。如果正好是端点上的牌，输出端点序号，否则需要输出这个点在哪两个端点之间。 题目思路： 假设骨牌倒下的速度是1.这样就可以用距离表征时间了。 如果最后倒下的牌正好是端点处的。那么就很好理解了，就是求所有点到这个点的最短路的最大值。设为Max1 如果最后倒下的是某两个端点之间的牌。那么就要认真想想了。比如是A点和B点之间的。可以先分别求出到A点的时间，和到B点的时间。然后再加上A和B之间的距离。所得的和就是从起点1到达最后终点的时间的两倍！为什么捏？可以这么思考：两个人，速度都是1，从起点开始，以同样的速度行走，然后在同一时刻到达同一点，那么他们所花的时间的和就是从起点到终点的距离的两倍嘛。不管他们分别到达A点和B点的先后顺序，总之，他们最后的效果都是相遇了！对于每一条边，都求出对应的时间。得到最大值，设为Max2 如果Max2 &amp;gt; Max1 说明什么捏？说明了：两个人仅仅到达某些端点，并不能相遇有木有！还需要再走一段路程，在某两个端点之间的某处相遇！并且，这两个端点就是当Max2最大的时候的两个端点。 如果两者相等或者Max1 &amp;gt; Max2 说明什么捏？其实貌似不能大于……因为，Max1就是起点到达所有点的最短距离的最大值嘛，而Max2是每条边上时间的最大值，然后可以发现，除了第一种情况，每条边上时间的最大值其实就是到达这条边的其中一个端点的时间的最大值……所以呢，Max1不能大于Max2.出去第一种情况狂，只能等于。 然后这道题目还有一个需要注意的地方，就是，当只有一张骨牌的时候，输出0.0……这种情况，，好吧，真不知道比赛的时候我怎么能想得出来…… #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MINN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 500+10; int dist[MAX], S[MAX], edge[MAX][MAX], n, m; void dijkstra(int v0) { int i, j; for (i = 1; i &amp;lt;= n; ++i) { S[i] = 0; dist[i] = edge[v0][i]; } S[v0] = 1; for (i = 1; i &amp;lt; n; ++i) { int Min = MAXN, u; for (j = 1; j &amp;lt;= n; ++j) { if (S[j] == 0 &amp;amp;&amp;amp; Min &amp;gt; dist[j]) { Min = dist[j]; u = j; } } S[u] = 1; for (j = 1; j &amp;lt;= n; ++j) { if (S[j] == 0 &amp;amp;&amp;amp; edge[u][j] !</description>
    </item>
    
    <item>
      <title>Dijkstra算法示例程序</title>
      <link>http://liuxueyang.github.io/posts/dijkstra%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sat, 04 May 2013 22:16:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/dijkstra%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/</guid>
      <description>输入：一个有向图，顶点个数 n ,然后是每条边的起点，终点，权值。顶点序号从0开始，-1 -1 -1表示结束。 输出：顶点0到其他各顶点的最短路径长度，并输出对应的最短路径。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 20; int S[MAX], dist[MAX], path[MAX], edge[MAX][MAX]; int n; void Dijkstra(int v0) { int i, j, k; for (i = 0; i &amp;lt; n; ++i) { dist[i] = edge[v0][i]; S[i] = 0; if (i !</description>
    </item>
    
    <item>
      <title>poj1679 The Unique MST ——判断最小生成树是否唯一_kruscal算法</title>
      <link>http://liuxueyang.github.io/posts/poj1679-the-unique-mst-%E5%88%A4%E6%96%AD%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80_kruscal%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 04 May 2013 21:57:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1679-the-unique-mst-%E5%88%A4%E6%96%AD%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80_kruscal%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1679 题目大意： 判断一个连通的无向图的最小生成树是不是唯一的，如果唯一，输出最小生成树的权值，否者输出“Not Unique!” 题目思路： 这题目看的书上的，其实，最开始我的想法是，在求最小生成树的过程中，如果扩展到某一个点的时候，有多种选择，也就是说，有多个权值相同的边可以选择，那么就break掉，说明最小生成树不唯一。其实这是有问题的，因为，很可能在这权值相同的边当中，只能选择其中一条，如果选择其它的就得不到最小生成树，这就是一个反例。所以原来的做法是错误的。 书上的做法是，首先，预处理，看每个边是不是有别的边的权值和它一样的，有的话就标记一下，用结构体里面的equal表示，然后用kruscal算法求一遍最小生成树，并且把这棵最小生成树里面的边都标记一下，用结构体里面的used表示，然后，对于那种有其他边和它权值相同的那种边，同时这条边在第一次求的最小生成树里面，我们就把它删除，做法就是用结构体里面的del标记，然后再次求一遍最小生成树，不用del被标记的边，这样如果求出来的最小生成树的权值和原来的一样，说明最小生成树不唯一，break; 然后就OK了，唉，其实这是很自然的一个想法~
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 100+10; typedef struct Edge { int u, v, w, equal, used, del; bool operator &amp;lt; (const Edge &amp;amp;other) const { return w &amp;lt; other.</description>
    </item>
    
    <item>
      <title>poj2048&amp;&amp;zoj1751 Highways ——最小生成树入门题_Prim算法</title>
      <link>http://liuxueyang.github.io/posts/poj2048zoj1751-highways-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 04 May 2013 01:25:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj2048zoj1751-highways-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1751 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1048 题目大意： 给定n个点的坐标。还有m对已经相连的点的编号。求连接这n个点的总权值最小的一棵生成树，输出还需要连接的点的编号。 题目思路： 这道题目和以前做过的poj2421是一样的。这里采用了那篇博客里面的第一种方法。幸运的是，在poj上1A了。但是在zoj上，因为输入输出格式有一些不一样，卡了一下，到最后我也没明白“If no new highways need to be built (all towns are already connected), then the output should be created but it should be empty.” 这句话的含义，看书上的翻译是，如果不需要再建了，输出一个空行。可是，在poj上，输出空行与否都是可以过的。在zoj上，输出空行就WA了，就是因为这个错误…… poj代码：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 759; double edge[MAX][MAX]; double lowcost[MAX];int nearvex[MAX]; int n, m; typedef struct Point { int x, y; }Point; Point point[MAX]; void prim(int u0) { int i, j, k, v;double sum = 0; for (i = 1; i &amp;lt;= n; ++i) { lowcost[i] = edge[i][u0]; nearvex[i] = u0; } lowcost[u0] = 0; nearvex[u0] = -1; for (i = 1; i &amp;lt; n; ++i) { double min = 1.</description>
    </item>
    
    <item>
      <title>poj2349 Arctic Network ——最小生成树入门题_Prim算法</title>
      <link>http://liuxueyang.github.io/posts/poj2349-arctic-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 03 May 2013 23:36:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj2349-arctic-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=2349 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=914 题目大意： 有一些炮台，如果这个炮台有卫星接收器，那么任意两个有卫星接收器的炮台可以通信，不受距离限制；否者，两个炮台之间只能通过对讲机通信，这是受距离限制的。要买一种对讲机，用在需要的炮台上，要求所有炮台两两之间可以直接或者间接通信，问要买通信距离至少为多少的对讲机可以满足要求。输入：S卫星接收器的数量，P炮台的数量，然后是P行，每行代表一个炮台的坐标。输出要求的对讲机的通信距离D。 题目思路： 题目意思比较难懂。关键是satellite channel的安放方法，注意，它是放在炮台上的，只要这个炮台上有这货，它就可以和任何也有这货的炮台通信。明白这一点，然后就简单了。有S个卫星接收器，那么就可以减少S-1个距离开销。要让D尽可能小，就让这S-1个距离开销最大，所以，想法就是，求这些点的最小生成树，然后把所选的边排序，第S大的边的权值就是所求。 开始题意没搞懂。关键是“Any two outposts with a satellite channel can communicate via the satellite, regardless of their location.”这句话没有理解明白，也就是说，任何两个有卫星接收器的炮台都可通信！然后自己就把问题复杂化了……写的代码就很复杂了。。后来改了一下，就过了。。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 500+10; int n, s, p; double edge[MAX][MAX]; double lowcost[MAX]; int nearvex[MAX]; typedef struct Point { double x, y; }Point; typedef struct Vex { int i, j; double len; bool operator &amp;lt; (const Vex &amp;amp; other) const { // 不能写反了 return len &amp;gt; other.</description>
    </item>
    
    <item>
      <title>poj1789 Truck History ——最小生成树入门题_Prim算法</title>
      <link>http://liuxueyang.github.io/posts/poj1789-truck-history-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 03 May 2013 16:00:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1789-truck-history-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1789 题目大意： 输入一个数字n，然后输入n个长度为7的字符串，从任意一个字符串开始派生，直到派生出所有的字符串，两个字符串的距离规定为他们对应位置不相等的字母的个数，求出一种派生方案，使得派生方案的优劣值最大，并输出这个优劣值。优劣值的定义是：1/Σ(to,td)d(to,td) 表示对所有派生对的距离求和，再取倒数。 题目了思路： 要让优劣值最大，只需要距离之和最小，把7个字符串看成7个点，每两个点有一个距离，目的就是求权值最小的生成树，其实就是最小生成树。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 2000+10; char a[MAX][MAX]; int edge[MAX][MAX]; int n, lowcost[MAX]; void prim(int u0) { int sum = 0, i, j, k; for (i = 1; i &amp;lt;= n; ++i) lowcost[i] = edge[u0][i]; lowcost[u0] = -1; for (i = 1; i &amp;lt; n; ++i) { int v = -1, min = MAXN; for (j = 1; j &amp;lt;= n; ++j) { if (lowcost[j] !</description>
    </item>
    
    <item>
      <title>zoj1586 QS Network ——最小生成树入门题_Prim算法</title>
      <link>http://liuxueyang.github.io/posts/zoj1586-qs-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 03 May 2013 01:59:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj1586-qs-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=586 题目大意： 题目意思比较难懂。看书上的翻译竟然没有看懂，还是打开OJ，看英文的原题。看了两遍的样子，终于差不多懂了。 QS是一种生物，要完成通信，需要设备，每个QS需要的设备的价格不同，并且，这种设备只能在两个QS之间用一次，也就是说，如果一个QS需要和3个QS通信的话，它就必须得买3个设备，同时，对方三个也必须买对应的适合自己的设备。同时，每两个QS之间是有距离的，要完成通信还需要网线，给出每两个QS之间的网线的价值。求一棵生成树，使得所需要的费用最少。数据范围：所有数据都在1000以内。 题目思路： 根据这种设备的特性，每个设备只能和另外一个QS通信，所以呢，建图的时候，每条边的权值就是网线的费用，加上这条边的两个端点的QS所需设备的费用的和。这样，就转化成了常规的最小生成树的问题。因为只需要求出最小费用，所以，可以不必记录prim过程中要选的边的顶点编号，也就是说，可以省略nearvex数组，用lowcost数组就可以实现。如果lowcost[i]的值是-1，则代表已经选择了这个点，否则，lowcost[i]依然表示集合T1内的顶点 i 距离集合T内个顶点权值最小的边的权值。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 1000+10; int edge[MAX][MAX], lowcost[MAX]; int t, n, pri[MAX]; void prim(int u0) { int sum = 0, i, j, v; for (i = 1; i &amp;lt;= n; ++i) lowcost[i] = edge[u0][i]; lowcost[u0] = -1; for (i = 1; i &amp;lt; n; ++i) { int min = MAXN; v = -1; for (j = 1; j &amp;lt;= n; ++j) { if (min &amp;gt; lowcost[j] &amp;amp;&amp;amp; lowcost[j] !</description>
    </item>
    
    <item>
      <title>最小生成树示例程序_Prim算法</title>
      <link>http://liuxueyang.github.io/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_prim%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 03 May 2013 01:04:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_prim%E7%AE%97%E6%B3%95/</guid>
      <description>输入：顶点个数n和边数m，然后是m条边的数据。u v w 分别代表两个顶点和权值。顶点从1开始记起。 输出：一次选择的各条边和最小生成树的权。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 100; int n, m, lowcost[MAX], nearvex[MAX], edge[MAX][MAX]; void prim(int u0) { int i, j, sum = 0; for (i = 1; i &amp;lt;= n; ++i) { lowcost[i] = edge[u0][i]; nearvex[i] = u0; } nearvex[u0] = -1; for (i = 1; i &amp;lt; n; ++i) { int min = MAXN, v = -1; for (j = 1; j &amp;lt;= n; ++j) { if (nearvex[j] !</description>
    </item>
    
    <item>
      <title>poj2421 Constructing Roads ——最小生成树入门题_Kruscal算法</title>
      <link>http://liuxueyang.github.io/posts/poj2421-constructing-roads-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 02 May 2013 10:17:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj2421-constructing-roads-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=2421 题目大意： 给定一个矩阵，第 i 行第 j 列表示点 i 和点 j　的距离是ｓ［ｉ］［ｊ］。然后输入Ｑ，下面Ｑ行，每行两个数字ａ，ｂ表示点ａ和点ｂ已经有路相连。求需要至少再修多长的路，可以构成一棵生成树。输出需要在修的路的总长度。 题目思路： 转化为最小生成树求解。有两种思路： １）把已经相连的两个点的权值设置为０，这样，就可以直接求最小生成树了。因为kruscal的过程中，一定会选择到已经相连的这些点，因为它们的权值是0嘛，同时，即使把它们的权值加上，也不会影响结果。这个方法我好不容易想出来了，可是还有一个问题，就是：输入a b 后，如何定位到相应的边，并把这个边的权值设置为0？开始的时候，是暴力找，超时了，然后自己想各种方法，还求出来个公式，用a,b,N,表示出边的编号。最后还是超时了。。看网上别人恰好有人也是这么个思路，但是他是怎么定位边，并把边的权值设置为0的，没仔细看，不知道为什么人家就用这种方法过了…… 2）第二种思路，如果a b 已经相连，很简单，只要它俩的根节点不同，就把它两个合并不就可以了么，这样，kruscal的过程中，就不会再加入这些已经存在的边的权值了。剩下的就是纯的kruscal问题。这个方法很好！看的别人的想法。然后自己写了一下，RE了一次，原因是，合并a b 的时候，没有判断他们的根节点是否不同。。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; typedef struct Edge { int u, v, w; bool operator &amp;lt; (const Edge &amp;amp;o) const { return w &amp;lt; o.</description>
    </item>
    
    <item>
      <title>hoj12616 Median Tree ——最小生成树入门题&amp;&amp;比赛残留题_Kruscal算法</title>
      <link>http://liuxueyang.github.io/posts/hoj12616-median-tree-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 01 May 2013 21:43:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hoj12616-median-tree-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://acm.hnu.cn/online/?action=problem&amp;amp;type=show&amp;amp;id=12616 题目大意： 给n个点,m条边，求一棵生成树，使得这个生成树的边的权值的中位数最小。输出这个中位数。 题目思路： 和poj1861&amp;amp;&amp;amp;zoj1542的思路是一样的。可以证明要求的树就是最小生成树。然后就是中位数的概念：长度为N的数列的中位数，就是(N+1)/2位置的数字。百度百科里面貌似不是严格的中位数的概念。 开始写了一遍按照那种不严格的中位数的定义写的。过了。kruscal的过程中，只需要计算到(n-1+1)/2-1的那一条边即可退出。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int n, m; const int em = 10000+10, vm = 1000+10; typedef struct Edge { int u, v, w; bool operator &amp;lt; (const Edge &amp;amp;other) const { return w &amp;lt; other.</description>
    </item>
    
    <item>
      <title>poj1861&amp;&amp;zoj1542 Network ——最小生成树入门题_Kruscal算法</title>
      <link>http://liuxueyang.github.io/posts/poj1861zoj1542-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 01 May 2013 20:52:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1861zoj1542-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1861 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=542 题目大意： 给n个点，m条边。求一棵生成树，并且满足任意两点之间的距离的最大值最小。输出这个最大值，然后输出树的边的数量，最后输出树的每条边。 题目思路： 其实就是求最小生成树。关键就是证明，对于一个图的最小生成树来说，它的最大边满足在所有的生成树的最大边里最小。这是可以理解的。简单思考一下：假设最小生成树不满足这个条件。那么就是说，存在另一棵生成树，它的最大边的值比最小生成树还小，但是它的权值之和可能比最小生成树大，但是这表明，构造最小生成树的时候，存在一步，选择边的时候，没有选择权值最小的，这是不可能的。所以矛盾。所以假设不成立。所以，问题就转化成了常规的求最小生成树的问题了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 1000+10; const int MAX1 = 15000+10; typedef struct Edge { int u, v, w; bool operator &amp;lt; (const Edge &amp;amp;other) const { return w &amp;lt; other.</description>
    </item>
    
    <item>
      <title>zoj1203 Swordfish ——最小生成树入门题_Kruscal算法</title>
      <link>http://liuxueyang.github.io/posts/zoj1203-swordfish-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 01 May 2013 13:36:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj1203-swordfish-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=203 题目大意： 给定N个点的坐标，求经过这N个点的路线长度总和的最小值。 题目思路： 求出任意两点之间的距离，然后就是最小生成树。 写的过程中还是遇到了三个问题，有一个局部变量没有初始化；没有把边按照权值排序；另外就是没有看输出，每两个case之间有一个空行。这里有一个十分常见的问题，就是最后一个case后面没有空行。否则会PE。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; typedef struct Edge { int u, v; double w; bool operator &amp;lt; (const Edge &amp;amp;other) const { return w &amp;lt; other.</description>
    </item>
    
    <item>
      <title>最小生成树示例程序_Kruscal算法</title>
      <link>http://liuxueyang.github.io/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_kruscal%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 01 May 2013 12:08:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_kruscal%E7%AE%97%E6%B3%95/</guid>
      <description>输入：顶点个数n和边数m，然后输入m行，每行输入格式：u v w 分别表示两个顶点和这个边的权值，顶点序号从1开始 输出：一次选择的各条边和最终的最小生成树的权值
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define MAXN 1000 #define MAXM 1000 int parent[MAXN], n, m; typedef struct Edge { int u, v, w; bool operator &amp;lt; (const Edge &amp;amp;other) const { return w &amp;lt; other.w; } }Edge; Edge edge[MAXM]; void init() { for (int i = 1; i &amp;lt;= n; ++i) parent[i] = -1; } int Find(int x) { int s = x, tmp; while (parent[s] &amp;gt;= 0) s = parent[s]; while (s !</description>
    </item>
    
    <item>
      <title>poj1094&amp;&amp;zoj1060 Sorting It All Out ——拓扑排序入门题</title>
      <link>http://liuxueyang.github.io/posts/poj1094zoj1060-sorting-it-all-out-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Wed, 01 May 2013 01:23:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1094zoj1060-sorting-it-all-out-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1094 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=60 题目大意： 输入两个整数，n, m 分别表示以下的字母在字母表前 n 个字母范围内，有 m 行，每行描述一个大小关系，只有小于号。如果从开始到某一个关系式可以确定最终的序列，就输出确定的序列。如果得到矛盾，就输出到此经历的几个关系式。如果最终都没有确定，就输出序列不能确定的信息。 题目思路： 边读入，边建图，每读入一条表达式，就拓扑排序判断是不是可以确定最后的序列了。如果可以得到最后包含全部n个字母的序列，后面的表达式只需要输入，但是不需要处理了。如果过程中到达一个表达式的时候，找到了一个环，就说明肯定不能确定最后的序列了。也不需要处理后面的表达式了。如果一直都没有确定，就一直处理。 这题大体上的思路是这样，但是还是有一些细节没有处理好。最严重的就是：如何在中间的过程中去判断环。不能单纯地比较弹栈的顶点个数和 n 的大小，因为可能读入的顶点个数还没有到达 ｎ的时候，就已经出现环了，这样，以后的输入就不用处理了。如何处理呢？我的方法就是，当前剩下的点当中，是不是还存在度数大于０的点，用ｂｕｇ标记，因为这个ｂｕｇ调试了好久。。如果存在的话，就说明返回－１，表示存在环。为什么会出现这个ｂｕｇ呢？因为这个涉及到到第几条表达式出现矛盾的问题。 主要还是思维不严谨，虽然后来测试数据过了，但还是不知道哪里错了，后来自己出了几组数据才发现那个ｂｕｇ。这题做了好久，有的人一下就过了，可是我却卡了两天……教训就是：遇到ｂｕｇ了不能慌，分析一下是不是自己当初的想法错了，还是哪个细节没有处理好。即使有一个细节处理不好，程序最后都会崩溃。还有就是，可能自己的处理方法不好，导致最后的ｂｕｇ超多，代码也超级繁琐……一开始就应该想清楚，有没有更好的处理办法，尤其是一些细节问题。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; bool edge[27][27]; int n, m, rela; string s, out; map&amp;lt;int,bool&amp;gt; mymap; int Count[27], mystack[27], Count1[27]; int topsort(int ki) { out.</description>
    </item>
    
    <item>
      <title>poj2585&amp;&amp;zoj2193 Window Pains ——拓扑排序入门题</title>
      <link>http://liuxueyang.github.io/posts/poj2585zoj2193-window-pains-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Tue, 30 Apr 2013 19:15:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj2585zoj2193-window-pains-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=2585 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2193 题目大意： 有9个窗口，每个窗口占4个格子，并且每个窗口的位置是固定的。如果重叠的话，在前面的窗口会覆盖另一种窗口，这9个窗口在4*4的矩阵里面，给出一种矩阵的格局。问这中格局是不是合法的。 题目思路： 还是看的书上的。刚开始一点也没有思路。方法就是：16个格子，每个格子可能会存在哪几种窗口，这是可以枚举出来的。针对输入的矩阵，那么可以判断，每一个格子会覆盖哪几种窗口，如果这种窗口在16个格子里面出现过，那么就可以判断当前这个格子一定覆盖了它，那么就可以用一条有向边连接当前窗口和被覆盖的窗口。这样，就可以得到一个图。在16个格子里面没有出现过的窗口我们可以不考虑。得到有向图后，发现，如果存在一个有向环，那么就一定是不合理的，因为这表明，一种窗口A覆盖了另一种窗口B，同时B又覆盖了A，这是不可能的。所以这个矩阵就是不合法的。反之，如果不存在有向环，就是合法的。这样，就转化为用拓扑排序判断环的问题了。先建图，再判断环。 写了两遍，其中出现各种BUG…… 第一遍：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; string cover[4][4]; int a[10][10];bool g[10][10];int id[10]; map&amp;lt;int, bool&amp;gt;mymap; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;poj2585.</description>
    </item>
    
    <item>
      <title>hoj12614 Dictionary ——拓扑排序找环&amp;&amp;比赛残留题</title>
      <link>http://liuxueyang.github.io/posts/hoj12614-dictionary-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E6%89%BE%E7%8E%AF%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/</link>
      <pubDate>Mon, 29 Apr 2013 16:48:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hoj12614-dictionary-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E6%89%BE%E7%8E%AF%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/</guid>
      <description>题目链接：http://acm.hnu.cn/online/?action=problem&amp;amp;type=show&amp;amp;id=12614&amp;amp;courseid=247 题目大意： 有一种字典。把字典中的符号映射到英文字母。输入一个n，然后是n行映射后的单词，判断这n个单词是不是符合字典序，所谓字典序就是前面的单词可以是后面的单词的前缀，并且这n个单词符合字符串排序后的顺序，这是针对原来的字母的，而不是映射之后的字母。 题目思路： 需要考虑映射之后的字母的相对顺序，来考虑是不是在原来的字母表中是不是符合字典序。 这道题目开始没看懂，最关键的第一段描述没有注意到，结果样例都看不懂。纠结了好久。但是涉及到前缀，觉得应该是字典树。 后来终于注意到第一段了，终于理解题目意思了。悲剧的是，还是纠结在字典树上面，老是在这方面想。没有思路。知道考虑相对顺序，但是不知道怎么映射……过程中llh其实提到了一下两个字母的相对顺序可以用边表示，可是，我没有继续往下想！后来听人家说，可以建图，然后找环。唉，原来就是llh那样想的。 回来之后，认真想了一下。方法是：预处理的过程中判断是不是出现这种情况：后面的单词是前面的单词的前缀，这是不符合条件的。同时在预处理的过程中建图，用临界表，如果一个字母A在另一个字母B的后面，就把B插入到A的出边表里面。然后就是在这个图里面找环，如果出现环了，就是不符合条件的。找环的方法就是刚刚做过的拓扑排序的方法。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int n; char a[509][17]; struct ArcNode { int to; struct ArcNode *next; }; ArcNode *List[50]; int Count[50]; bool topsort() { int i = 0, j, k, top = -1; ArcNode *temp; bool flag = false; for (i = 0; i &amp;lt; 26; ++i) { if (Count[i] == 0) { Count[i] = top; top = i; } } for (i = 0; i &amp;lt; 26; ++i) { if (top == -1) { flag = true; break; } j = top; top = Count[top]; temp = List[j]; while (temp) { k = temp-&amp;gt;to; Count[k]--; if (Count[k] == 0) { Count[k] = top; top = k; } temp = temp-&amp;gt;next; } } if (flag) return false; else return true; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hnu247.</description>
    </item>
    
    <item>
      <title>拓扑排序示例程序</title>
      <link>http://liuxueyang.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sun, 28 Apr 2013 01:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/</guid>
      <description>输入：顶点个数n，边数m，然后是m行，表示每条边的起点和终点u, v 表示从顶点u到顶点v的一条有向边。输入0 0 表示结束。 输出：如果不存在有向环，则输出一个拓扑有序序列；否则，输出“Netword has a cycle!” #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int n, m, Count[100], i, j, top, out[100]; struct ArcNode{ int to; struct ArcNode *next; }; ArcNode *List[100]; void topsort() { ArcNode *temp; top = -1; int k, len = 0; bool flag = true; for (i = 0; i &amp;lt; n; ++i) { if (Count[i] == 0) { Count[i] = top; top = i; } } for (i = 0; i &amp;lt; n; ++i) { k = top; if (k == -1) { flag = false; break; } top = Count[k]; temp = List[k]; out[len++] = k + 1; while (temp !</description>
    </item>
    
    <item>
      <title>邻接表示例程序</title>
      <link>http://liuxueyang.github.io/posts/%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sat, 27 Apr 2013 22:29:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/</guid>
      <description>输入：n，m代表顶点数目和边数。然后m行，代表每个边的起点和终点。0 0 表示结束。 输出：第一行为n个正整数，表示每个点的出度；第二行为n个正整数，表示每个点的入度。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 100; struct ArcNode{ // 边节点 int adjvex; ArcNode *nextarc; }; struct VNode{ // 顶点 int data; ArcNode *head1; // 出边表表头指针 ArcNode *head2; // 入边表表头指针 }; struct LGraph{ // 临界表结构体 VNode vertexs[MAX]; // 顶点数组 int vexnum, arcnum; }; LGraph lg; void CreateLG() { int i = 0; ArcNode *pi; int v1, v2; //scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;lg.</description>
    </item>
    
    <item>
      <title>2013年4月26日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8826%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Fri, 26 Apr 2013 22:53:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8826%E6%97%A5-%E6%99%B4/</guid>
      <description>25日 晚上去图书馆还书，没去跑步。开始读TAOCP，^_^ 26日 都起跑了才发现脚貌似有点儿受伤，大脚趾有些疼的感觉。乖乖回来了o(╯□╰)o 看来得休息几天了。 今天晚上自习的时候开始考虑要不要考研，以前的想法都是坚决不考研的，但是现在，唉……我也不知道该怎么办，总之，不想这些了，现在还是好好学习数学，英语，还有专业课，到时候想考就拼一下。目前最重要的是认真做比赛，还要努力把数学英语搞好，这货哪里都用得到。把自己的基础打好，各种技术都要自己去学，不管以后是去考研还是去找工作，都有好处，具体怎么样，以后的事情以后再说，现在想这些都没用。 纯粹胡思乱想…… 人生貌似有些迷茫了又。。迟早要面对，所谓选择和机会，都是留给认真准备的人的。什么都不会，感觉无路可走…… 看到一句话：当你倒了一杯热水，准备去喝的时候，发现水已经凉了，那么恭喜你，你已经进入状态了。</description>
    </item>
    
    <item>
      <title>2013年4月24日 阴转晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8824%E6%97%A5-%E9%98%B4%E8%BD%AC%E6%99%B4/</link>
      <pubDate>Thu, 25 Apr 2013 02:09:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8824%E6%97%A5-%E9%98%B4%E8%BD%AC%E6%99%B4/</guid>
      <description>晚上有一些冷，开始起跑的时候状态就不好，中途产生了厌跑的心理，这种事情是最可怕的，尤其是这种情况，体力跟不上，还有一些负面情绪，最后在中途停下来了，悲剧了……其实跑步的时候，最大的敌人就是自己，如何战胜自己。后来就是跑跑停停，最后还是勉强跑完了。。 唉，我承认自己的意志力可能永远没有人家强，比如高中同学shiwei，从心底里佩服这种人，能够一上午一动不动地趴桌子上做题。现在还能想起那么专注的情景，似乎外界早已经和自己无关，这种状态我貌似很少有，自从上大学以来。。真的。 不是玩手机，就是看书的时候，看一会儿就看不下去了……唉，心太浮躁了。 也许是电脑用太多了，干什么都想追求速度，电脑卡一点儿就受不了，学什么东西都想一下就学会，从来没有沉下心来认真思考过，没有全神贯注地学习过，最后也是欲速不达。 最近几天睡觉都比较早，除了今天为了补英语作业。。都没有什么时间写代码。在机房的时间也荒废了很多，不是上网了，就是干别的了，反正是时间就这么一点一点地流逝了。时间不等人。</description>
    </item>
    
    <item>
      <title>hdu2795 Billboard ——线段树入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu2795-billboard-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Wed, 24 Apr 2013 09:30:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu2795-billboard-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2795 题目大意： 高度为h,长度为w的板子，贴n个海报，每个海报的高度都为1，长度由n个整数给出。贴海报的原则是，从高到低，优先选高的，从左到右，优先选右边的位置。起初每个海报在板子上所在的行数。 题目思路： 建立一棵叶子节点有h个的线段树，每个节点代表这个区间内的最大值，最开始，叶子节点都是w。然后每插入一个值就插入到叶子节点，输出叶子节点的值，然后更新父节点。 这道题目的难点是，要想到建立线段树，把模型抽象出来。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 200000+10; int a[MAX&amp;lt;&amp;lt;2], n, h, w, b[MAX]; void pushup(int rt) { a[rt] = max(a[rt&amp;lt;&amp;lt;1], a[rt&amp;lt;&amp;lt;1|1]); } void build(int l, int r, int rt) { if (l == r) { a[rt] = w; return; } int m = (l + r) &amp;gt;&amp;gt; 1; build(lson); build(rson); pushup(rt); } void update(int p, int k, int l, int r, int rt) { if (l == r) { a[rt] -= k; return; } int m = (l + r) &amp;gt;&amp;gt; 1; if (p &amp;lt;= m) update(p, k, lson); else update(p, k, rson); pushup(rt); } int query(int k, int l, int r, int rt) { if (l == r) { return l; } int m = (l + r) &amp;gt;&amp;gt; 1, ret = 0; /* if (a[rt&amp;lt;&amp;lt;1] &amp;gt;= k) ret = query(k, lson); else ret = query(k, rson); */ if (a[rt] &amp;gt;= k) { if (a[rt&amp;lt;&amp;lt;1] &amp;gt;= k) ret = query(k, lson); else ret = query(k, rson); } else return 0; return ret; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu2795.</description>
    </item>
    
    <item>
      <title>2013年4月23日 雨</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8823%E6%97%A5-%E9%9B%A8/</link>
      <pubDate>Wed, 24 Apr 2013 08:31:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8823%E6%97%A5-%E9%9B%A8/</guid>
      <description>22日 雨 晚上下雨，没跑成…… 23日 阴转雨 晚上跑步出门的时候，有一些小雨点，但是貌似好几天没跑了，所以，还是起跑了。状态还差不多，天气也挺凉快，到终点的时候，悲剧了，开始下雨了。。还有2500+m的路程。。唉，浑身上下都是汗水和雨水。最终还是回来了，可怜我的P3……进水了还没挂o(╯□╰)o晚上回去赶紧洗澡，换衣服……</description>
    </item>
    
    <item>
      <title>hdu1394 Minimum Inversion Number ——线段树入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu1394-minimum-inversion-number-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Tue, 23 Apr 2013 23:23:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1394-minimum-inversion-number-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1394 题目大意： 给一个数字由0~n-1这n个数字组成的数列，不断地把第一个数字移动到最后，一共得到n个数列。求这n个数列中，逆序数最小是多少。 题目思路： 首先，建一棵线段树，每个节点表示这个区间内已经插入的数字的个数，开始初始化为0.然后没读入一个数字，把这个数字插入得到线段树的叶子节点，然后向上更新父节点。这样，在建树的过程中，就可以统计出每个逆序数，也就是说，可以再插入每个数字的时候，查找已经插入的数字当中，比这个数字大的数字有多少个，直到最后就可以求出这个数列的逆序数。 然后，利用数列的性质。因为每次都是把第一个数字移动到最后，比如这个数字是a，那么显然，比这个数字小的有a个，比这个数字大的有n-1-a个；因为这个数字在最前面，所以当前这个数字的逆序数是a，把这个数字移动到最后之后，这个数字的逆序数是n-1-a，逆序数增加量：n-1-a-a。这样就可以由原来的数列的逆序数求出所有数列的逆序数。好神奇~
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 5000+10; int a[MAX&amp;lt;&amp;lt;2], n, b[MAX]; void pushup(int rt) { a[rt] = a[rt&amp;lt;&amp;lt;1] + a[rt&amp;lt;&amp;lt;1|1]; } void build(int l, int r, int rt) { if (l == r) { a[rt] = 0; return; } int m = (l + r) &amp;gt;&amp;gt; 1; build(lson); build(rson); pushup(rt); } void update(int p, int l, int r, int rt) { if (l == r) { a[rt]++; return; } int m = (l + r) &amp;gt;&amp;gt; 1; if (p &amp;lt;= m) update(p, lson); else update(p, rson); pushup(rt); } int query(int L, int R, int l, int r, int rt) { if (L &amp;lt;= l &amp;amp;&amp;amp; R &amp;gt;= r) { return a[rt]; } int m = (l + r) &amp;gt;&amp;gt; 1, ret = 0; if (L &amp;lt;= m) ret += query(L, R, lson); if (R &amp;gt; m) ret += query(L, R, rson); return ret; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu1394.</description>
    </item>
    
    <item>
      <title>hdu1754 I Hate It &amp;&amp; hdu1166 敌兵布阵 ——线段树复习</title>
      <link>http://liuxueyang.github.io/posts/hdu1754-i-hate-it--hdu1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Tue, 23 Apr 2013 14:54:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1754-i-hate-it--hdu1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A4%8D%E4%B9%A0/</guid>
      <description>题目链接： http://acm.hdu.edu.cn/showproblem.php?pid=1754　 http://acm.hdu.edu.cn/showproblem.php?pid=1166 都是最基础的线段树，考的知识点就是点更新，区间求和，区间求最大值。再次学线段树，感觉理解加深了一些。 但是写的时候还是会出现各种奇葩的错误。唉。 hdu1754
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 200000+10; int gra[MAX&amp;lt;&amp;lt;2], m , n; void pushup(int rt) { gra[rt] = max(gra[rt&amp;lt;&amp;lt;1], gra[rt&amp;lt;&amp;lt;1|1]); } void build(int l, int r, int rt) { if (l == r) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;gra[rt]); return; } int m = (l + r) &amp;gt;&amp;gt; 1; build(lson); build(rson); pushup(rt); } void update(int p, int k, int l, int r, int rt) { if (l == r) { gra[rt] = k; return; } int m = (l + r) &amp;gt;&amp;gt; 1; if (p &amp;lt;= m) update(p, k, lson); else update(p, k, rson); pushup(rt); } int query(int L, int R, int l, int r, int rt) { if (L &amp;lt;= l &amp;amp;&amp;amp; R &amp;gt;= r) { return gra[rt]; } int m = (l + r) &amp;gt;&amp;gt; 1, ret = 0; if (L &amp;lt;= m) ret = max(ret, query(L, R, lson)); if (R &amp;gt; m) ret = max(ret, query(L, R, rson)); return ret; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu1754.</description>
    </item>
    
    <item>
      <title>poj2478 ——欧拉函数入门题</title>
      <link>http://liuxueyang.github.io/posts/poj2478-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 22 Apr 2013 12:58:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj2478-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=2478 题目大意： 给你一个数列f(N)，这个数列是由一系列不能约分的分数 a / b (0 &amp;lt; a &amp;lt; b &amp;lt;= n 且 (a,b) = 1)按照递增的顺序排列而成的。输入一个N，求这个数列中元素的个数。 题目思路： 因为题目只需要求出元素的个数，所以，把分母相同的放在一起，然后就发现规律了，其实就是求从2到 n 的欧拉函数的和。范围只有10^6，可以打表预处理。思路很清晰。因为要反复用欧拉函数，所以比较快的方法是用递推的方法求。 for (i = 1; i &amp;lt;= maxn; ++i) f[i] = i; for (i = 2; i &amp;lt;= maxn; i+=2) f[i] /= 2; for (i = 3; i &amp;lt;= maxn; i+=2){ if (f[i] == i){ for (j = i; j &amp;lt;= maxn; j+=i){ f[j] = f[j] / i * (i - 1); } } }  　这个方法和筛法求素数比较类似，貌似就是那个思想。模拟一下什么就懂了。这里也用到了欧拉函数的性质：φ(n) = n * (1 - 1/p1) * (1 - 1/p2) * …… * (1 - 1/pk)。</description>
    </item>
    
    <item>
      <title>poj2407 Relatives ——欧拉函数入门题</title>
      <link>http://liuxueyang.github.io/posts/poj2407-relatives-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 22 Apr 2013 08:36:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj2407-relatives-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=2407 题目大意： 这个题目就是欧拉函数的定义，求一个数字的欧拉函数。 题目思路： 用公式：φ(n) = n * (1-1/p1) * (1-1/p2) * …… * (1-1/pk)。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;poj2407.</description>
    </item>
    
    <item>
      <title>poj2480 Longge&#39;s problem ——积性函数入门题</title>
      <link>http://liuxueyang.github.io/posts/poj2480-longges-problem-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 21 Apr 2013 23:45:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj2480-longges-problem-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=2480 题目大意： 给定一个数字N，求∑gcd(i, N) 1&amp;lt;=i &amp;lt;=N 的值。 题目思路： x是一个数字，m与n互素，则gcd(x,m*n) = gcd(x, m) * gcd(x, n) 令g(y) = gcd(x, y) 那么g(y)是一个积性函数。令f(N) = ∑gcd(i, N) 满足gcd(x, n) = 1 的个数是欧拉函数φ(n)，那么可以知道，满足gcd(x, n) = p 的个数可以这么求：x 和 n 同时除以 p ，那么gcd(x/p, n/p) = 1 ，那么个数就是φ(n/p)。 分解N = p1^a1 * p2^a2 * …… *pn^an ，则f(N) = f(p1^a1 * p2^a2 * …… *pn^an) = f(p1^a1) * f(p2^a2) * …… * f(pn^an)； 可以枚举pi^ai的因数，对于f(pi^ai) = 1 * φ(pi^ai) + pi * φ(pi^(ai-1)) + pi^2 * φ(pi^(ai-2)) + …… + pi^(ai-1) * φ(pi) + pi^ai * φ(1)； 根据φ(pi^ai) = pi^ai - pi^(ai-1)，那么可以化简上面的式子：f(pi^ai) = ai * pi^ai + ai * pi^(ai-1) + pi^ai = pi^ai * (ai + ai/pi + 1)； 所以，f(N) = N * (a1 + a1/p1 + 1) * (a2 + a2/p2 + 1) * …… * (an + an/pn + 1)。 这题当然不是自己想出来的，但是学习了一下积性函数，看的神牛的解题代码：http://hi.</description>
    </item>
    
    <item>
      <title>2013年4月21日 阴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8821%E6%97%A5-%E9%98%B4/</link>
      <pubDate>Sun, 21 Apr 2013 23:04:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8821%E6%97%A5-%E9%98%B4/</guid>
      <description>19日 晚上挑战赛，输了，回宿舍很晚了，没去跑步。 20日 今天状态不是很好，中途P3还没电了……虽然跑得很慢，但还是跑完全程了~ 21日 晚上校队讨论，回去10点多了，没去跑步。今天上午上西班牙语选修课，很有意思~中南赛没能去，唉。以后挑战赛坚决不能输！</description>
    </item>
    
    <item>
      <title>uestc1824 Judgment Day ——比赛残留题</title>
      <link>http://liuxueyang.github.io/posts/uestc1824-judgment-day-%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/</link>
      <pubDate>Sat, 20 Apr 2013 09:30:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uestc1824-judgment-day-%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/</guid>
      <description>题目链接：http://www.acm.uestc.edu.cn/problem.php?pid=1824 题目大意： 给一个大的字符串，给一个数字n，然后给出n个小的字符串，在大的字符串里面每个字母只能选一次，问最多可以组成多少个小的字符串。小的字符串最多有10个，每个小字符串和大字符串长度最多10000。 题目思路： 因为最多有10个小的字符串，从10个里面选，最多有1024种选法。因为字符串只包含26个小写字母，可以统计每个小字符串里面的每个小写字母的个数，这样，复杂度大约在10×26×1024,是10^5的范围，可以枚举。 比如对于n个字符串，最多有1&amp;lt;&amp;lt;n种，用 x 从1枚举到1&amp;lt;&amp;lt;n - 1，然后用 j 从 0 枚举到n-1，用 1 &amp;lt;&amp;lt; j 和 x 相与，如果为1,则 j +1 表示第 j + 1 个人被选上了，判断它是不是能被选上，如果能被选上，那么 cnt++，再和max相比较，最后得到max。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int L = 100000+10; char s[L], a[15][L]; int t, nn, cnt[29], ca[15][29], cc[29]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;j.</description>
    </item>
    
    <item>
      <title>2013年4月19日 四校联赛挑战赛总结</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8819%E6%97%A5-%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B%E6%8C%91%E6%88%98%E8%B5%9B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 20 Apr 2013 09:06:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8819%E6%97%A5-%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B%E6%8C%91%E6%88%98%E8%B5%9B%E6%80%BB%E7%BB%93/</guid>
      <description>卡在了水题上。后面的题目就不用说了，根本就没看。平时学习的东西根本就没有用上，简单题这一关就过不了。 唯一需要注意的就是，一道题目，有了想法，自己先把能考虑到的情况都考虑周全，不要指望和队友讨论再讨论一下，有的时候队友在思考自己的想法，没有时间，所以自己一定要考虑周全，再敲代码，千万不要有一个想法就敲，快写完的时候发现错了……就悲剧了。还有就是，读题，这次我就读错了一道题目，把队友坑了，虽然后来队友发现了，但我们三个还是都没有想法，比较坑的是，这题可以枚举，因为是10个人，范围很小。我们三个都没有注意到这一点。llh本来当时还问了一下范围，我看题的时候看到了10人，后来忘了，，就说题目没有给……我去……以后一定不能出现这种情况！ 然后就是代码能力，千万不能把代码敲错，比如赛后敲一道题目，思路很清晰，但是敲的时候就错了，调试很久，后来才发现，原来是自己命名的变量用错了，还有一些地方写错了……浪费很多时间，照这个情况，就算这道题目比赛的时候知道怎么做，也不一定能敲出来，虽然就是枚举。 比赛的时候过得第二道题目，我的想法是错的，llh有另一个想法，敲完后不知道哪里错了，虽然给我讲了，但是还是不太理解，最后还是因为一个小细节没处理好。不是想法的问题。当初我能够仔细按照那个想法做一下就好了，以后队友讲想法的时候认真理解。 总的来说，还是水题都过不了。第一：没有想法。第二，代码能力。第三，好好学STL，有的时候，切水题用STL很方便。至于没有想法这个问题，只有多练习，多思考，一般的水题都不会太难，考察的关键是思路和代码能力。 zsl神牛昨天跟我说，每次比赛都要好好总结，比赛后没过的题目都要过了，只要校队有人过的，都必须过，没人过的，也要过几道，如果校队的人都比不过，到了现场赛就不用说了！唉，确实是这样。谢谢sl学长。 这次挑战赛又输了，四校联赛又不能去了，我们队从来没有赢过Babel。唉，太窝囊了…… 从现在起，坚决不能再输给他们了！ 5月份就去南京邀请赛了，我不知道为什么我们从来没有赢过Babel却可以去南京，但是，既然让我们队去了，就别想别的，不要让大家失望，认真珍惜这次出去的机会！</description>
    </item>
    
    <item>
      <title>poj2001 Shortest Prefixes ——字典树复习</title>
      <link>http://liuxueyang.github.io/posts/poj2001-shortest-prefixes-%E5%AD%97%E5%85%B8%E6%A0%91%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Fri, 19 Apr 2013 15:46:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj2001-shortest-prefixes-%E5%AD%97%E5%85%B8%E6%A0%91%E5%A4%8D%E4%B9%A0/</guid>
      <description>题目链接：http://poj.org/problem?id=2001 这道题目以前写过，复习一下字典树，再写一遍……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; char a[1000+10][30], base = &#39;a&#39;; const int lo = 26; typedef struct trie{ int num; bool terminal; struct trie *son[lo]; }trie; trie *newtrie(){ trie *pnt = new trie; pnt-&amp;gt;num = 1; pnt-&amp;gt;terminal = false; for (int i = 0; i &amp;lt; lo; ++i) pnt-&amp;gt;son[i] = NULL; return pnt; } void insert(char str[], trie *pnt, int len){ trie *tem = pnt; for (int i= 0; i &amp;lt; len; ++i){ if (tem-&amp;gt;son[str[i]-base] !</description>
    </item>
    
    <item>
      <title>poj1298 The Hardest Problem Ever ——水题</title>
      <link>http://liuxueyang.github.io/posts/poj1298-the-hardest-problem-ever-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Fri, 19 Apr 2013 14:18:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1298-the-hardest-problem-ever-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1298 题目大意： 字母映射。太简单了。不说了。感脚都不好意思在博客里面写……水题一次最多切3道，再多就没意思了……也没有意义…… 题目思路： 为了学习ＳＴＬ，用的ｍａｐ。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; map&amp;lt;char, char&amp;gt; mymap; string a, b, c; char aa[10000]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;1298.</description>
    </item>
    
    <item>
      <title>poj3087 Shuffle&#39;m Up ——水题</title>
      <link>http://liuxueyang.github.io/posts/poj3087-shufflem-up-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Fri, 19 Apr 2013 13:53:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj3087-shufflem-up-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=3087 题目大意： 给定长度都为Ｃ两个字符串，Ｓ１，Ｓ2，和一个要求的结果字符串ＳＳ。先把Ｓ２的最下面一张牌放在最下面，然后Ｓ１，Ｓ２交错的叠放，得到Ｓ，再把Ｓ最下面的Ｃ个字符赋值给Ｓ１，把剩下的赋值给Ｓ２，再次重复上面的过程。最后求出要得到ＳＳ，需要几步这样的过程。 题目思路： 开始以为是用ＳＴＬ的栈，后来才发现根本用不到，直接用字符串模拟就可以了。为了学习一下ＳＴＬ，用的是ｓｔｒｉｎｇ类。只要比较当前得到的字符串和要得到的字符串是不是相等就可以了。如果永远也得不到要得到的字符串，那么就一定存在Ｓ１和Ｓ２和原来的Ｓ１和Ｓ２都对应相等，其实这道题目的难点就在这里。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;3087.</description>
    </item>
    
    <item>
      <title>poj1002 487-3279 ——水题</title>
      <link>http://liuxueyang.github.io/posts/poj1002-487-3279-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Fri, 19 Apr 2013 11:22:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1002-487-3279-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1002 题目大意： 给定一组电话号码，如果是包括字母，那么就映射到数字，统计相同的电话号码个数大于1的号码，按照从小到大的顺序输出，并且输出相应的个数。 题目思路： 因为电话号码最多又7位数字，在整数范围内，把每个读入的电话号码转化成整数，用一个ｍａｐ记录是不是出现过，如果出现过，就把相应的ｍａｐ记录加1,如果没有出现过，就把这个数字放进一个数组ａｒｒ里面，这样ａｒｒ里面的数字是不重复的。最后把ａｒｒ排序，对于每一个数组元素，输出相应的ｍａｐ记录，也就是它出现过的次数。 输出的时候，按照整数输出，但是要注意，开始要输出3位，如果前面有0的话，按照整数输出就不行，所以要控制格式，用ｐｒｉｎｔｆ（“%03ｄ”）；这样的格式，表示前面要补齐0；卡住了，看得以前的代码才想到这种情况，还是思维不严谨 啊～
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MINN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int arr[100000+10]; map&amp;lt;char, int&amp;gt; ma; char pri[10]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;poj1002.</description>
    </item>
    
    <item>
      <title>2013年4月18日 雨</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8818%E6%97%A5-%E9%9B%A8/</link>
      <pubDate>Thu, 18 Apr 2013 23:46:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8818%E6%97%A5-%E9%9B%A8/</guid>
      <description>今天跑步状态超好，呼吸，速度都控制得很好，不知不觉就跑完全程了，还有一种意犹未尽的感觉。O(∩_∩)O哈哈~ 刚刚发现，其实自己每天的跑步路程也不过5200米，赶脚弱爆了……~唉，继续加油吧~~</description>
    </item>
    
    <item>
      <title>2013年4月17日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8817%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Wed, 17 Apr 2013 23:37:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8817%E6%97%A5-%E6%99%B4/</guid>
      <description>今天跑步状态不错。起跑的时候正好遇到两个哥们在一起跑，我去……还跑得挺快，遇到高手了，但是正好也有了动力，紧跟着跑，状态还不错，跑得挺爽，好久没这么有激情地跑过了，然后不到一半的时候，一哥们干脆停下来了……挺悲剧的，唉，只要一停下来，就基本跑不起来了，然后就剩下我跟另一个人跑，那人很强悍，以那个速度，一直那么跑，不带减速的，然后我心理想：这回遇到真正的高手了。他同时也在加速，我有点儿撑不住，但是还是尽力坚持，因为我知道，只要距离拉远了，再跟上就不可能了，一直这么坚持了一段时间，心里想着，当一个人的平均速度和别人本来就有差距的时候，注定是没有赢得希望的，因为人家以正常的速度跑，习惯了，你以人家的速度跑，一般很快就到了极点，好的情况就是距离被拉远，自己速度放慢，调整自己，直到平稳下来，以自己正常的速度跑；比较悲剧的情况是，到了自己的极点，透支了体力，干脆停下来了。但我还是坚持跟上，不让自己和对方的距离拉大，努力和对方的距离，不超过两三秒的样子，再到后来，那哥们停下来了，我去……这……唉，悲剧了，然后我就可耻地轻松地超过了人家o(╯□╰)o 其实那人挺强的，以他那个速度，我不可能像他那样坚持那么长的距离，但是我还是坚持下来了，运气好~O(∩_∩)O哈哈~ 然后我就继续以那个速度跑到了终点，太爽了，好久不这么畅快地跑了，稍微休息一下，原路返回，显然没有那么多体力了，所以就以超慢的速度，跑回来了，当做调整一下。 其实，在比赛的过程中，尤其是有一个人快要超过你的时候，很多人都是适当加快速度，给对方以心理压力，但是，过度逞强，完全打乱了自己的节奏就得不偿失了，最终很可能被别人超过，甚至自己体力透支，不得不停下来，当你因为别人改变自己的节奏，一开始你就输了，即使最终赢了，也没有发挥出自己最好的状态。跑步的过程中，很大一部分比的是心理和意志力，如果实力和体力相差不大的话。 其实，有一个比你强的人在你前面，确实能让跑步的效果更好，但是，更多的时候是自己一个人跑，当没有别人带着你的时候，你要学会自己调整，呼吸和心态。毕竟，跑步是自己的事情，没有人能帮你。别的事情也一样…… 最近事情超多，比较忙，甚至写程序的时间也很少了，只有提高自己的效率，写程序就要认真写，做作业就要全神贯注地做，不能三心二意，平时的零碎时间可以想想算法，认真体会算法的思想，尤其是，养成一开始就养成不依赖模板的习惯，自己手敲，多敲几遍，每次敲的时候都会有不同的错误，但是在这个过程中，也加深了自己对算法的理解。一道题目不会做，不要急着去翻人家的解题报告，自己多想想，或者有思路了，代码敲出来了，但是有怎么也找不出来的bug，这个时候可以先放一放，过几天再拿出来敲一遍，或许就豁然开朗了，很多问题都是自己当时陷入了思维误区，或者长时间想一个问题，把自己搞糊涂了，过一段时间再想，再分析一下就感觉思路更清晰了。不要一个bug找好久，效率很低，也耽误了学习新知识的时间。同时也注意多培养自己的代码能力，一道题目好不容易有想法了，但是敲出来的代码就是有各种bug，这就反映出了自己的代码能力和代码习惯，有的人代码习惯比较好，虽然敲得比较慢，但是能够1A，这种比我这种很快敲出来，但bug无数的好多了……我去…… 说实话，很惊讶，我们队竟然有机会去南京的邀请赛……RP值爆发了，好有压力，所以，什么也不想了，加油!</description>
    </item>
    
    <item>
      <title>Snakes &amp; Ladders ——BFS入门题</title>
      <link>http://liuxueyang.github.io/posts/snakes--ladders-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Wed, 17 Apr 2013 09:28:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/snakes--ladders-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=116&amp;amp;page=show_problem&amp;amp;problem=555 题目大意： 给一个棋盘，分布着蛇和梯子，投骰子确定走的步数，问最少投几次骰子可以到达终点，到达蛇头就回到蛇尾，到达梯子底部就上升到梯子顶部。 思路： BFS，到达每一个节点都可以扩展出6个节点，判断终点是不是到达过，如果到达过，退出循环。 这题WA了……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int D, N , S, L, a[23*23], b[23*23]; typedef struct La{ int start, end; }La; La la[120]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;arb.</description>
    </item>
    
    <item>
      <title>poj1006 Biorhythms ——中国剩余定理入门题</title>
      <link>http://liuxueyang.github.io/posts/poj1006-biorhythms-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Wed, 17 Apr 2013 02:20:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1006-biorhythms-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1006 题目大意： 人体有三个周期，23，28，33. 对于每个周期分别给出从第0天开始，这三个周期的高潮出现的一个日期，不一定是第一次，p , e , i 。给出一个天数 d 表示今年已经过去了多少天，计算在这 d 天之后，三个高潮同时出现的那一天距离现在还有多少天。 思路： 23， 28， 33 是两两互素的，题目意思就是求一个数字 x ，使得这个数字 x 和 p 对23同余，同时 x 和 e 对28同余，同时 x 和 i 对33同余。所以可以用中国剩余定理解。 这是一个同余方程组。 x = p(mod 23); x = e (mod 28); x = i(mod 33); 这里的&amp;rsquo;=&amp;lsquo;代表同余符号。 因为求的是大于d的，所以，当求得的解小于等于d的时候，要加上模 23*28*33；直到解大于d为止。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int d, p, e, i, m[4], a[4]; LL M, Mi; void exgcd(int a, int b, int &amp;amp;d, int &amp;amp;x, int &amp;amp;y){ if (!</description>
    </item>
    
    <item>
      <title>2013年4月16日 阴转晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8816%E6%97%A5-%E9%98%B4%E8%BD%AC%E6%99%B4/</link>
      <pubDate>Tue, 16 Apr 2013 22:42:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8816%E6%97%A5-%E9%98%B4%E8%BD%AC%E6%99%B4/</guid>
      <description>今天跑步状态两个字：完美！ 从一开始就感觉跑得比较快，并且节奏和呼吸都控制得比较好，本来觉得可能跑不完全程，结果连自己都很惊讶，竟然以那样的速度跑完了全程，时间大约40分钟，路程貌似是最长的一次，好神奇。可能是今天身体状态比较好，再加上心理状态比较积极，好久没有跑得这么酣畅淋漓了！ 其实跑步的过程中，最重要的是战胜自己的心理，通过了这一关，剩下的就都不是问题了，有时候甚至会惊讶于自己竟然 能够跑这么远，起初这都是不曾想象过的。 总之今天跑步的速度堪比当年高中时候的跑步速度，O(∩_∩)O哈哈~太爽了 ACM其实只是一个比赛，当做一种爱好吧，全力以赴，不为别的，只因为兴趣而已，解决问题的成就感是最吸引人的~在ACM上强加上一些别的东西反而觉得很没意思了……不单单是做题，最重要的是培养自己独立思考和解决问题的能力，奖项只是附加品，不是全部。千万不要舍本逐末。</description>
    </item>
    
    <item>
      <title>2013年4月15日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8815%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Tue, 16 Apr 2013 00:49:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8815%E6%97%A5-%E6%99%B4/</guid>
      <description>13日 晴 那天去中南比赛，回来比较累，下午睡了一觉，晚上去跑步，然后喝了一口水，我去……跑的过程中各种纠结，，唉，全程不舒服，走走停停，很不爽。 14日 晴 天气比较好，可惜，晚上校队有讨论，回到宿舍已经10点半了，这个时候的湘江边几乎没什么人了，貌似还有点儿害怕~长沙这种，地方嘛，^_^ 跑一半路程就回来了，一点儿也没意思，o(╯□╰)o 后来权当散步了。。。。 最近几天貌似状态不好啊。 15日 晴，小雨 晚上去跑步，开始有一哥们儿在我后面跑，赶脚好有动力，O(∩_∩)O哈哈~所以开始速度比较快，跑到后期那哥们儿从另一条路走了，每个人的路线都不一样啊，后来一直自己跑，回来的路上，突然下起了雨，悲剧了，还是雨点儿特别大的那种，然后继续跑，最担心的是手机和P3进水了……o(╯□╰)o不过还好，不到几分钟，雨就停了，后来觉得没什么意思，走走停停地回来了…… 今天为yr酱他当初每天做几道题，不算水题，答曰：10+。我……难道这就是境界的差别么？唉，不可同日而语 难道大神们都是这么练出来的么？好吧，ORZ……加油吧，显然是做的太慢了。。 妈妈说，在ACM界有三种人可以生存下来：1. 天赋异禀 2. 勤奋过人 3. 媳妇熬成婆 照个进度下去，要是还不努力，我估计最多属于第三种。。o(╯□╰)o 不扯了，赶紧刷题去！</description>
    </item>
    
    <item>
      <title>uva10591 - Happy Number ——水题</title>
      <link>http://liuxueyang.github.io/posts/uva10591---happy-number-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Mon, 15 Apr 2013 23:35:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva10591---happy-number-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=1532 题目大意： 给一个数字，各位数字的平方和相加，依次循环，如果最后得到1，那么这个数字就是happy number，如果不能，就是unhappy number。 思路： 因为题目范围只有10^9，所以可以暴力求解，数字的平方和最大是9*9*9=729，可以用一个数组标记这个数字是否被访问过。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int visit[1000]; int solve(int n){ int m = 0; while (n){ m += (n%10)*(n%10); n /= 10; } return m; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;uva10591.</description>
    </item>
    
    <item>
      <title>hdu2098 不要62 ——数位DP入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu2098-%E4%B8%8D%E8%A6%8162-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 15 Apr 2013 21:24:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu2098-%E4%B8%8D%E8%A6%8162-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2089 题目大意： 含有4或者62的数字是不吉利数字，给一个区间，[m, n]，求这个区间内的除了不吉利数字以外的数字的数目。 思路： 由于数据范围只有1~1000000，可以暴力，水题，但是为了练习一下数位DP，没有把它当水题做…… 看的是这个人的代码：http://blog.csdn.net/acm_cxlove/article/details/7819907# 和hdu3555那道题目相似，但是多了一个条件，多了一个不含有4的条件，讨论一下。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; LL dp[8][3]; int a[8], b[8]; bool flag; int solve(int k){ int len = 0; LL temp = k; while (k){ a[++len] = k % 10; k /= 10; } LL ans = 0; int last = 0; flag = false; a[len+1] = 0; for (int i = len; i &amp;gt;= 1; --i){ ans += dp[i-1][2] * a[i]; if (flag){ans += dp[i-1][0] * a[i];} //高位位填4，低位的不管 if (!</description>
    </item>
    
    <item>
      <title>hdu1202 The calculation of GPA ——水题</title>
      <link>http://liuxueyang.github.io/posts/hdu1202-the-calculation-of-gpa-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Mon, 15 Apr 2013 20:39:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1202-the-calculation-of-gpa-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1202 题目大意：先计算出学分和点数的乘积的和，然后在除以学分之和。 思路： 很简单。只能说这道题目比较坑……不说什么了 本来是早上起来想写道水题，练练手，结果碰见这种题目，刚才我还无聊的测试了很多次，交了N遍，发现这么个坑的问题，感觉这种题目很没有意思……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu1202.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif int t; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;t)){ double cnt = 0, cnt1 = 0; double s, p; for (int i = 0; i &amp;lt; t; ++i){ cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; p; cnt += s; if (p&amp;gt;=90 &amp;amp;&amp;amp; p &amp;lt;= 100) cnt1 += 4.</description>
    </item>
    
    <item>
      <title>uestc1307 windy数 ——数位DP入门题</title>
      <link>http://liuxueyang.github.io/posts/uestc1307-windy%E6%95%B0-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 15 Apr 2013 19:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uestc1307-windy%E6%95%B0-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.uestc.edu.cn/problem.php?pid=1307  题目大意： 不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。windy想知道，在A和B之间，包括A和B，总共有多少个windy数？ 思路： 具体解释代码中有。看的这个人的代码：http://blog.csdn.net/acm_cxlove/article/details/7819907# 然后自己又分析了一下，终于明白了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int dp[15][10], a[15]; // 这个函数求的是区间（0，n）内的个数 LL solve(int n){ int len = 0; LL ans = 0; while (n){ a[++len] = n % 10; n /= 10; }int i, j; a[len+1] = 0; // 长度为1~len-1 for (i = 1; i &amp;lt;= len-1; ++i) for (j = 1; j &amp;lt;= 9; ++j) // 注意j从1开始，因为最高位不能是0！ ans += dp[i][j]; // debug了好久！！！ // 长度为len，但是最高位是a[len] - 1 for (i = 1; i &amp;lt;= a[len] - 1; ++i) ans += dp[len][i]; // 长度为len，但是最高位是a[len] for (i = len - 1; i &amp;gt;= 1; --i){ for (j = 0; j &amp;lt; a[i]; ++j) if (abs(a[i+1] - j) &amp;gt;= 2) ans += dp[i][j]; if (abs(a[i] - a[i+1]) &amp;lt; 2) break; } return ans; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;uestcoj1307.</description>
    </item>
    
    <item>
      <title>hdu3555 Bomb ——数位DP入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu3555-bomb-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 14 Apr 2013 11:23:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu3555-bomb-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=3555 题目大意： 给一个数字n,范围在1~2^63-1，求1~n之间含有49的数字有多少个。 思路： 经典的数位DP，学习了一下，看的别人的代码：http://www.cnblogs.com/luyi0619/archive/2011/04/29/2033117.html 状态转移： dp[i][0]代表长度为 i 并且不含有49的数字的个数； dp[i][1]代表长度为 i 并且不含有49，但是最高位是9的数字的个数； dp[i][2]代表长度为 i 并且含有49的数字的个数。 数组 a[i] 从低位到高位存储 n 的每一位数字。 则：dp[i][0] = dp[i-1][0] * a[i] - dp[i-1][1]; 表示长度为 i 的不含有49的数字的个数等于长度为 i - 1 的不含有49的数字的个数*当前的数字，因为这个位置可以填0~a[i] - 1，然后再减去长度为 i - 1 的最高位是9的数字的个数，因为如果长度为 i - 1 的最高位是9的话，那么高一位就不能填4了，否则就组成了49。 dp[i][1] = dp[i-1][0]; 表示长度为 i 的并且不含有49同时最高位是9的数字的个数等于，长度为 i - 1 的不含有49的数字的个数，因为只要在它的高一位加上一个9就可以了。 dp[i][2] = dp[i-1][2] * a[i] + dp[i-1][1]; 表示长度为 i 的含有49的数字的个数等于，长度为 i - 1 的数字的个数*当前的数字，再加上长度为 i - 1 的并且不含有49同时最高位是9的数字的个数，因为这个时候，只要在高一位加上一个4就可以了，这样在最高的两位就组成了一个49。 做法是从数字的高位向低位扫描，对于第 i 位， 其实这个题目还有一个地方不懂，就是为什么要在输入 n 后，要把 n 加1。想了一下特例，比如输入49，按照上面的做法，在第3步，并不会把符合条件的数字加上，因为4不是严格大于4，最后的执行结果就是0，但是如果加上1之后，n就变成了50，这样第3步恰好可以执行，结果就是正确的了。但是对于一般的情况，还是不知道为什么要把n加1……o(╯□╰)o 这题还是卡了很久，照着别人的代码敲的，死活过不了，然后又找了一份代码：http://blog.</description>
    </item>
    
    <item>
      <title>2013年4月12日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8812%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Sat, 13 Apr 2013 02:49:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8812%E6%97%A5-%E6%99%B4/</guid>
      <description>休息了两天，今天本来想好好跑一下，结果还没有出公寓就岔气了……后来全程都不爽，一直岔气，想起一句话：比赛中的错误往往是在起跑后的两分钟内犯下的，甚至是在第一分钟内。后来跑得还算好吧，但是没有了节奏感，明天希望状态好一点儿~</description>
    </item>
    
    <item>
      <title>zoj2913 Bus Pass ——BFS入门题</title>
      <link>http://liuxueyang.github.io/posts/zoj2913-bus-pass-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sat, 13 Apr 2013 01:29:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj2913-bus-pass-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1912 题目大意： 有很多个地区，有几条公交线经过一些地区，求出一个地区，满足，使这个地区到这些公交线上的所有公交站的距离中的最大值，最小。（这里的距离指的是两点之间的边数） 思路： 对于这些公交站中的每一个点，BFS，求出出当前点外，其他所有点到这个点的最小距离，然后对于公交站上的其他点，也进行同样地操作，不断更新所有点到公交站上的当前点的最小距离的较大值，然后遍历所有点，求出距离最小的一个点。用res1数组存储。res数组的作用是对于公交线上的每个点，BFS其他点的时候，临时存放其他点到这个公交站的最小距离，然后在与res1数组进行比较，用来更新res1数组。 注意： visited数组，标记这个是不是被访问过，并且标记的顺序要想清楚！把这个点入队的时候就要标记它被访问了，而不是它出队的时候再标记！这是因为，如果两天点同时和一个点相邻，如果等点出队的时候在标记的话，就会产生这个点被访问两次的情况，这个问题让我纠结了一个星期……我去……
比如这种情况，Ｃ和Ａ，Ｂ同时相邻，假如：先访问Ａ，ｒｅｓ［Ｂ］　＝　ｒｅｓ［Ｃ］　＝　２，把Ａ标记，然后出队；再访问Ｂ，ｒｅｓ［Ｃ］　＝　３，Ｃ的值显然是不对的，所以，当把Ｂ，Ｃ两个点入队的时候，就把他们标记为已经访问，就可以了…… 做这个题目感触挺大的，首先，写代码要全神贯注，不能有一点儿疏忽，否则很容易犯那种超级难找出来的隐蔽的错误，一定要考虑明白再写；然后就是数组的下标什么的，养成好习惯，到底什么时候该从０开始，什么时候该从１开始，我觉得从１开始比较保险，因为有的时候会用到编号，比如这道题目，点的标号从１开始；最后就是思考这种题目应该如何存储题目给的信息，这个东西是看的书上的思想； 自己写代码比看着人家的代码写感觉和收获是完全不一样的。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 10000+10; int edge[MAX][11], res[MAX], res1[MAX], ve, pa, mz[MAX]; bool visited[MAX]; queue&amp;lt;int&amp;gt; qt; void bfs(int id){ res[id] = 1; qt.</description>
    </item>
    
    <item>
      <title>一个bug，持续更新……</title>
      <link>http://liuxueyang.github.io/posts/%E4%B8%80%E4%B8%AAbug%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Fri, 12 Apr 2013 19:48:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E4%B8%80%E4%B8%AAbug%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</guid>
      <description> scanf(&amp;ldquo;%d%d&amp;rdquo;, &amp;amp;n, &amp;amp;mz[n]); 这样的写法是不对的…… 全局变量不要和局部变量命名成相同的名字，尤其是循环变量不要设置成全局的，很危险。 数组要初始化，尤其是多case的时候 写代码的时候要全神贯注，千万不要因为一时的疏忽，出现一个最难发现的最弱智的bug…… 还有，memset(a, 1, sizeof(a));貌似有错……慎用。注：这货只能用4个字节都相同的整数！比如，0x7f7f7f7f 或者 0x3f3f3f3f 有一点最受不了的就是：为什么最近输入老是忘了写取地址符？果然是敲代码敲得少了么…… 输入格式，要用%lld还是%I64d，也可以用cin,cout如果输入量比较少的话。 D = 3；1 &amp;lt;&amp;lt; D - 1 的结果是什么？注意优先级！有位运算的需要加上括号！ ==不要写成=，以前以为自己肯定不会犯这种错误，谁知道……唉 初始化技术变量，尤其是多case的时候 当多个case运行不对的时候，尝试一下只输入一个case，因为可能是多case的过程中，变量没有初始化 尤其是开数组的时候，千万不能把大小写错了，或者，当出现运行都出现系统错误的时候，可能是数组越界了，看一下开数组的时候是不是开小了，或者是数字打错了。 代码错了，自己想办法出数据测试，其实是一种十分重要的能力。 写线段树的时候，计算中点的时候，int M = L + (R-L)&amp;gt;&amp;gt;1；这么写是不对的。。至于为什么，我也不知道。。反正因为这货卡了好久== 直接这么写就行：int M = L+(R-L)/2；  </description>
    </item>
    
    <item>
      <title>2013年4月9日 阴转小雨</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%889%E6%97%A5-%E9%98%B4%E8%BD%AC%E5%B0%8F%E9%9B%A8/</link>
      <pubDate>Wed, 10 Apr 2013 07:37:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%889%E6%97%A5-%E9%98%B4%E8%BD%AC%E5%B0%8F%E9%9B%A8/</guid>
      <description>下午下雨，晚上去跑步，半路上下小雨点，开始犹豫要不要继续往前跑，最后到一半路程的时候就往回走了，结果又不下雨了，长沙的鬼天气，跑着一点儿也不爽，状态很不好，可能是该休息一两天了，后期的时候干脆就当散步了，走回来了…… 不过雨后的湘江边确实空气也挺好，一边走边思考问题，也是一种不错的享受～</description>
    </item>
    
    <item>
      <title>2013年4月8日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%888%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Tue, 09 Apr 2013 02:05:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%888%E6%97%A5-%E6%99%B4/</guid>
      <description>今天跑步很悲剧，遇到极点了，中途各种不想跑，各种累，但还是坚持下来了，嗯，跑步嘛，总会有这种时候，尤其是今天下午也比较热，这种时候，最重要的就是两个字：坚持。不管怎么样，千万不能停下来，如果一停下来，基本就跑步不起来了…… 加油~</description>
    </item>
    
    <item>
      <title>zoj 1649 Rescue ——BFS入门题</title>
      <link>http://liuxueyang.github.io/posts/zoj-1649-rescue-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 08 Apr 2013 20:21:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj-1649-rescue-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=649 题意： 给一个字符矩阵，‘#’代表墙壁，&amp;rsquo;.&amp;lsquo;代表空格，‘x’代表有警察的空格，&amp;rsquo;r&amp;rsquo;和&amp;rsquo;a&amp;rsquo;分别代表一屌丝，并且&amp;rsquo;r&amp;rsquo;要到&amp;rsquo;a&amp;rsquo;那里去串门儿，r走一个空格花费单位时间1，走一个有警察的空格需要先干掉警察，话费单位时间1，然后再走过去，也就是共花费时间2，请问屌丝r到屌丝a那里去最少花费的时间。 思路： 首先要搞明白一个问题：就是路径最短的路不一定花费时间最少。这是可以理解的，比如，一条很短但是有很多警察，另一条路很长，但是没有警察，很有可能是第二条路花费时间少。用深搜？貌似不太合适，因为你一条路径访问过一个点后，另一条路径很可能也会访问这个点，并且时间较少。关键是深搜找到的接不一定是最优的。所以，考虑用广搜解。这道题最朴素的广搜显然不行，也就是说，仅仅求步数最少的不可行，需要加上访问时间这个附加条件。 用一个结构体数组存储每个点的信息，包括坐标，到达这个点所需要的最短时间，从起点开始搜，先访问起点，然后把起点出队，如果从一个点A到达下一个点B的当前所需时间比这个点现在标记的时间少，则把这个点入队，然后判断点A的另一个方向上的下一个点。这样，总有一天队列会为空，这是因为，某个点不可能被访问无数次，也就是说，某个点不可能无数次入队，因为到达某个点所需要的时间一定是有个最小值的，所以BFS一定可以结束，并且最后找到的点‘a’的信息一定是最优解。输出就可以了，如果无解，因为初始化到达所有点所需时间都是MAXN，所以，如果点‘a’的时间信息如果等于MAXN，那么说明无解。 第一次做深搜，这道题开始不知道怎么做，看了书上的思路，坚持没看代码，自己又想了想，就试着开始写，好神奇，竟然1A了！！！
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MINN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; typedef struct point{ int a, b, t; }point; point p[220][220], st, en; char s[220][220]; int n, m, T, si, sj, di, dj; queue&amp;lt;point&amp;gt; qt; void bfs(){ qt.</description>
    </item>
    
    <item>
      <title>2013年4月7日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%887%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Mon, 08 Apr 2013 07:26:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%887%E6%97%A5-%E6%99%B4/</guid>
      <description>昨天补概率论作业，没时间写，补上~ 今天天气很好，但是下午最后一节有课，所以打算晚上9点钟去跑步。 不得不说，晚上的湘江边很美，尤其是天气很好的晚上，春天，也许是最适合跑步的季节，不冷不热，微风习习，一路上还看见不少跑步的男男女女，有的是为了锻炼身体，有的是为了减肥，有的单纯是因为爱好。 今天跑步状态不错，很稳，时间，速度都控制得很准，正好半小时。然后在湘江边做了一下拉伸，稍微休息了一下，欣赏了一下美景，就心满意足地回来了。 其实，晚上去跑步也别有一种感觉。以后，下午最后一节有课就晚上去跑，否则就下午。 附上一段代码：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif int day = 当前寿命; while (1){ if (!</description>
    </item>
    
    <item>
      <title>speedcell&#39;s SPFA</title>
      <link>http://liuxueyang.github.io/posts/speedcells-spfa/</link>
      <pubDate>Sun, 07 Apr 2013 19:21:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/speedcells-spfa/</guid>
      <description>版权永久属于speedcell，神代码，给跪了……yr酱V5…… 这东西虽然还没有学，先收藏起来~ 多谢yr酱……O(∩_∩)O哈哈~
/* Author : Speedcell Update : 2013-03-24 Version : soppYcell 2.1(a) */ #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;bitset&amp;gt; #include &amp;lt;memory&amp;gt; #include &amp;lt;complex&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;math.h&amp;gt; #include &amp;lt;time.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; #include &amp;lt;locale.h&amp;gt; using namespace std; #pragma pack(4) #ifndef __CONSTANT__ #define __CONSTANT__ typedef long long LONG; const double pi = acos(-1.</description>
    </item>
    
    <item>
      <title>zoj 2165 Red and Black ——BFS入门题</title>
      <link>http://liuxueyang.github.io/posts/zoj-2165-red-and-black-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 07 Apr 2013 19:06:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj-2165-red-and-black-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1165 题意： 给一个字符矩阵，“.”代表黑色格子，“#”代表红色格子，有一个起点“@”，它属于黑色格子，一个人从起点出发，只能走黑色格子，并且只能上下左右走，不能对角线走，问这个人能走到的黑色格子有多少个。输出个数。输入W，H，代表有W列，H行，然后输入一个字符矩阵，输出能走到的最多的黑色格子的个数，包括起点。 思路： 这个题目很简单，和zoj 2110 类似，但是这道题目比那道简单多了，不用剪枝，不用恢复现场，直接深搜就可以。首先找到起点，然后从起点出发，判断这个点是不是被访问过，如果被访问过，就return；否则判断这个格子是不是黑色格子或者是起点，如果是，就cnt++，然后标记这个格子已经被访问过，如果不是，return; 如果没有return，就在这个点的四个方向继续深搜。思路很清晰。1A。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; int w, h, cnt = 0; char s[22][22]; bool flag[22][22]; int dir[4][2] = {{0,1},{1,0},{-1,0},{0,-1}}; void dfs(int i, int j){ if (i &amp;lt;= 0 || j &amp;lt;= 0 || i &amp;gt; h || j &amp;gt; w) return; if (flag[i][j]) return; if (s[i][j] == &#39;.</description>
    </item>
    
    <item>
      <title>zoj 2412 Farm Irrigation ——DFS入门题</title>
      <link>http://liuxueyang.github.io/posts/zoj-2412-farm-irrigation-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 07 Apr 2013 12:48:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj-2412-farm-irrigation-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1412 题意： 有11种正方形，每种正方形里面对应一种形状的水管，不同的的正方形一用A到K表示，给一个矩阵，问至少需要多少个水源可以使矩形中所有的地方都可以被灌溉，如果两个相邻的正方形的水管正好对口，那么这两个正方形可以共用一个水源。 思路： 开始感觉很复杂，明显可以DFS做，但是感觉比较麻烦，关键是怎么处理题目中的条件。 首先，处理11种不同的水管，分4个方向，1表示有接口，0表示没有接口。用一个二维数组存所有种类的水管。 然后，把输入的字符转化成数字，可以再输入的时候边输入边处理，用字符减去字符“A”就可以了，对应的上面给11中不同水管中的一种。以上这两个处理方法要注意，学习一下，稍微看了一下别人的代码才想到的。这种看似比较简单的处理，往往给解题带来比较大的方便。 最后，就是如何深搜了。这个要考虑清楚。用一个flag二维数组表示是否访问过这个方格。深搜的时候，如果访问到它时，先判断它是否被访问过，然后立刻标记为已访问。然后就是判断当前方格的四个方向是不是有接口，如果某个方向有接口的话，就判断这个方向上的下一个方格中，和当前方格相邻的边是不是有接口，如果有接口，则继续深搜这个相邻的点。这里有个处理：（k+2）%4，意味着，比如：当前方格如果右边有接口，则判断右边的方格的左边的边是不是有接口，其它情况一样。然后就是主函数里面的dfs外面的for循环，思想和以前做过的zoj 1709是一样的，就是搜到某个点的时候，用一个mrk标记一下，把和它有关系的点都搜完，如果有符合条件的，mrk会改变，然后就cnt++用来计数，这种题目是相似的，都是要求符合条件的点相邻。 有一个细节，就是矩阵的数组还是从1开始吧，数组稍微开大一点儿，这样在深搜下一个方向的时候，就不会因为数组越界出错了。这个问题以前没有注意到。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; int grid[11][4] = {{0,0,1,1},{1,0,0,1},{0,1,1,0},{1,1,0,0},{0,1,0,1}, {1,0,1,0},{1,0,1,1},{0,1,1,1},{1,1,1,0},{1,1,0,1},{1,1,1,1}}; int dir[4][2] = {{0,1},{1,0},{0,-1},{-1,0}}; bool flag[55][55]; int s[55][55]; bool mrk = false; int n, m; void dfs(int i, int j){ if (i &amp;lt;= 0 || i &amp;gt; m || j &amp;lt;= 0 || j &amp;gt; n) return; if (flag[i][j]) return; mrk = true; flag[i][j] = true; for (int k = 0; k &amp;lt; 4; ++k){ if (grid[s[i][j]][k] &amp;amp;&amp;amp; grid[s[i+dir[k][0]][j+dir[k][1]]][(k+2)%4]){ dfs(i+dir[k][0], j+dir[k][1]); } } return; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;zoj2412.</description>
    </item>
    
    <item>
      <title>2013年4月6日四校联赛总结</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%886%E6%97%A5%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 07 Apr 2013 10:29:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%886%E6%97%A5%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B%E6%80%BB%E7%BB%93/</guid>
      <description>昨天的四校联赛比赛很失败，整场比赛我似乎都没有做题，也没有几乎敲键盘，差点儿爆零……最后还是队友过了一道，很对不起队友，糗……最近都在看课本，敲键盘不多，都没有感觉了，水题也想不到该怎么做…… 最大的问题是没有准确分析复杂度，两道题目明显可以暴力的，可是就是没有想到，开始也分析了一下复杂度，但是貌似觉得很大，就没有往下去想，以后不能想当然，准确分析复杂度后再想解决办法。 yr说的对，最重要的是学会如何在逆境中最大化地利用有限资源的那种能力。也许现在学的东西还不多，但是，你把学过的东西真正掌握了嘛？你是不是在比赛的时候真正把学过的东西最大化地用上了？你是不是发挥出了平时训练出来的能力？ yr给的建议：学知识的顺序还是按照白书的顺序来吧。书太多了，自己竟然把白书给忘了……先把例题切掉，打一下基础。</description>
    </item>
    
    <item>
      <title>2013年4月6日  晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%886%E6%97%A5--%E6%99%B4/</link>
      <pubDate>Sun, 07 Apr 2013 01:26:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%886%E6%97%A5--%E6%99%B4/</guid>
      <description>比赛完去跑步，今天天气很好，有温和的阳光，还有微微的风，跑步正合适，开始还是跑得有点儿快……中途前面还有骑直行车的，然后动力就来了，速度加快了，紧跟着自行车，跑得比较爽，也不感觉特别累，明显比前两天跑得快，路程比以前长，但是还是比平常快了整整五分钟！唉，先慢慢来吧，先不追求速度，关键是跑得高兴。^_^ 阳春三月，江边有很多放风筝的，哈哈，突然发现春天真的来了。 所有的不愉快，都随风而去……温和的阳光里，跑步结束，望着天上各种各样的风筝，变得豁达起来。周围的三五成群的人们，都在享受这春光，多美好的境界。</description>
    </item>
    
    <item>
      <title>zoj 1709 Oil Deposits ——DFS入门题</title>
      <link>http://liuxueyang.github.io/posts/zoj-1709-oil-deposits-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 07 Apr 2013 00:23:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj-1709-oil-deposits-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=709 题目大意： 给一个矩阵，*代表空地，@代表油田，并且@如果水平，竖直，对角线相邻的话就认为是一块油田，问有多少块油田。 思路就是DFS，从第一个字符开始搜，找到一个@就标记一下，cnt++，然后看它的八个方向上是不是有@，如果有，全部标记为*，不需要恢复现场。然后输出cnt的值就行了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; char s[110][110]; bool flag; int cnt, n, m; int dir[8][2] = {{0,1},{0,-1},{-1,0},{1,0},{1,1},{-1,1},{1,-1},{-1,-1}}; void dfs(int i, int j){ if (i &amp;lt; 0 || j &amp;lt; 0 || i &amp;gt; m || j &amp;gt; n) return; if (s[i][j] == &#39;*&#39;) return; if (s[i][j] == &#39;@&#39;) flag = true; s[i][j] = &#39;*&#39;; for (int k = 0; k &amp;lt; 8; ++k){ if (s[i+dir[k][0]][j+dir[k][1]] == &#39;@&#39;){ dfs(i+dir[k][0], j+dir[k][1]); } } } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;zoj1709.</description>
    </item>
    
    <item>
      <title>zoj 2110 Tempter of the Bone ——DFS&#43;剪枝</title>
      <link>http://liuxueyang.github.io/posts/zoj-2110-tempter-of-the-bone-dfs&#43;%E5%89%AA%E6%9E%9D/</link>
      <pubDate>Sat, 06 Apr 2013 23:20:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj-2110-tempter-of-the-bone-dfs&#43;%E5%89%AA%E6%9E%9D/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1110 题意： 给一个矩阵，‘X’代表墙壁，‘.’代表空格，‘S’代表起始位置，‘D’代表终点。从起点开始，每个空格只许经过一次，求在规定的时间t的时候，能否正好到达终点。每走一个花费1个单位时间。输入n,m,t，分别代表矩阵的行，列，规定的时间。 思路： 深度优先搜索，从起点开始，按照四个方向搜索，判断某个方向的下一个方格如果不是墙壁的话，就把它标为墙壁，然后从这个点继续往下搜索，如果从这个点往下搜索失败后，就要把这个点标记回原来的空格符号：‘.’。然后尝试下一个方向。直到i == di, j == dj, t == T的时候，表示搜索成功，flag = true; return; 其中si sj 是起点位置，di dj是终点位置，T是当前所花费的时间。 然后还有几处剪枝：如果这个矩阵的空格的数目小于等于时间t，那么不可能成功。这在主函数里面可以剪枝。在dfs的过程中，如果发现剩余的时间小于当前位置到终点的最小距离，可以直接判断搜索失败；如果剩余的时间和当前位置到终点的最小时间的差值是奇数的话，可以判断搜索一定失败，可以剪枝，如果是偶数的话，则可能成功。 今天突然发现，以前写的解题报告太搓了……向kedebug的博客学习，O(∩_∩)O哈哈~加油
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; bool flag; char s[9][9]; int t, n, m, si, sj, di, dj; int dir[4][4] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; void dfs(int i, int j, int T){ if (i == di &amp;amp;&amp;amp; j == dj &amp;amp;&amp;amp; T == t){ flag = true; return; } if (i &amp;lt;= 0 || j &amp;lt;= 0 || i &amp;gt; n || j &amp;gt; m) return; int temp = t - T - abs(i-di) - abs(j-dj); if (temp &amp;lt; 0 || temp&amp;amp;1)return; for (int k = 0; k &amp;lt; 4; ++k){ if (s[i+dir[k][0]][j+dir[k][1]] !</description>
    </item>
    
    <item>
      <title>2013年4月5日  雨，阴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%885%E6%97%A5--%E9%9B%A8%E9%98%B4/</link>
      <pubDate>Sat, 06 Apr 2013 00:05:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%885%E6%97%A5--%E9%9B%A8%E9%98%B4/</guid>
      <description>上午下雨，还好下午下得不那么大了，4点半的时候正好去跑步，还飘着小雨点儿，不过不影响跑步，还是前天一样，开始的时候跑得过快了，有点儿吃不消的感觉，今天跑的比较多，虽然实跑时间也是整整半小时，但明显比前天跑得远，Google告诉我大概有7000米的样子，现在不追求速度，跑得高兴就行啦。 跑步的过程中，今天感觉不错，尤其是后半段，整个人完全处于那种比较好的状态，脑袋里什么也不想，只注意着自己的呼吸，耳边只有音乐，眼前只有远方的风景，天气还下着小雨，湘江上烟雨迷蒙，好有诗意~还刮着风，开始是逆风，回来虽然顺风，但一点儿感觉也没有，还不如逆风跑舒服。 跑完之后做了一下拉伸，在江边休息了一下，雨还在下着，身上的外套早已湿透了，南方的雨就是这样，斜风细雨不须归…… 今天跑步的时候听《时光》有一种特殊的感觉。 时光 ——许巍　在阳光温暖的春天走在这城市的人群中在不知不觉的一瞬间又想 起你&amp;hellip;&amp;hellip;你是记忆中最美的春天是我难以再回去的昨天你像鲜花那样地绽放让我 心动&amp;hellip;&amp;hellip;We~sayWe~say~~We~say~~We~say~~在阳光温暖的春天走在这城市的人群中在不知不觉的一瞬间又想 起你&amp;hellip;&amp;hellip;也许就在这一瞬间你的笑容依然如晚霞般在川流不息的时光中神采 飞扬&amp;hellip;&amp;hellip; We~say~~We~say~~We~say~~We~say~~~~</description>
    </item>
    
    <item>
      <title>hdu 1059 Dividing ——多重背包复习</title>
      <link>http://liuxueyang.github.io/posts/hdu-1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Fri, 05 Apr 2013 12:29:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E5%A4%8D%E4%B9%A0/</guid>
      <description>Dividing
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 11367 Accepted Submission(s): 3168
Problem Description Marsha and Bill own a collection of marbles. They want to split the collection among themselves so that both receive an equal share of the marbles. This would be easy if all the marbles had the same value, because then they could just split the collection in half. But unfortunately, some of the marbles are larger, or more beautiful than others.</description>
    </item>
    
    <item>
      <title>2013年4月4日  雨</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%884%E6%97%A5--%E9%9B%A8/</link>
      <pubDate>Fri, 05 Apr 2013 03:37:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%884%E6%97%A5--%E9%9B%A8/</guid>
      <description>清明时节雨纷纷，从中午开始就一直下雨……跑步自然没有跑成，这是让我惊奇的是，今天竟然没有感觉到大腿酸痛，，还好好的，，这不科学……本来是很久不运动了的，o(╯□╰)o 中午看到一本中文版《跑者世界》心里满是欣喜，高中时候就听说过这本杂志，村上君还提到过，只是一直没见过哪里卖，然后就跑到综合楼自习的时候看，，好吧……无语了，说实话，这本可能不是真正的《Runner&amp;rsquo;s world》，手上这本杂志唯一吸引我的就是他的封面了……内容明显是各种广告。。 希望明天不下雨，继续跑步！ 发点儿牢骚。最近脑袋里面老是不知不觉地就冒出那些个破事儿……唉，没出息。。还是多干点儿正事儿吧，实在无聊，那就多读点儿闲书吧！这么好的日子，何必让自己那么纠结呢。 中午睡午觉的时候，又想起，明年暑假我就大四了啊，就该找工作了，就该面对各种了，可是，我准备好了么？</description>
    </item>
    
    <item>
      <title>2013年4月3日  小雨，阴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%883%E6%97%A5--%E5%B0%8F%E9%9B%A8%E9%98%B4/</link>
      <pubDate>Thu, 04 Apr 2013 01:46:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%883%E6%97%A5--%E5%B0%8F%E9%9B%A8%E9%98%B4/</guid>
      <description>今天第一次跑步，从下午5点开始，大约跑了半个小时。各种爽啊，又找回了从前那种感觉，只不过一开始跑的时候有点儿兴奋，跑的有点儿快了，到后来有点儿撑不住……坐等明天腿部肌肉酸痛，哈哈，不管那么多了，人生得意须尽欢不是么~ 尤其是今天的天气，湘江上弥漫着水雾，恰好刚刚下过一点儿小雨，空气湿漉漉的，跑步的过程中，真的像梦境一般，周围是安静的，只注意着自己的呼吸，耳机的音乐，前进的脚步声……这种时候适合冥想，向往禅的境界。突然发现，也许自己最大的损失就是没有早些坚持跑步锻炼，在跑步的过程中，那样的状态，是什么也不能达到的，这就是人生的意义么。 有时候，自己就那么不知不觉地跑着，过了一段时间，突然发现，自己竟然跑了这么远了，竟然到了这个原来看似很遥远的地方；还有的时候，感觉还没怎么跑，然后发现自己早就已经看不到起点了，想要回去已经不是那么容易了。 刚回到公寓，天气就下起雨来了，好吧……我的运气要不要这么好啊！恰好去食堂吃饭，出来雨停了，O(∩_∩)O哈哈~ 突然发现，自己一天当中，最有意义，利用最充分的时间就是出去跑步的这段时间，尤其是跑完后，似乎一切都豁然开朗了，什么都想通了。 穿着专业跑鞋跑步确实爽，还有当初买的那个飞利浦的GoGear就是为了跑步的时候用的，遗憾的是一直都没有派上真正的用场，现在用着超爽。 最近的一些事情很多次让我想起了《当我跑步时，我在想些什么》里面村上君的那句话：原来大家都是一样的啊，哈哈。其实很多事情面前，每个人都是一样的，你遇到的困难别人也遇到过，所以，加油吧！没什么大不了的不是么。</description>
    </item>
    
    <item>
      <title>2013年3月zoj月赛总结</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B43%E6%9C%88zoj%E6%9C%88%E8%B5%9B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 03 Apr 2013 02:55:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B43%E6%9C%88zoj%E6%9C%88%E8%B5%9B%E6%80%BB%E7%BB%93/</guid>
      <description>周日的比赛，一直没有时间写，补上。 唉，其实菜鸟也没什么可总结的，无非都是什么都不会，但每次比赛后还是留下一点儿东西吧，不管有木有用…… 当然是没有任何悬念地被虐。然后就木有然后了…… 整场比赛只做了一道水题，并且还是比赛最后才A的，就是前面博客写过的那个楼外楼的那道 。另外还有一道，是DP+快速幂，好像是chosing number，clj好不容易把DP的部分做出来了，只可惜，我不会快速幂……泪……所以这两天才赶紧把快速幂看了。然后第一题，可以转化成线段树，以前的线段树题目都白写了，真正遇到题目的时候还是不会做，其实就算还记得也写不出来，因为据说要先把题目中树的每个节点编号，然后就转化成线段树了，很明显，那个转化我不会……然后还有一道DP，虽然一直都知道DP狠重要，但还是一直以来都没有认真做过，以后好好做DP，别的还有组合数学题，貌似 还有一个图论题，这些东西都没接触过…… 赶紧加油吧，慢慢积累，有计划，然后坚持不懈。</description>
    </item>
    
    <item>
      <title>poj 1995 Raising Modulo Numbers ——快速幂</title>
      <link>http://liuxueyang.github.io/posts/poj-1995-raising-modulo-numbers-%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Tue, 02 Apr 2013 17:47:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj-1995-raising-modulo-numbers-%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; int m; LL power(LL a, LL k){ LL ans = 1; while (k){ if (k&amp;amp;1){ ans = (ans * a) % m; k--; } k &amp;gt;&amp;gt;= 1; a = (a*a)%m; } return ans; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;1995.</description>
    </item>
    
    <item>
      <title>poj 3233 Matrix Power Series ——矩阵快速幂&#43;二分求解</title>
      <link>http://liuxueyang.github.io/posts/poj-3233-matrix-power-series-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82&#43;%E4%BA%8C%E5%88%86%E6%B1%82%E8%A7%A3/</link>
      <pubDate>Tue, 02 Apr 2013 17:06:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj-3233-matrix-power-series-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82&#43;%E4%BA%8C%E5%88%86%E6%B1%82%E8%A7%A3/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define LL long long #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 typedef struct matrix{ int a[33][33]; }matrix; matrix A, B, per; int m, k, n; void init(){ scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;k, &amp;amp;m); for (int i = 0; i &amp;lt; n; ++i){ for (int j = 0; j &amp;lt; n; ++j){ scanf(&amp;quot;%d&amp;quot;, &amp;amp;A.</description>
    </item>
    
    <item>
      <title>zoj 3693 Happy Great BG</title>
      <link>http://liuxueyang.github.io/posts/zoj-3693-happy-great-bg/</link>
      <pubDate>Sun, 31 Mar 2013 22:26:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj-3693-happy-great-bg/</guid>
      <description>The summer training of ZJU ICPC in July is about to end. To celebrate this great and happy day, the coaches of ZJU ICPC Team Navi and Fancy decided to BG everyone! Beside the two coaches, there are N participants. Those participants are divided into four groups to make problems for other groups. After a brief discussion, they decided to go to Lou Wai Lou and have a great lunch. The cost for each person to have a meal in Lou Wai Lou is W yuan.</description>
    </item>
    
    <item>
      <title>hdu 2035 人见人爱A^B ——同余的简单性质</title>
      <link>http://liuxueyang.github.io/posts/hdu-2035-%E4%BA%BA%E8%A7%81%E4%BA%BA%E7%88%B1ab-%E5%90%8C%E4%BD%99%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%A7%E8%B4%A8/</link>
      <pubDate>Sun, 31 Mar 2013 22:19:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-2035-%E4%BA%BA%E8%A7%81%E4%BA%BA%E7%88%B1ab-%E5%90%8C%E4%BD%99%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%A7%E8%B4%A8/</guid>
      <description>Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others)Total Submission(s): 15572 Accepted Submission(s): 11012 </description>
    </item>
    
    <item>
      <title>hdu 1021 Fibonacci Again   ——同余的简单性质</title>
      <link>http://liuxueyang.github.io/posts/hdu-1021-fibonacci-again---%E5%90%8C%E4%BD%99%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%A7%E8%B4%A8/</link>
      <pubDate>Sun, 31 Mar 2013 22:12:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1021-fibonacci-again---%E5%90%8C%E4%BD%99%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%A7%E8%B4%A8/</guid>
      <description>Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others)Total Submission(s): 26755 Accepted Submission(s): 12950 </description>
    </item>
    
    <item>
      <title>2013/03/30 国防科技大学 第十六届“银河之光”文化节ACM-ICPC程序设计竞赛 总结</title>
      <link>http://liuxueyang.github.io/posts/2013-03-30-%E5%9B%BD%E9%98%B2%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6-%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8A%E9%93%B6%E6%B2%B3%E4%B9%8B%E5%85%89%E6%96%87%E5%8C%96%E8%8A%82acm-icpc%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 30 Mar 2013 21:48:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/2013-03-30-%E5%9B%BD%E9%98%B2%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6-%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8A%E9%93%B6%E6%B2%B3%E4%B9%8B%E5%85%89%E6%96%87%E5%8C%96%E8%8A%82acm-icpc%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E6%80%BB%E7%BB%93/</guid>
      <description>今天去国防科技大学参加他们学校的校内选拔赛，是个人赛。有一些教训，总结一下。 第一题，大数相加，很明显的模板题，自己平时还真的没写过……现场手敲，基本思路知道，但是自己还是太天真了，忘了进位，WA了一次，然后改的过程中还是出现各种错误，可能是因为着急，看人家过的那么快，有点儿不淡定，最后还是过了。　然后，去看一道数学题，很天真的TLE了…… 然后，做另一道水题，名字叫E. High Tree，就是有点儿麻烦，思路很简单，求一个函数的积分，然后好不容易敲出来了，但是各种WA……各种测试数据都能过，自己也想了一些测试数据，但还是WA…… 然后就去做别人过了的题，篮球的那道，开始也看到了，貌似很复杂的样子，然后又认真想了一下，原来就是高一的物理题，想着我是不是想简单了，然后就敲了，WA了，本来读题的时候注意到了给的角度是角度制的，可能需要转换，然后写的时候就忘了……然后就改了一下，然后又发现还有别的小错误，本来公式都列对了，但是敲的时候，忘了写一个小步骤……汗……然后就过了…… 继续看那道E题，最后实在看不出哪里错了，下定决心自己重新写一遍！按照差不多的思路敲了一遍，但是某些处理方法不同，还是WA，各种纠结，绞尽脑汁，终于想到了一种没有考虑的情况，就是指数为x和常数也有可能有指数的那种情况，狂喜，赶紧加上，交了，WA……然后继续改，然后就一直卡了…… 看别的其他人过的题目，明显没有思路，知识存储不够…… 然后就一直那么卡着……那道题目一直想，各种情况，越想越复杂。。一直痛苦到最后……2题。。 后来才知道，有一道背包的题目，最近刚看的背包，容易么，可惜那道题目根本就没有看……一直在纠结E题……以后得改。 总结一下主要发现的问题： 1. 水题不是做的少，是自己写代码习惯不好，不管多么简单的题目，思维不严谨，总是WA那么几次，才可以勉强过，这是病，得治。 2. 知识存储不够，现在除了水题，什么也不会做，另外，如果一道题实在是陷入了思维误区，改不过来后，要换题，至少要去认真读一下其他的不太难的题目，比如这次的那个背包的题目，就挺悲剧…… 3. 数学是硬伤，有很多题目都是赤裸裸的数学题，如果不会，那真的是连神也救不了自己了……比如那道，球的题目，给出球的半径，水的体积，求高度的题目，这不是高数么……然后就是那道数论的题目，不会推公式，木有办法，然后就是最后一道排列组合的题目，如果不会，那就是真的不会了…… 4. 然后就是内种板子题，比如第一道，经典的大数加法，都木有敲过有木有！！这些基本的东西以后要敲，至少得敲几遍吧…… 最近的腾讯，百度的比赛，很多就是数学题，硬伤……比如，今天的腾讯复赛，最简单的一道就是第一道，排列组合的数学题，不会，木有办法……还有，今天的百度之星，两道题目，都是那种数学味道的题目。数学是有多重要啊！！ 恶补数学，然后是DP，然后是数据结构，图论各种…… 今天第一次看到高中生跟大学生一起比赛，没认真观察，但是没有悬念地被人完虐，很困惑，高中搞过竞赛的都知道，高中搞竞赛时很尴尬的一件事情，除了特别强的那种，还有高考课，还要搞竞赛，没有被保送就什么也木有了，就会各种悲剧，数学物理竞赛的还好，不过OI和高考毛线关系都木有啊！搞不好就注定悲剧啊，但是人家还是比大学生搞得好啊有木有！次奥，明显是大学生的时间比较多的，明明是人家高中生面对的情况更不利的，但是，还是没有人家高中生强，其实，原因很简单，高中生都在很认真地做，用心做，因为有压力，所以会投入更多的精力，但是我们，就差远了……不是没有时间，是没有静下心来，没有用心……连敲代码都不如人家高中生快的…… 不说了，说多了都是泪……</description>
    </item>
    
    <item>
      <title>nefu118 n!后面有多少个0 数论</title>
      <link>http://liuxueyang.github.io/posts/nefu118-n%E5%90%8E%E9%9D%A2%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA0-%E6%95%B0%E8%AE%BA/</link>
      <pubDate>Sat, 30 Mar 2013 02:25:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/nefu118-n%E5%90%8E%E9%9D%A2%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA0-%E6%95%B0%E8%AE%BA/</guid>
      <description>数论题。统计n!里面有多少个素数5即可。公式：[n/p] + [n/p^2] + [n/p^3] + …… 然后发现一个很无语的问题，nefu上面不能用这个：
#ifndef ONLINE_JUDGE freopen(&amp;quot;nefu118.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif  要不要这样啊，别的OJ可都是可以用的好不……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; int main(void){ int n, m; scanf(&amp;quot;%d&amp;quot;, &amp;amp;m); while (m--){ scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); int t = 5, cnt = 0; while (t &amp;lt;= n){ cnt += n/t; t *= 5; } printf(&amp;quot;%d\n&amp;quot;, cnt); } return 0; }  然后，这么个简单的问题，还是纠结了一下……刚开始做数学，加油！ ↖(^ω^)↗</description>
    </item>
    
    <item>
      <title>hdu 1712 ACboy needs your help 分组背包</title>
      <link>http://liuxueyang.github.io/posts/hdu-1712-acboy-needs-your-help-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</link>
      <pubDate>Fri, 29 Mar 2013 15:08:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1712-acboy-needs-your-help-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</guid>
      <description>ACboy needs your help
Time Limit: 1000&amp;frasl;1000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 2403 Accepted Submission(s): 1223
Problem Description ACboy has N courses this term, and he plans to spend at most M days on study.Of course,the profit he will gain from different course depending on the days he spend on it.How to arrange the M days for the N courses to maximize the profit?
Input The input consists of multiple data sets.</description>
    </item>
    
    <item>
      <title>hdu 2159 FATE 二维背包</title>
      <link>http://liuxueyang.github.io/posts/hdu-2159-fate-%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85/</link>
      <pubDate>Fri, 29 Mar 2013 13:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-2159-fate-%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85/</guid>
      <description>FATE
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 4682 Accepted Submission(s): 2105
Problem Description 最近xhd正在玩一款叫做FATE的游戏，为了得到极品装备，xhd在不停的杀怪做任务。久而久之xhd开始对杀怪产生的厌恶感，但又不得不通过杀怪来升完这最后一级。现在的问题是，xhd升掉最后一级还需n的经验值，xhd还留有m的忍耐度，每杀一个怪xhd会得到相应的经验，并减掉相应的忍耐度。当忍耐度降到0或者0以下时，xhd就不会玩这游戏。xhd还说了他最多只杀s只怪。请问他能升掉这最后一级吗？
Input 输入数据有多组，对于每组数据第一行输入n，m，k，s(0 &amp;lt; n,m,k,s &amp;lt; 100)四个正整数。分别表示还需的经验值，保留的忍耐度，怪的种数和最多的杀怪数。接下来输入k行数据。每行数据输入两个正整数a，b(0 &amp;lt; a,b &amp;lt; 20)；分别表示杀掉一只这种怪xhd会得到的经验值和会减掉的忍耐度。(每种怪都有无数个)
Output 输出升完这级还能保留的最大忍耐度，如果无法升完这级输出-1。
Sample Input 10 10 1 10 1 1 10 10 1 9 1 1 9 10 2 10 1 1 2 2
Sample Output 0 -1 1
二维背包。这道题目开始的思路是错误的，我把经验值看成了一个背包容量，实际上，这是不恰当的。因为，这个背包容量必须至少要装满，还有，可以超过这个容量，如果超过了，这样做是不可解的。 后来也没有认真想，就看了一下别人的代码，惭愧……又在翻别人的代码。。 明白了，把忍耐值看成一个背包，怪物个数看成另一个背包，这样就有2个背包容量，求出最大的经验值，然后再遍历一次，求出比要求的经验值大的，并且忍耐度最小的，就ＯＫ了。 明白了之后，然后我就把原来的代码开始修改，悲剧的是，后面的改了，但是输入的地方没有改，死活也Ａ不了……明明就40行代码，搞得这么纠结……次嗷……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; const int MAX = 0x3f3f3f3f; int f[120][120]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;2159.</description>
    </item>
    
    <item>
      <title>poj 1014 Dividing 多重背包</title>
      <link>http://liuxueyang.github.io/posts/poj-1014-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 28 Mar 2013 20:59:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj-1014-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; int f[120000+10], V; const int MAX = 0x3f3f3f3f; void zeropack(int c, int w){ for (int v = V; v &amp;gt;= c; --v){ f[v] = max(f[v], f[v-c] + w); } } void completepack(int c, int w){ for (int v = c; v &amp;lt;= V; ++v){ f[v] = max(f[v], f[v-c] + w); } } int main(void){ int a[7], cnt = 1; #ifndef ONLINE_JUDGE freopen(&amp;quot;1014.</description>
    </item>
    
    <item>
      <title>hdu 1114 Piggy-Bank 完全背包</title>
      <link>http://liuxueyang.github.io/posts/hdu-1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 28 Mar 2013 12:14:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>Piggy-Bank
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 6841 Accepted Submission(s): 3375
Problem Description Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank.</description>
    </item>
    
    <item>
      <title>hdu 2602 Bone Collector 01背包</title>
      <link>http://liuxueyang.github.io/posts/hdu-2602-bone-collector-01%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 28 Mar 2013 10:34:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-2602-bone-collector-01%E8%83%8C%E5%8C%85/</guid>
      <description>Bone Collector
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 17590 Accepted Submission(s): 6954
Problem Description Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave … The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get ?</description>
    </item>
    
    <item>
      <title>zoj 3410 Layton&#39;s Escape</title>
      <link>http://liuxueyang.github.io/posts/zoj-3410-laytons-escape/</link>
      <pubDate>Thu, 21 Mar 2013 10:59:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj-3410-laytons-escape/</guid>
      <description>Professor Layton is a renowned archaeologist from London&amp;rsquo;s Gressenheller University. He and his apprentice Luke has solved various mysteries in different places. Unfortunately, Layton and Luke are trapped in a pyramid now. To escape from this dangerous place, they need to pass N traps. For each trap, they can use Ti minutes to remove it. If they pass an unremoved trap, they will lose 1 HP. They have K HP at the beginning of the escape and they will die at 0 HP.</description>
    </item>
    
    <item>
      <title>zoj 3409 KKV</title>
      <link>http://liuxueyang.github.io/posts/zoj-3409-kkv/</link>
      <pubDate>Wed, 20 Mar 2013 21:43:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj-3409-kkv/</guid>
      <description>KKV (short for Kinetic Kill Vehicle), a new kind of projectile, is a powerful weapon and has a great ability to move in the space. PLA developed a new missile based on the technology of KKV, and this kind of missile can launch and fly in the space, find the target and destroy it. Now the launch site of the KKV missile is at position (0, 0, 0), the missile will fly through N polygonal lines in order and its initial speed is zero.</description>
    </item>
    
    <item>
      <title>zoj 3406 Another Very Easy Task</title>
      <link>http://liuxueyang.github.io/posts/zoj-3406-another-very-easy-task/</link>
      <pubDate>Tue, 19 Mar 2013 21:46:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj-3406-another-very-easy-task/</guid>
      <description>This task is so easy that the description is omitted.
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; char a[100000]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;1.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); freopen(&amp;quot;1.out&amp;quot;, &amp;quot;w&amp;quot;, stdout); #endif while (gets(a)){ int len = strlen(a); bool flag = false; int cnt = 0; for (int i = 0; i &amp;lt; len; ++i){ cnt = 0; flag = false; while (isalpha(a[i])){ if (!</description>
    </item>
    
    <item>
      <title>zoj 3407 Doraemon&#39;s Cake Machine</title>
      <link>http://liuxueyang.github.io/posts/zoj-3407-doraemons-cake-machine/</link>
      <pubDate>Tue, 19 Mar 2013 21:42:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj-3407-doraemons-cake-machine/</guid>
      <description>One day, N kids got one cake (a cylinder in shape). They decided to divide the cake so that everyone can have one piece of that cake. In the interest of fairness, pieces of the cake should be equal in size. However, the kids had no knives to cut the cake. Luckily, Doraemon borrowed them a magic cake machine that can cut and clone cake. To use Doraemon&amp;rsquo;s cake machine, exactly M instructions must be entered.</description>
    </item>
    
    <item>
      <title>poj 1061 青蛙的约会  ——扩展欧几里得</title>
      <link>http://liuxueyang.github.io/posts/poj-1061-%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A--%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</link>
      <pubDate>Mon, 18 Mar 2013 16:13:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj-1061-%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A--%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstring&amp;gt; #define LL long long int LL exgcd(LL a, LL b, LL &amp;amp;x, LL &amp;amp;y){ if (b == 0){ x = 1; y = 0; return a; } LL r = exgcd(b, a%b, x, y); LL t = x; x = y; y = t - a / b * y; return r; } LL gcd(LL a, LL b){ return b ==0?a:gcd(b,a%b); } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;poj1061.</description>
    </item>
    
    <item>
      <title>uva 11991 - Easy Problem from Rujia Liu?</title>
      <link>http://liuxueyang.github.io/posts/uva-11991---easy-problem-from-rujia-liu/</link>
      <pubDate>Sat, 16 Mar 2013 18:31:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva-11991---easy-problem-from-rujia-liu/</guid>
      <description>Though Rujia Liu usually sets hard problems for contests (for example, regional contests like Xi&amp;rsquo;an 2006, Beijing 2007 and Wuhan 2009, or UVa OJ contests like Rujia Liu&amp;rsquo;s Presents 1 and 2), he occasionally sets easy problem (for example, &amp;lsquo;the Coco-Cola Store&amp;rsquo; in UVa OJ), to encourage more people to solve his problems :D Given an array, your task is to find the k-th occurrence (from left to right) of an integer v.</description>
    </item>
    
    <item>
      <title>uva 11995 - I Can Guess the Data Structure!</title>
      <link>http://liuxueyang.github.io/posts/uva-11995---i-can-guess-the-data-structure/</link>
      <pubDate>Sat, 16 Mar 2013 14:30:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva-11995---i-can-guess-the-data-structure/</guid>
      <description>There is a bag-like data structure, supporting two operations: Throw an element x into the bag. Take out an element from the bag. Given a sequence of operations with return values, you&amp;rsquo;re going to guess the data structure. It is a stack (Last-In, First-Out), a queue (First-In, First-Out), a priority-queue (Always take out larger elements first) or something else that you can hardly imagine! There are several test cases. Each test case begins with a line containing a single integer n (1&amp;lt;=n&amp;lt;=1000).</description>
    </item>
    
    <item>
      <title>hdu 1065 I Think I Need a Houseboat</title>
      <link>http://liuxueyang.github.io/posts/hdu-1065-i-think-i-need-a-houseboat/</link>
      <pubDate>Fri, 15 Mar 2013 19:24:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1065-i-think-i-need-a-houseboat/</guid>
      <description>I Think I Need a Houseboat
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 5929 Accepted Submission(s): 1761
Problem Description
Fred Mapper is considering purchasing some land in Louisiana to build his house on. In the process of investigating the land, he learned that the state of Louisiana is actually shrinking by 50 square miles each year, due to erosion caused by the Mississippi River. Since Fred is hoping to live in this house the rest of his life, he needs to know if his land is going to be lost to erosion.</description>
    </item>
    
    <item>
      <title>hdu 1214 圆桌会议</title>
      <link>http://liuxueyang.github.io/posts/hdu-1214-%E5%9C%86%E6%A1%8C%E4%BC%9A%E8%AE%AE/</link>
      <pubDate>Fri, 15 Mar 2013 19:22:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1214-%E5%9C%86%E6%A1%8C%E4%BC%9A%E8%AE%AE/</guid>
      <description>圆桌会议
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 2179 Accepted Submission(s): 1490
Problem Description HDU ACM集训队的队员在暑假集训时经常要讨论自己在做题中遇到的问题.每当面临自己解决不了的问题时,他们就会围坐在一张圆形的桌子旁进行交流,经过大家的讨论后一般没有解决不了的问题,这也只有HDU ACM集训队特有的圆桌会议,有一天你也可以进来体会一下哦:),在一天在讨论的时候,Eddy想出了一个极为古怪的想法,如果他们在每一分钟内,一对相邻的两个ACM队员交换一下位子,那么要多少时间才能得到与原始状态相反的座位顺序呢?(即对于每个队员，原先在他左面的队员后来在他右面，原先在他右面的队员在他左面),这当然难不倒其他的聪明的其他队友们,马上就把这个古怪的问题给解决了,你知道是怎么解决的吗?
Input 对于给定数目N(1&amp;lt;=N&amp;lt;=32767)，表示有N个人,求要多少时间才能得到与原始状态相反的座位顺序(reverse)即对于每个人，原先在他左面的人后来在他右面，原先在他右面的人在他左面。
Output 对每个数据输出一行，表示需要的时间(以分钟为单位)
Sample Input 4 5 6
Sample Output 2 4 6
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; int main(void){ int n; #ifndef ONLINE_JUDGE freopen(&amp;quot;1214.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)){ int a, b; a = n / 2; b = n - a; printf(&amp;quot;%d\n&amp;quot;, a*(a-1)/2+b*(b-1)/2); } return 0; }  这道题目意思很好明白，就是每次只能两个人交换位置，求最少交换多少次，才能够产生顺序相反的排列。</description>
    </item>
    
    <item>
      <title>hdu 1056 HangOver</title>
      <link>http://liuxueyang.github.io/posts/hdu-1056-hangover/</link>
      <pubDate>Fri, 15 Mar 2013 11:01:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1056-hangover/</guid>
      <description>HangOver
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 7186 Accepted Submission(s): 2884
Problem Description How far can you make a stack of cards overhang a table? If you have one card, you can create a maximum overhang of half a card length. (We&amp;rsquo;re assuming that the cards must be perpendicular to the table.) With two cards you can make the top card overhang the bottom one by half a card length, and the bottom one overhang the table by a third of a card length, for a total maximum overhang of 1&amp;frasl;2 + 1&amp;frasl;3 = 5&amp;frasl;6 card lengths.</description>
    </item>
    
    <item>
      <title>poj 1659 Frogs&#39; Neighborhood</title>
      <link>http://liuxueyang.github.io/posts/poj-1659-frogs-neighborhood/</link>
      <pubDate>Wed, 13 Mar 2013 21:37:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj-1659-frogs-neighborhood/</guid>
      <description>Frogs&amp;rsquo; Neighborhood Time Limit: 5000MS Memory Limit: 10000K Total Submissions: 5599 Accepted: 2419 Special Judge
Description
未名湖附近共有N个大小湖泊L1, L2, &amp;hellip;, Ln(其中包括未名湖)，每个湖泊Li里住着一只青蛙Fi(1 ≤ i ≤ N)。如果湖泊Li和Lj之间有水路相连，则青蛙Fi和Fj互称为邻居。现在已知每只青蛙的邻居数目x1, x2, &amp;hellip;, xn，请你给出每两个湖泊之间的相连关系。
Input
第一行是测试数据的组数T(0 ≤ T ≤ 20)。每组数据包括两行，第一行是整数N(2 &amp;lt; N &amp;lt; 10)，第二行是N个整数，x1, x2,&amp;hellip;, xn(0 ≤ xi ≤ N)。
Output
对输入的每组测试数据，如果不存在可能的相连关系，输出&amp;rdquo;NO&amp;rdquo;。否则输出&amp;rdquo;YES&amp;rdquo;，并用N×N的矩阵表示湖泊间的相邻关系，即如果湖泊i与湖泊j之间有水路相连，则第i行的第j个数字为1，否则为0。每两个数字之间输出一个空格。如果存在多种可能，只需给出一种符合条件的情形。相邻两组测试数据之间输出一个空行。
Sample Input
3 7 4 3 1 5 4 2 1 6 4 3 1 4 2 0 6 2 3 1 1 2 1</description>
    </item>
    
    <item>
      <title>poj 3225 Help with Intervals</title>
      <link>http://liuxueyang.github.io/posts/poj-3225-help-with-intervals/</link>
      <pubDate>Wed, 13 Mar 2013 21:35:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj-3225-help-with-intervals/</guid>
      <description>Description Input Output Sample Input Sample Output #include &amp;lt;cstdio&amp;gt; using namespace std; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 const int maxn = 65535*2+10; int cover[maxn&amp;lt;&amp;lt;2],xorm[maxn&amp;lt;&amp;lt;2]; bool hash[maxn+10]; void fxor(int rt){ if (cover[rt] != -1) cover[rt] ^= 1; else xorm[rt] ^= 1; } void PushDown(int rt){ if (cover[rt] != -1){ cover[rt&amp;lt;&amp;lt;1] = cover[rt&amp;lt;&amp;lt;1|1] = cover[rt]; xorm[rt&amp;lt;&amp;lt;1] = xorm[rt&amp;lt;&amp;lt;1|1] = 0; cover[rt] = -1; // there has been a BUG.</description>
    </item>
    
    <item>
      <title>hdu 1040 As Easy As A&#43;B</title>
      <link>http://liuxueyang.github.io/posts/hdu-1040-as-easy-as-a&#43;b/</link>
      <pubDate>Wed, 13 Mar 2013 21:23:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1040-as-easy-as-a&#43;b/</guid>
      <description>As Easy As A+B
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 26401 Accepted Submission(s): 11218
Problem Description These days, I am thinking about a question, how can I get a problem as easy as A+B? It is fairly difficulty to do such a thing. Of course, I got it after many waking nights. Give you some integers, your task is to sort these number ascending (升序).</description>
    </item>
    
    <item>
      <title>hdu 1018 Big Number</title>
      <link>http://liuxueyang.github.io/posts/hdu-1018-big-number/</link>
      <pubDate>Wed, 13 Mar 2013 21:12:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1018-big-number/</guid>
      <description>Big Number
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 18525 Accepted Submission(s): 8292
Problem Description In many applications very large integers numbers are required. Some of these applications are using keys for secure transmission of data, encryption, etc. In this problem you are given a number, you have to determine the number of digits in the factorial of the number.
Input Input consists of several lines of integer numbers.</description>
    </item>
    
    <item>
      <title>hdu 1028 Ignatius and the Princess III</title>
      <link>http://liuxueyang.github.io/posts/hdu-1028-ignatius-and-the-princess-iii/</link>
      <pubDate>Wed, 13 Mar 2013 21:09:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1028-ignatius-and-the-princess-iii/</guid>
      <description>Ignatius and the Princess III
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 8447 Accepted Submission(s): 6009
Problem Description &amp;ldquo;Well, it seems the first problem is too easy. I will let you know how foolish you are later.&amp;rdquo; feng5166 says.
&amp;ldquo;The second problem is, given an positive integer N, we define an equation like this: N=a[1]+a[2]+a[3]+&amp;hellip;+a[m]; a[i]&amp;gt;0,1&amp;lt;=m&amp;lt;=N; My question is how many different equations you can find for a given N.</description>
    </item>
    
    <item>
      <title>hdu 1019 Least Common Multiple</title>
      <link>http://liuxueyang.github.io/posts/hdu-1019-least-common-multiple/</link>
      <pubDate>Wed, 13 Mar 2013 09:18:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1019-least-common-multiple/</guid>
      <description>Least Common Multiple
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 21158 Accepted Submission(s): 7899
Problem Description The least common multiple (LCM) of a set of positive integers is the smallest positive integer which is divisible by all the numbers in the set. For example, the LCM of 5, 7 and 15 is 105.
Input Input will consist of multiple problem instances. The first line of the input will contain a single integer indicating the number of problem instances.</description>
    </item>
    
    <item>
      <title>hdu 1061 Rightmost Digit</title>
      <link>http://liuxueyang.github.io/posts/hdu-1061-rightmost-digit/</link>
      <pubDate>Wed, 13 Mar 2013 08:40:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1061-rightmost-digit/</guid>
      <description>Rightmost Digit
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 22887 Accepted Submission(s): 8739
Problem Description Given a positive integer N, you should output the most right digit of N^N.
Input The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow. Each test case contains a single positive integer N(1&amp;lt;=N&amp;lt;=1,000,000,000).</description>
    </item>
    
    <item>
      <title>hdu 1212 Big Number</title>
      <link>http://liuxueyang.github.io/posts/hdu-1212-big-number/</link>
      <pubDate>Tue, 12 Mar 2013 22:01:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1212-big-number/</guid>
      <description>Big Number
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 3386 Accepted Submission(s): 2305
Problem Description As we know, Big Number is always troublesome. But it&amp;rsquo;s really important in our ACM. And today, your task is to write a program to calculate A mod B.
To make the problem easier, I promise that B will be smaller than 100000.
Is it too hard? No, I work it out in 10 minutes, and my program contains less than 25 lines.</description>
    </item>
    
    <item>
      <title>hdu 1164 Eddy&#39;s research I</title>
      <link>http://liuxueyang.github.io/posts/hdu-1164-eddys-research-i/</link>
      <pubDate>Tue, 12 Mar 2013 21:21:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1164-eddys-research-i/</guid>
      <description>Eddy&amp;rsquo;s research I
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 4452 Accepted Submission(s): 2680
Problem Description Eddy&amp;rsquo;s interest is very extensive, recently he is interested in prime number. Eddy discover the all number owned can be divided into the multiply of prime number, but he can&amp;rsquo;t write program, so Eddy has to ask intelligent you to help him, he asks you to write a program which can do the number to divided into the multiply of prime number factor .</description>
    </item>
    
    <item>
      <title>hdu 1097 A hard puzzle</title>
      <link>http://liuxueyang.github.io/posts/hdu-1097-a-hard-puzzle/</link>
      <pubDate>Tue, 12 Mar 2013 16:19:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1097-a-hard-puzzle/</guid>
      <description>A hard puzzle
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 21925 Accepted Submission(s): 7696
Problem Description lcy gives a hard puzzle to feng5166,lwg,JGShining and Ignatius: gave a and b,how to know the a^b.everybody objects to this BT problem,so lcy makes the problem easier than begin. this puzzle describes that: gave a and b,how to know the a^b&amp;rsquo;s the last digit number.But everybody is too lazy to slove this problem,so they remit to you who is wise.</description>
    </item>
    
    <item>
      <title>hdu 1108 最小公倍数</title>
      <link>http://liuxueyang.github.io/posts/hdu-1108-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</link>
      <pubDate>Tue, 12 Mar 2013 14:35:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1108-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</guid>
      <description>最小公倍数
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 24145 Accepted Submission(s): 13180
Problem Description 给定两个正整数，计算这两个数的最小公倍数。
Input 输入包含多组测试数据，每组只有一行，包括两个不大于1000的正整数.
Output 对于每个测试用例，给出这两个数的最小公倍数，每个实例输出一行。
Sample Input 10 14
Sample Output 70
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; int gcd(int a, int b){ return b == 0 ? a : gcd(b, a%b); } int main(void){ int a, b; #ifndef ONLINE_JUDGE freopen(&amp;quot;1108.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif while (~scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b)){ printf(&amp;quot;%d\n&amp;quot;, a * b / gcd(a, b)); } return 0; }  基础的数学题……</description>
    </item>
    
    <item>
      <title>hdu 1039 Easier Done Than Said?</title>
      <link>http://liuxueyang.github.io/posts/hdu-1039-easier-done-than-said/</link>
      <pubDate>Tue, 12 Mar 2013 14:32:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1039-easier-done-than-said/</guid>
      <description>Easier Done Than Said?
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 5021 Accepted Submission(s): 2535
Problem Description Password security is a tricky thing. Users prefer simple passwords that are easy to remember (like buddy), but such passwords are often insecure. Some sites use random computer-generated passwords (like xvtpzyo), but users have a hard time remembering them and sometimes leave them written on notes stuck to their computer.</description>
    </item>
    
    <item>
      <title>hdu 1113 Word Amalgamation</title>
      <link>http://liuxueyang.github.io/posts/hdu-1113-word-amalgamation/</link>
      <pubDate>Tue, 12 Mar 2013 14:29:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1113-word-amalgamation/</guid>
      <description>Word Amalgamation
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 1834 Accepted Submission(s): 854
Problem Description In millions of newspapers across the United States there is a word game called Jumble. The object of this game is to solve a riddle, but in order to find the letters that appear in the answer it is necessary to unscramble four words. Your task is to write a program that can unscramble words.</description>
    </item>
    
    <item>
      <title>CF 281A Word Capitalization</title>
      <link>http://liuxueyang.github.io/posts/cf-281a-word-capitalization/</link>
      <pubDate>Mon, 11 Mar 2013 20:34:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/cf-281a-word-capitalization/</guid>
      <description>A. Word Capitalization time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output
Capitalization is writing a word with its first letter as a capital letter. Your task is to capitalize the given word.
Note, that during capitalization all the letters except the first one remains unchanged. Input
A single line contains a non-empty word. This word consists of lowercase and uppercase English letters.</description>
    </item>
    
    <item>
      <title>CF 142B T-primes</title>
      <link>http://liuxueyang.github.io/posts/cf-142b-t-primes/</link>
      <pubDate>Sun, 10 Mar 2013 16:36:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/cf-142b-t-primes/</guid>
      <description>B. T-primes time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output
We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we&amp;rsquo;ll call a positive integer t Т-prime, if thas exactly three distinct positive divisors.
You are given an array of n positive integers. For each of them determine whether it is Т-prime or not. Input</description>
    </item>
    
    <item>
      <title>CF 230A Dragons</title>
      <link>http://liuxueyang.github.io/posts/cf-230a-dragons/</link>
      <pubDate>Sun, 10 Mar 2013 16:30:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/cf-230a-dragons/</guid>
      <description>C - Dragons Time Limit:2000MS Memory Limit:262144KB 64bit IO Format:%I64d &amp;amp; %I64u Submit Status Practice CodeForces 230A
Description
Kirito is stuck on a level of the MMORPG he is playing now. To move on in the game, he&amp;rsquo;s got to defeat all n dragons that live on this level. Kirito and the dragons have strength, which is represented by an integer. In the duel between two opponents the duel&amp;rsquo;s outcome is determined by their strength.</description>
    </item>
    
    <item>
      <title>CF 231A Team</title>
      <link>http://liuxueyang.github.io/posts/cf-231a-team/</link>
      <pubDate>Sun, 10 Mar 2013 16:28:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/cf-231a-team/</guid>
      <description>A - Team Time Limit:2000MS Memory Limit:262144KB 64bit IO Format:%I64d &amp;amp; %I64u Submit Status Practice CodeForces 231A
Description
One day three best friends Petya, Vasya and Tonya decided to form a team and take part in programming contests. Participants are usually offered several problems during programming contests. Long before the start the friends decided that they will implement a problem if at least two of them are sure about the solution.</description>
    </item>
    
    <item>
      <title>hdu4484 Hailstone HOTPO ——水题</title>
      <link>http://liuxueyang.github.io/posts/hdu4484-hailstone-hotpo-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Sun, 10 Mar 2013 16:21:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4484-hailstone-hotpo-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=4484 题目思路： 直接模拟即可
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int cal(int n) { int Max = n; while (n!=1) { if ((n&amp;amp;1) == 0) { n /= 2; } else { n = n * 3 + 1; } if (n &amp;gt; Max) Max = n; } return Max; } void solve() { int n; scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); int i, t, ca; for (i = 0; i &amp;lt; n; ++i) { scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;t, &amp;amp;ca); int ans = cal(ca); printf(&amp;quot;%d %d\n&amp;quot;, t, ans); } } int main(void) { //freopen(&amp;quot;4484.</description>
    </item>
    
    <item>
      <title>Casting</title>
      <link>http://liuxueyang.github.io/posts/casting/</link>
      <pubDate>Sun, 10 Mar 2013 16:16:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/casting/</guid>
      <description>#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; char a[10000000+10]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif int t; scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); while (t--){ int s, b; scanf(&amp;quot;%d%d%s&amp;quot;, &amp;amp;s, &amp;amp;b, a); int len = strlen(a), po = 1, temp = 0; for (int i = len-1; i &amp;gt;= 0; --i){ temp += (a[i]-&#39;0&#39;) * po; temp %= (b-1); } printf(&amp;quot;%d %d\n&amp;quot;, s, temp); } return 0; }  求在某个进制的数字的余数，没卡。</description>
    </item>
    
    <item>
      <title>Mystery</title>
      <link>http://liuxueyang.github.io/posts/mystery/</link>
      <pubDate>Sun, 10 Mar 2013 16:14:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/mystery/</guid>
      <description>#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; char a[200]; int b[800]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif int t; scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); while (t--){ int s; scanf(&amp;quot;%d&amp;quot;, &amp;amp;s); getchar(); gets(a); int n; scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); for (int i = 0; i &amp;lt; n; ++i) scanf(&amp;quot;%d&amp;quot;, b+i); printf(&amp;quot;%d &amp;quot;, s); int po = 0, len = strlen(a); for (int i = 0; i &amp;lt; n; ++i) { po = po + b[i]; if (po &amp;gt;= len) po = po % len; else if (po &amp;lt; 0) po = (po + len); printf(&amp;quot;%c&amp;quot;, a[po]); } printf(&amp;quot;\n&amp;quot;); } return 0; }  题目不难，就是卡了很久，最后才发现，原来是输入的文件里面写错了，多打了一个空格……次奥……</description>
    </item>
    
    <item>
      <title>poj1579 Function Run Fun</title>
      <link>http://liuxueyang.github.io/posts/poj1579-function-run-fun/</link>
      <pubDate>Fri, 08 Mar 2013 13:38:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj1579-function-run-fun/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int ww[22][22][22]; int w(int a, int b, int c){ if (a &amp;lt;= 0 || b &amp;lt;= 0 || c &amp;lt;= 0) return 1; if (a &amp;gt; 20 || b &amp;gt; 20 || c &amp;gt; 20) return w(20, 20, 20); if (ww[a][b][c] &amp;gt; 0) return ww[a][b][c]; if (a &amp;lt; b &amp;amp;&amp;amp; b &amp;lt; c) return ww[a][b][c] = w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c); else return ww[a][b][c] = w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1); } int main(void){ int a, b, c; #ifndef ONLINE_JUDGE freopen(&amp;quot;poj1759.</description>
    </item>
    
    <item>
      <title>poj 2528 Mayor&#39;s posters</title>
      <link>http://liuxueyang.github.io/posts/poj-2528-mayors-posters/</link>
      <pubDate>Tue, 05 Mar 2013 15:40:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj-2528-mayors-posters/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 const int maxn = 111111; int li[maxn], ri[maxn], x[maxn*3], col[maxn&amp;lt;&amp;lt;4], cnt; bool hash[maxn]; void PushDown(int rt){ if (col[rt] != -1){ col[rt&amp;lt;&amp;lt;1] = col[rt&amp;lt;&amp;lt;1|1] = col[rt]; col[rt] = -1; } } void update(int L,int R, int c, int l, int r, int rt){ if (L &amp;lt;= l &amp;amp;&amp;amp; R &amp;gt;= r){col[rt] = c; return;} PushDown(rt); int m = (l + r) &amp;gt;&amp;gt; 1; if (L &amp;lt;= m) update(L, R, c, lson); if (R &amp;gt; m) update(L, R, c, rson); } void query(int l, int r, int rt){ if (col[rt] !</description>
    </item>
    
    <item>
      <title>poj 3468 A Simple Problem with Integers</title>
      <link>http://liuxueyang.github.io/posts/poj-3468-a-simple-problem-with-integers/</link>
      <pubDate>Mon, 04 Mar 2013 19:14:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj-3468-a-simple-problem-with-integers/</guid>
      <description>A Simple Problem with Integers Time Limit: 5000MS Memory Limit: 131072K Total Submissions:40260 Accepted: 11693 Case Time Limit: 2000MS
Description
You have N integers, A1, A2, &amp;hellip; , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval.
Input</description>
    </item>
    
    <item>
      <title>hdu 1698 Just a Hook</title>
      <link>http://liuxueyang.github.io/posts/hdu-1698-just-a-hook/</link>
      <pubDate>Mon, 04 Mar 2013 01:36:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1698-just-a-hook/</guid>
      <description>Just a Hook
Time Limit: 4000&amp;frasl;2000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 10792 Accepted Submission(s): 5328
Problem Description In the game of DotA, Pudge’s meat hook is actually the most horrible thing for most of the heroes. The hook is made up of several consecutive metallic sticks which are of the same length.
Now Pudge wants to do some operations on the hook.
Let us number the consecutive metallic sticks of the hook from 1 to N.</description>
    </item>
    
    <item>
      <title>poj 2828 Buy Tickets</title>
      <link>http://liuxueyang.github.io/posts/poj-2828-buy-tickets/</link>
      <pubDate>Sat, 02 Mar 2013 21:01:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj-2828-buy-tickets/</guid>
      <description>Description Input Output Sample Input Sample Output 这道题目想法很重要，先建树，每个节点表示这个区间内的空的位置的数量，然后，从后往前读，Pos的值表示这个人前面有多少个空位，之所以从后往前读，是因为这样每个人的位置是确定的，以后就不用移动了，以后直接在树里面查找空位就可以了。 具体实现见代码：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 const int maxn = 222222; int tree[maxn&amp;lt;&amp;lt;2], val[maxn], pos[maxn], ans[maxn]; int id; void build(int l, int r, int rt){ tree[rt] = r - l + 1; if (l == r) {return;} int m = (l + r) &amp;gt;&amp;gt; 1; build(lson); build(rson); } void update(int p, int l, int r, int rt){ tree[rt]--; if (l == r){id = l-1; return;} int m = (l + r) &amp;gt;&amp;gt; 1; if (tree[rt&amp;lt;&amp;lt;1] &amp;gt;= p) update(p, lson); else {p -= tree[rt&amp;lt;&amp;lt;1]; update(p, rson);} } int main(void){ int n; #ifndef ONLINE_JUDGE freopen(&amp;quot;poj2828.</description>
    </item>
    
    <item>
      <title>hdu 2795 Billboard</title>
      <link>http://liuxueyang.github.io/posts/hdu-2795-billboard/</link>
      <pubDate>Sat, 02 Mar 2013 19:25:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-2795-billboard/</guid>
      <description>Billboard
Time Limit: 20000&amp;frasl;8000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 5912 Accepted Submission(s): 2682
Problem Description At the entrance to the university, there is a huge rectangular billboard of size h*w (h is its height and w is its width). The board is the place where all possible announcements are posted: nearest programming competitions, changes in the dining room menu, and other important information.
On September 1, the billboard was empty.</description>
    </item>
    
    <item>
      <title>hdu 1394 Minimum Inversion Number</title>
      <link>http://liuxueyang.github.io/posts/hdu-1394-minimum-inversion-number/</link>
      <pubDate>Sat, 02 Mar 2013 18:00:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1394-minimum-inversion-number/</guid>
      <description>Minimum Inversion Number
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 5892 Accepted Submission(s): 3587
Problem Description The inversion number of a given number sequence a1, a2, &amp;hellip;, an is the number of pairs (ai, aj) that satisfy i &amp;lt; j and ai &amp;gt; aj.
For a given sequence of numbers a1, a2, &amp;hellip;, an, if we move the first m &amp;gt;= 0 numbers to the end of the seqence, we will obtain another sequence.</description>
    </item>
    
    <item>
      <title>poj 2945 Find the Clones</title>
      <link>http://liuxueyang.github.io/posts/poj-2945-find-the-clones/</link>
      <pubDate>Wed, 27 Feb 2013 23:50:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj-2945-find-the-clones/</guid>
      <description>Find the Clones Time Limit: 5000MS Memory Limit: 65536K Total Submissions: 6265 Accepted: 2328
Description Doubleville, a small town in Texas, was attacked by the aliens. They have abducted some of the residents and taken them to the a spaceship orbiting around earth. After some (quite unpleasant) human experiments, the aliens cloned the victims, and released multiple copies of them back in Doubleville. So now it might happen that there are 6 identical person named Hugh F.</description>
    </item>
    
    <item>
      <title>poj 1056 IMMEDIATE DECODABILITY</title>
      <link>http://liuxueyang.github.io/posts/poj-1056-immediate-decodability/</link>
      <pubDate>Wed, 27 Feb 2013 19:05:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj-1056-immediate-decodability/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; const int sonnum = 2, base = &#39;0&#39;; struct Trie { int num; bool terminal; Trie *son[sonnum]; }; Trie *NewTrie() { Trie *temp = new Trie; temp-&amp;gt;num = 1; temp-&amp;gt;terminal = false; for (int i = 0; i &amp;lt; sonnum; ++i) temp-&amp;gt;son[i] = NULL; return temp; } bool Insert(Trie *pnt, char *s, int len) { Trie *temp = pnt; bool mrk = true; for (int i = 0; i &amp;lt; len; ++i) { if (temp-&amp;gt;son[s[i]-base] == NULL) temp-&amp;gt;son[s[i]-base] = NewTrie(); else { temp-&amp;gt;son[s[i]-base]-&amp;gt;num++; if (temp-&amp;gt;son[s[i]-base]-&amp;gt;terminal == true) mrk = false; } temp = temp-&amp;gt;son[s[i]-base]; } temp-&amp;gt;terminal = true; return mrk; } int main(void) { Trie *tree; char a[20]; int cnt = 1; #ifndef ONLINE_JUDGE freopen(&amp;quot;poj2056.</description>
    </item>
    
    <item>
      <title>poj 2503 Babelfish</title>
      <link>http://liuxueyang.github.io/posts/poj-2503-babelfish/</link>
      <pubDate>Wed, 27 Feb 2013 00:28:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj-2503-babelfish/</guid>
      <description>Babelfish Time Limit: 3000MS Memory Limit: 65536K Total Submissions: 26498 Accepted: 11378
Description You have just moved from Waterloo to a big city. The people here speak an incomprehensible dialect of a foreign language. Fortunately, you have a dictionary to help you understand them.
Input Input consists of up to 100,000 dictionary entries, followed by a blank line, followed by a message of up to 100,000 words. Each dictionary entry is a line containing an English word, followed by a space and a foreign language word.</description>
    </item>
    
    <item>
      <title>poj 2001 Shortest Prefixes ——字典树入门</title>
      <link>http://liuxueyang.github.io/posts/poj-2001-shortest-prefixes-%E5%AD%97%E5%85%B8%E6%A0%91%E5%85%A5%E9%97%A8/</link>
      <pubDate>Tue, 26 Feb 2013 23:29:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj-2001-shortest-prefixes-%E5%AD%97%E5%85%B8%E6%A0%91%E5%85%A5%E9%97%A8/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; char a[1000+10][25]; const int sonnum = 26, base = &#39;a&#39;; struct Trie { int num; bool terminal; struct Trie *son[sonnum]; }; Trie *NewTrie() { Trie *temp = new Trie; temp-&amp;gt;num = 1; temp-&amp;gt;terminal = false; for (int i = 0; i &amp;lt; sonnum; ++i) temp-&amp;gt;son[i] = NULL; return temp; } void Insert(Trie *pnt, char *s, int len) { Trie *temp = pnt; for (int i = 0; i &amp;lt; len; ++i) { if (temp-&amp;gt;son[s[i]-base] == NULL) temp-&amp;gt;son[s[i]-base] = NewTrie(); else temp-&amp;gt;son[s[i]-base]-&amp;gt;num++; temp = temp-&amp;gt;son[s[i]-base]; } temp-&amp;gt;terminal = true; } Trie *Find(Trie *pnt, char *s, int len) { Trie *temp = pnt; for (int i = 0; i &amp;lt; len; ++i) { if (temp-&amp;gt;son[s[i]-base]-&amp;gt;num == 1) { printf(&amp;quot;%c&amp;quot;, s[i]); return temp; } printf(&amp;quot;%c&amp;quot;, s[i]); temp = temp-&amp;gt;son[s[i]-base]; } return temp; } int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;poj2001.</description>
    </item>
    
    <item>
      <title>CF271 C. Secret</title>
      <link>http://liuxueyang.github.io/posts/cf271-c.-secret/</link>
      <pubDate>Fri, 15 Feb 2013 17:14:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/cf271-c.-secret/</guid>
      <description>C. Secret time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output
The Greatest Secret Ever consists of n words, indexed by positive integers from 1 to n. The secret needs dividing between k Keepers (let&amp;rsquo;s index them by positive integers from 1 to k), the i-th Keeper gets a non-empty set of words with numbers from the set Ui = (ui, 1, ui, 2, &amp;hellip;, ui, |Ui|).</description>
    </item>
    
    <item>
      <title>CF271 A. Beautiful Year</title>
      <link>http://liuxueyang.github.io/posts/cf271-a.-beautiful-year/</link>
      <pubDate>Fri, 15 Feb 2013 16:10:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/cf271-a.-beautiful-year/</guid>
      <description>A. Beautiful Year time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output
It seems like the year of 2013 came only yesterday. Do you know a curious fact? The year of 2013 is the first year after the old 1987 with only distinct digits.
Now you are suggested to solve the following problem: given a year number, find the minimum year number which is strictly larger than the given one and has only distinct digits.</description>
    </item>
    
    <item>
      <title>CF271 B. Prime Matrix</title>
      <link>http://liuxueyang.github.io/posts/cf271-b.-prime-matrix/</link>
      <pubDate>Fri, 15 Feb 2013 16:06:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/cf271-b.-prime-matrix/</guid>
      <description>B. Prime Matrix time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output
You&amp;rsquo;ve got an n × m matrix. The matrix consists of integers. In one move, you can apply a single transformation to the matrix: choose an arbitrary element of the matrix and increase it by 1. Each element can be increased an arbitrary number of times.
You are really curious about prime numbers.</description>
    </item>
    
    <item>
      <title>poj 2752</title>
      <link>http://liuxueyang.github.io/posts/poj-2752/</link>
      <pubDate>Wed, 30 Jan 2013 20:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/poj-2752/</guid>
      <description>题目链接：http://poj.org/problem?id=2752 #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #define N 400000 using namespace std; char s[N]; int next[N], a[N]; void getnext(char *p, int *next) { int i = 0, j = -1, len = strlen(p); next[0] = -1; while (i &amp;lt; len) { if (j == -1 || p[j] == p[i]) { i++; j++; next[i] = j; } else j = next[j]; } } int main(void) { freopen(&amp;quot;poj2752.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); while (~scanf(&amp;quot;%s&amp;quot;, s)) { getnext(s, next); int len = strlen(s), i, k = 0; i = len; a[0] = len; while (next[i] &amp;gt; 0) { i = next[i]; a[++k] = i; } for (int j = k; j &amp;gt;= 0; --j) { printf(&amp;quot;%d&amp;quot;, a[j]); if (j) printf(&amp;quot; &amp;quot;); } printf(&amp;quot;\n&amp;quot;); } return 0; }  这道题目要求既是前缀字符串又是后缀字符串的所有可能的长度，正好运用了KMP算法里面next数组的意义，要保证结果是针对整个字符串的，所以在next数组中从后往前扫描即可，因为，next数组中，越往后，数字就越大，并且表示的是后缀和前缀相同的最大长度，所以所得到的结果顺序是反的，要求从小到大输出，逆序输出就可以了。</description>
    </item>
    
    <item>
      <title>CF266 B. Queue at the School</title>
      <link>http://liuxueyang.github.io/posts/cf266-b.-queue-at-the-school/</link>
      <pubDate>Wed, 23 Jan 2013 10:23:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/cf266-b.-queue-at-the-school/</guid>
      <description>B. Queue at the School time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output
During the break the schoolchildren, boys and girls, formed a queue of n people in the canteen. Initially the children stood in the order they entered the canteen. However, after a while the boys started feeling awkward for standing in front of the girls in the queue and they started letting the girls move forward each second.</description>
    </item>
    
    <item>
      <title>CF266 A. Stones on the Table</title>
      <link>http://liuxueyang.github.io/posts/cf266-a.-stones-on-the-table/</link>
      <pubDate>Wed, 23 Jan 2013 10:19:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/cf266-a.-stones-on-the-table/</guid>
      <description>A. Stones on the Table time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output
There are n stones on the table in a row, each of them can be red, green or blue. Count the minimum number of stones to take from the table so that any two neighboring stones had different colors. Stones in a row are considered neighboring if there are no other stones between them.</description>
    </item>
    
    <item>
      <title>hdu 1046</title>
      <link>http://liuxueyang.github.io/posts/hdu-1046/</link>
      <pubDate>Tue, 22 Jan 2013 09:30:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1046/</guid>
      <description>Gridland
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 2455 Accepted Submission(s): 1168
Problem Description For years, computer scientists have been trying to find efficient solutions to different computing problems. For some of them efficient algorithms are already available, these are the “easy” problems like sorting, evaluating a polynomial or finding the shortest path in a graph. For the “hard” ones only exponential-time algorithms are known. The traveling-salesman problem belongs to this latter group.</description>
    </item>
    
    <item>
      <title>hdu 1048</title>
      <link>http://liuxueyang.github.io/posts/hdu-1048/</link>
      <pubDate>Tue, 22 Jan 2013 09:29:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1048/</guid>
      <description>The Hardest Problem Ever
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 11459 Accepted Submission(s): 5165
Problem Description Julius Caesar lived in a time of danger and intrigue. The hardest situation Caesar ever faced was keeping himself alive. In order for him to survive, he decided to create one of the first ciphers. This cipher was so incredibly sound, that no one could figure it out without knowing how it worked.</description>
    </item>
    
    <item>
      <title>hdu 1049</title>
      <link>http://liuxueyang.github.io/posts/hdu-1049/</link>
      <pubDate>Tue, 22 Jan 2013 09:28:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1049/</guid>
      <description>Climbing Worm
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 8745 Accepted Submission(s): 5659
Problem Description An inch worm is at the bottom of a well n inches deep. It has enough energy to climb u inches every minute, but then has to rest a minute before climbing again. During the rest, it slips down d inches. The process of climbing and resting then repeats. How long before the worm climbs out of the well?</description>
    </item>
    
    <item>
      <title>hdu 1064</title>
      <link>http://liuxueyang.github.io/posts/hdu-1064/</link>
      <pubDate>Tue, 22 Jan 2013 09:27:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1064/</guid>
      <description>Financial Management
Time Limit: 400&amp;frasl;200 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 6666 Accepted Submission(s): 4157
Problem Description Larry graduated this year and finally has a job. He’s making a lot of money, but somehow never seems to have enough. Larry has decided that he needs to grab hold of his financial portfolio and solve his financing problems. The first step is to figure out what’s been going on with his money.</description>
    </item>
    
    <item>
      <title>hdu 1144</title>
      <link>http://liuxueyang.github.io/posts/hdu-1144/</link>
      <pubDate>Tue, 22 Jan 2013 09:26:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1144/</guid>
      <description>Prerequisites?
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 634 Accepted Submission(s): 401
Problem Description Freddie the frosh has chosen to take k courses. To meet the degree requirements, he must take courses from each of several categories. Can you assure Freddie that he will graduate, based on his course selection?
Input Input consists of several test cases. For each case, the first line of input contains 1 ≤ k ≤ 100, the number of courses Freddie has chosen, and 0 ≤ m ≤ 100, the number of categories.</description>
    </item>
    
    <item>
      <title>hdu 1076</title>
      <link>http://liuxueyang.github.io/posts/hdu-1076/</link>
      <pubDate>Tue, 22 Jan 2013 09:24:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1076/</guid>
      <description>An Easy Task
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 10133 Accepted Submission(s): 6291
Problem Description Ignatius was born in a leap year, so he want to know when he could hold his birthday party. Can you tell him?
Given a positive integers Y which indicate the start year, and a positive integer N, your task is to tell the Nth leap year from year Y.</description>
    </item>
    
    <item>
      <title>hdu 1196</title>
      <link>http://liuxueyang.github.io/posts/hdu-1196/</link>
      <pubDate>Tue, 22 Jan 2013 09:23:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1196/</guid>
      <description>Lowest Bit
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 5440 Accepted Submission(s): 3963
Problem Description Given an positive integer A (1 &amp;lt;= A &amp;lt;= 100), output the lowest bit of A.
For example, given A = 26, we can write A in binary form as 11010, so the lowest bit of A is 10, so the output should be 2.
Another example goes like this: given A = 88, we can write A in binary form as 1011000, so the lowest bit of A is 1000, so the output should be 8.</description>
    </item>
    
    <item>
      <title>hdu 1201</title>
      <link>http://liuxueyang.github.io/posts/hdu-1201/</link>
      <pubDate>Tue, 22 Jan 2013 09:22:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1201/</guid>
      <description>18岁生日
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 12363 Accepted Submission(s): 3885
Problem Description Gardon的18岁生日就要到了，他当然很开心，可是他突然想到一个问题，是不是每个人从出生开始，到达18岁生日时所经过的天数都是一样的呢？似乎并不全都是这样，所以他想请你帮忙计算一下他和他的几个朋友从出生到达18岁生日所经过的总天数，让他好来比较一下。
Input 一个数T，后面T行每行有一个日期，格式是YYYY-MM-DD。如我的生日是1988-03-07。
Output T行，每行一个数，表示此人从出生到18岁生日所经过的天数。如果这个人没有18岁生日，就输出-1。
Sample Input 1 1988-03-07
Sample Output 6574
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; bool leap(int n) { if (n%400==0 || (n%4==0 &amp;amp;&amp;amp; n%100!=0)) return true; else return false; } int main(void) { int t, y, m, d; #ifndef ONLINE_JUDGE freopen(&amp;quot;18.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); while (t--) { scanf(&amp;quot;%d-%d-%d&amp;quot;, &amp;amp;y, &amp;amp;m, &amp;amp;d); if (leap(y)&amp;amp;&amp;amp;(m==2)&amp;amp;&amp;amp;(d==29)) { printf(&amp;quot;-1\n&amp;quot;); continue; } int sum = 0; for (int i = 1; i &amp;lt;= 17; ++i) if (leap(i+y)) sum += 366; else sum += 365; sum += 365; if (leap(y) &amp;amp;&amp;amp; (m&amp;lt;2 || (m==2&amp;amp;&amp;amp;d&amp;lt;=29))) sum++; if (leap(y+18) &amp;amp;&amp;amp; (m&amp;gt;2 || (m==2&amp;amp;&amp;amp;d==29))) sum++; printf(&amp;quot;%d\n&amp;quot;, sum); } return 0; }  看的人家的代码才搞定……简洁，准确，代码要多练，才能精简</description>
    </item>
    
    <item>
      <title>CodeForce 264 A. Escape from Stones</title>
      <link>http://liuxueyang.github.io/posts/codeforce-264-a.-escape-from-stones/</link>
      <pubDate>Mon, 21 Jan 2013 10:53:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/codeforce-264-a.-escape-from-stones/</guid>
      <description>A. Escape from Stones time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output
Squirrel Liss lived in a forest peacefully, but unexpected trouble happens. Stones fall from a mountain. Initially Squirrel Liss occupies an interval [0, 1]. Next, n stones will fall and Liss will escape from the stones. The stones are numbered from 1 to n in order.
The stones always fall to the center of Liss&amp;rsquo;s interval.</description>
    </item>
    
    <item>
      <title>hdu 1062 Text Reverse</title>
      <link>http://liuxueyang.github.io/posts/hdu-1062-text-reverse/</link>
      <pubDate>Fri, 18 Jan 2013 02:12:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1062-text-reverse/</guid>
      <description>Text Reverse
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 10835 Accepted Submission(s): 4104
Problem Description Ignatius likes to write words in reverse way. Given a single line of text which is written by Ignatius, you should reverse all the words and then output them.
Input The input contains several test cases. The first line of the input is a single integer T which is the number of test cases.</description>
    </item>
    
    <item>
      <title>A. Roma and Lucky Numbers</title>
      <link>http://liuxueyang.github.io/posts/a.-roma-and-lucky-numbers/</link>
      <pubDate>Tue, 15 Jan 2013 10:56:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/a.-roma-and-lucky-numbers/</guid>
      <description>A. Roma and Lucky Numbers time limit per test 1 second memory limit per test 256 megabytes input standard input output standard output
Roma (a popular Russian name that means &amp;lsquo;Roman&amp;rsquo;) loves the Little Lvov Elephant&amp;rsquo;s lucky numbers.
Let us remind you that lucky numbers are positive integers whose decimal representation only contains lucky digits 4 and 7. For example, numbers 47, 744, 4 are lucky and 5, 17, 467 are not.</description>
    </item>
    
    <item>
      <title>hdu 1999 不可摸数</title>
      <link>http://liuxueyang.github.io/posts/hdu-1999-%E4%B8%8D%E5%8F%AF%E6%91%B8%E6%95%B0/</link>
      <pubDate>Fri, 11 Jan 2013 11:15:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1999-%E4%B8%8D%E5%8F%AF%E6%91%B8%E6%95%B0/</guid>
      <description>Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others)Total Submission(s): 5821 Accepted Submission(s): 1524 数学题，输入n，判断n是不是不可摸数。 设t = n - 1。 如果t是素数的话，那么要使得S(m) = n，只要m = t * t即可，此时m的真因子有：1, t。则S(m) = t + 1 = n，也就是说n可摸 如果t不是素数，但是t可以表示成两个素数的和的话，设 i 是素数，并且t = i + (t-i)，其中 t-i 也是素数。那么要使得S(m) = n，只要m = i * (t - i) 即可，此时，m 的真因子有：1, i , t - i 。则S(m) = 1 + i + t - i = t + 1 = n，也就是说 n 可摸 （这里注意：t - i !</description>
    </item>
    
    <item>
      <title>ftime使用</title>
      <link>http://liuxueyang.github.io/posts/ftime%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 23 Dec 2012 21:34:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/ftime%E4%BD%BF%E7%94%A8/</guid>
      <description>t2.time获取秒，t2.millitm获取毫秒。详见网站： http://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/timeb.h.html </description>
    </item>
    
    <item>
      <title>vim 缩进技巧</title>
      <link>http://liuxueyang.github.io/posts/vim-%E7%BC%A9%E8%BF%9B%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Sun, 16 Dec 2012 13:05:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/vim-%E7%BC%A9%E8%BF%9B%E6%8A%80%E5%B7%A7/</guid>
      <description>缩进：n, m &amp;gt; 表示从n行到m行缩进　缩出用 &amp;gt; n &amp;gt; 表示从当前行起,再往下数n行，缩进 缩出用 &amp;gt; n ==表示从当前行起，再往下数n-1行，自动排版 自动排版：G=gg</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.3.3 二进制生成子集</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.3.3-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%94%9F%E6%88%90%E5%AD%90%E9%9B%86/</link>
      <pubDate>Sat, 15 Dec 2012 14:30:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.3.3-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%94%9F%E6%88%90%E5%AD%90%E9%9B%86/</guid>
      <description>多简洁的位运算！</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.3.2 位向量生成子集</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.3.2-%E4%BD%8D%E5%90%91%E9%87%8F%E7%94%9F%E6%88%90%E5%AD%90%E9%9B%86/</link>
      <pubDate>Sat, 15 Dec 2012 13:29:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.3.2-%E4%BD%8D%E5%90%91%E9%87%8F%E7%94%9F%E6%88%90%E5%AD%90%E9%9B%86/</guid>
      <description>比增量构造要复杂，但是想法简洁</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.3.1 增量构造生成子集</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.3.1-%E5%A2%9E%E9%87%8F%E6%9E%84%E9%80%A0%E7%94%9F%E6%88%90%E5%AD%90%E9%9B%86/</link>
      <pubDate>Sat, 15 Dec 2012 13:06:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.3.1-%E5%A2%9E%E9%87%8F%E6%9E%84%E9%80%A0%E7%94%9F%E6%88%90%E5%AD%90%E9%9B%86/</guid>
      <description>体会递归的想法，其实挺巧妙的。</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.2.4 生成的排列，STL实现</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.2.4-%E7%94%9F%E6%88%90%E7%9A%84%E6%8E%92%E5%88%97stl%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 15 Dec 2012 12:04:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.2.4-%E7%94%9F%E6%88%90%E7%9A%84%E6%8E%92%E5%88%97stl%E5%AE%9E%E7%8E%B0/</guid>
      <description>实现很简洁，强大的STL</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.2.2 生成可重集的排列</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.2.2-%E7%94%9F%E6%88%90%E5%8F%AF%E9%87%8D%E9%9B%86%E7%9A%84%E6%8E%92%E5%88%97/</link>
      <pubDate>Sat, 15 Dec 2012 11:41:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.2.2-%E7%94%9F%E6%88%90%E5%8F%AF%E9%87%8D%E9%9B%86%E7%9A%84%E6%8E%92%E5%88%97/</guid>
      <description>先把数列排序，再修改以前的程序。
注意体会for里面的条件</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.2.1 生成1到N的排列</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.2.1-%E7%94%9F%E6%88%901%E5%88%B0n%E7%9A%84%E6%8E%92%E5%88%97/</link>
      <pubDate>Sat, 15 Dec 2012 10:08:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.2.1-%E7%94%9F%E6%88%901%E5%88%B0n%E7%9A%84%E6%8E%92%E5%88%97/</guid>
      <description>注意多体会递归的想法</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.7.4 双基回文数</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.7.4-%E5%8F%8C%E5%9F%BA%E5%9B%9E%E6%96%87%E6%95%B0/</link>
      <pubDate>Fri, 14 Dec 2012 20:57:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.7.4-%E5%8F%8C%E5%9F%BA%E5%9B%9E%E6%96%87%E6%95%B0/</guid>
      <description>双基回文数很多，所以可以暴力。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;iomanip&amp;gt; using namespace std; int trans(int n, int base) { int a[100], i = 1; a[0]=n%base; n/=base; while (n) { a[i++]=n%base; n/=base; } int len = i; int mrk = 1; for (i = 0; i &amp;lt; len; ++i) { if (a[i] != a[len-1-i]) { mrk = 0; break; } } return mrk; } int main(void) { int n; #ifndef ONLINE_JUDGE freopen(&amp;quot;in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { int mrk = 0, cnt = 0; for (int i = n+1; ; ++i) { cnt = 0; for (int j = 2; j &amp;lt; 11; ++j) { if (trans(i, j)) { cnt++; if (cnt==2) { mrk = 1; printf(&amp;quot;%d\n&amp;quot;, i); break; } } } if (mrk) break; } } return 0; }  注意在trans()函数中，a数组不能小于32，原因是，转化成2进制的时候，数组要足够大，刚开始只开了20，出现了错误，并且发现一个有趣的问题，i的值会竟然会自动调整！不信的话，你试试把代码改成下面这样：（只改这个地方，其他地方不变）</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.7.3 分数拆分</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.7.3-%E5%88%86%E6%95%B0%E6%8B%86%E5%88%86/</link>
      <pubDate>Fri, 14 Dec 2012 20:00:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.7.3-%E5%88%86%E6%95%B0%E6%8B%86%E5%88%86/</guid>
      <description>找出x,y的范围，枚举就可以了
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; int main(void) { int k; #ifndef ONLINE_JUDGE freopen(&amp;quot;in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;k)) { for (int i = k+1; i &amp;lt;= 2*k; ++i) { if ((k*i)/(i-k)%1==0) printf(&amp;quot;1/%d = 1/%d + 1/%d\n&amp;quot;, k, (k*i)/(i-k), i); } } return 0; }   </description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.7.2 最大乘积</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.7.2-%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</link>
      <pubDate>Fri, 14 Dec 2012 19:40:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.7.2-%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</guid>
      <description>因为范围只有18个数字，所以可以枚举起点和终点。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; long long int f(int a[], int start, int end) { long long int sum = 1; for (int i = start; i &amp;lt; end + 1; ++i) { sum *= a[i]; } return sum; } int main(void) { int n, a[20]; #ifndef ONLINE_JUDGE freopen(&amp;quot;in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { for (int i = 0; i &amp;lt; n; ++i) scanf(&amp;quot;%d&amp;quot;, &amp;amp;a[i]); long long int sum=-1; for (int i = 0; i &amp;lt; n; ++i) { for (int j = i; j &amp;lt; n; ++j) { if (f(a, i, j) &amp;gt; sum) sum = f(a, i, j); } } printf(&amp;quot;%lld\n&amp;quot;, sum); } return 0; }  根据数据范围，估算一下能不能暴力</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.7.1 除法</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.7.1-%E9%99%A4%E6%B3%95/</link>
      <pubDate>Fri, 14 Dec 2012 19:21:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.7.1-%E9%99%A4%E6%B3%95/</guid>
      <description>这道题目还是卡了很久，原因是要考虑0是不是出现过，要标记。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;math.h&amp;gt; void f(int a[], int n) { a[n%10] = 1; n/=10; while (n) { a[n%10] = 1; n/=10; } return; } int main(void) { int n, i, a[11], k, temp; freopen(&amp;quot;in&amp;quot;, &amp;quot;r&amp;quot;, stdin); while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { for (i = 100; i &amp;lt; 50000; ++i) { k = i * n; memset(a, 0, sizeof(a)); temp = k; if (temp/100000!=0) continue; f(a, temp); f(a, i); a[temp/10000] = a[i/10000] = 1; int mrk=1; for (int s = 0; s &amp;lt; 10; ++s) { if(!</description>
    </item>
    
    <item>
      <title>gdb调试方法简要总结</title>
      <link>http://liuxueyang.github.io/posts/gdb%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 14 Dec 2012 09:02:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/gdb%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/</guid>
      <description>在编译的时候加上 -g 选项，如： g++ -Wall -g test.cpp -o test 开始调试： gdb test 基本命令： l 显示代码，是list的简写 b 插入断点，是break的简写 n 下一步，是next的简写 s 单步运行，是stepinto的简写，可以进入函数内部 p 打印，是print的简写，可以打印变量 disp 在每一步运行中显示要求的变量，是display的简写 d disp 编号 删除指定编号的display，d是delete的简写 dis disp 编号 禁止指定编号的display，dis是disable的简写 en disp 编号 恢复指定编号的display，en是enable的简写 u 行号 运行到指定行号</description>
    </item>
    
    <item>
      <title>重载运算符 [] 实现寻找数组的第K大的元素</title>
      <link>http://liuxueyang.github.io/posts/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6--%E5%AE%9E%E7%8E%B0%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Fri, 14 Dec 2012 08:52:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6--%E5%AE%9E%E7%8E%B0%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>方法是利用快排的想法，效率O(N)
/* * use the method of quicksort. The time efficiency is * O(N). * * */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;iomanip&amp;gt; using namespace std; class Array { public: friend istream &amp;amp; operator &amp;gt;&amp;gt; (istream &amp;amp; input, Array &amp;amp; a); friend ostream &amp;amp; operator &amp;lt;&amp;lt; (ostream &amp;amp; outpu, Array &amp;amp; a); int operator [] (int p); void exchange(int &amp;amp;s, int &amp;amp;t); int partition(int *p, int l, int r); int k_element(int *p, int l, int r, int k); int getlen(){return len;} private: int *a; int len; }; int Array::operator [] (int p) { return k_element(a, 0, len-1, p); } int Array::k_element(int *p, int l, int r, int k) { if (l &amp;lt; r) { int q = partition(p, l, r); if (q + 1 == k) return p[q]; else if (q + 1 &amp;gt; k) return k_element(p, l, q-1, k); else return k_element(p, q+1, r, k); //这个地方尤其要注意，应该还是k，而不是k-q-1！ } else return p[l]; } ostream &amp;amp; operator &amp;lt;&amp;lt; (ostream &amp;amp; output, Array &amp;amp; array) { for (int i = 0; i &amp;lt; array.</description>
    </item>
    
    <item>
      <title>创建一个类，重载运算符实现多项式的加，减，乘运算</title>
      <link>http://liuxueyang.github.io/posts/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E8%BF%90%E7%AE%97/</link>
      <pubDate>Fri, 14 Dec 2012 08:44:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E8%BF%90%E7%AE%97/</guid>
      <description>唉，我太弱了，这么个简单的东西，还是用数组写的，却因为各种错误，弄了一个晚上，C++还得好好学啊，各种语法，要弄清楚。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; class Polynomial { public: Polynomial(int = 0); friend istream &amp;amp; operator &amp;gt;&amp;gt; (istream &amp;amp; input, Polynomial &amp;amp; pl); friend ostream &amp;amp; operator &amp;lt;&amp;lt; (ostream &amp;amp; output, Polynomial &amp;amp; pl); Polynomial &amp;amp; operator += (Polynomial &amp;amp; add); Polynomial &amp;amp; operator -= (Polynomial &amp;amp; add); Polynomial &amp;amp; operator - (Polynomial &amp;amp; add); Polynomial &amp;amp; operator * (Polynomial &amp;amp;); Polynomial &amp;amp; operator + (Polynomial &amp;amp; add); Polynomial &amp;amp; operator *= (Polynomial &amp;amp;); Polynomial &amp;amp; operator = (Polynomial &amp;amp; right); Polynomial &amp;amp; test(Polynomial &amp;amp; right); private: int *a; int size, num; }; Polynomial &amp;amp; Polynomial::operator *= (Polynomial &amp;amp; mu) { Polynomial b, c; c = *this; b = *this; for (int j=0,r=0; j&amp;lt;b.</description>
    </item>
    
    <item>
      <title>Hanoi</title>
      <link>http://liuxueyang.github.io/posts/hanoi/</link>
      <pubDate>Wed, 12 Dec 2012 09:19:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hanoi/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; int step = 1; void move(char from, char to) { printf(&amp;quot;%d: %c-&amp;gt;%c\n&amp;quot;, step++, from, to); } void h(int n, char from, char via, char to) { if (n == 1) {move(from, to); return;} h(n-1, from, to, via); move(from, to); h(n-1, via, from, to); } int main(void) { int n; while (cin &amp;gt;&amp;gt; n) { step = 1; h(n, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;); } return 0; }  挺简单的一个Hanoi程序</description>
    </item>
    
    <item>
      <title>tips</title>
      <link>http://liuxueyang.github.io/posts/tips/</link>
      <pubDate>Mon, 10 Dec 2012 13:35:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/tips/</guid>
      <description>其实，一天过完之后，你真应该问问自己，今天自己干嘛了？还记得昨天你干了什么吗？前天呢？ 如果你记不起来，那你多半是在混日子。</description>
    </item>
    
    <item>
      <title>数组名和指针相同吗？</title>
      <link>http://liuxueyang.github.io/posts/%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%90%8C%E5%90%97/</link>
      <pubDate>Tue, 04 Dec 2012 19:13:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%90%8C%E5%90%97/</guid>
      <description>/* 数组名和指针相同吗？ */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; int a[][3] = {{1, 2, 3}, {1, 2, 3}, {4, 5, 6}, {3, 4, 5}}; int sizef(int b[][3]) { cout &amp;lt;&amp;lt; sizeof(b) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; sizeof(b[0]) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; sizeof(b)/sizeof(b[0]) &amp;lt;&amp;lt; endl; } int main(void) { // int a[][3] = {{1, 2, 3}, {1, 2, 3}, {4, 5, 6}, {3, 4, 5}}; cout &amp;lt;&amp;lt; sizeof(a) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; sizeof(a[0]) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; sizeof(a)/sizeof(a[0]) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;quot;***********&amp;quot; &amp;lt;&amp;lt; endl; sizef(a); // cout &amp;lt;&amp;lt; sizef(a) &amp;lt;&amp;lt; endl; system(&amp;quot;pause&amp;quot;); return 0; }  上面的程序的结果是： 48 12 4</description>
    </item>
    
    <item>
      <title>zoj 2110 Tempter of the Bone</title>
      <link>http://liuxueyang.github.io/posts/zoj-2110-tempter-of-the-bone/</link>
      <pubDate>Thu, 29 Nov 2012 14:10:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/zoj-2110-tempter-of-the-bone/</guid>
      <description>The doggie found a bone in an ancient maze, which fascinated him a lot. However, when he picked it up, the maze began to shake, and the doggie could feel the ground sinking. He realized that the bone was a trap, and he tried desperately to get out of this maze.
The maze was a rectangle with sizes N by M. There was a door in the maze. At the beginning, the door was closed and it would open at the T-th second for a short period of time (less than 1 second).</description>
    </item>
    
    <item>
      <title>Erlang_3</title>
      <link>http://liuxueyang.github.io/posts/erlang_3/</link>
      <pubDate>Tue, 27 Nov 2012 15:45:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/erlang_3/</guid>
      <description>计算阶乘两种写法：
-module(continue). -export([factor/1]). factor(0) -&amp;gt; 1; factor(N) -&amp;gt; N * factor(N - 1). %factor(N) when N &amp;gt; 0 -&amp;gt; % N * factor(N - 1); %factor(0) -&amp;gt; 1.  这里注意，第一种写法，如果输入的值是负数，那么函数进入死循环，内存溢出，第二种写法输入负数，函数会不执行。 内置函数： hd/1 返回列表第一个元素 tl/1 返回删除第一个元素后的其余部分 length/1 返回列表的长度 tuple_size/1 返回元组的数目 element/2 返回元组的第n个元素 setlement(2, Tuple). setelement/3 替换元组的第一个元素，并返回新的元组 setelement(3, Tuple, Three). erlang:appedn_element/2 向元组添加一个元素作为最后的元素 erlang:append_element(Tuple, 6).</description>
    </item>
    
    <item>
      <title>Erlang_2</title>
      <link>http://liuxueyang.github.io/posts/erlang_2/</link>
      <pubDate>Tue, 27 Nov 2012 15:35:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/erlang_2/</guid>
      <description>1.函数 举个例子：判断一个数字是奇数还是偶数
-module(rev). -export([even/1]). even(Value) -&amp;gt; if Value rem 2 == 1 -&amp;gt; odd; Value rem 2 == 0 -&amp;gt; even end.  文件名和模块名要相同。在终端中引用函数的时候，先编译，c(rev). 然后引用函数 rev:even(N). 其中N是一个已经赋值的变量。 上面的函数的另一种写法： -module(rev). -export([even/1]). even(Value) -&amp;gt; case Value rem 2 of 1 -&amp;gt; odd; 0 -&amp;gt; even end.  </description>
    </item>
    
    <item>
      <title>bash 改为 vim 输入模式</title>
      <link>http://liuxueyang.github.io/posts/bash-%E6%94%B9%E4%B8%BA-vim-%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 26 Nov 2012 01:16:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/bash-%E6%94%B9%E4%B8%BA-vim-%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>打开文件：vim ~/.bashrc 加上这条语句：set -o vi &amp;gt;&amp;gt; ~/.bashrc</description>
    </item>
    
    <item>
      <title>Erlang_1</title>
      <link>http://liuxueyang.github.io/posts/erlang_1/</link>
      <pubDate>Sat, 24 Nov 2012 19:56:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/erlang_1/</guid>
      <description>1.在终端运行的时候末尾要输入 . 号 2.数学运算符： + 加法 正号 - 减法 负号 * 乘法 / 浮点除法 div 整数除法 rem 整数取余 3.基元表示文字常量 4.布尔类型 没有单独表示布尔类型的布尔值或字符 and 与 andalso 第一个参数为假，返回假则第二个参数不需计算 or 或 orelse 第一个参数是真，返回真，不计算第二个参数 xor 异或 不同为真，相同为假 not 非 5.元组 {a, b, c, d} 元组中的数据元素不一定是相同的类型</description>
    </item>
    
    <item>
      <title>hdu 1161 Eddy&#39;s mistakes</title>
      <link>http://liuxueyang.github.io/posts/hdu-1161-eddys-mistakes/</link>
      <pubDate>Fri, 23 Nov 2012 18:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1161-eddys-mistakes/</guid>
      <description>Eddy&amp;rsquo;s mistakes
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 5189 Accepted Submission(s): 2956
Problem Description Eddy usually writes articles ,but he likes mixing the English letter uses, for example &amp;ldquo;computer science&amp;rdquo; is written frequently &amp;ldquo;coMpUtEr scIeNce&amp;rdquo; by him, this mistakes lets Eddy&amp;rsquo;s English teacher be extremely discontentment.Now please you to write a procedure to be able in the Bob article English letter to turn completely the small letter.</description>
    </item>
    
    <item>
      <title>hdu 1166 敌兵布阵</title>
      <link>http://liuxueyang.github.io/posts/hdu-1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5/</link>
      <pubDate>Fri, 23 Nov 2012 18:46:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5/</guid>
      <description>敌兵布阵
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 22041 Accepted Submission(s): 9654
Problem Description C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。 中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:&amp;ldquo;你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：&amp;rdquo;我知错了。。。&amp;rdquo;但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.
Input 第一行一个整数T，表示有T组数据。 每组数据第一行一个正整数N（N&amp;lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&amp;lt;=ai&amp;lt;=50）。 接下来每行有一条命令，命令有4种形式： (1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30） (2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）; (3)Query i j ,i和j为正整数,i&amp;lt;=j，表示询问第i到第j个营地的总人数; (4)End 表示结束，这条命令在每组数据最后出现; 每组数据最多有40000条命令
Output 对第i组数据,首先输出“Case i:”和回车, 对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。
Sample Input 1 10 1 2 3 4 5 6 7 8 9 10 Query 1 3 Add 3 6 Query 2 7 Sub 10 2 Add 6 3 Query 3 10 End</description>
    </item>
    
    <item>
      <title>hdu1754 I Hate It ——线段数入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu1754-i-hate-it-%E7%BA%BF%E6%AE%B5%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Fri, 23 Nov 2012 18:42:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1754-i-hate-it-%E7%BA%BF%E6%AE%B5%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1754
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #define maxn 200000&amp;lt;&amp;lt;2 //#define max(a,b) ((a)&amp;gt;(b)?(a):(b)) #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 int Max[maxn]; using namespace std; void pushup(int rt) { Max[rt] = max(Max[rt&amp;lt;&amp;lt;1],Max[rt&amp;lt;&amp;lt;1|1]); } void build(int l, int r, int rt) { if(l==r) {scanf(&amp;quot;%d&amp;quot;, &amp;amp;Max[rt]); return;} int m=l+((r-l)&amp;gt;&amp;gt;1); build(lson);build(rson); pushup(rt); } void update(int p, int ck, int l, int r, int rt) { if (l==r) {Max[rt] = ck; return;} int m=l+((r-l)&amp;gt;&amp;gt;1); if (p &amp;lt;= m) update(p, ck, lson); else update(p, ck, rson); pushup(rt); } int query(int L, int R, int l, int r, int rt) { if (L &amp;lt;= l &amp;amp;&amp;amp; R &amp;gt;= r) {return Max[rt];} int m=l+((r-l)&amp;gt;&amp;gt;1); int ret = 0; if (L&amp;lt;=m) ret = max(query(L,R,lson),ret); if (R&amp;gt;m) ret = max(query(L,R,rson),ret); return ret; } int main(void) { int N, M; #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>ubuntu 12.04 安装之后的配置问题</title>
      <link>http://liuxueyang.github.io/posts/ubuntu-12.04-%E5%AE%89%E8%A3%85%E4%B9%8B%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 20 Nov 2012 12:07:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/ubuntu-12.04-%E5%AE%89%E8%A3%85%E4%B9%8B%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</guid>
      <description> 首先换软件源。 如果安装vim的时候出现问题，比如： Reading package lists&amp;hellip; DoneBuilding dependency tree Reading state information&amp;hellip; DonePackage vim is not available, but is referred to by another package.This may mean that the package is missing, has been obsoleted, oris only available from another source E: Package &amp;lsquo;vim&amp;rsquo; has no installation candidate 执行 sudo apt-get update 就可以了 如果刚刚安装上系统，没有中文输入法，也没有输入法的切换面板，执行： killall ibus-daemon ibus-daemon -d 然后就出现了输入法切换面板，点击，找到 preferences 选项，在 inputmethod 里面添加中文输入法就可以了。 设置允许root 登录 ： vi /etc/lightdm/lightdm.conf. 在这个文件末尾加上下面两行代码 greeter-show-manual-login=trueallow-guest=false 保存退出。然后 sudo passwd root 设置root登录密码就可以了。  </description>
    </item>
    
    <item>
      <title>ubuntu12.04 iNodeClient 连校园网</title>
      <link>http://liuxueyang.github.io/posts/ubuntu12.04-inodeclient-%E8%BF%9E%E6%A0%A1%E5%9B%AD%E7%BD%91/</link>
      <pubDate>Mon, 12 Nov 2012 22:46:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/ubuntu12.04-inodeclient-%E8%BF%9E%E6%A0%A1%E5%9B%AD%E7%BD%91/</guid>
      <description>百度文库里面有一个文档，叫做”ubuntu_12.04_安装_iNodeClient_教程“，按照那个做，安装上之后然后发现能通过身份验证，但是连不上网，继续执行下面的操作。 sudo chmod -R 777 /home/suruibin/iNodeClient（后面这个路径改成你自己的安装目录）
进入目录 cd iNodeClient 安装：sudo ./install.sh
sudo ln -s /usr/lib/i386-linux-gnu/libtiff.so.4 /usr/lib/i386-linux-gnu/libtiff.so.3
sudo apt-get install libjpeg62
从网上找到libtiff.so.4这个文件，执行 sudo cp libtiff.so.4 /usr/lib
到此iNodeClient安装好了，输入用户名，密码什么的就可以了。
2012-11-12 22:45:04
这个方法以前一直可以，但是最近貌似不行了……囧，后来找各种方法，http://hi.baidu.com/shen1000shen/item/c935a9383b615542033edcf9 这位神牛总结的很好，佩服！终于连上网了，Ubuntu爽到爆～</description>
    </item>
    
    <item>
      <title>uva 537 - Artificial Intelligence?</title>
      <link>http://liuxueyang.github.io/posts/uva-537---artificial-intelligence/</link>
      <pubDate>Fri, 09 Nov 2012 23:42:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva-537---artificial-intelligence/</guid>
      <description>Physics teachers in high school often think that problems given as text are more demanding than pure computations. After all, the pupils have to read and understand the problem first! So they don&amp;rsquo;t state a problem like U=10V, I=5A, P=?&amp;quot; but rather likeYou have an electrical circuit that contains a battery with a voltage of U=10V and a light-bulb. There&amp;rsquo;s an electrical current of I=5A through the bulb. Which power is generated in the bulb?</description>
    </item>
    
    <item>
      <title>vim 配置 转载</title>
      <link>http://liuxueyang.github.io/posts/vim-%E9%85%8D%E7%BD%AE-%E8%BD%AC%E8%BD%BD/</link>
      <pubDate>Fri, 09 Nov 2012 08:23:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/vim-%E9%85%8D%E7%BD%AE-%E8%BD%AC%E8%BD%BD/</guid>
      <description>一个比较偷懒的方法是执行一下命令： cd /etc/vim sudo vi vimrc 然后把里面的注释去掉就可以了,但是里面的配置不太全。 原文链接 http://www.oschina.net/code/snippet_103341_9644 linux 平台：
&amp;quot; ----------------- Author: Ruchee &amp;quot; ----------------- Email: my@ruchee.com &amp;quot; ----------------- WebSite: http://www.ruchee.com &amp;quot; ----------------- Date: 2012-05-01 &amp;quot; Ctrl + H --光标移当前行行首 &amp;quot; Ctrl + J --光标移下一行行首 &amp;quot; Ctrl + K --光标移上一行行尾 &amp;quot; Ctrl + L --光标移当前行行尾 &amp;quot; Ctrl + C --编译 [支持C/C++、Java、Haskell] &amp;quot; Ctrl + R --运行 [支持C/C++、Java、Haskell、Lua、Perl、Python、Ruby] &amp;quot; Ctrl + ] --转到函数定义 &amp;quot; Ctrl + T --返回调用函数 &amp;quot; Ctrl + E --一步加载语法模板和作者、时间信息 &amp;quot; &amp;lt;C-P&amp;gt; --单词补全 &amp;quot; &amp;lt;C-X&amp;gt;&amp;lt;C-L&amp;gt; --整行补全 &amp;quot; Tab键 --插入模式下的全功能语法结构补全 [snipMate插件] &amp;quot; Shift + Insert --向Vim中粘贴从别处复制的内容 &amp;quot; u [小写] --单步复原 [非插入模式] &amp;quot; U [大写] --整行复原 [非插入模式] &amp;quot; jj --保存文件并留在插入模式 [插入模式] &amp;quot; kk --返回Normal模式 [插入模式] &amp;quot; nt --打开NERDTree [非插入模式] &amp;quot; tl --打开TagList [非插入模式] &amp;quot; za --打开或关闭当前折叠 &amp;quot; zM --关闭所有折叠 &amp;quot; zR --打开所有折叠 &amp;quot; :set syntax=cpp --手动选择语法高亮 [或 :set filetype=cpp] &amp;quot; :%!</description>
    </item>
    
    <item>
      <title>uva 10010 - Where&#39;s Waldorf?</title>
      <link>http://liuxueyang.github.io/posts/uva-10010---wheres-waldorf/</link>
      <pubDate>Fri, 09 Nov 2012 07:57:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva-10010---wheres-waldorf/</guid>
      <description>Given a m by n grid of letters, ( ), and a list of words, find the location in the grid at which the word can be found. A word matches a straight, uninterrupted line of letters in the grid. A word can match the letters in the grid regardless of case (i.e. upper and lower case letters are to be treated as the same). The matching can be done in any of the eight directions either horizontally, vertically or diagonally through the grid.</description>
    </item>
    
    <item>
      <title>uva 253 - Cube painting</title>
      <link>http://liuxueyang.github.io/posts/uva-253---cube-painting/</link>
      <pubDate>Thu, 08 Nov 2012 22:07:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva-253---cube-painting/</guid>
      <description>We have a machine for painting cubes. It is supplied with three different colors: blue, red and green. Each face of the cube gets one of these colors. The cube&amp;rsquo;s faces are numbered as in Figure 1.  Figure 1. Since a cube has 6 faces, our machine can paint a face-numbered cube in different ways. When ignoring the face-numbers, the number of different paintings is much less, because a cube can be rotated.</description>
    </item>
    
    <item>
      <title>uva 10161 - Ant on a Chessboard</title>
      <link>http://liuxueyang.github.io/posts/uva-10161---ant-on-a-chessboard/</link>
      <pubDate>Thu, 08 Nov 2012 21:13:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva-10161---ant-on-a-chessboard/</guid>
      <description>One day, an ant called Alice came to an M*M chessboard. She wanted to go around all the grids. So she began to walk along the chessboard according to this way: (you can assume that her speed is one grid per second) At the first second, Alice was standing at (1,1). Firstly she went up for a grid, then a grid to the right, a grid downward. After that, she went a grid to the right, then two grids upward, and then two grids to the left…in a word, the path was like a snake.</description>
    </item>
    
    <item>
      <title>uva 113 - Power of Cryptography</title>
      <link>http://liuxueyang.github.io/posts/uva-113---power-of-cryptography/</link>
      <pubDate>Thu, 08 Nov 2012 00:07:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva-113---power-of-cryptography/</guid>
      <description>Current work in cryptography involves (among other things) large prime numbers and computing powers of numbers modulo functions of these primes. Work in this area has resulted in the practical use of results from number theory and other branches of mathematics once considered to be of only theoretical interest. This problem involves the efficient computation of integer roots of numbers. Given an integer and an integer you are to write a program that determines , the positive root of p.</description>
    </item>
    
    <item>
      <title>uva 621 - Secret Research</title>
      <link>http://liuxueyang.github.io/posts/uva-621---secret-research/</link>
      <pubDate>Wed, 07 Nov 2012 23:32:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva-621---secret-research/</guid>
      <description>At a certain laboratory results of secret research are thoroughly encrypted. A result of a single experiment is stored as an information of its completion: positive result&#39;, negative result&amp;rsquo;, experiment failed&#39; or experiment not completed&amp;rsquo;
 The encrypted result constitutes a string of digits S, which may take one of the following forms:
 (A sample result S35 means that if we add digits 35 from the right hand side to a digit sequence then we shall get the digit sequence corresponding to a failed experiment) You are to write a program which decrypts given sequences of digits.</description>
    </item>
    
    <item>
      <title>uva 107 - The Cat in the Hat</title>
      <link>http://liuxueyang.github.io/posts/uva-107---the-cat-in-the-hat/</link>
      <pubDate>Wed, 07 Nov 2012 21:46:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva-107---the-cat-in-the-hat/</guid>
      <description>(An homage to Theodore Seuss Geisel) The Cat in the Hat is a nasty creature,But the striped hat he is wearing has a rather nifty feature. With one flick of his wrist he pops his top off. Do you know what&amp;rsquo;s inside that Cat&amp;rsquo;s hat?A bunch of small cats, each with its own striped hat. Each little cat does the same as line three,All except the littlest ones, who just say ``Why me?</description>
    </item>
    
    <item>
      <title>uva 10790 - How Many Points of Intersection?</title>
      <link>http://liuxueyang.github.io/posts/uva-10790---how-many-points-of-intersection/</link>
      <pubDate>Wed, 07 Nov 2012 00:12:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva-10790---how-many-points-of-intersection/</guid>
      <description>We have two rows. There are a dots on the top row and b dots on the bottom row. We draw line segments connecting every dot on the top row with every dot on the bottom row. The dots are arranged in such a way that the number of internal intersections among the line segments is maximized. To achieve this goal we must not allow more than two line segments to intersect in a point.</description>
    </item>
    
    <item>
      <title>uva 11044 Searching for Nessy</title>
      <link>http://liuxueyang.github.io/posts/uva-11044-searching-for-nessy/</link>
      <pubDate>Tue, 06 Nov 2012 23:57:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva-11044-searching-for-nessy/</guid>
      <description>The Loch Ness Monsteris a mysterious and unidentified animal said to inhabit Loch Ness, a large deep freshwater loch near the city of Inverness in northern Scotland. Nessie is usually categorized as a type of lake monster. http://en.wikipedia.org/wiki/Loch_Ness_Monster In July 2003, the BBC reported an extensive investigation of Loch Ness by a BBC team, using 600 separate sonar beams, found no trace of any ¨sea monster¨ (i.e., any large animal, known or unknown) in the loch.</description>
    </item>
    
    <item>
      <title>uva 573 The Snail</title>
      <link>http://liuxueyang.github.io/posts/uva-573-the-snail/</link>
      <pubDate>Tue, 06 Nov 2012 23:54:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva-573-the-snail/</guid>
      <description>The Snail
A snail is at the bottom of a 6-foot well and wants to climb to the top. The snail can climb 3 feet while the sun is up, but slides down 1 foot at night while sleeping. The snail has a fatigue factor of 10%, which means that on each successive day the snail climbs 10% 3 = 0.3 feet less than it did the previous day. (The distance lost to fatigue is always 10% of the first day&amp;rsquo;s climbing distance.</description>
    </item>
    
    <item>
      <title>lost</title>
      <link>http://liuxueyang.github.io/posts/lost/</link>
      <pubDate>Tue, 06 Nov 2012 14:27:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/lost/</guid>
      <description>从今年暑假7月15日开始学ACM到现在已经快4个月了，水平还是那么的水。。。照这样下去，明年的这个时候该是什么样子，，唉。。 从开始到现在走了不少弯路，明显把太多时间花在了做水题上，也没有做多少总结，根本没有去认真学一下正经的算法，其实算法才是最重要的，把算法学好需要很长的时间积累，不是短期内就可以搞定的。以后少做水题，多学算法，针对学习的算法多练习，平均每天做3题比较合适，还有，多总结，经常用的算法多写几遍，熟练，代码要精简。 好好加油吧，再坚持一阵子，虽然不知道以后会变成怎样。 看书要有针对性地看。做ACM，关键是态度，人家做IOI的，不也是高中生吗，人家照样比大学生强。至于队友，LLH明年大四肯定就不做了，这让我颇有压力，希望在大二这一年剩下的时间里面好好做，争取能取得一点成绩，这样也算少留下一点遗憾吧。明年我还要不要继续做下去，再说。也许会，也许不会。 让时间决定。</description>
    </item>
    
    <item>
      <title>转载  ACM训练计划</title>
      <link>http://liuxueyang.github.io/posts/%E8%BD%AC%E8%BD%BD--acm%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92/</link>
      <pubDate>Tue, 06 Nov 2012 12:43:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E8%BD%AC%E8%BD%BD--acm%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92/</guid>
      <description>看完人家的博客，发现任重道远。。。 一位高手对我的建议： 一般要做到50行以内的程序不用调试、100行以内的二分钟内调试成功.acm主要是考算法的，主要时间是花在思考算法上，不是花在写程序与debug上。 下面给个计划你练练： 第一阶段：练经典常用算法，下面的每个算法给我打上十到二十遍，同时自己精简代码，因为太常用，所以要练到写时不用想，10-15分钟内打完，甚至关掉显示器都可以把程序打出来. 1.最短路(Floyd、Dijstra,BellmanFord) 2.最小生成树(先写个prim,kruscal要用并查集，不好写) 3.大数（高精度）加减乘除 4.二分查找. (代码可在五行以内) 5.叉乘、判线段相交、然后写个凸包. 6.BFS、DFS,同时熟练hash表(要熟，要灵活,代码要简) 7.数学上的有：辗转相除（两行内），线段交点、多角形面积公式. 8. 调用系统的qsort, 技巧很多，慢慢掌握. 9. 任意进制间的转换 第二阶段：练习复杂一点，但也较常用的算法。 如： 1. 二分图匹配（匈牙利），最小路径覆盖 2. 网络流，最小费用流。 3. 线段树. 4. 并查集。 5. 熟悉动态规划的各个典型：LCS、最长递增子串、三角剖分、记忆化dp 6.博弈类算法。博弈树，二进制法等。 7.最大团，最大独立集。 8.判断点在多边形内。 9. 差分约束系统. 10. 双向广度搜索、A*算法，最小耗散优先. 第三阶段：前两个阶段是打基础，第三阶段是锻炼在比赛中可以快速建立模型、想新算法。这就要平时多做做综合的题型了。 1. 把oibh上的论文看看（大概几百篇的，我只看了一点点，呵呵）。 2. 平时扫扫zoj上的难题啦，别老做那些不用想的题.(中大acm的版主经常说我挑简单的来做:-P ) 3. 多参加网上的比赛，感受一下比赛的气氛，评估自己的实力. 4. 一道题不要过了就算，问一下人，有更好的算法也打一下。 5. 做过的题要记好 :-) （一） 不可能都完全记住那么多的算法. 常用算法,拿过来就可以写出来 不常用的,拿起书来,看10分钟,就能理解算法(因为以前记过). 对以前没有记过的算法,就不好说了,难的可能要研究好几天. 这样就可以了. 应该熟练掌握的常用的算法应该有: 各种排序算法（插入排序、冒泡排序、选择排序，快速排序，堆排序，归并排序） 线性表(一般的线性表,栈,队列)的插入和删除 二叉树的遍历（前序，中序，后序） 图的遍历（深度优先，广度优先） 二分法查找，排序二叉树，Hash查找（处理冲突的方法）。 （二） 分析一个东西,你可以用不同的眼光去看待,有很多时候,就跟自己生活一样,觉得小时候看待问题很幼稚,现在看问题全面了,而且方式不一样了,为什么,就是成长吧,就跟这个一样的,你对算法,比如写一个程序,可能直接写很简单,可是可以有一些有趣的方式,比如通过什么样来表达,怎么样更高效..等等吧 （三） 于大学里把基本的专业课学扎实就ok，如：数据结构，离散，操作系统等。碰到一些基本的数据结构和算法，如查找排序要根据原理马上能写出相应的代码就行了，我个人是这样理解的，对于更深层次的东西，也是建立在自己熟练的基础之上的吧 （四） 算法与数据结构考验试题精析》第2版 机械工业出版社 如果你想练习的话，这里有N多的题可以来练习，但实际中能用到的比较少，除非搞一些高端的玩意，不过平时也可以在自己的项目中结合使用 （五） 数据结构在平时可能用不上，但数据结构可以培养你程序时如果注意效率的意识，一个学过数据结构的人和一个没有学过数结构的人写出来的程序可能在效率上有差别。 （六） 搞ACM需要的掌握的算法.</description>
    </item>
    
    <item>
      <title>uva10177 (2/3/4)-D Sqr/Rects/Cubes/Boxes?</title>
      <link>http://liuxueyang.github.io/posts/uva10177-2-3-4-d-sqr-rects-cubes-boxes/</link>
      <pubDate>Mon, 05 Nov 2012 19:37:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva10177-2-3-4-d-sqr-rects-cubes-boxes/</guid>
      <description>Problem J (2/3/4)-D Sqr/Rects/Cubes/Boxes? Input: standard input Output: standard output Time Limit: 2 seconds You can see a (4x4) grid below. Can you tell me how many squares and rectangles are hidden there? You can assume that squares are not rectangles. Perhaps one can count it by hand but can you count it for a (100x100) grid or a (10000x10000) grid. Can you do it for higher dimensions? That is can you count how many cubes or boxes of different size are there in a (10x10x10) sized cube or how many hyper-cubes or hyper-boxes of different size are there in a four-dimensional (5x5x5x5) sized hypercube.</description>
    </item>
    
    <item>
      <title>uva 100 The 3n&#43;1 problem</title>
      <link>http://liuxueyang.github.io/posts/uva-100-the-3n&#43;1-problem/</link>
      <pubDate>Mon, 05 Nov 2012 10:48:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva-100-the-3n&#43;1-problem/</guid>
      <description>Problems in Computer Science are often classified as belonging to a certain class of problems (e.g., NP, Unsolvable, Recursive). In this problem you will be analyzing a property of an algorithm whose classification is not known for all possible inputs. Consider the following algorithm: 2. print n 3. if n = 1 then STOP 4. if n is odd then 5. else 6. GOTO 2 Given the input 22, the following sequence of numbers will be printed 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1 It is conjectured that the algorithm above will terminate (when a 1 is printed) for any integral input value.</description>
    </item>
    
    <item>
      <title>uva 10038 Jolly Jumpers</title>
      <link>http://liuxueyang.github.io/posts/uva-10038-jolly-jumpers/</link>
      <pubDate>Mon, 05 Nov 2012 10:42:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/uva-10038-jolly-jumpers/</guid>
      <description>A sequence of n &amp;gt; 0 integers is called a jolly jumper if the absolute values of the difference between successive elements take on all the values 1 through n-1. For instance, is a jolly jumper, because the absolutes differences are 3, 2, and 1 respectively. The definition implies that any sequence of a single integer is a jolly jumper. You are to write a program to determine whether or not each of a number of sequences is a jolly jumper.</description>
    </item>
    
    <item>
      <title>从今天起，好好写博客，好好总结</title>
      <link>http://liuxueyang.github.io/posts/%E4%BB%8E%E4%BB%8A%E5%A4%A9%E8%B5%B7%E5%A5%BD%E5%A5%BD%E5%86%99%E5%8D%9A%E5%AE%A2%E5%A5%BD%E5%A5%BD%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 05 Nov 2012 08:06:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/%E4%BB%8E%E4%BB%8A%E5%A4%A9%E8%B5%B7%E5%A5%BD%E5%A5%BD%E5%86%99%E5%8D%9A%E5%AE%A2%E5%A5%BD%E5%A5%BD%E6%80%BB%E7%BB%93/</guid>
      <description>每天找出一段时间总结一下自己今天学习过的知识，写博客是一个比较好的方法，坚持下去吧。 每天都要有一点进步 ！</description>
    </item>
    
  </channel>
</rss>