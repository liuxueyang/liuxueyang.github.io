<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LXY Site</title>
    <link>http://liuxueyang.github.io/</link>
    <description>Recent content on LXY Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright &amp;copy; 2018 (LXY). All Rights Reserved.</copyright>
    <lastBuildDate>Mon, 14 May 2018 11:26:10 +0800</lastBuildDate>
    
	<atom:link href="http://liuxueyang.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>读书笔记6「技术类」</title>
      <link>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B06%E6%8A%80%E6%9C%AF%E7%B1%BB/</link>
      <pubDate>Mon, 14 May 2018 11:26:10 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B06%E6%8A%80%E6%9C%AF%E7%B1%BB/</guid>
      <description>总结一下最近正在读的技术书吧。
C++大学教程（第九版） 这本快读完了，很基础，相当于把这门语言简单系统地复习了一遍。书里面的例子很详细，程序风格很清晰，只不过有些相对高级的知识点解释地不是特别透彻，还是需要配合别的书看。
C++ 程序设计语言（第 1 - 3 部分）（原书第 4 版） 这本书非常详细，毕竟 C++ 作者的作品。我只看了前面几章，语言细节真的是非常多，感觉读起来有点儿枯燥，不过有点儿意思。</description>
    </item>
    
    <item>
      <title>读书笔记5</title>
      <link>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B05/</link>
      <pubDate>Sun, 29 Apr 2018 10:45:16 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B05/</guid>
      <description>整理博客的时候，发现五年前竟然写过四篇读书笔记的博客来着，那就接着更一篇吧。
最近还是看了一些书，先把名字列出来吧，随后再更新（肚子饿了
《我是猫》——夏目漱石 很有趣的一本书。
《人间失格》——太宰治 一个人是如何走向毁灭的。
《巷说百物语》——京极夏彦 妖怪推理小说，第一次接触，有点儿意思。
《羔羊的盛宴》——米泽穗信 几个独立的故事，最后的一道菜阿姆斯丹羊有点儿黑暗系。</description>
    </item>
    
    <item>
      <title>整理博客</title>
      <link>http://liuxueyang.github.io/posts/%E6%95%B4%E7%90%86%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sun, 29 Apr 2018 10:25:30 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E6%95%B4%E7%90%86%E5%8D%9A%E5%AE%A2/</guid>
      <description>可算想起来整理一下博客了。本来想把以前的博客都删掉的，后来想想还是算了，毕竟还是不能忘记历史啊（2333 不过看几年前写的东西真是好羞耻啊。。
我还是决定迁移回 Hugo，由于博客一共有 400 多篇，hexo 生成速度实在是太慢。主要是三个需要搞：
 部分博客原先使用的是 Jekyll，这些需要把文件头的 layout: 条目删掉； 部分博客文件头的的 tags: 后面没有中括号 []，这些要把中括号加上； 选一个主题；  删除 layout: 很简单啦，sed 一把梭：</description>
    </item>
    
    <item>
      <title>2017 年结束了</title>
      <link>http://liuxueyang.github.io/posts/2017-12-23-summary-for-2017/</link>
      <pubDate>Sat, 23 Dec 2017 16:15:50 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2017-12-23-summary-for-2017/</guid>
      <description>2017 年这么快就过完了！实在是不知道怎么总结这一年。但还是记录一下吧！
 一月到五月，每天都在玩儿…… 每天是吃了睡，睡了玩，玩了睡。生活很规律。不过好像学了一点儿东西来着。 六、七月，生活还是挺平静，发现还是北方城市适合我，和在南方相比，舒服很多。 八、九月，噩梦。 十月到十二月，除去个人事情比较多，需要到处跑来跑去以外，过得还算平静。  总的来说，这一年真是大起大落，经历了一些之前想都没有想过的事情。。不过还是有很多开心的事情，比如补了好多番什么的。至于技术方面嘛，没有什么长进。。</description>
    </item>
    
    <item>
      <title>Clustering</title>
      <link>http://liuxueyang.github.io/posts/clustering/</link>
      <pubDate>Wed, 17 May 2017 15:33:49 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/clustering/</guid>
      <description>题目链接：pdf
题目给出一个些点的坐标，要求把这些点分成k组，求这k组中，组和组之间的点 的最小距离d。
这道题，好像可以用Kruskal？比如：按照边长度从小到大扫描， 同时记录当前有多少个连通分量（比如：每次Union之后连通分量 的个数减一），一直到只剩k个连通分量的时候，找到下一个可用 边（这个边的两个点在不同的连通分量中）的时候退出循环。这个 可用边就是答案。
因为要求最小的d嘛，所以就是贪心吧。
所以相对难实现的就是这些了：</description>
    </item>
    
    <item>
      <title>Building Roads to Connect Cities</title>
      <link>http://liuxueyang.github.io/posts/building-roads-to-connect-cities/</link>
      <pubDate>Wed, 17 May 2017 15:24:43 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/building-roads-to-connect-cities/</guid>
      <description>题目链接：pdf
给出平面上的一些点，任意两点之间可以相连，求最小生成树的总权值。
用Kruskal：把所有边按照边长度升序排序，循环所有边，每次加入一个边之前要判断这个边的两个点是不是在一个集合中，如果是那么跳过，如果不是那么把这个边的两个点合并到一个集合中。集合操作用带路径压缩的并查集。循环边的过程中累加边的权值。
// Tue May 16 17:02:04 2017 // Tue May 16 20:42:10 2017 #include &amp;lt;bits/stdc++.</description>
    </item>
    
    <item>
      <title>Detecting Anomalies in Currency Exchange Rates</title>
      <link>http://liuxueyang.github.io/posts/detecting-anomalies-in-currency-exchange-rates/</link>
      <pubDate>Wed, 17 May 2017 15:01:28 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/detecting-anomalies-in-currency-exchange-rates/</guid>
      <description>题目链接：pdf
题目给一个有向图，判定这个有向图是不是存在负环。
思路：
对这个图进行Bellman-Ford算法：不断对所有边进行松弛操作，循环进行V次，如果第V次仍然有边被松弛，那么说明存在负环。
相反，如果第V次没有边被松弛，那么说明没有负环。
在讨论Dijkstra算法的时候，最开始的V*E的算法其实就是Bellman-Ford算法。
初始化的时候把dist数组初始化为0。为什么呢？因为我们找的是负环，所以我们可以假设所有点到对源点的距离都是0。如果有负环，那么一定有负边，在第V次松弛所有边的时候，这个环中一定有一个点的最短路为负值。
// Mon May 15 14:13:09 CST 2017 // Mon May 15 15:09:41 CST 2017 // 一个有向图是不是存在负环 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; using namespace std; typedef pair&amp;lt;int, int&amp;gt; PII;	// from, to struct edge { int from; int to; int w; }; int negative_cycle(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;cost) { vector&amp;lt;int&amp;gt; dist(adj.</description>
    </item>
    
    <item>
      <title>Computing the Minimum Cost of a Flight</title>
      <link>http://liuxueyang.github.io/posts/computing-minimum-cost-of-a-flight/</link>
      <pubDate>Wed, 17 May 2017 08:37:01 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/computing-minimum-cost-of-a-flight/</guid>
      <description>题目链接：pdf
题目给出一个有向图，边的权值非负，求起点到终点的最短路。
用Dijkstra，基本思想是这样的：如果一个有向图权值非负，那么两点之间的最 短路有最优子结构的性质。两点之间的最短路上的任意两点之间的路径也是最优 的。
设S -&amp;gt; ... -&amp;gt; u -&amp;gt; .</description>
    </item>
    
    <item>
      <title>Checking whether a Graph is Bipartite</title>
      <link>http://liuxueyang.github.io/posts/checking-whether-a-graph-is-bipartite/</link>
      <pubDate>Wed, 17 May 2017 00:06:00 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/checking-whether-a-graph-is-bipartite/</guid>
      <description>题目链接：pdf
题目给一个无向图，判定这个图是否是二分图。
所谓二分图就是，用可以两种颜色给这个图的所有节点染色，并且满足相邻两个点颜色不同。
思路：
模拟染色过程，遍历所有点，如果这个点没有被染色，那么用BFS从这个点开始染色，当出现两个点颜色相同，说明这个图不是二分图。如果这个点已经被染色过，那么判断一下和这个点直接相连的点和它的颜色是否相同。
// Sun May 14 21:24:26 CST 2017 // Sun May 14 21:43:44 CST 2017 /* 二分图判定 */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; using std::vector; using std::queue; int bipartite(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj) { int result = 1; vector&amp;lt;int&amp;gt; color(adj.</description>
    </item>
    
    <item>
      <title>Computing the Minimum Number of Flight Segments</title>
      <link>http://liuxueyang.github.io/posts/computing-minimum-number-of-flight-segments/</link>
      <pubDate>Tue, 16 May 2017 23:57:39 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/computing-minimum-number-of-flight-segments/</guid>
      <description>题目链接：pdf
给一个无向图，一个起点，一个终点，求从起点到终点的路径的边数的最小值。
就是一遍BFS。
// Sun May 14 21:01:40 CST 2017 // Sun May 14 21:20:34 CST 2017 /* 最简单的BFS */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; using std::vector; using std::queue; int distance(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, int s, int t) { vector&amp;lt;int&amp;gt; dist(adj.</description>
    </item>
    
    <item>
      <title>Checking Whether Any Intersection in a City is Reachable from Any Other</title>
      <link>http://liuxueyang.github.io/posts/checking-whether-any-intersection-in-a-city-is-reachable-any-other/</link>
      <pubDate>Tue, 16 May 2017 23:24:52 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/checking-whether-any-intersection-in-a-city-is-reachable-any-other/</guid>
      <description>题目链接：pdf
题目给出一个有向图，要求输出图中强连通分量的个数。
我把这样的强连通分量叫做一个sink：不存在一个边从这个强连通分量中的任意 一个点连接到其它连通分量。也就是说如果把这个强连通分量缩成一个点的话， 它的出度为0。
我把和一个图的所有边都反向的图叫做反向图。貌似没有这样的术语。不知道 reverse graph应该怎么翻译。
思路大概是这样的：
 如果我们知道一个有向图的sink中的一个点，那么我们就可以求出这个强连 通分量的所有点，因为强连通分量中的任意两个点都相互可达。 如何求有相同的sink？我们知道反向图的强连通分量的个数和原图的强连通 分量一定是一样的，只是方向不同。并且，原图的sink对应于反向图的 source strong connected component，所以我们可以通过求反向图的source SCC，来求原图的sink。 求一个图的source SCC的思路和用DFS求拓扑排序的思路是一样的，我们可以 按照所有点的DFS回退的时刻降序排序，这样DFS最晚回退的点就是反向图的 source SCC，也就是原图的sink，我们可以第二次DFS得到这个sink中的所有 点并且从原图中去掉，继续求下一个sink，同时计数。  实现的过程中出现了非常难以发现的bug：一个vector，我在dfs里面加入元素， 然后在调用dfs的外层循环中循环这个vector。所以对于小数据并没有显现出错 误，对于10000的数据就出现段错误了。调试了很久，不过xhe也教了我好多调试 的方法，比如gdb，valgrind，libsigseg库，strace等。不过gdb调试的时候查 看STL数据结构里面的数据的时候还是有点小麻烦，这个时候IDE的调试工具就好 用很多了。</description>
    </item>
    
    <item>
      <title>Determining an Order of Courses</title>
      <link>http://liuxueyang.github.io/posts/determining-an-order-of-courses/</link>
      <pubDate>Tue, 16 May 2017 23:11:46 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/determining-an-order-of-courses/</guid>
      <description>题目链接：pdf
题目给出一个有向图，保证没有环，求这个有向图所有点的拓扑排序之后的序列， 只输出一种即可。
同样用DFS，求拓扑排序的过程一般是先求所有出度为0的点，然后删除这些点， 如此循环。DFS的过程中，回退过程最早的那个点一定是出度为0，所以就可以记 录下DFS的过程中每个点回退的时刻，然后按照时刻大小逆序排序就是拓扑顺序 了。
// Sat May 13 00:14:15 CST 2017 // Sat May 13 09:27:41 CST 2017 // 拓扑排序 #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; using namespace std; typedef pair&amp;lt;int, int&amp;gt; PII; vector&amp;lt;PII &amp;gt; post;	// index, clock_cnt int clock_cnt; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, vector&amp;lt;int&amp;gt; &amp;amp;used, int x) { used[x] = true; for (auto v : adj[x]) { if (!</description>
    </item>
    
    <item>
      <title>Checking Consistency of CS Curriculum</title>
      <link>http://liuxueyang.github.io/posts/checking-consistency-curriculum/</link>
      <pubDate>Tue, 16 May 2017 23:00:54 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/checking-consistency-curriculum/</guid>
      <description>题目链接：pdf
题目给一个有向图，判断是不是有环。我的方法是DFS，对于一个点，访问的过程中存在这三种情况：
 访问v的过程中，再次访问到了v这个点，说明存在环。 完成访问v后（DFS已经回退到v之后），以后再次访问到了v，这是没有问题 的，这种情况不能说明存在环。 v还没有访问过。  因此用三个不同的值来标记这三种情况就可以了。
// Fri May 12 22:50:22 CST 2017 // Fri May 12 23:50:02 CST 2017 // 判断一个有向图是不是有环。。。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; /* visit[i]的值有三种情况： 0:这个点没有访问过 1:这个点正在访问 2:这个点以及和它相连的点都已经访问过了 所以DFS的过程中，下一个点遇到了visit[e] == 1说明有环。 */ void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, vector&amp;lt;int&amp;gt; &amp;amp;visit, int x, bool &amp;amp;mark) { // cout &amp;lt;&amp;lt; &amp;quot;(&amp;quot; &amp;lt;&amp;lt; x + 1 &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;quot;)&amp;quot; &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;; visit[x] = 1; if (mark) return; for (auto e : adj[x]) { if (mark) return; else if (visit[e] == 1) { mark = true; return; } else if (!</description>
    </item>
    
    <item>
      <title>Adding Exits to a Maze</title>
      <link>http://liuxueyang.github.io/posts/adding-exits-to-maze/</link>
      <pubDate>Tue, 16 May 2017 22:52:55 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/adding-exits-to-maze/</guid>
      <description>题目链接：pdf
给出一个无向图，求连通分量的个数。对这个图做一遍DFS同时计数就好了。因 为我用邻接表表示图，所以还要记得孤点的情况，这个后来才发现。
// Begin: Fri May 12 19:52:46 CST 2017 // Finish: Fri May 12 20:16:44 CST 2017 // 求有几个连通块。。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, vector&amp;lt;bool&amp;gt; &amp;amp;visit, int x) { visit[x] = true; for (size_t i = 0; i &amp;lt; adj[x].</description>
    </item>
    
    <item>
      <title>Finding an Exit from a Maze</title>
      <link>http://liuxueyang.github.io/posts/finding-an-exit-from-maze/</link>
      <pubDate>Tue, 16 May 2017 22:28:46 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/finding-an-exit-from-maze/</guid>
      <description>题目链接：pdf
这道题目给出一个无向图，一个起点，一个终点，判断从起点是否能够到达终点。 显然就是从起点开始做一次DFS就可以了。
// 2017/05/12 19:35:19 // 判断两个点是否连通。。。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, int x, int y, vector&amp;lt;bool&amp;gt; &amp;amp;visit) { visit[x] = true; if (visit[y]) return; for (size_t i = 0; i &amp;lt; adj[x].</description>
    </item>
    
    <item>
      <title>Typeclass in Haskell筆記</title>
      <link>http://liuxueyang.github.io/posts/typeclass-in-haskell%E7%AD%86%E8%A8%98/</link>
      <pubDate>Wed, 19 Apr 2017 09:29:24 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/typeclass-in-haskell%E7%AD%86%E8%A8%98/</guid>
      <description>代數數據類型 這樣定義一個類型：
data Name = Name String String  Name既是類型名，也是一個Value Constructor，一個類型通常有多個Value Constructor，不過按照習慣，如果一個類型僅僅有一個Value Constructor，那麼它的名字通常和類型名同名。</description>
    </item>
    
    <item>
      <title>foldl和foldr的不同點</title>
      <link>http://liuxueyang.github.io/posts/foldr%E5%92%8Cfoldl%E5%87%BD%E6%95%B8%E8%BE%A8%E6%9E%90/</link>
      <pubDate>Tue, 18 Apr 2017 16:37:32 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/foldr%E5%92%8Cfoldl%E5%87%BD%E6%95%B8%E8%BE%A8%E6%9E%90/</guid>
      <description>foldl foldl這個函數的類型是：
(a -&amp;gt; b -&amp;gt; a) -&amp;gt; a -&amp;gt; [b] -&amp;gt; b  它接收一個函數、一個起始值、一個列表。它的作用相當于：</description>
    </item>
    
    <item>
      <title>Haskel筆記 10</title>
      <link>http://liuxueyang.github.io/posts/haskell-%E7%AC%94%E8%AE%B010/</link>
      <pubDate>Tue, 18 Apr 2017 15:03:07 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/haskell-%E7%AC%94%E8%AE%B010/</guid>
      <description>這是Functionally Solving Problems一章的筆記。
Reverse Polish notation calculator polish :: (Num a, Read a) =&amp;gt; String -&amp;gt; a polish = head .</description>
    </item>
    
    <item>
      <title>Haskell 笔记9</title>
      <link>http://liuxueyang.github.io/posts/haskell-%E7%AC%94%E8%AE%B09/</link>
      <pubDate>Thu, 13 Apr 2017 08:01:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/haskell-%E7%AC%94%E8%AE%B09/</guid>
      <description>这是第九章的笔记
Hello, world! Files and streams getContents：从标准输入读数据，返回IO Action，一直到文件末尾。
-- print lines whose length is less than 10 main = do lines &amp;lt;- getContents putStr .</description>
    </item>
    
    <item>
      <title>几种个人文档同步方案</title>
      <link>http://liuxueyang.github.io/posts/%E5%87%A0%E7%A7%8D%E4%B8%AA%E4%BA%BA%E6%96%87%E6%A1%A3%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/</link>
      <pubDate>Wed, 12 Apr 2017 15:16:05 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%87%A0%E7%A7%8D%E4%B8%AA%E4%BA%BA%E6%96%87%E6%A1%A3%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/</guid>
      <description>因为前几天（4月7日晚上）我的笔记本硬盘突然坏了，不能读盘了，造成了一些损失，之前做得Coursera上的三部分PL课的作业什么的都没有了，当初也没有多想就没有放到网盘里面同步，万万没想到硬盘会出问题。另外损失了大概两天的工作量，因为两天之前同步过一次Dropbox，因为需要频繁修改一些文件，Dropbox也就会频繁同步，我的电脑比较老了，一直开着Dropbox比较占内存和CPU，所以只是偶尔打开Dropbox。这也算是一个教训吧，所以在这里纪录一下。
最简单的就是用网盘了，比如Dropbox之类的。Slackware里面我用Dropbox和OneDrive。另外一种方法就是Gitlab或者Bitbucket的私有仓储，如果可以公开的话，可以直接放到Github的公开仓库，缺点就是需要频繁git add，git push什么的，这个时候Emacs的插件magit就很有用了。
以后尤其是手写的文档，一定要注意经常同步。不管是移动硬盘还是笔记本硬盘都不如网盘靠谱，至于数据的安全性嘛，都是一些笔记啊，程序啊之类的，好像也没有什么特别需要保护的。当然也可以把文件加密再上传到网盘。</description>
    </item>
    
    <item>
      <title>Haskell 笔记7</title>
      <link>http://liuxueyang.github.io/posts/haskell-%E7%AC%94%E8%AE%B07/</link>
      <pubDate>Wed, 12 Apr 2017 11:16:43 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/haskell-%E7%AC%94%E8%AE%B07/</guid>
      <description>这是一些阅读Learn You a Haskell for Great Good!的时候的笔记，之前用Latex写的，放在Dropbox里面，现在想把它们整理一下，放在博客里。这是第七章 Modules的笔记。
Loading modules 之前用TeXmacs虽然挺方便，但还是感觉有点不舒服。所以还是换回来吧。</description>
    </item>
    
    <item>
      <title>Haskell 笔记1</title>
      <link>http://liuxueyang.github.io/posts/haskell-%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Wed, 12 Apr 2017 10:35:34 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/haskell-%E7%AC%94%E8%AE%B01/</guid>
      <description>这是一些阅读Learn You a Haskell for Great Good!的时候的笔记，之前用Latex写的，放在Dropbox里面，现在想把它们整理一下，放在博客里。这是第二章 Starting Out的笔记。</description>
    </item>
    
    <item>
      <title>重新整理博客</title>
      <link>http://liuxueyang.github.io/posts/%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Mon, 10 Apr 2017 21:11:11 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86%E5%8D%9A%E5%AE%A2/</guid>
      <description>这么长时间过去了，好像很久不管这个博客了，差不多10个月过去了。是时候 把这些零散的东西整理一下了。争取把之前在别的地方写的东西都整理到这里 来。这样以后查看会方便很多吧！
主要是2014年的「博客园」上面的东西。找了一下现有的工具hexo-migrator-cnblogs发现早已经不维护了，现在也不能用了。所以写了一个简单的脚本来爬取我的博客：
# 2017/04/11 00:45:15 AM # Author: liuxueyang from bs4 import BeautifulSoup import requests import re import os.</description>
    </item>
    
    <item>
      <title>整理Bilibili安卓客户端缓存的视频</title>
      <link>http://liuxueyang.github.io/posts/%E6%95%B4%E7%90%86bilibili%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E7%9A%84%E8%A7%86%E9%A2%91/</link>
      <pubDate>Thu, 16 Mar 2017 22:30:48 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E6%95%B4%E7%90%86bilibili%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%93%E5%AD%98%E7%9A%84%E8%A7%86%E9%A2%91/</guid>
      <description>昨天晚上无意中看到了B站竟然有TOUCH。。完全没想到。所以我决定这次要把这部动画片全部下载下来，B站的视频质量看起来还不错。所以最简单的方法就是用安卓客户端缓存，然后在电脑上处理了。
其实之前我做过这件事情。当初是为了整理「暖暖日记」这部番，因为它每集仅仅有5分钟左右。每个视频只有一个文件，所以只需要找到所有视频然后读json文件找到视频名称，重命名就好了。
不过这次好像有点不同：每集一般有25分钟，缓存的是高清的。奇怪的是：即使是同一集，最开始我缓存的时候某一集是仅仅有一个mp4文件，然后我又实验了一次，发现它就变成了多个flv文件。。真是迷。。
处理也不难，如果是单个mp4文件直接重命名就好了。如果是多个flv文件，那么就需要先合并，然后再命名。
然后看了一下之前写的Perl程序，竟然，看不太懂了。。。T_T，然而还好，最后还是搞定了：
#!/usr/bin/perl # Date : 2017/03/16 19:14:35 # Finish: 2017/03/16 22:04:07 # NOTE: There MUST NOT be any non-ascii character in the path!</description>
    </item>
    
    <item>
      <title>复习C&#43;&#43;</title>
      <link>http://liuxueyang.github.io/posts/%E5%A4%8D%E4%B9%A0c/</link>
      <pubDate>Mon, 06 Mar 2017 23:24:07 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%A4%8D%E4%B9%A0c/</guid>
      <description>今天复习了一下C++。很久很久不碰这门语言，早上看到一段代码竟然感觉十分陌生。this，const pointer，引用之类的，有点忘了。其实也不是忘，就是感觉很陌生。比如this别的语言里面也有，只是不是指针，比较容易混淆。所以就大概查了一下C++ Primer，然后做了几道题目。放在这里。
题目一 给CMyString类写一个方法，使它能够支持赋值=操作。CMyString类已经给出。
#include &amp;lt;bits/stdc++.h&amp;gt; // implement a operator `=` on class CMyString using namespace std; class CMyString { public: CMyString(char * pData = NULL); CMyString(const CMyString &amp;amp; str); CMyString &amp;amp; operator =(const CMyString &amp;amp;); void print(); ~CMyString(void); private: char * m_pData; }; CMyString &amp;amp; CMyString::operator =(const CMyString &amp;amp; str) { // if (this == &amp;amp;str) return *this; // delete [] m_pData; // m_pData = NULL; // m_pData = new char[strlen(str.</description>
    </item>
    
    <item>
      <title>const member function in cpp</title>
      <link>http://liuxueyang.github.io/posts/const-member-function-in-cpp/</link>
      <pubDate>Mon, 06 Mar 2017 11:25:18 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/const-member-function-in-cpp/</guid>
      <description>默认情况下，this是一个const pointer to the nonconst version of the class type。比如有一个类A，那么在类里面，this的类型是A * const。因为不能把一个const对象的地址赋值给一个指向nonconst对象的指针，因此不能把this绑定到一个const对象上。这就导致，不能在const对象上调用一个nonconst member function。</description>
    </item>
    
    <item>
      <title>const pointer and pointer to const in Cpp</title>
      <link>http://liuxueyang.github.io/posts/const-pointer-and-pointer-to-const-in-cpp/</link>
      <pubDate>Mon, 06 Mar 2017 10:03:28 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/const-pointer-and-pointer-to-const-in-cpp/</guid>
      <description>中文翻译好像有常量指针和指针常量这两种说法。然而翻译过来让我更加费解。还是英文更加直白。
pointer to const const int b = 30; const int * bptr = &amp;amp;b;  bptr是一个指针，它指向的是一个类型为const int的对象。可以对bptr本身的内容（保存的地址）进行修改，但是不能对它指向的对象进行修改：</description>
    </item>
    
    <item>
      <title>Learn C&#43;&#43;</title>
      <link>http://liuxueyang.github.io/posts/learn-c/</link>
      <pubDate>Mon, 06 Mar 2017 09:56:32 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/learn-c/</guid>
      <description>我已经很久没有碰过C++这门语言了。重新看到C++程序的时候竟然有些陌生，很多语法都模糊了。所以我打算复习一下。</description>
    </item>
    
    <item>
      <title>学习org-mode</title>
      <link>http://liuxueyang.github.io/posts/%E5%AD%A6%E4%B9%A0org-mode/</link>
      <pubDate>Fri, 17 Feb 2017 14:09:39 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%AD%A6%E4%B9%A0org-mode/</guid>
      <description>今天我花了非常多的时间来学习org-mode，以前主要用它来记录每天的工作和学习日志，仅仅记录学习时间，几乎只用到了Clock in, Clock out之类的功能。这两天我发现我非常有必要对学过的东西做一个总结或者笔记，供以后查看，不然每次捡起很久之前看的东西还是有点困难。比如前几周学的PL课程，分三部分，学完第一部分觉得还可以，第二部分就比较难了，有些比较新的概念虽然没有完全理解，但是照葫芦画瓢做作业还是可以的。然后到了第三部分，也能够顺利把作业完成。然而到了最后的考试的时候考到第二部分的知识和概念，我竟然几乎完全记不起来了！说实话我还是挺惊讶的。所以我决定以后要经常作笔记，没有完全理解的概念和原理应该经常回顾，反复消化。所以我决定认真学习一下org-mode，用它来管理我的笔记。
本来我把笔记放在了 Dropbox 里面同步，后来想了想，我可能还是会拷贝一份在这里。以后查阅可能会方便很多。随后我会陆续把关于org-mode的笔记贴到下面。</description>
    </item>
    
    <item>
      <title>解决Konsole下Emacs org-mode快捷键不能使用的问题</title>
      <link>http://liuxueyang.github.io/posts/%E8%A7%A3%E5%86%B3kconsole%E4%B8%8Bemacs-org-mode%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 16 Feb 2017 20:11:10 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E8%A7%A3%E5%86%B3kconsole%E4%B8%8Bemacs-org-mode%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>如果想在终端里面使用Emacs的话，org-mode的有些快捷键可能会失效，比如M-LEFT，这个问题在这里有一个解决方案：Stack Overflow。然而我还是觉得挺麻烦的。
今天瞎玩的时候，一个非常偶然的机会，发现这个问题在KDE 4里面的原生的Konsole里面可以非常容易地被解决，只需要在Profile的设置里面的Keyboard标签里面的Key Bindings设置成Default (Xfree 4)，如图：
然后在org-mode里面就可以使用类似于M-LEFT之类的快捷键了。虽然GUI版本的Emacs可能会比较好看，不过还是终端下用Emacs更方便一点。另外，说到终端，以前经常用Terminator，不过在KDE 4里面其实原生的Konsole体验更好。顺便说一句：Slackware是我用过的最好用的发行版。KDE 4非常好用，当作主力机使用了两个多月了，没有出现过问题。</description>
    </item>
    
    <item>
      <title>对折腾编辑器配置的想法</title>
      <link>http://liuxueyang.github.io/posts/%E5%AF%B9%E6%8A%98%E8%85%BE%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%83%B3%E6%B3%95/</link>
      <pubDate>Tue, 14 Feb 2017 17:42:28 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%AF%B9%E6%8A%98%E8%85%BE%E7%BC%96%E8%BE%91%E5%99%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%83%B3%E6%B3%95/</guid>
      <description>我是先接触的Vim，用了很长一段时间，去年才开始使用Emacs。两种编辑器我觉得都挺不错，有的时候使用Emacs，有的时候使用Vim。当然，我也喜欢使用各种IDE。对于我来说，使用Vim和Emacs最大的乐趣就是可以定制各种各样奇怪的东西，虽然只是找别人开发分享的插件，但还是充满了乐趣。有的时候发现了某个非常厉害的插件会特别特别兴奋，这种情况遇到过两次：一次是abo-abo这个俄罗斯人开发的Emacs插件，一次是junegunn这个韩国人开发的Vim插件。
有机会也学着写写怎么写插件吧。配置编辑器其实挺花时间并且会上瘾，看来也没有什么意义，因为使用再好的编辑器，也没法阻止你写出丑陋的程序，也没法提高工作和学习效率。所以听过一句话，大意大概是这样：如果世界上的程序员能够把折腾编辑器的一般精力花在「更有价值」的事情上面的话，工作效率也许会提升不止一倍。
我配置过很多次Vim和Emacs，也因为这样或者那样的原因推翻过很多次。也使用过一些类似于Spacemacs的这种称为「世界级配置」的Emacs。然而我还是喜欢自己从头开始配置，因为别人的需求和我个人的需求不可能完全一致，使用别人的非常全面的配置反而会给我引来更多没法预料的问题，太臃肿的配置也让可移植性变差，比如版本问题，比如想要引入一个插件的时候，和原来的配置的冲突问题等等。
慢慢的我还是比较喜欢非常轻量级的、能够恰好满足我的个人需求的配置。我可以根据需要来手动加载当前需要的配置和插件，而不是当启动的时候一次性一次性全部加载进来。还有，如果不是特别需要，就不要加入新的插件，尽量保持配置文件的清晰和简洁，能够轻易移植。所以我打算慢慢地开始重新配置我的编辑器，要遵守的原则是：尽量保持简洁、轻量。不要强行解决「次要」问题，不适合使用编辑器做的事情就不要强行来实现。
其实，Emacs本身的初始配置对于一些场景来说，就已经够用了。
另外，这两种编辑器，如果非要做一个比较的话，我更喜欢Emacs，但是类似于临时修改个系统配置文件之类的事情，使用Vim快速解决。对于日常工作：写程序、记笔记等，我全部在Emacs里面做。
 唉……如果老是依赖某种东西的话，毕竟不算是真正的勇气。——风间彻
 2016/02/17 01:16:57AM 更新 昨晚又折腾了很久的Emacs，该完成的任务又没有完成。其实仔细想想，折腾编辑器确实耽误了我非常非常多的时间，带来的回报却很少。所以决定不再自己折腾和配置编辑器了。刚才又适用了一下 Spacemacs，其实感觉还不错。至于到底是不是完全适合自己，倒不是最重要的，重要的是能用，能够比较方便地实现日常的编辑工作，如果有些小的瑕疵或者违反我个人的习惯的话，那就慢慢适应吧。我不得不承认，我自己再怎么配置也不可能有 Spacemacs 的配置全面可靠。所以我决定以后就用 Spacemacs 了。花很多时间折腾编辑器甚至舍本逐末对目前的我来说是一件非常不明智的事情。</description>
    </item>
    
    <item>
      <title>开始使用Raspbian</title>
      <link>http://liuxueyang.github.io/posts/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8raspbian/</link>
      <pubDate>Tue, 14 Feb 2017 15:30:46 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8raspbian/</guid>
      <description>这两天折腾了一下树莓派，因为我的树莓派里面的Arch Linux不能启动了。开机的时候，ACT LED并没有闪烁，查了一下wiki才知道这表示pi没有读取SD卡。试了很多次，开始以为接触问题，擦了擦卡然后开机的时候用力按着，还是不行。在IRC里问了一下，后来猜测可能是/boot分区出问题了，或者firmware在系统更新的时候出问题了，或者是pi的硬件的问题，或者是SD卡的问题。
之前的手机里还有一个SD卡，只有2GB。然后备份数据之后，刷了Raspbian Lite，插入树莓派顺利进入系统了。能正常用。所以只能是SD卡里的系统问题了。
花了点时间把树莓派里面的数据备份了一下，然后刷了Raspbian jessie，稍微配置了一下。意外地好用。我还是挺满意这个系统的。如果只是在树莓派里写写程序的话，用起来还是挺舒服的。本机用VNC连接到树莓派的桌面，然后就可以像另外一台配置比较低的电脑一样使用了。以前我以为VNC什么的速度可能很慢，画面也不清晰，这两天一直在用，发现其实体验非常好。可以根据主机屏幕的大小来设置树莓派的分辨率，我记得好像是设置一下/boot/config.txt文件里面的framebuffer_width和framebuffer_height这两个变量就好了。然后在VNC的设置里面再设置成同样的分辨率。完美。
在树莓派里写程序的时候，好像除了一些非常轻量级的IDE能用之外，别的只能用Emacs或者Vim了。JetBrains家的IDE估计是没法用。:P</description>
    </item>
    
    <item>
      <title>Use Hexo</title>
      <link>http://liuxueyang.github.io/posts/use-hexo/</link>
      <pubDate>Tue, 14 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/use-hexo/</guid>
      <description>Welcome to Hexo! This is your very first post. Check documentation for more info.</description>
    </item>
    
    <item>
      <title>折腾Emacs和Fcitx的兼容问题</title>
      <link>http://liuxueyang.github.io/posts/2017-01-02-emacs-fcitx-thought/</link>
      <pubDate>Mon, 02 Jan 2017 11:21:37 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2017-01-02-emacs-fcitx-thought/</guid>
      <description>在Emacs时而不能使用Fcitx中文输入法。
我只是把这件事记录在这里，我并没有搞定这个问题。
 把下面的程序放到~/.xprofile文件里。未果。  export LANG=zh_CN.UTF8 export LC_CTYPE=en_US.UTF-8 export XMODIFIERS=&#39;@im=fcitx&#39; export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export GTK3_IM_MODULE=fcitx   放到~/.</description>
    </item>
    
    <item>
      <title>Slackware Dolphin中文文件夹显示乱码</title>
      <link>http://liuxueyang.github.io/posts/2016-12-30-slackware-dolphin-chinese/</link>
      <pubDate>Fri, 30 Dec 2016 07:33:01 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2016-12-30-slackware-dolphin-chinese/</guid>
      <description>在Slackware里面的KDE 4的默认文件夹管理器Dolphin里面，中文文件夹的名称显示是一堆问号。这个问题是我前两天遇到的，还是记在这里吧。问题描述如下。
Dolphin的侧边栏可以显示中文，如图：
如果我想要建立一个中文名称的文件夹的话：
就会成为这样：
我的locale是这样的：
我的解决方法是这样的：
在/etc/profile.d/lang.sh这个文件里面，有这样一句话：
# en_US is the Slackware default locale: export LANG=en_US  把它改成这样就可以了：</description>
    </item>
    
    <item>
      <title>开始使用Slackware</title>
      <link>http://liuxueyang.github.io/posts/2016-12-29-start-to-use-slackware/</link>
      <pubDate>Thu, 29 Dec 2016 22:33:15 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2016-12-29-start-to-use-slackware/</guid>
      <description>前两天，我在整理我的硬盘，顺便整理了一下我的openSUSE Leap里面的资料，同样也是十分的混乱。花了很长时间整理，全部移动到移动硬盘里。过程中发现openSUSE Leap的官方源连不上了，正常情况下官方源应该会选择国内速度最快的镜像的，然而有的时候就是蜜汁连不上……去年我也遇到过这种情况，然后我就放弃这个发行版了（后来又回来了……）。这次我决定替换掉openSUSE Leap 42.2，理由：
 官方源有的时候连不上； 早上开机，一直使用到晚上，有的时候即使使用Xfce4也会变得卡； Plasma 5的BUG太多，出问题的次数太多； 跨版本升级的时候有点麻烦； 其实忍它很久了。  好吧，其实都是借口，我只是想试一试Slackware了。看了一下官方的文档，地址在这里：Document，这个文档挺不错的。粗略看完了。安装过程原来挺简单的，我还以为有多复杂。其中有一点挺人性化：安装过程中会提示你要不要制作一个启动盘，这样在系统出现问题无法启动的时候，利用启动盘就可以直接启动系统，然后我就制作了一个。没想到，很快我就用上了。Slackware使用的是LILO，而不是GRUB，Slackware不是那么激进，开发过程比较慢也比较保守，这一点我还是比较喜欢的，不用经常更新。是这样的：安装完之后，我发现LILO的第一个启动项是Windows而不是Slackware，我想把第一个换成Linux。然后在LILO的高级设置里面只选择了Windows，然后保存重启，发现启动项里只有Windows了……原来高级设置里的启动项目需要自己一个一个添加。没法进Slackware了，所以之前的启动盘就有用了，顺利进入Slackware，重新设置LILO，顺利解决。</description>
    </item>
    
    <item>
      <title>使用Time Machine备份系统时磁盘空间不足的问题</title>
      <link>http://liuxueyang.github.io/posts/2016-12-05-timemachine-macos/</link>
      <pubDate>Mon, 26 Dec 2016 17:41:06 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2016-12-05-timemachine-macos/</guid>
      <description>Time Machine这个功能我只在当初刚买了MacBook Air之后不久才用过一次。后来就再也没有管它。当初在移动硬盘里面分出125GB的空间作为Time Machine的分区。那次备份的时间是2014年8月24日。距离现在已经两年多了。
之前我用这个Time Machine把电脑恢复到了2014年8月24日的状态。挺好用的。没有遇到问题。方法如下：
1. 关机，插入移动硬盘 2. 在电脑开机的时候，按住cmd + R键 3.</description>
    </item>
    
    <item>
      <title>做事情分清主次</title>
      <link>http://liuxueyang.github.io/posts/2016-12-25-stop-organize/</link>
      <pubDate>Sun, 25 Dec 2016 19:58:52 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2016-12-25-stop-organize/</guid>
      <description>我花了很长时间在整理移动硬盘里面的文件上面，并且发现工作量十分巨大。一直到晚上，好像还有很多，没办法估计。因为太乱了。在这件优先级不是特别高的事情上，我似乎花了太多的时间，这是不值得的。
所以我打算目前先放弃着手这件事情，我打算平时每天拿出二十分钟来整理硬盘，这样应该会让我觉得工作量小一点，因为这件事情并不是特别紧急，所以可以慢慢来。只是需要坚持下去就是了。
我本来还想折腾一下Slackware这个Linux发行版，不知道为什么，每隔一段时间，总想折腾一点什么，似乎有一点强迫症。刚才我的老电脑上面的Windows 10又出现了奇怪的问题：不能关机。命名按下了关机的按钮，屏幕也黑了。过了一会儿还没有完全关闭，再按一下回车键，就有回到了登录界面。在登录界面直接关机，也是一样的效果。只能强制关机。这种情况对于我这种有点「强迫症」的人来说有点难受啊。不过，还是凑合一下吧，不能完全取代掉Windows，不得不承认，有时候它还是会给我帮上一些忙的。
所以目前最重要的事情就是：学习Android开发，上架一个APP。至于这个APP是什么，我已经有了几个想法，写在了笔记里面，就不在这里写了，随后可能会写一些博客来纪录我遇到的问题或者解决方法等。
说来有点惭愧，我以前，是非常地讨厌Java和Android，要说原因，我也说不上来，反正就是不想看一行的Java程序。现在想想，当初为什么会那样呢？可能还是因为见得少吧，实践得少，经验少，所以才会像个井底之蛙。类似的情况还有，以前特别讨厌Windows、特别喜欢Linux、特别喜欢使用Vim编辑器、特别讨厌使用Emacs编辑器、特别讨厌使用IDE等等。这些都是我以前有过的想法。而现在，我使用Vim也使用Emacs，同时也会使用IDE。对于开发工作，如果有条件能够方便地使用IDE的话，我就会使用IDE；对于日常学习的时候写的小程序或者做日常的笔记，我会使用Emacs；如果要在终端里面临时修改配置文件的话，我会使用Vim；虽然Windows有的时候会出现一些小问题，但是我平时还是会使用它，我甚至还尝试着学过一些C#语言。虽然以前经常性地忍不住折腾不同发行版的Linux，现在也会理性地克制住，稳定下来。所以，人啊，还是要保持一种比较开放的心态，活得也舒服一点。逛一些技术向的论坛的时候，经常看到一些和我以前的想法类似的人，搞得气氛有点奇怪，所以慢慢我也不喜欢逛论坛或者不喜欢看类似类型的帖子了。
好像跑题了。做事情还是应该至少有一个计划，先完成每天的重要的目标，次要或者不重要的等到最后做或者不做。这样工作效率会高一点。而不是忙了很久，却收效甚微。所以还是要克制住自己「跑题」的欲望，把大多数时间投入到重要的事情上面。
「写这篇博客用时36分钟。」</description>
    </item>
    
    <item>
      <title>养成整理的习惯</title>
      <link>http://liuxueyang.github.io/posts/2016-12-23-organize-computer/</link>
      <pubDate>Fri, 23 Dec 2016 20:24:14 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2016-12-23-organize-computer/</guid>
      <description>我的电脑空间不够用了。整理的时候我才发现，我的目录是多么混乱。很多可能用到的、再也用不到的、以前用过的、很久都没有用的各种各样的文档，塞在各种各样的目录下面。有一些照片，很久没有看过，也没有想过要备份一下。很多软件，即使一年也没有用过，也还是在那里。不知道何年何月才有机会打开。很多截图，用过了即使知道以后再也不用了也没想过要删除。网络上下载的图片，没有收藏价值的也从来没有想过要删除。网络上下载的各种文档，没有想过要按照主题分类管理一下。写过的测试程序，有的时候懒得同步到Gitlab、Github或者各种网盘上，就临时放在了本地，从来没有整理过。
当然，移动硬盘里的情况更是惨不忍睹。很多备份，没有分类，还有很多奇怪的重复。
在电脑里面，之前因为想要一个新的环境，就新建了几个用户。现在看来是错误的选择。这更加重了电脑的混乱。我的几个旧电脑都是这样的情况，尤其是Linux系统，更是混乱。
是时候花一些时间来开始整理了。我的想法是这样的：
 把一些不大的文档，全部分类，保存到DropBox里面。最好建立一个索引。  按照使用频率把文档分类，分别放到多个帐号里面，好处是，如果更换平台或者系统的话，我只需要同步最常用的那个帐号里面的文件就好了，同步速度会快一些。其实，DropBox有选择性同步的功能，可是我还是想要保持目录结构的尽量清晰和简洁，这就需要分类，目录尽量少。  把所有的程序相关的东西（别人的程序、自己写的程序），同步到Github、GitLab里面。 多个系统里面的目录结构尽量相同，如果有同步的必要就要同步。并且如果有更新的话，要及时检查更改是不是更新到了网盘里。尽量少出现同步冲突的情况。比如这两天我发现macOS里的DropBox很奇怪地没有同步一个文件，导致出现了冲突，合并两个文件并不是特别好合并（它是特定格式的）。 每个电脑或者系统，可以建立多个用户，但是只有一个主用户，其它用户仅仅在极特殊的情况下使用。  事实上，我每天使用的东西，或者我这一生能够使用的东西是非常有限的。只是我太贪婪，占有了很多根本用不到的东西，除了心理安慰，别的没有什么用。所以，养成每天都整理的习惯，更有条理一点。其实对于我来说啊，还是不要太贪心，能够做好一些事情就已经很不错了。</description>
    </item>
    
    <item>
      <title>个人努力</title>
      <link>http://liuxueyang.github.io/posts/2016-12-23-life-labixiaoxin/</link>
      <pubDate>Fri, 23 Dec 2016 17:59:39 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2016-12-23-life-labixiaoxin/</guid>
      <description>人啊，还是依靠个人努力。至于是不是要考虑到历史的进程，对于我来说，倒不是那么重要，毕竟，「我」只有一个，在另外的历史进程里的「我」是什么样子，我不知道。所以我还是过好自己的生活就可以了。
最近，「蜡笔小新」的视频在哔哩哔哩上因为版权原因全部被删除了，唯一的乐趣没有了。不过还好，有良心UP主在直播间里24小时播放蜡笔小新。缺点是不能自己选集看了，优点是至少还有的看。</description>
    </item>
    
    <item>
      <title>第一次使用Jekyll来搭建博客</title>
      <link>http://liuxueyang.github.io/posts/2016-12-23-first-jekyll/</link>
      <pubDate>Fri, 23 Dec 2016 17:39:27 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2016-12-23-first-jekyll/</guid>
      <description>第一次使用Jekyll来搭建静态博客。这里有一份关于Markdown语法的文档：Markdown，挺不错的。
如果想要在Jekyll的Markdown里面使用Github图标的形式插入Github的项目地址，可以这样：
{% highlight markdown %} {\% include icon-github.html username=&amp;ldquo;username&amp;rdquo; %} / repository-name {% endhighlight %}</description>
    </item>
    
    <item>
      <title>2016</title>
      <link>http://liuxueyang.github.io/posts/2016/</link>
      <pubDate>Fri, 07 Oct 2016 22:12:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2016/</guid>
      <description>玩过 游戏 i wanna 之前看散人优瓦夏玩i wanna游戏挺欢乐。可惜我手残，玩不了这种游戏。最近发现，也许这种游戏是一种比较好的培养耐心的方式吧？今天下午玩了一个多小时，最后手指酸疼。比较神奇的是，我竟然还感觉挺有意思的。过程中完全没想过一定要通关怎么怎么样，只是沉浸在其中，明显感觉到一次比一次好。从开始玩到某一关，总共死了500+次。后来又从开始玩了一遍，到同样的关卡只死了80+次。进步这么明显，我还是蛮惊讶的。当我开始怀疑人生的时候，不妨玩玩i wanna吧。;-)
Besiege 这个游戏在Steam上买了，可惜没怎么玩，看到B站上的大神们玩出各种花样，看着比较过瘾，然而自己还是算了吧。</description>
    </item>
    
    <item>
      <title>Spoj, math: CPCRC1C - Sum of Digits</title>
      <link>http://liuxueyang.github.io/posts/spoj-math-cpcrc1c-sum-of-digits/</link>
      <pubDate>Sun, 14 Aug 2016 21:11:34 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-math-cpcrc1c-sum-of-digits/</guid>
      <description>Primary Problem 题目大意：
给两个数字a和b，求从a到b所有数字的每一位的和。比如1到3就是：1+2+3=6, 10到12 就是：1+0 + 1+1 + 1+2=6，范围是10^9  为了表示方便，用[n]表示从1到n的所有数字的每一位的和。要求从a到b，只需要计算[b] - [a]就可以。</description>
    </item>
    
    <item>
      <title>Spoj: ANARC09A - Seinfeld</title>
      <link>http://liuxueyang.github.io/posts/spoj-anarc09a-seinfeld/</link>
      <pubDate>Sun, 14 Aug 2016 15:59:14 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-anarc09a-seinfeld/</guid>
      <description>题目意思：
一个字符串由`{`和`}`组成，长度最多位2000，求最少修改多少次可以使得这个字符串合法。  如果把合法的字符串都消去的话，那么最后留下不合法的括号，一定是这样的}*{*其中 *代表0个或者多个。题目规定字符串长度是偶数，所以不合法的括号的长度也一定是偶数， 假设它是len。
1. 如果只有左括号或者右括号，那么答案是`len/2`； 2. 如果左右括号都有，那么答案是左括号的个数/2 + 右括号的个数 / 2，如果左括号 或者右括号的个数是奇数，那么答案增加一。比如这个例子：`}}}{{{`  所以复杂度是O(n)。</description>
    </item>
    
    <item>
      <title>Spoj, dynamic-programming: ASSIGN - Assignments</title>
      <link>http://liuxueyang.github.io/posts/spoj-dynamic-programming-assign-assignments/</link>
      <pubDate>Sun, 14 Aug 2016 15:08:27 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-dynamic-programming-assign-assignments/</guid>
      <description>题目意思：
有n个学生和n个任务，每个学生有喜欢的任务，输入一个矩阵，第i行第j列表示第i个 学生喜欢第j个任务。把任务分配给所有学生，使得每个学生得到的任务都是他喜欢的。 输出有多少种分配方法。n的最大值是20。  用一个数字的一个位表示这个任务是否已经被分配，如果任务全部被分配，那么这个数字就 是(1&amp;lt;&amp;lt;n)-1。可以想到这样的递归方法：solve(i,mask) 表示对i..n这些人分配任务的 方法的数目，mask代表此时对1..i-1这些人已经分配了任务，也就是说mask的二进制表示里 面有i-1个1。对当前的人，如果他喜欢第j个任务，并且mask的第j位是0，那么就可以把这 个任务分配给他，继续考虑下一个人。</description>
    </item>
    
    <item>
      <title>Spoj, dynamic-programming: AIBOHP - Aibohphobia</title>
      <link>http://liuxueyang.github.io/posts/spoj-dynamic-programming-aibohp-aibohphobia/</link>
      <pubDate>Fri, 12 Aug 2016 21:36:32 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-dynamic-programming-aibohp-aibohphobia/</guid>
      <description>给一个字符串，求最少插入多少个字符，可以使得这个字符串是回文的。
可以这样想：我们假设它已经是回文的，那么把这个字符串逆序，如果它是回文的，那么对 应的每个字符应该相等。可以它不是回文的，那么就需要尽量少地加一些字符，加多少呢？ 那么需要知道当前的最长连续公共子序列的长度len，把不相等的那些字符串加进去就成为 了回文的。加进去的字符的最少个数 = 字符串长度 - 原先的字符串和它的逆序字符串的最 长连续公共子序列的长度。</description>
    </item>
    
    <item>
      <title>Spoj, dynamic-programming: BYTESM2 - Philosophers Stone</title>
      <link>http://liuxueyang.github.io/posts/spoj-dynamic-programming-bytesm2-philosophers-stone/</link>
      <pubDate>Fri, 12 Aug 2016 21:32:26 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-dynamic-programming-bytesm2-philosophers-stone/</guid>
      <description>在矩阵里面捡石头，求最大值。和常见的直角三角形那样的问题是一样的。
/* * ===================================================================================== * * Filename: main.cpp * * Description: http://www.</description>
    </item>
    
    <item>
      <title>Dynamic-programming: Spoj DIEHARD - DIE HARD</title>
      <link>http://liuxueyang.github.io/posts/dynamic-programming-spoj-diehard-die-hard/</link>
      <pubDate>Fri, 12 Aug 2016 21:14:23 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/dynamic-programming-spoj-diehard-die-hard/</guid>
      <description>题目很好理解：
有三个区域，你在每个区域里面只能停留一秒，每个区域会对你的两个指标h和a增加或者减少： 区域A：h += 3, a += 2 区域B：h -= 5, a -= 10 区域C：h -= 20, a+= 5 你在任意区域最多只能停留1秒，下一秒必须移动到其它两个区域中的一个，也就是说 你不能一直呆在一个区域。在任意时刻，如果你的两个指标其中的任意一个&amp;lt;=0，那么 游戏结束，输出你一共在游戏里面停留了多长时间。  如果不加什么思考，那么容易想到，直接递归就可以了，递归函数有三个参数：当前的h值， 当前的a值，当前的位置。为了不重复求解，用一个三位数组存储这一步的结果。</description>
    </item>
    
    <item>
      <title>show and hide dot files in Finder of OS X El Capitan</title>
      <link>http://liuxueyang.github.io/posts/show-and-hide-dot-files-in-finder-of-os-x-el-capitan/</link>
      <pubDate>Thu, 04 Aug 2016 10:39:01 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/show-and-hide-dot-files-in-finder-of-os-x-el-capitan/</guid>
      <description>Fish Run the following code in fish shell. Then it works as a charm.</description>
    </item>
    
    <item>
      <title>Text Adventure Game in Land of Lisp</title>
      <link>http://liuxueyang.github.io/posts/text-adventure-game-in-land-of-lisp/</link>
      <pubDate>Mon, 01 Aug 2016 23:19:46 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/text-adventure-game-in-land-of-lisp/</guid>
      <description>Land of LiSP 这本书里面的第五章和第六章构建了一个字符冒险游戏，游戏截图如下：
;; 2016.07.30 23:22:41 PM ;; Sabastian ;; building a text adventure game engine ;; ==================== ;; location (defparameter *nodes* &#39;((living-room (you are in the living-room.</description>
    </item>
    
    <item>
      <title>2016/07/31 17:43:50 PM 杂事</title>
      <link>http://liuxueyang.github.io/posts/2016-07-31-17-43-50-pm-%E6%9D%82%E4%BA%8B/</link>
      <pubDate>Sun, 31 Jul 2016 17:44:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2016-07-31-17-43-50-pm-%E6%9D%82%E4%BA%8B/</guid>
      <description>这两天开始重新读 Land of LISP 这本书，之前只读到了第六章，这次重头开始复习一遍， 发现这本书写的挺有意思，循序渐进，并且也特别有趣。目前的节奏是每天读一章到两章的 样子。我买的是原版的英文书，读书的过程中体会到，纸质书的质量对阅读心情特别重要！ 好的书就让人有阅读欲望，甚至愿意经常抱着它读，看完也会收藏起来，国外的书那么贵其 实也有道理，书的质量好啊……然而国内的很多引进的计算机的书虽然卖的便宜，然而质量并 不能和人家比。。</description>
    </item>
    
    <item>
      <title>spoj, segment tree: KGSS - Maximum Sum</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-kgss-maximum-sum/</link>
      <pubDate>Tue, 26 Jul 2016 08:58:52 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-kgss-maximum-sum/</guid>
      <description>Problem Link
每个节点保存三个值：区间的最大值，区间的第二大值，区间的最大的两个数的和
平常的区间的点更新和区间查询
// 2016/07/25 19:29:33 PM // Sabastian #include &amp;lt;iostream&amp;gt; #include &amp;lt;math.</description>
    </item>
    
    <item>
      <title>spoj, segment tree: HORRIBLE - Horrible Queries</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-horrible-horrible-queries/</link>
      <pubDate>Mon, 25 Jul 2016 23:25:39 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-horrible-horrible-queries/</guid>
      <description>Problem Link
平常的线段树区间更新和区间查询
// 2016/07/22 14:38:03 PM // Sabastian #include &amp;lt;iostream&amp;gt; #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>spoj, segment tree: GSS4 - Can you answer these queries IV</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-gss4-can-you-answer-these-queries-iv/</link>
      <pubDate>Mon, 25 Jul 2016 23:19:05 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-gss4-can-you-answer-these-queries-iv/</guid>
      <description>Problem Link
这道题目并没有用到懒惰更新，只是有一个优化：当一个区间的和等于区间长度的时候，那么他就没有必要更新了。
平常的线段树区间更新和区间查询
另外注意，题目中并没有说X和Y的大小关系。。
// 2016/07/22 19:58:12 PM // Sabastian #include &amp;lt;iostream&amp;gt; #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>spoj, segment tree: GSS3 - Can you answer these queries III</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-gss3-can-you-answer-these-queries-iii/</link>
      <pubDate>Mon, 25 Jul 2016 23:16:44 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-gss3-can-you-answer-these-queries-iii/</guid>
      <description>Problem Link
similar to GSS1 in addition to point update in segment tree.</description>
    </item>
    
    <item>
      <title>spoj, segment tree: GSS1 - Can you answer these queries I</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-gss1-can-you-answer-these-queries-i/</link>
      <pubDate>Mon, 25 Jul 2016 23:07:09 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-gss1-can-you-answer-these-queries-i/</guid>
      <description>Problem Link
max sum of a sequence can be from one of the three:</description>
    </item>
    
    <item>
      <title>spoj, segment tree: BRCKTS - Brackets</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-brckts-brackets/</link>
      <pubDate>Mon, 25 Jul 2016 22:56:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-brckts-brackets/</guid>
      <description>Problem Link
开始没有读懂题目，合法括号的意思其实就是常识情况下的括号合法：整个序列的左括号数目和右括号的数目相同，但是也不能出现这样的：)))(((，所以还要保证在任意一点，左括号的数目大于等于右括号的数目。
这就需要，在序列里面任意一点，左边的不匹配的左括号的数目一定等于右边的不匹配右括号的数目。
平常的线段树的点更新和区间查询
#include &amp;lt;iostream&amp;gt; using namespace std; struct SegmentTreeNode { int unmatchedLeft, unmatchedRight; void assignLeaf(char value) { if (value == &#39;(&#39;) { unmatchedLeft = 1; unmatchedRight = 0; } else { unmatchedLeft = 0; unmatchedRight = 1; } } void merge(SegmentTreeNode &amp;amp;left, SegmentTreeNode &amp;amp;right) { int L_unl = left.</description>
    </item>
    
    <item>
      <title>spoj, segment tree: AKVQLD03 - How to Handle the Fans</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-akvqld03-how-to-handle-the-fans/</link>
      <pubDate>Mon, 25 Jul 2016 22:49:37 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-akvqld03-how-to-handle-the-fans/</guid>
      <description>Problem Link
平常的线段树点更新和区间查询
#include &amp;lt;iostream&amp;gt; #include &amp;lt;string.h&amp;gt; using namespace std; struct SegmentTreeNode { // fields on the node long long sum; void assignLeaf(int value) { sum = value; } void merge(SegmentTreeNode &amp;amp;left, SegmentTreeNode &amp;amp;right) { sum = left.</description>
    </item>
    
    <item>
      <title>segment tree, lazy propagation, codechef: Flipping Coins</title>
      <link>http://liuxueyang.github.io/posts/codechef-flipping-coins/</link>
      <pubDate>Mon, 25 Jul 2016 22:40:35 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codechef-flipping-coins/</guid>
      <description>Problem Link
平常的线段树区间更新、区间查询加上懒惰更新
// 2016/07/24 22:01:19 PM // Sabastian #include &amp;lt;iostream&amp;gt; #include &amp;lt;math.</description>
    </item>
    
    <item>
      <title>iTerm2 查看图片</title>
      <link>http://liuxueyang.github.io/posts/iterm2-%E6%9F%A5%E7%9C%8B%E5%9B%BE%E7%89%87/</link>
      <pubDate>Mon, 11 Jul 2016 18:14:26 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/iterm2-%E6%9F%A5%E7%9C%8B%E5%9B%BE%E7%89%87/</guid>
      <description>首先是，OS X El Capitan的几个截图技巧：
 ⌘ + ⇪ + 3 ：全屏截图，并且把截图保存在桌面。 ⌘ + ⇪ + 4 ：区域截图，可以自由拖动大小，松开触摸板自动保存截图到桌面。 ⌘ + ⇪ + 4 ，然后，单击空格键，可以选定窗口截图。（这么好用的快捷键我很长时间都不知道……） ⌘ + ⇪ + 4，然后用触摸板选定一个矩形区域，然后，按住空格键，再拖动鼠标，就可以发现，矩形区域跟随鼠标移动，但是大小不变。 ⌘ + ⇪ + 4，选定一个矩形区域，然后，按住 ⇪ 键，然后鼠标如果在左右方向移动，那么你可以发现矩形区域高度被锁定；如果在按住 ⇪ 键的同时，鼠标在上下方向移动，那么左右方向被锁定。 ⌘ + ⇪ + 4，选定一个矩形区域，按住 ⇪ 和 ⌥ 键，再拖动鼠标，可以发现，矩形区域在锁定一个方向的基础上，在水平或者数值方向上呈对称性变化。  在终端里面的时候，有时需要查看一下图片到底是不是想要的那一张，然而并不想在打开finder看，所以，这个功能就比较有用了，如图：</description>
    </item>
    
    <item>
      <title>POJ3320 Jessica&#39;s Reading Problem</title>
      <link>http://liuxueyang.github.io/posts/poj3320-jessica-s-reading-problem/</link>
      <pubDate>Sun, 03 Jul 2016 19:00:24 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj3320-jessica-s-reading-problem/</guid>
      <description>Problem Jessica&amp;rsquo;s Reading Problem
Solution 方法和Subsequence一样，只是增加一个计数的步骤。
Code C++ #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; using namespace std; const int MAX_N = 100 * 10000 + 1; int a[MAX_N], n; set&amp;lt;int&amp;gt; idea; map&amp;lt;int, int&amp;gt; num_idea; void solve() { idea.</description>
    </item>
    
    <item>
      <title>Poj3061 Subsequence</title>
      <link>http://liuxueyang.github.io/posts/poj3061-subsequence/</link>
      <pubDate>Sat, 02 Jul 2016 16:58:15 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj3061-subsequence/</guid>
      <description>Problem Subsequence
Solution 方法一：O(nlogn)
1. 计算前序和 2. 定起点，二分找不小于S的最小的连续区间和  方法二：O(n)</description>
    </item>
    
    <item>
      <title>Educational Codeforces Round 10. D. Nested Segments: c&#43;&#43;, perl and common lisp implementation, Segment Tree</title>
      <link>http://liuxueyang.github.io/posts/educational-codeforces-round-10-d-nested-segments-c-perl-and-common-lisp-implementation/</link>
      <pubDate>Fri, 01 Jul 2016 07:53:06 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/educational-codeforces-round-10-d-nested-segments-c-perl-and-common-lisp-implementation/</guid>
      <description>Problem Link
Fenwick Tree，它的本质就是把一个序列的和划分成一个个子序列的和。比如一个序列的长 度是10，那么10的二进制是1010，也就是2^1 + 2^3，所以结果就是树里面2和8两个节点的 和。在树里面，节点（n）表示数列里从1到n的元素的和，那么：
 (1) = (1) (2) = (2) (3) = (1) + (2) (4) = (4) (5) = (1) + (4) (6) = (2) + (4)   按照右端点排序，然后把它离散化； 按照左端点倒序排列，从大到小循环，计算右端点在Fenwick Tree里面的presum（也就 是之前插入的比当前右端点小的数量），这个presum就是当前的segment包含的segment 的个数； 把当前右端点插入Fewnwick Tree；  题目要求计算每个端点包含的segment的数量，因为后面要用到排序和离散化，所以可以在 结构体或者类中增加一个域表示它原来在数组中的初始位置。每计算一个presum就可以根据 这个域放到结果数组里面的对应位置。</description>
    </item>
    
    <item>
      <title>Binary Search Tree: Perl and Common Lisp implementation</title>
      <link>http://liuxueyang.github.io/posts/binary-search-tree-perl-and-common-lisp-implementation/</link>
      <pubDate>Thu, 30 Jun 2016 08:33:38 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/binary-search-tree-perl-and-common-lisp-implementation/</guid>
      <description>Perl #!perl use strict; use warnings; use utf8; use 5.</description>
    </item>
    
    <item>
      <title>Lowest common ancestor in binary tree: perl, c and common lisp implementation</title>
      <link>http://liuxueyang.github.io/posts/lowest-common-ancestor-in-binary-tree-perl-c-and-common-lisp-implementation/</link>
      <pubDate>Mon, 27 Jun 2016 17:32:47 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/lowest-common-ancestor-in-binary-tree-perl-c-and-common-lisp-implementation/</guid>
      <description>Find lowest common ancestor in binary tree. We assume the values in the tree are unique and the two values are always in the tree.</description>
    </item>
    
    <item>
      <title>Fenwick Tree</title>
      <link>http://liuxueyang.github.io/posts/fenwick-tree/</link>
      <pubDate>Mon, 27 Jun 2016 00:54:39 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/fenwick-tree/</guid>
      <description>Fenwick Tree的原理是，把一个前缀和划分成多个子序列的和，子序列的个数是当前前缀和元素个数的数字二进制表示中的1的个数。
Perl实现：
#!/usr/bin/env perl -n #=============================================================================== # FILE: fenwick_tree.pl # AUTHOR: Sabastian (liuxueyang.</description>
    </item>
    
    <item>
      <title>推荐Rime小鹤双拼输入法</title>
      <link>http://liuxueyang.github.io/posts/%E6%8E%A8%E8%8D%90rime%E5%B0%8F%E9%B9%A4%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95/</link>
      <pubDate>Fri, 17 Jun 2016 08:02:11 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E6%8E%A8%E8%8D%90rime%E5%B0%8F%E9%B9%A4%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95/</guid>
      <description>之前一直没有时间配置我的OS X上的Rime输入法。所以我最近认真配置了一下。首先，推荐 一篇博客： 安装及配置 Mac 上的 Rime 输入法——鼠鬚管 (Squirrel) 这是一篇好博客。然而复制配置文件的时候，还是不能直接复制到编辑器里面，一定要注意 格式！因为这篇博客，我发现了小鹤双拼输入法，然后随便找了一篇关于小鹤双拼的文章： 做少数派中的少数派：双拼输入快速入门 看了一下里面的键位映射图，大概理解了一下，就马上开始用了。也没怎么刻意记忆，不知 道哪个键就看一下那个图，和朋友聊了几句，就可以打字了，虽然很慢，但是可以接受。前 天晚上开始接触，昨天上午就可以愉快地打字了。到现在大概用了一天半的时间，我就可以 用双拼愉快地写这篇博客了。</description>
    </item>
    
    <item>
      <title>Karabiner —— 自定义MacBook Air键盘</title>
      <link>http://liuxueyang.github.io/posts/karabiner--%E8%87%AA%E5%AE%9A%E4%B9%89macbook-air%E9%94%AE%E7%9B%98/</link>
      <pubDate>Wed, 15 Jun 2016 11:25:11 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/karabiner--%E8%87%AA%E5%AE%9A%E4%B9%89macbook-air%E9%94%AE%E7%9B%98/</guid>
      <description>一直以来，我的MacBook Air的键盘有几个键总是莫名其妙不灵。。换了一次键盘，然而问 题依旧，并且，问题不好重现，仿佛它不高兴了就不灵了。。这给打字带来了极大的不爽。。 所以我的解决办法是外接键盘。。或者外接USB键盘，或者外接蓝牙键盘。然而，这便携性 就没有了。。还要经常担心我那个蓝牙键盘的支脚是不是压倒了原装键盘的某个功能键什么 的。。。所以就很蛋疼。。
所以为了解决蓝牙键盘经常压到Air的原装键盘的问题，我就在原装键盘上面垫上一本小书， 一定程度上解决了这个问题。。然后我就去淘宝搜有没有买专用的板子的啊。。:joy: :joy: 原来我的思路也蛮开阔的。。并没有，随手在Bing搜了一下，看到了V2EX的一个帖子 说如何关闭MacBook Air自带的键盘，诶？这倒是一个办法。然后我就开始折腾了：</description>
    </item>
    
    <item>
      <title>Codeforces Round #356 (Div. 2) C. Bear and Prime 100</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-356-div-2-c-bear-and-prime-100/</link>
      <pubDate>Sat, 11 Jun 2016 08:05:05 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-round-356-div-2-c-bear-and-prime-100/</guid>
      <description>C. Bear and Prime 100 This is an interactive problem.</description>
    </item>
    
    <item>
      <title>problem when configuring vim taglist plugin</title>
      <link>http://liuxueyang.github.io/posts/problem-when-configuring-vim-taglist-plugin/</link>
      <pubDate>Fri, 10 Jun 2016 22:44:32 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/problem-when-configuring-vim-taglist-plugin/</guid>
      <description>最开始，用这个插件的时候出现了类似
ctags unrecognized option &#39;--format=2&#39;^@^itry
这样的问题。
然后我看了一下ctags的man page，发现，确实没有这个选项。这……是为啥。
然后去看taglist插件的manual和它的首页，发现，它里面说的是exuberant ctags，然后 我看了一下这个对比了一下Linux里面的系 统的ctags的man page，发现确实不一样。然后我在常用的PATH里面找了一下exuberant， 很快就找到了/usr/bin/ctags-exuberant，然后根据taglist的文档，设置一个变量就好 了。</description>
    </item>
    
    <item>
      <title>fish shell tutorial</title>
      <link>http://liuxueyang.github.io/posts/fish-shell-tutorial/</link>
      <pubDate>Sat, 04 Jun 2016 10:12:04 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/fish-shell-tutorial/</guid>
      <description>在fish里面，相邻的列表或者字符串会按照笛卡尔积来展开。比如：
liu@lisp /p/tmp&amp;gt; echo {good,bad}&amp;quot; apples&amp;quot; good apples bad apples liu@lisp /p/tmp&amp;gt; set -l a x y z liu@lisp /p/tmp&amp;gt; echo $a x y z liu@lisp /p/tmp&amp;gt; set -l b 1 2 3 liu@lisp /p/tmp&amp;gt; echo $a$b x1 y1 z1 x2 y2 z2 x3 y3 z3 liu@lisp /p/tmp&amp;gt; echo $a&amp;quot;-&amp;quot;$b x-1 y-1 z-1 x-2 y-2 z-2 x-3 y-3 z-3 liu@lisp /p/tmp&amp;gt; echo {x,y,z}$b x1 y1 z1 x2 y2 z2 x3 y3 z3 liu@lisp /p/tmp&amp;gt; echo {$b}word 1word 2word 3word liu@lisp /p/tmp&amp;gt; echo &amp;quot;$b&amp;quot;word 1 2 3word  上面用到了括号扩展的功能：在一个大括号里面以逗号分隔的几个字符串会被扩展成列表里 面的每个元素被当作一个新的变量。比如：</description>
    </item>
    
    <item>
      <title>Codeforces Round #353 (Div. 2) C. Money Transfers</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-353-div-2-c-money-transfers/</link>
      <pubDate>Tue, 31 May 2016 13:57:13 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-round-353-div-2-c-money-transfers/</guid>
      <description>There are n banks in the city where Vasya lives, they are located in a circle, such that any two banks are neighbouring if their indices differ by no more than 1.</description>
    </item>
    
    <item>
      <title>Codeforces Round #354 (Div. 2) C. Vasya and String</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-354-div-2-c-vasya-and-string/</link>
      <pubDate>Mon, 30 May 2016 23:21:39 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-round-354-div-2-c-vasya-and-string/</guid>
      <description>High school student Vasya got a string of length n as a birthday present.</description>
    </item>
    
    <item>
      <title>2016年5月29日</title>
      <link>http://liuxueyang.github.io/posts/2016%E5%B9%B45%E6%9C%8829%E6%97%A5/</link>
      <pubDate>Sun, 29 May 2016 19:14:43 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2016%E5%B9%B45%E6%9C%8829%E6%97%A5/</guid>
      <description>前几天花了大量的时间整理我的各个平台的浏览器书签，最后终于不得不承认，要想一次性 把那么杂乱的书签整理好、去重然后找一个好的插件保持各个浏览器同步是一件很困难的 事情……
所以我想把杂乱的旧书签备份一下，然后重新开始。:joy:我还发现，其实我之前保存书签 的方法一点都不科学。。有的东西其实更适合保存在Evernote里面。Evernote的浏览器插件 其实是一个非常好用的东西。只是我一直没有好好利用。保存到Evernote的好处还有就是即 使原先的链接失效了也丝毫不影响我的笔记内容。并且Evernote各个平台都有比较好的客户 端，也可以很方便地整理和复习。
所以就要比较合理地管理Evernote了，建立笔记本、笔记本组、标签什么的，自己慢慢摸索 吧。感觉分类就是有点麻烦。</description>
    </item>
    
    <item>
      <title>推荐Now Then Pro</title>
      <link>http://liuxueyang.github.io/posts/%E6%8E%A8%E8%8D%90now-then-pro/</link>
      <pubDate>Sat, 28 May 2016 23:01:55 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E6%8E%A8%E8%8D%90now-then-pro/</guid>
      <description>最近我一直在使用一个APP：Now Then Pro。这 是我使用的最好用的一个时间类APP了。
我一般用它来跟踪我的时间，流程是这样的：
 做事情之前首先新建一个任务 点击开始计时 把事情完成，再次点击任务，停止计时 切换到其它任务，当前任务自动停止，新任务开始计时  这样我一整天的每一个小时都可以被记录下来，睡前翻看一下回想一下当前做了什么事情是 一件很有成就感的事情。它有统计功能，柱状图或者饼状图很直观地显示我的时间分配是怎 样的。</description>
    </item>
    
    <item>
      <title>推荐 KDE Connect</title>
      <link>http://liuxueyang.github.io/posts/%E6%8E%A8%E8%8D%90kde-connect/</link>
      <pubDate>Fri, 27 May 2016 23:35:58 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E6%8E%A8%E8%8D%90kde-connect/</guid>
      <description>这是Linux里面的一个超级好用的工具。我之前都用AirDroid，但是也有缺点，就是在Linux 里面只能在浏览器里面使用，也只是勉强能够使用而已。
然而，这个就不一样了，它有Android版。真的是超级好用啊！下面是我经常使用的功能：
 同步剪切板，比如在手机上面复制了一段文字，然后就立刻可以在我的Linux里面用快捷 键C-v把刚才复制的内容粘贴到电脑上面。 比如电脑上面正在播放音乐或者视频，然而我再手机上面就可以控制媒体播放，比如快 进、暂停或者播放。这个可以在一个场景使用到：我把笔记本和显示器或者电视机连接起 来，然后我就可以用我的android来作为遥控器了。 图片或者文件互相发送。  截图以后再补上吧。</description>
    </item>
    
    <item>
      <title>2016年5月23日</title>
      <link>http://liuxueyang.github.io/posts/2016%E5%B9%B45%E6%9C%8823%E6%97%A5/</link>
      <pubDate>Mon, 23 May 2016 22:18:34 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2016%E5%B9%B45%E6%9C%8823%E6%97%A5/</guid>
      <description>今天我发现时间越来越紧迫了起来。
突然想到要整理一下我的浏览器收藏夹，因为我在用三种浏览器，Safari，Chrome 和Firefox，在Mac OS X上面用Safari和Chrome，在旧电脑的Linux上面用Firefox，因为开 Chrome实在是，太卡。。:joy::joy::joy:所以同步收藏夹就成了一个问题。一直以来，我 都没有整理过我的收藏夹，并且不知道什么时候手贱，在Safari里面点了导入Chrome的收藏 夹，然后又在Safari里面导入Firefox的收藏夹，然后在Chrome里面导入Safari的收藏夹， 然后在Firefox里面导入Chrome的收藏夹……然后各种同步。。不知道为啥反正就是各种乱， 很多重复的，也没办法简单地删除，因为都有后来自己添加的收藏并且没有同步或者导入的 别的浏览器的。尝试过各种乱七八糟的去掉收藏夹里面重复网页的浏览器插件，Chrome和 Firefox里面的都试过，下午在Linux里面的Firefox里面又试了一下：</description>
    </item>
    
    <item>
      <title>2016年5月22日</title>
      <link>http://liuxueyang.github.io/posts/2016%E5%B9%B45%E6%9C%8822%E6%97%A5/</link>
      <pubDate>Sun, 22 May 2016 09:26:26 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2016%E5%B9%B45%E6%9C%8822%E6%97%A5/</guid>
      <description>一天天的，过得飞快。。从现在开始，做事情就好好做，憋半途而废，看书就好好看，憋看 到一半就扔了。。写东西就好好写，憋写到一半就废掉了。。我发现我最近经常做这种事情， 惭愧。做事情认真一点，专注一点。
哦，最近我还迷上了学画画，也觉得挺有意思的，尤其是进入一个新的世界，虽然还不会画， 但是挺有趣。最近有点放纵，看电影、逛B站、看视频什么的。好好读书啊！
另外，好好活着，不好么。:joy::joy::joy:
哦，我的Emacs支持Emoji了。哈哈。棒棒哒！:+1:</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>http://liuxueyang.github.io/about/</link>
      <pubDate>Sat, 19 Mar 2016 08:43:57 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/about/</guid>
      <description>Github: @liuxueyang
 QQ: 1459917536
 Email: liuxueyang457@163.com
 IRC: abel-abel</description>
    </item>
    
    <item>
      <title>Codeforces Round #345 (Div. 2) Problem B</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-345-div-2-problem-b/</link>
      <pubDate>Fri, 18 Mar 2016 14:33:20 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-round-345-div-2-problem-b/</guid>
      <description>题意 给一个整数序列，长度小于1000，每个元素元素小于1000大于1，把这个序列任意排序，使得相邻的两个数字满足$a[$i] &amp;lt; $a[$i+1]的pair的个数最大。只需要输出最大的pair个数。
其实画图可以很形象地说明问题。这些图都是用Emacs画的，挺有意思。
首先统计出每个数字的个数。接下来：
第一种思考角度如下图：
从小到大比较相邻组的大小，把较小的那一组的大小累加起来，然而要不要累加较大的这一组的大小那就要看是不是有别的组的大小比它还要大。从下面的图的第2列和地5列可以看到这样的情况。因此还要记录一个最大值。
这个角度从图里面看是从左往右。a -&amp;gt; b -&amp;gt; c -&amp;gt; d这样的顺序。</description>
    </item>
    
    <item>
      <title>2016年春</title>
      <link>http://liuxueyang.github.io/posts/2016%E5%B9%B4%E6%98%A5/</link>
      <pubDate>Sun, 13 Mar 2016 21:16:45 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2016%E5%B9%B4%E6%98%A5/</guid>
      <description>这几天人机大战，李世乭0:3，看得心疼……今天终于、终于赢了！
这几天很多阴谋论，很多打脸，很多嘲讽，没关系，它们都会随风而去。然而，李世乭的今 天会被载入史册。
新的一年，过得很快啊！转眼间，现在已经是3月13日了。这几天学习进度其实略慢。要看 的东西比较多：数值分析、高等数学、英语单词、Perl、具体数学、算法、计算机网络。
一点一点来吧～
反正就是成天瞎折腾……最近才开始用Tmux，还可以，解放了在一个窗口里面开很多个终端 Tab的问题，比较好用的是Session的功能，我可以把不同的窗口分类放到不同的Session里。 另外，平常的编辑还是用Vim吧，我的Emacs用来写Lisp系的语言还可以。毕竟再怎么说它还 是不如Vim轻量。哦，对了，前天一个偶然的机会发现了Vim也有一个Mark的功能，我以前只 知道在一个文件里面可以设置Bookmark，然而我没有想到这个Bookmark是全局的，也就是你 可以用:marks命令来浏览最近设置的标签，即使你在别的目录里面的别的文件里面编辑。 这就很方便……并且比Emacs里面原装的Bookmark功能更方便更快……Vim的乐趣就是即使用了很 长时间，然而总是能够发现新的东西。比如我现在用的Vim配置文件是2013年配的，一直用 到现在没出过问题。尽量保持配置文件简单并且Github同步，Emacs的配置也尽量这样。所 以我的Emacs配置里只同步一个init.</description>
    </item>
    
    <item>
      <title>咳……</title>
      <link>http://liuxueyang.github.io/posts/ke-none/</link>
      <pubDate>Thu, 24 Dec 2015 20:34:53 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/ke-none/</guid>
      <description>== 时间过得 好快…… 刚才无意来到这里。。原来都过去这么久了啊。现在是2015年的12月24日，上次来这里是2014年上半年。。
哎。
不过回头看一看， 还是蛮欢乐的呐^_^</description>
    </item>
    
    <item>
      <title>Ruby implementation of 2048 game</title>
      <link>http://liuxueyang.github.io/posts/ruby-implementation-of-2048-game/</link>
      <pubDate>Thu, 16 Apr 2015 15:36:09 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/ruby-implementation-of-2048-game/</guid>
      <description>Ruby Implementation of 2048 game
 Played in terminal. Control with arrow keys or vim-keybindings.</description>
    </item>
    
    <item>
      <title>rename files in ruby</title>
      <link>http://liuxueyang.github.io/posts/rename-files-in-ruby/</link>
      <pubDate>Wed, 15 Apr 2015 15:34:11 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/rename-files-in-ruby/</guid>
      <description>我有下面的文件：
/home/aries/Music/LuoJi/罗辑思维第三季第7期：统一是怎样炼成的_鸿新网www.hhxin.com整理.mp3 /home/aries/Music/LuoJi/罗辑思维第三季第4期：谁绑架了团结_鸿新网www.hhxin.com整理.mp3 /home/aries/Music/LuoJi/罗辑思维第三季第2期：大清帝国的生死时速_鸿新网www.hhxin.com整理.mp3 /home/aries/Music/LuoJi/罗辑思维第三季第6期：人类灭绝的一种可能_鸿新网www.hhxin.com整理.mp3 /home/aries/Music/LuoJi/罗辑思维第三季第3期：坏国王的遗产_鸿新网www.hhxin.com整理.mp3 /home/aries/Music/LuoJi/罗辑思维第三季第5期：秦始皇在隐瞒什么_鸿新网www.hhxin.com整理.mp3 /home/aries/Music/LuoJi/罗辑思维第三季第1期：大门口的野蛮人_鸿新网www.hhxin.com整理.mp3  我想要重命名这些文件，使文件名更明了，更方便在我的MP3上查看，所以，我写了如下简单的ruby脚本：</description>
    </item>
    
    <item>
      <title>block example in Ruby</title>
      <link>http://liuxueyang.github.io/posts/block-example-in-ruby/</link>
      <pubDate>Sun, 12 Apr 2015 15:33:16 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/block-example-in-ruby/</guid>
      <description>这几天看Ruby，挺有意思的，比如Block的用法：
#!/usr/bin/ruby def total2(from, to, &amp;amp;block) result = 0 from.upto(to) do |num| if block result += block.</description>
    </item>
    
    <item>
      <title>2015 New Year</title>
      <link>http://liuxueyang.github.io/posts/2015-new-year/</link>
      <pubDate>Sun, 08 Mar 2015 15:30:52 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2015-new-year/</guid>
      <description>时间说过得快其实也挺快的。。转眼一看这个可怜的博客，上一篇文章是2014-11-14,今天是2015-03-08,差不多四个月啊。回头想想我都做了些什么：
2014 2014年11、12月：正在找工作，投简历，参加各种宣讲会。
2015 2015年1月：有了几个可怜的「offer」后，开始看书，意识到其实我没什么擅长的东西。。看了一些common lisp的书，把Common LISP: A Gentle Introduction to Symbolic Computation这本英文版的书看完了。另外占时间比较多的事情就是毕业设计的开题报告。然后就是抱着kindle看乱七八糟的书了……这段时间，自从用上了LAMY，开始喜欢用这货写字儿了，经常去上自习的时候，无聊了就拿出日记本开始胡乱写……然后就差不多写完了整整一个本子，不禁惊讶于积累的力量，一件小小的事情，持续做一段时间，往往能达到自己都意识不到的效果。所以我就觉得还不如在纸上写东西比较好，干脆就忘掉博客了……当然有代码的话，博客更好，但是……貌似我也没什么可以值得贴出来的代码。直接扔在 github里面多好，自己查着也方便。</description>
    </item>
    
    <item>
      <title>C is Interesting</title>
      <link>http://liuxueyang.github.io/posts/c-is-interesting/</link>
      <pubDate>Fri, 14 Nov 2014 15:39:20 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/c-is-interesting/</guid>
      <description>最近偶尔看C语言，看了一点有意思的东西。
 C语言里函数声明有一个很有意思的现象：  如果一个函数没有float, short, 或者char类型的参数，在函数生命中完全可以省略 参数类型的说明（但是函数定义中不可以省略）。
也就是说有一个函数定义：
double double(double a) { return a * a; }  那么这个函数可以声明为：</description>
    </item>
    
    <item>
      <title>create, print, insert, delete and reverse list</title>
      <link>http://liuxueyang.github.io/posts/create-print-insert-delete-and-reverse-list/</link>
      <pubDate>Thu, 23 Oct 2014 15:45:58 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/create-print-insert-delete-and-reverse-list/</guid>
      <description>/* * ===================================================================================== * Filename : list.c * Created : 10/21/14 16:12 * Description : create list.</description>
    </item>
    
    <item>
      <title>some sort algorithms</title>
      <link>http://liuxueyang.github.io/posts/some-sort-algorithms/</link>
      <pubDate>Thu, 09 Oct 2014 15:48:33 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/some-sort-algorithms/</guid>
      <description>In order to know whether a sort algorithm is stable, we need to know how it works.</description>
    </item>
    
    <item>
      <title>process filenames with spaces</title>
      <link>http://liuxueyang.github.io/posts/process-filenames-with-spaces/</link>
      <pubDate>Thu, 09 Oct 2014 15:46:59 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/process-filenames-with-spaces/</guid>
      <description>I have some files whose filenames are like this:
[some thing there]Sed &amp;amp; awk, 2nd Edition[some thing there].</description>
    </item>
    
    <item>
      <title>Hey,recently</title>
      <link>http://liuxueyang.github.io/posts/hey-recently/</link>
      <pubDate>Thu, 18 Sep 2014 15:51:23 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hey-recently/</guid>
      <description>貌似大概有整整一个月没有动博客了啊！这个月的几件事情：
 上学期成绩出来了，没有挂，满足了。大部分课程都是考试前两周上自习看的。编译原理老师平时成绩给得高，最后勉强给我拉到了90+，其实……我的目标是过了就行了啊=_= 6月份考的六级过了，494分，裸考，运气好。之前两次裸考的结果分别是：400+，416.这次可能人品好。 小学期跟计科的几个以前不认识同学合作，最后还是水过。总的过程还是挺欢乐的！ 上次阿里水水的笔试过了之后去武汉面试，没过。这让我重新审视了一下自己现在的情况。 圣斗士星矢的后续作品还没补完。一辉、沙加、穆。这三个圣斗士最帅了。 网易的笔试题目出得很认真，比阿里认真多了。答成那个样子也是应该的！ 看了几部不错的电影：《心灵捕手》、《这个杀手不太冷》、《美丽人生》、《姐姐的守护者》  呵，就这样。</description>
    </item>
    
    <item>
      <title>Some simple syntax on lisp and perl</title>
      <link>http://liuxueyang.github.io/posts/some-simple-syntax-on-lisp-and-perl/</link>
      <pubDate>Sun, 17 Aug 2014 23:55:06 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/some-simple-syntax-on-lisp-and-perl/</guid>
      <description>I am learning perl and common lisp these days.</description>
    </item>
    
    <item>
      <title>run-9</title>
      <link>http://liuxueyang.github.io/posts/run-9/</link>
      <pubDate>Fri, 08 Aug 2014 21:48:23 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/run-9/</guid>
      <description>昨天立秋，夏天还没过就结束了。今天天气一下子就凉快了许多。
计算机网络就看到这里吧。下午开始看鸟哥的书。我至少把鸟哥的两本书过一遍。鸟哥的书内容挺多的，一整页里面密密麻麻的都是字儿。不过也确实讲的东西挺全的，也容易懂，就是看着比较枯燥。今天下午看得比较痛苦。。。。%&amp;gt;_&amp;lt;%
另外开始看得一本书就是*Learning Python*英文版的，据说中文版的比较坑。这本书我看着还不错，挺全的，O&amp;rsquo;Reilly经典风格，上下册，两本摞起来比现代汉语词典厚一点。。。虽然是英语，语言挺通俗，看着竟然挺流畅。
下午自习恶心到了，晚上干脆不出去了……窝在宿舍边看书边写这本python书上的例子。。
晚上有点不爽其实，难道是因为没有动力，还是为什么？
还有一本书，*Common Lisp the Language*，这本书打算平时有空了就看，英文的开源版本，下载了HTML格式的放到iPad里面，这样就可以离线看了，这本书比较枯燥，并且还是英文的，看的会慢一些，不知道什么时候能看完，越快越好！</description>
    </item>
    
    <item>
      <title>run-8</title>
      <link>http://liuxueyang.github.io/posts/run-8/</link>
      <pubDate>Mon, 04 Aug 2014 21:06:47 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/run-8/</guid>
      <description>8月2日——8月4日 其实我感觉我有必要总结一下每天都干了点什么。
这三天一直都在看着两本书《sed &amp;amp; awk》和《Learning the bash Shell》。
《Learning the bash Shell》还是讲了很多我以前不知道的东西，当然也有很多很熟悉的东西，有些细节书里面根本就没有解释，直接默认读者知道了，要不是之前看的那本书补充，估计会很困惑。总的来说还是收获颇丰。看了200页，还剩100页左右。</description>
    </item>
    
    <item>
      <title>Write a Shell script to simulate the &#39;tree&#39; command</title>
      <link>http://liuxueyang.github.io/posts/write-a-shell-script-to-simulate-the-tree-command/</link>
      <pubDate>Sun, 03 Aug 2014 21:55:34 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/write-a-shell-script-to-simulate-the-tree-command/</guid>
      <description>I wrote a shell script to simulate the &amp;lsquo;tree&amp;rsquo; tool in Linux.</description>
    </item>
    
    <item>
      <title>run-7</title>
      <link>http://liuxueyang.github.io/posts/run-7/</link>
      <pubDate>Fri, 01 Aug 2014 20:40:01 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/run-7/</guid>
      <description>自习 最近自习的地点从复临舍转战KFC和Dicos，说来也奇怪，每次去这两个地方上自习都效率比较在教室高，从来不睡觉犯困什么的，诶，看来我还是不习惯在特别安静的地方学习。可能是高中的时候养成的习惯吧，我记得高中班里自习的时候都是乱哄哄的，我们班主任老李，特别好的一个老师，曾经专门说过这件事情，说他从来没向其他老师一样把教室自习的纪律什么的管得特别严是因为，我们都应该养成这种即使在嘈杂的环境下也能专注的习惯，因为，并不会什么时候都能有那种安安静静的环境，现在想想也对。这个技能我倒是学到了=_=
宿舍 前天（7月30日）晚上9点多宿舍停电了！！宿舍七楼，夏天，靠着电扇维持适宜的生存温度，竟然没电了！宿舍是呆不下去了，抱着凉席去了楼顶，既然没电了，就睡觉吧，夏夜，晚风，再好不过了。故意把一切的电子产品放在了宿舍，享受这个宁静的夜晚吧。躺在凉席上面，望着夜晚的星空，诶，天上能分辨出来的比较明亮的星星只有三颗，其它的都是依稀可见，用眼角余光可以感觉到它们的存在，可是你真正看那个位置的时候，你却找不出他们在哪里，可能是我散光？脑海里可以想一些乱七八糟的事情，或者干脆什么都不想，数一数那些依稀可见的星星。长沙晚上的天空，只有正上方还有一些夜空的意思，天边四周都是暗红色，总有一种大话西游里牛魔王和至尊宝大战的时候的天空的感觉。。暗红色。小时候，夜晚都是漆黑漆黑的，天气好的时候，夜空是深蓝色，纯净的深蓝，还有满天满天一闪一闪明亮的星星，能清楚地看到北斗七星——我唯一分辨出来的星座。迷迷糊糊的，就睡着了。早上七点多醒来的，是被明亮的太阳晒醒的。自然醒，这种一觉醒来，天下大白的感觉，尤其是在楼顶，感觉最好了，醒得早的话，还能看到东边的美丽的朝霞，满天的被日初照成橘红色的云彩，宛如仙境，可惜这种待遇，只有夏天才有。这也算是夏天的一个福利吧。
早晨起来洗澡的时候，洗头的时候，把洗发露在头上抹好之后，然后就，，水龙头不出水了！！！天下哪有这么巧的事情啊！！这是在存心逗我！！一般的洗澡前把衣服脱了发现没水这不算什么，，哪有这样的啊！！！偏偏在抹上洗发露的时候就没水了！！！！这种事情发生的概率很小对不对？
前几天，晚上外面似乎要下雨的样子，就在宿舍打地铺睡，因为床上实在太热了，晚上凉席是烫，床上的铁护栏都是热热乎乎的。。重点是，早上五点的时候，感觉小腿怎么有点痒啊，感觉有什么东西在爬啊，迷迷糊糊醒了，起来一开灯，我call，一只蟑螂爬在凉席上面啊！！原来刚才就是这货爬我腿上啊！！我默默的对它竖起了中指，call，足足有中指两个关节那么长！！然后这货还爬在毛毯上不下来，后来也没踩死它，让人家愉快地逃走了，诶，大家都要活命的对不对？看外面也没下雨，淡定地卷起凉席，来到了楼顶，刚躺下没10分钟，天空中依稀飘起了可爱的小雨点。。。大家抱起凉席就往回跑。。。
读书 《Linux Command Line and Shell Scripting Bible》这本书，这几天把10——19章看完了，前面10章都是讲命令，需要用的时候再查吧，有时间可以翻翻，20、21章讲的wed,gawk的高级用法，只有两章的篇幅，讲的也不够透彻，先放着等以后看。在后面几章就是高级shell脚本编程了，数据库，Web，E-mail什么的，这些东西很重要，先留着，把shell脚本写熟一点了再深入研究。这本书还是不错的，用来把基础知识扫一遍比较合适，好书。</description>
    </item>
    
    <item>
      <title>run-6</title>
      <link>http://liuxueyang.github.io/posts/run-6/</link>
      <pubDate>Tue, 29 Jul 2014 23:33:22 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/run-6/</guid>
      <description>最近看完了两本书：
 《雪地杀机》 《恶意》
 都是东野圭吾的推理小说。发现东野的小说总是擅长写那种杀人动机很难讲通的故事，至少我是这么认为的。就比如说前段时间看的那部《放学后》，我一直都不能理解那个动机，据说宫部美雪还夸奖那部小说的动机很新颖。。
《雪地杀机》，讲的故事挺有意思，双重推理。简单说就是：设置一个场景，让大家来演一场推理剧，事实上在这不推理剧中真正的实施杀人计划。所谓双重，就是，这个计划的作者为了自己爱的姑娘才实施的，姑娘想出来的这个计划，目的很明确，就是杀掉三个人，这个计划的实施者，毕竟是个平凡人，不能承受自己杀人的痛苦，所以就演了一出戏，表面上按照姑娘的计划进行，实际上并没有杀人。整个故事最后是个悲剧吧，也有一点感人，最后一幕挺有意思，大家都被感动得哭了，贵子真是蠢萌蠢萌的：
 不知何时，中西贵子来到我身边，说：“这个借给你！”说着，她递出已经湿透的手帕。
 哈哈，画面感超强有没有！</description>
    </item>
    
    <item>
      <title>后会无期</title>
      <link>http://liuxueyang.github.io/posts/run-thecontinent/</link>
      <pubDate>Wed, 23 Jul 2014 11:57:10 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/run-thecontinent/</guid>
      <description>今儿7月23日。
诶，7月16日，也就是去深圳参观回来的那一天，《后会无期》发了一首主题歌《平凡之路》……我call，朴树！！！十年了啊！第一遍听就觉得特别好听，这种歌，对我来说，少。
诶，韩寒、朴树，一个是从小就比较喜欢的作家，一个是从小就喜欢的歌手。完美的组合。
第一次读韩寒的作品是在小学的时候，貌似是五年级，《零下一度》记得书里面有一个角色叫做“傻子”。
朴树的歌，一直以来最喜欢的是《白桦林》、《生如夏花》、《她在睡梦中》、《来不及》……算了，不列举了，太多。。。。
所以最近都在单曲循环《平凡之路》。MV里面的歌词字幕，今天才知道，那是韩寒的手笔啊！韩寒写的字真好看。
我最喜欢的歌手只有两个：一个是许巍，一个是朴树。恰好两个人的声线又那么相似。
预告片里面有两句台词，挺有意思：
 你连世界都没有观过，哪来的世界观？ 我的名字就是：闭嘴</description>
    </item>
    
    <item>
      <title>simple linux assembly program</title>
      <link>http://liuxueyang.github.io/posts/simple-linux-assembly-program/</link>
      <pubDate>Sun, 20 Jul 2014 00:19:48 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/simple-linux-assembly-program/</guid>
      <description>There are three simple linux assembly program I wrote today.</description>
    </item>
    
    <item>
      <title>run-5</title>
      <link>http://liuxueyang.github.io/posts/run-5/</link>
      <pubDate>Fri, 04 Jul 2014 08:40:09 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/run-5/</guid>
      <description>诶，昨天终于愉快地考完了！虽然考试和准备考试的过程中并不愉快=_= 不过还是考完了，解放了，哈哈。
前两天，又折腾了一次，开始进入openSUSE的世界。彻底离开ubuntu了！哥们现在要的就是稳定，ubuntu有点小坑，虽然易用，容易入门，但是不是特别稳定，经常出个小问题什么的，版本问题啦，是不是跳出来个窗口说什么什么error，即使是LTS版本，实际上根本没有支持那么长时间。
所以，我就转投openSUSE了。那天晚上真的是装系统装得很痛苦。主要原因不是openSUSE，而是我的U盘，下载的DVD镜像大概4.1G吧，我有两个U盘，一个4G，一个16G，只能用16G的。首先把要准备的资料都备份了一下到移动硬盘里面。然后呢，就在CentOS下面制作了个启动盘，重点来了！电脑启动的时候还是老毛桃界面，也就是说，windows启动盘的那个东西并没有被擦除啊我call。我觉得这是巧合，就有重复了几次制作启动盘，每次十几分钟啊，痛苦地等待啊，问题依然存在。然后就把镜像copy到移动硬盘里面，关键是tm拷到最后的时候出现了错误！但是拷进去的大小还是4.1G，直觉告诉我，这其中有诈！没准儿这个文件没拷贝完整。但是我的windows又没有制作镜像的那个软件，所以，我就抱着侥幸心理！在windows下面把U盘格式化了，结果还是开机进入老毛桃界面！这tm格式化没用的？这个老毛桃也太强悍了吧！无奈，然后回到windows下面，下了个老毛桃，把U盘启动盘的空间还原了，这回总行了吧。试了一下，果然ok。没错，这个时候，操作老毛桃的时候，因为U盘和移动硬盘都插在电脑上面，手残一下点错了，把移动硬盘格式化了！，祸不单行啊！所有资料全没了，算了，我也不打算找回数据了，虽然里面有好多尘封的pdf以及TOUCH的全套mobi漫画以及全套101集高清动画以及很多有意思的视频以及很多盗版的kindle电子书，这种时候我也想不了那么多了，先把系统搞好，早点睡觉！然后在centos下面用从移动硬盘里面拷贝出来的镜像制作了个启动盘，没错是移动硬盘里面的，诶，no zuo no die，我明明知道这个镜像可能有问题，可还是抱着侥幸心理！结果没错，果然是装到一半，提示丢失了一个系统文件，中断了。。镜像没有了怎么办？只能重新下载呗T^T，现在已经是凌晨3点了，校园网还算比较快。下完之后，老老实实地制作好启动盘，重启，愉快并且顺利地装完了，完美替换掉ubuntu，并且grub2也替换掉了，很愉快地都装好了，只花了半个小时，关键是分区什么的以前都分好了，只需要替换一下就行了，根本不用做别的事情，注意一下grub2的安装位置就没问题。
诶，我只能说，之前花了两个小时备份数据白白浪费了！好不容易把数据备份的那么好，结果，，不仅把备份的数据丢了，也把移动硬盘里面其他的东西丢了。。囧 丢了就丢了吧，反正我也用不到，资料什么的有了Google然后再加上书什么的，没什么解决不了的。几十G的电子书从来也不看，对自己也真的没什么用处。
话说系统搞完后，大概就凌晨五点了，call，我今年从来没有通过宵啊！加上再过两天就考试了啊！我还在这里搞这些啊！赶紧睡觉了就，早上十点起，白天竟然也没感觉怎么样。。</description>
    </item>
    
    <item>
      <title>Run-4</title>
      <link>http://liuxueyang.github.io/posts/run-4/</link>
      <pubDate>Sat, 21 Jun 2014 12:28:24 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/run-4/</guid>
      <description>最近深切体会到一句话：莫装逼，装逼遭雷劈。没什么别的可说的。
最近出门耳朵里都塞一副耳机，连着mp3听播客，原来一整天下来能听很多东西，很多一直想听但是一直没有机会或者时间听的播客都在走路的时候或者吃饭的时候听完了，算下来大概一天下来能听一期到两期的东西，时间大约在两个小时左右，有点惊讶，原来光走路或者吃饭的时间也有这么多可以利用。恩，最近听的播客有：
 狗熊有话说 坏蛋调频 东吴相对论 科学脱口秀 友的聊 大内密谈 逻辑思维 IT公论  诶，对了，有些播客不适合在吃饭的时候听，比如：科学脱口秀，真的是节操满地流啊，有那么一次吃着饭听这个，几位主播讲特别重口味的话题，具体是什么你懂得=_= 第几期就不说了。。反正最后我还是故作淡定地把饭吃完了。。</description>
    </item>
    
    <item>
      <title>A small pathogen plugin problem</title>
      <link>http://liuxueyang.github.io/posts/a-small-pathogen-plugin-problem/</link>
      <pubDate>Tue, 17 Jun 2014 20:10:27 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/a-small-pathogen-plugin-problem/</guid>
      <description>When I install vim-instant-markdown with pathogen. I find it can not be installed.</description>
    </item>
    
    <item>
      <title>Run-3</title>
      <link>http://liuxueyang.github.io/posts/run-3/</link>
      <pubDate>Sun, 15 Jun 2014 19:26:21 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/run-3/</guid>
      <description>一周过去了。这一周嘛，开销有点大，入了omx680，一件迪卡侬，一个电脑桌。最赞的是电脑桌了，宿舍空间有点紧张，放书的空间比较少，搞得没有什么地方放电脑或者键盘了。一个单人电脑桌正好。
13日下午照常去跑步。换上衣服，戴上omx680，装备都齐全了。也没什么可以总结的。分段吧：
 前1/4路程：开始吧，状态不是特别好，速度有点慢。但还是坚持慢慢跑。 1&amp;frasl;4~1/2路程：开始有点感觉了，天气有点热，继续跑着，不知不觉到了橘子洲头毛爷爷那里。这里的小风吹的，那叫一个爽啊，真不想走了，多吹一会儿。 1&amp;frasl;2~3/4路程：返程了，开始试了一下赤脚跑步，没想到感觉很不错，脚步很轻松，感觉确实可以纠正一些跑步姿势，我的脚完全可以承受。不过手里拿着一双鞋确实跑起来不雅观，后来还是穿上了=_= 3&amp;frasl;4~4/4路程：开始有点难受了，速度不那么快了。还是像往常一样，坚持到最后了。没什么波澜，也没什么特别的。就这样。  周五下午接到一电话面试，被一个接一个的问题问成狗了。其实吧，最好还是有自己最得意，最擅长的一方面，否则真的一点也没有竞争力啊。
考试周快到了，开始准备考试了，今天下午去自习吧，打开mp3听友的聊291期，背景音乐竟然是岩崎良美和一系列TOUCH的配乐啊，亲切感啊，就凭这个背景音乐，大赞啊，回宿舍果断去iTunes上给五星并且评论了一下。</description>
    </item>
    
    <item>
      <title>run-2</title>
      <link>http://liuxueyang.github.io/posts/run-2/</link>
      <pubDate>Sat, 07 Jun 2014 08:07:48 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/run-2/</guid>
      <description>昨天下午，6月6日，天气阴沉沉的，周五下午，没有太阳。就又出去爽了一把。
穿好跑鞋，换好衣服，这可惜耳机坏了，只好左翻右翻找到很久以前的一副耳机，入耳式那种。就出发了。
开始跑得并不快，但是节奏还不错。然后就发现一个严重的问题，耳机塞得耳朵疼，并且跑起来一响一响的，塞紧了耳朵不舒服，塞松了会掉出来，靠。一把扯下来，扔进路边垃圾桶里，哥们我早就看它不爽了。这下好了，什么也没有，可以享受纯净的跑步了。
感觉也还好，不知不觉跑到了橘子洲大桥。心想，要不再跑一段吧，然后走过大桥，到了橘子洲，愉快的跑着。路上状态不算好也不算坏。就到了毛爷爷那里，发现湘江水比上星期又涨了不少。这个时候有点累了赶脚，休息了7分钟，心想，总不能坐车回去吧，也没带钱啊，继续跑吧，回来的时候，开始沿着河边跑，后来到上面去，在马路上跑，不像周末人多得不行，现在人很少，真是平时锻炼的绝佳去处，空气好，环境又好，没有嘈杂的声音，只有自己的脚步声，享受吧。比我想象的要快，就到了大桥。
剩下的路程就有点小艰难了，腿抬起来的时候变得困难、吃力。脚步不知什么时候变小了很多，左小腿肌肉似乎僵硬，开始罢工了。但是除此之外没有其它的不适感。
最后，很平静地跑到了终点，对，很平静，一直保持很慢的速度，望着江对岸毛爷爷，似乎很遥远的样子，好像我刚才不曾到过那里。全程跑得还是比较干净的。
同样，这次距离大概15km，也没有精确地计算过，因为我手机还是诺基亚。塞班系统那种。=_= 地图上距离只能算个大概。第三次跑这段路程，明显比上次习惯了不少，过程中虽然没有音乐，但也没有太阳，所以不算太热，也不太渴，唯一的就是有点饿，心想着跑完之后要拼命吃一顿。后来证明，这只是个幻想而已，跑完之后草草吃些东西，回宿舍休息了。
话说上周跑完全程第二天丝毫没有什么不适，之前几周每逢周末就下雨，虽然好几周不跑，看来身体并没有退化多少，说明身体比以前强壮了一些吧。
对了，还得入副耳机，又要破费了。周末这两天搞定。</description>
    </item>
    
    <item>
      <title>Round#251</title>
      <link>http://liuxueyang.github.io/posts/round251/</link>
      <pubDate>Thu, 05 Jun 2014 10:44:10 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/round251/</guid>
      <description>A. Devu, the Singer and Churu, the Joker  Devu is a renowned classical singer.</description>
    </item>
    
    <item>
      <title>Run-1</title>
      <link>http://liuxueyang.github.io/posts/run-1/</link>
      <pubDate>Sun, 01 Jun 2014 21:56:35 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/run-1/</guid>
      <description>这篇用中文写。。=_=
昨天五月的最后一天，下午天气不错，就出去跑步了。开始起跑的时候脚步轻快，速度略快，但是丝毫没觉得，跑一段后发现情况不对劲儿，开始大口喘气儿了，这个节奏不对啊，果然是因为很久不跑步没节奏了啊。然后开始减慢速度，调整节奏，逐渐恢复正常速度了。
路上碰见两个大人和一个目测四五岁的小男孩正在慢跑，看小男孩满头大汗，看起来还跑了很久的样子。突然感觉那孩纸太萌了！哈哈哈，一边跑一边呼呼喘气，萌翻了^_^
跑步的时候挺适合听podcast的，有的播客正好40来分钟，跑完后正好也听完一期。很多不错的播客都是这个时候发现的。并且跑步的时候把注意力可以集中在播客上，也就不会感觉无聊和枯燥，不知不觉就跑了很长一段距离。今天听《友的聊播客》讲的是彩虹衫俱乐部，一个北京的咖啡厅式的自行车俱乐部，现实中还是有很多为了梦想而坚持的故事。‘白菜’为了买那辆梅花，花了3万，大概是他和女朋友当时所有的钱。然后一年都在省吃俭用。单单是为了热爱，大概很少人会这么做吧。
就那么一直跑，到了橘子洲，发现变化挺大的，正在改造的样子，沿着橘子洲江边跑，一个多月不来，这里也有游船了啊，还有那种小快艇，有人飞快的驾驶着快艇在江上飞驰，激起白色的水花，像在水面上翻腾的鱼，看着就过瘾啊，可惜我连游泳都还不会。。羡慕……
也有那种比较大的游船，速度不快，正好和我跑步的速度一致，就跟着这艘船一直跑到了橘子洲末尾。休息片刻，发现湘江水位涨得很明显啊，之前来这里还可以看到岸边，现在完全被淹没了。橘子洲和与河西之间的那片长条的湿地，有一部分也被水淹没了。不得不说，路上风景真的不错啊，从路边的树上投下的夕阳的余晖，虽然返程的时候比去的时候痛苦吃力得多，但是边欣赏着周围的美景，也不觉得特别累了。过了橘子洲大桥之后是最痛苦的阶段，腿部肌肉变得僵硬，迈出的每一步都感觉骨骼在撞击地面，腿里好像灌了铅，脚步变得沉重，什么节奏，什么呼吸，都顾不得了，心里面只有一个念头：快点到终点吧。这个时候还是很自然地超过了两辆自行车。接着，一段路程后，又被这两辆自行车超过去了，而我已经丝毫没了斗志，这种时候，心里真的什么也懒得去想，口干舌燥，似乎一点力量也没有了，就这样慢慢跑，接近绝望地一步一步挪向终点。
等还有差不多200米的时候，之前那两辆距离我60米左右，很神奇的是，也不知道哪里来的力量，开始冲刺，连我自己都惊讶哪里来的动力。然后就超过那两辆自行车，一直冲到终点了。啊！终于跑完了啊！终于可以不用再跑了！这让我想起了村上君的那本书里面写的类似于这么一句话，等跑到终点的时候，所有人得想法只有一个，终于可以不用再跑了！
现在只想喝一大桶水，然后躺床上。
回公寓后，买了一杯果汁，一口喝完。又买了一杯。。
已经是晚上了，回宿舍立马在地上铺上席子，躺下，边听播客边迷迷糊糊地睡着了。迷迷糊糊中好像宿舍亮着的灯灭了，似乎是停电了，后来不知怎么又亮了。不知是梦还是现实。睡了一个多小时自然醒。感觉只有一个字，爽！</description>
    </item>
    
    <item>
      <title>A Text Adventure Game by CommonLISP</title>
      <link>http://liuxueyang.github.io/posts/a-text-adventure-game-by-commonlisp/</link>
      <pubDate>Sun, 01 Jun 2014 20:23:29 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/a-text-adventure-game-by-commonlisp/</guid>
      <description>Today, I read the book Land of Lisp. It is interesting to write a text adventure game.</description>
    </item>
    
    <item>
      <title>My Previous Blog</title>
      <link>http://liuxueyang.github.io/posts/my-previous-blog/</link>
      <pubDate>Sat, 31 May 2014 09:51:20 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/my-previous-blog/</guid>
      <description>My Previous Blog is Desert Guard.
This is whay I migrate my blog here.</description>
    </item>
    
    <item>
      <title>Editor</title>
      <link>http://liuxueyang.github.io/posts/editor/</link>
      <pubDate>Fri, 30 May 2014 20:49:43 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/editor/</guid>
      <description>Today, I tried some editor. In the past, I always use vim and do not like any other editors at all and have not ever tried others.</description>
    </item>
    
    <item>
      <title>NFA2DFA</title>
      <link>http://liuxueyang.github.io/posts/nfa2dfa/</link>
      <pubDate>Wed, 28 May 2014 14:01:53 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/nfa2dfa/</guid>
      <description>input: number of symbols symbol set(each space between two symbol) number of states(state number starts from 1 to n by default) start state number number of accept states accept states set state transfer table (epsilon transfer is at column one and if there are several epsilon transfers, seperate them with a comma without spaces) The following file is the input file.</description>
    </item>
    
    <item>
      <title>Chapter 5</title>
      <link>http://liuxueyang.github.io/posts/chapter-5/</link>
      <pubDate>Tue, 27 May 2014 23:51:33 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/chapter-5/</guid>
      <description>Optional Parameters we can use optional arguments in a function, such as:</description>
    </item>
    
    <item>
      <title>My new post</title>
      <link>http://liuxueyang.github.io/posts/my-new-post/</link>
      <pubDate>Mon, 26 May 2014 00:10:08 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/my-new-post/</guid>
      <description>From now on, I will write something everyday to improve myself.</description>
    </item>
    
    <item>
      <title>some simple recursive lisp programs</title>
      <link>http://liuxueyang.github.io/posts/some-simple-recursive-lisp-programs/</link>
      <pubDate>Fri, 09 May 2014 01:28:13 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/some-simple-recursive-lisp-programs/</guid>
      <description>Write a procedure count-list to count the number of elements in a list  (defun count-list (numbers) (if (null numbers) 0 (+ 1 (count-list (rest numbers))))) (print (count-list &#39;(1 2 3))) result: 3   Write a procedure reverse-list to reverse each word in a list of words  (defun reverse-list (numbers) (if (null numbers) nil (cons (reverse (first numbers)) (reverse-list (rest numbers))))) (reverse-list &#39;(&amp;quot;dog&amp;quot; &amp;quot;pan&amp;quot; &amp;quot;tar&amp;quot; &amp;quot;tip&amp;quot; &amp;quot;net&amp;quot;))  result: (&amp;quot;god&amp;quot; &amp;quot;nap&amp;quot; &amp;quot;rat&amp;quot; &amp;quot;pit&amp;quot; &amp;quot;ten&amp;quot;)</description>
    </item>
    
    <item>
      <title>April Fools Day Contest 2014</title>
      <link>http://liuxueyang.github.io/posts/april-fools-day-contest-2014/</link>
      <pubDate>Tue, 29 Apr 2014 09:56:46 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/april-fools-day-contest-2014/</guid>
      <description>April Fools Day Contest 2014
Ａ、Ｃ、Ｈ三道题目
A. The Great Game</description>
    </item>
    
    <item>
      <title>指针的问题</title>
      <link>http://liuxueyang.github.io/posts/%E6%8C%87%E9%92%88%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 10 Apr 2014 19:22:13 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E6%8C%87%E9%92%88%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>这些细节的问题涉及到语言内部的实现和处理，现在还是没有太懂。
尤其是关于const的问题。
比如说下面的代码：
#include &amp;lt;stdio.h&amp;gt; int main(void) { const int x = 1; int y = 3; int * p = (int *)&amp;amp;x; *p = 3; printf(&amp;quot;x = %d\n&amp;quot;, x); printf(&amp;quot;*p = %d\n&amp;quot;, *p); if (y == true) printf(&amp;quot;true\n&amp;quot;); return 0; } /* output: x = 1 *p = 3 */  也就是说，const类型的整型变量的值并没有改变。印象中好像是const类型的变量在内存中存放的位置和普通变量不一样之类的……当初也想到这个了，笔试的时候不太确定。整道题做错了。。。白写了那么多啊囧。</description>
    </item>
    
    <item>
      <title>CodeForces 239 Long Path</title>
      <link>http://liuxueyang.github.io/posts/codeforces-239-long-path/</link>
      <pubDate>Mon, 31 Mar 2014 12:11:01 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-239-long-path/</guid>
      <description>每个房间有两个单向出口，就是只能进不能出，这个开始理解错了。
进入房间的时候，首先要在屋顶画一个叉叉，如果画完之后叉叉的个数是奇数的话：那么就从第二条出口出去，会到达ｐ[ i ]房间；如果叉叉的个数是偶数的话，那么就到下一个房间。
问从1到ｎ+1房间一共走了多少个这样的单项出口。
有一个条件：1 &amp;lt;= p[ i ] &amp;lt;= i 这个开始也没有注意到==。这是个很重要的条件。</description>
    </item>
    
    <item>
      <title>CodeForces 239A. Triangle</title>
      <link>http://liuxueyang.github.io/posts/codeforces-239a-triangle/</link>
      <pubDate>Sun, 30 Mar 2014 20:42:29 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-239a-triangle/</guid>
      <description>Link: http://codeforces.com/contest/407/problem/A
给定直角三角形的2个直角边a，b。求在直角坐标系中，是否存在对应的直角三角形，使得三个定点都在整点上，并且三边都不和坐标轴平行。
如果存在，输出YES，和三个点的坐标。否则输出NO
很显然，为了方便，可以把原点作为 一个顶点。
这道题目做的时候少考虑了很多情况。
比如：
如何使得边不和坐标轴平行？ 要保证要求的另外两个点的横坐标或者纵坐标不能相等。</description>
    </item>
    
    <item>
      <title>Longest Increasing Subsequence</title>
      <link>http://liuxueyang.github.io/posts/longest-increasing-subsequence/</link>
      <pubDate>Sat, 22 Mar 2014 23:44:49 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/longest-increasing-subsequence/</guid>
      <description>很久不写算法了== 写个东西练练手
最长上升子序列
输入n，然后是数组a[ ]的n个元素
输出最长上升子序列的长度
一、最简单的方法复杂度O(n * n)
DP[ i ] 是以a[ i ] 为结尾的最长上升子序列的长度。 DP[ i ] = max{DP[ j ] + 1 | j &amp;lt; i &amp;amp;&amp;amp; a[ j ] &amp;lt; a[ i ]}  代码：</description>
    </item>
    
    <item>
      <title>Vim插件管理</title>
      <link>http://liuxueyang.github.io/posts/vim%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 04 Mar 2014 15:44:39 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/vim%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86/</guid>
      <description>话说，用Git和pathogen管理Vim插件再方便不过了！真是神器啊，以后再也不用因为换电脑或者系统重新配置Vim了！
首先得学会用Git
安装Git
sudo apt-get install git  基本设置
$ git config --global user.</description>
    </item>
    
    <item>
      <title>PE文件格式 持续更新ing</title>
      <link>http://liuxueyang.github.io/posts/pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0ing/</link>
      <pubDate>Thu, 27 Feb 2014 07:17:01 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0ing/</guid>
      <description>PE文件就是exe文件和dll文件，前者是可执行文件，后者是动态连接库文件。两者的区别仅仅是字面上的，唯一的区别就是内部的一个字段标识这个文件是exe文件还是dll文件。
对于PE文件格式，举一个例子来说明比较清楚：
　比如我打开一个.exe文件，gvim.exe 也就是gvim的安装程序
　首先就是DOS头：前两个字节，5A4Dh 表示MZ，这只是一个DOS可执行文件标记，表示这个文件是一个可执行文件。
　DOS头的最后一个Double word 在地址3ch处，可以发现它的值是：0000 00D8 h 它指向真正的PE头。</description>
    </item>
    
    <item>
      <title>poj1298 The Hardest Problem Ever 简单题</title>
      <link>http://liuxueyang.github.io/posts/poj1298-the-hardest-problem-ever-%E7%AE%80%E5%8D%95%E9%A2%98/</link>
      <pubDate>Tue, 04 Feb 2014 12:47:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1298-the-hardest-problem-ever-%E7%AE%80%E5%8D%95%E9%A2%98/</guid>
      <description>链接：http://poj.org/problem?id=1298&amp;amp;lang=default&amp;amp;change=true
简单的入门题目也有这么强悍的技巧啊！！
书上面的代码：
很厉害有没有=_=
n;main(k){for(;read(0,&amp;amp;n,1);k-=n&amp;lt;11)k%3||putchar(n%91&amp;lt;65?n:n%70%44+65);}  72字节。
用到了read这个函数
对于不需要处理的字符串，没有作处理，简化了很多。</description>
    </item>
    
    <item>
      <title>poj2368 Buttons Nim取石子游戏</title>
      <link>http://liuxueyang.github.io/posts/poj2368-buttons-nim%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Mon, 03 Feb 2014 23:50:07 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2368-buttons-nim%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</guid>
      <description>链接：http://poj.org/problem?id=2368
和前面差距还是很大啊囧
代码：
k,a;main(i){for(scanf(&amp;quot;%d&amp;quot;,&amp;amp;k),a=k-1,i=3;i&amp;lt;=k/2&amp;amp;&amp;amp;k%i;++i);k%i||(a=i-1);printf(&amp;quot;%d\n&amp;quot;,a);}  短码之美那本书上面的这道题目的代码思路是对的，可是会TLE的。
可是ozy的代码还是那么短得可怕😨
那个，又省掉了一个特别脑残的变量。。
代码：
k;main(i){for(scanf(&amp;quot;%d&amp;quot;,&amp;amp;k),i=3;i&amp;lt;=k/2&amp;amp;&amp;amp;k%i;++i);printf(&amp;quot;%d\n&amp;quot;,k%i?k-1:i-1);}  78字节。</description>
    </item>
    
    <item>
      <title>2014新年</title>
      <link>http://liuxueyang.github.io/posts/2014%E6%96%B0%E5%B9%B4/</link>
      <pubDate>Sun, 02 Feb 2014 14:51:52 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2014%E6%96%B0%E5%B9%B4/</guid>
      <description>那个，过年了。今天是正月初三。现在在我姥姥家。
外面二姨她们在斗地主，很欢乐。
无聊，找到台电脑，上网呗。
没什么可看的，想起下学期有门课叫做编译原理。
不妨google一下编译原理吧。然后就顺着找到了这个人的wiki里面的这篇文章：http://www.annhe.net/article-2445.html.
正好是湖大的，校友，比我大一届，10级的。去的新浪，羡慕啊。
那个，等到今年9月份，就该我了。。
可我怎么觉得我还差早呢？
在家比较混乱的样子，最多看看短码之美那本书娱乐一下，感觉挺有意思的样子，但还是看的很慢啊囧╭(╯^╰)╮
上学期没有挂，真是rp爆发加运气好啊，首先要感谢的是德克士，给我提供了那么暖和的复习环境……=_=</description>
    </item>
    
    <item>
      <title>均分01</title>
      <link>http://liuxueyang.github.io/posts/%E5%9D%87%E5%88%8601/</link>
      <pubDate>Wed, 22 Jan 2014 10:16:10 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%9D%87%E5%88%8601/</guid>
      <description>真是无语，刚才写了一遍，添加博客标签的时候，浏览器自动刷新了一下，
然后tm写的东西就没有了！！还得重写。。
开始没懂，学弟给讲的==
感觉很厉害的样子。
可以切分一次。 不管什么串，一定可以切分两次完成。  证明：
　把这个串的首尾相连，设连接点是A，串的中点是B，设直线AB是L，L的左右的0的个数不相等，不妨设左边大于右边。顺时针旋转直线L，每旋转一次左右两边0的个数只可能发生两种变化：不变，+1，-1 。</description>
    </item>
    
    <item>
      <title>poj1852 Ants ——想法题、水题</title>
      <link>http://liuxueyang.github.io/posts/poj1852-ants-%E6%83%B3%E6%B3%95%E9%A2%98%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Mon, 21 Oct 2013 07:48:08 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1852-ants-%E6%83%B3%E6%B3%95%E9%A2%98%E6%B0%B4%E9%A2%98/</guid>
      <description>求最短时间和最长时间。
当两个蚂蚁相遇的时候，可以看做两个蚂蚁穿过，对结果没有影响。O（N）的复杂度
c++版：
#include &amp;lt;cstdio&amp;gt; #define min(a, b) (a) &amp;lt; (b) ?</description>
    </item>
    
    <item>
      <title>编写安装中断7ch的中断例程：将一个以0结尾的字符串，转化为大写</title>
      <link>http://liuxueyang.github.io/posts/%E7%BC%96%E5%86%99%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%AD7ch%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E5%B0%86%E4%B8%80%E4%B8%AA%E4%BB%A50%E7%BB%93%E5%B0%BE%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%A4%A7%E5%86%99/</link>
      <pubDate>Thu, 17 Oct 2013 21:12:57 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E7%BC%96%E5%86%99%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%AD7ch%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B%E5%B0%86%E4%B8%80%E4%B8%AA%E4%BB%A50%E7%BB%93%E5%B0%BE%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%A4%A7%E5%86%99/</guid>
      <description>中断的安装程序：
assume cs:code code segment start: mov ax, cs mov ds, ax mov si, offset chstr mov ax, 0 mov es, ax mov di, 200h mov cx, offset chstrend - offset chstr cld rep movsb mov ax, 0 mov es, ax mov word ptr es:[7ch * 4 + 0], 200h mov word ptr es:[7ch * 4 + 2], 0 mov ax, 4c00h int 21h chstr: mov si, 0 lh: mov cx, 0 mov cl, [si] jcxz ok and byte ptr [si], 11011111b inc si jmp lh ok: iret chstrend: nop code ends end start  测试程序：</description>
    </item>
    
    <item>
      <title>编写中断例程7ch：计算word型数据的平方</title>
      <link>http://liuxueyang.github.io/posts/%E7%BC%96%E5%86%99%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B7ch%E8%AE%A1%E7%AE%97word%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B9%B3%E6%96%B9/</link>
      <pubDate>Thu, 17 Oct 2013 20:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E7%BC%96%E5%86%99%E4%B8%AD%E6%96%AD%E4%BE%8B%E7%A8%8B7ch%E8%AE%A1%E7%AE%97word%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B9%B3%E6%96%B9/</guid>
      <description>实现计算一个word型数据的平方。
这是安装程序。
assume cs:code code segment start: mov ax, cs mov ds, ax mov si, offset sqr mov ax, 0 mov es, ax mov di, 200h mov cx, offset sqrend - offset sqr cld rep movsb mov ax, 0 mov es, ax mov word ptr es:[7ch * 4+0], 200h mov word ptr es:[7ch * 4 + 2], 0 mov ax, 4c00h int 21h sqr: mul ax iret sqrend: nop code ends end start  这是应用程序。</description>
    </item>
    
    <item>
      <title>编写0号中断的处理程序：处理除法溢出</title>
      <link>http://liuxueyang.github.io/posts/%E7%BC%96%E5%86%990%E5%8F%B7%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%A4%84%E7%90%86%E9%99%A4%E6%B3%95%E6%BA%A2%E5%87%BA/</link>
      <pubDate>Thu, 17 Oct 2013 19:49:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E7%BC%96%E5%86%990%E5%8F%B7%E4%B8%AD%E6%96%AD%E7%9A%84%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%A4%84%E7%90%86%E9%99%A4%E6%B3%95%E6%BA%A2%E5%87%BA/</guid>
      <description>在除法溢出的时候，在屏幕中间显示字符串“divide error!”
安装程序：
assume cs:code code segment start: mov ax, cs mov ds, ax mov si, offset do0 mov ax, 0 mov es, ax mov di, 200h mov cx, offset do0end - offset do0 cld rep movsb mov ax, 0 mov ds, ax mov word ptr ds:[0*4], 200h mov word ptr ds:[0*4 + 2], 0 do0: jmp do0start db &amp;quot;divide error!</description>
    </item>
    
    <item>
      <title>实验十一：编写子程序</title>
      <link>http://liuxueyang.github.io/posts/%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80%E7%BC%96%E5%86%99%E5%AD%90%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Tue, 15 Oct 2013 16:45:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80%E7%BC%96%E5%86%99%E5%AD%90%E7%A8%8B%E5%BA%8F/</guid>
      <description>将一个0结尾的字符串中的小写字母转化成大写字母
assume cs:code, ds:data data segment db &amp;quot;Beginner&#39;s All-purpose Symbolic Instruction Code.</description>
    </item>
    
    <item>
      <title>试验十 3.数值显示</title>
      <link>http://liuxueyang.github.io/posts/%E8%AF%95%E9%AA%8C%E5%8D%81-3-%E6%95%B0%E5%80%BC%E6%98%BE%E7%A4%BA/</link>
      <pubDate>Fri, 11 Oct 2013 13:01:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E8%AF%95%E9%AA%8C%E5%8D%81-3-%E6%95%B0%E5%80%BC%E6%98%BE%E7%A4%BA/</guid>
      <description>题目的意思是：
　把一个16进制的数字转化成十进制，然后在屏幕的第3行，第8列，用绿色输出。
这货倒是不太难，就是学会调用之前写过的函数就行了==
assume cs:code, ds:data, ss:stack data segment db 10 dup(0) data ends stack segment dw 10 dup(0) stack ends code segment start: mov ax, 12666 mov dx, 0 mov bx, data mov ds, bx mov si, 0 call dtoc mov dh, 8 mov dl, 3 mov cl, 2 call show_str mov ax, 4c00h int 21h dtoc: push si mov bx, 10 mov cx, ax mov di, 0 sad: div bx add dx, 30h push dx mov dx, 0 inc di mov cx, ax add cx, 1 loop sad mov bp, 0 mov cx, di ago: pop dx mov al, dl mov ds:[bp], al inc bp loop ago mov ds:[bp], 0 pop si ret show_str: push dx push cx ;row dec dh mov al, 0a0h mul dh push ax ;col dec dl mov al, 2h mul dl pop bx add ax, bx mov di, 0b800h mov es, di mov bp, ax mov bl, cl change: mov cl, [si] mov ch, 0 jcxz ok mov di, si add di, di mov al, ds:[si] mov byte ptr es:[bp+di], al mov byte ptr es:[bp+di+1], bl inc si jmp short change ok: pop cx pop dx ret code ends end start  虽然很长……看起来好腻害的样子=_=</description>
    </item>
    
    <item>
      <title>解决除法溢出问题</title>
      <link>http://liuxueyang.github.io/posts/%E8%A7%A3%E5%86%B3%E9%99%A4%E6%B3%95%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 10 Oct 2013 23:54:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E8%A7%A3%E5%86%B3%E9%99%A4%E6%B3%95%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98/</guid>
      <description>被除数是dword型，除数是dword型，结果是dword型。
参数：
　ax=dword型数据的低16位
　dx=dword型数据的高16位
　cx=除数
返回：
　dx=结果的高16位，ax=结果的低16位</description>
    </item>
    
    <item>
      <title>编写子程序，显示字符串</title>
      <link>http://liuxueyang.github.io/posts/%E7%BC%96%E5%86%99%E5%AD%90%E7%A8%8B%E5%BA%8F%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 08 Oct 2013 11:41:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E7%BC%96%E5%86%99%E5%AD%90%E7%A8%8B%E5%BA%8F%E6%98%BE%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>在屏幕的8行3列，用绿色显示data段中的字符串。
assume cs:code, ds:data data segment db &#39;Welcome to masm!&#39;, 0 data ends code segment start: mov dh, 8 mov dl, 3 mov cl, 2 mov ax, data mov ds, ax mov si, 0 call show_str mov ax, 4c00h int 21h show_str: push dx push cx ;row dec dh mov al, 0a0h mul dh push ax ;col dec dl mov al, 2h mul dl pop bx add ax, bx mov di, 0b800h mov es, di mov bp, ax mov bl, cl change: mov cl, [si] mov ch, 0 jcxz ok mov di, si add di, di mov al, ds:[si] mov byte ptr es:[bp+di], al mov byte ptr es:[bp+di+1], bl inc si jmp short change ok: pop cx pop dx ret code ends end start  开始遇到了很奇怪的bug，最终还是不知道为什么，所以换了一种方式解决问题了。</description>
    </item>
    
    <item>
      <title>call指令的一个细节</title>
      <link>http://liuxueyang.github.io/posts/call%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BB%86%E8%8A%82/</link>
      <pubDate>Mon, 07 Oct 2013 08:49:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/call%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%80%E4%B8%AA%E7%BB%86%E8%8A%82/</guid>
      <description>执行下面这个程序之后，ax的值是多少？
assume cs:code code segment start: mov ax, 0 call s inc ax s: pop ax mov ax, 4c00h int 21h code ends end start  答案是0006h</description>
    </item>
    
    <item>
      <title>codeforces A. Difference Row</title>
      <link>http://liuxueyang.github.io/posts/codeforces-a-difference-row/</link>
      <pubDate>Mon, 07 Oct 2013 00:28:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-a-difference-row/</guid>
      <description>link: http://codeforces.com/contest/347/problem/A
开始看起来很复杂的样子，但是刚写下样例，就发现因为中间的都消去了，其实起作用的就是最大值和最小值=_=
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; int a[102]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>codeforces B.Fixed Points</title>
      <link>http://liuxueyang.github.io/posts/codeforces-b-fixed-points/</link>
      <pubDate>Mon, 07 Oct 2013 00:23:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-b-fixed-points/</guid>
      <description>link: http://codeforces.com/contest/347/problem/B
很简单，最多只能交换一次，也就是说，最多会增加两个。可能会增加一个。也可能一个也不增加（此时都是fixed point）
#include &amp;lt;cstdio&amp;gt; using namespace std; int a[100002]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>终于在cmd窗口里出现了颜色了！！！感动ing……</title>
      <link>http://liuxueyang.github.io/posts/%E7%BB%88%E4%BA%8E%E5%9C%A8cmd%E7%AA%97%E5%8F%A3%E9%87%8C%E5%87%BA%E7%8E%B0%E4%BA%86%E9%A2%9C%E8%89%B2%E4%BA%86%E6%84%9F%E5%8A%A8ing/</link>
      <pubDate>Sun, 06 Oct 2013 15:31:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E7%BB%88%E4%BA%8E%E5%9C%A8cmd%E7%AA%97%E5%8F%A3%E9%87%8C%E5%87%BA%E7%8E%B0%E4%BA%86%E9%A2%9C%E8%89%B2%E4%BA%86%E6%84%9F%E5%8A%A8ing/</guid>
      <description>在窗口的中央打印三行字。
要求：　　第一行绿色字
　第二行绿底红色
　第三行白底蓝色
assume cs:code, ds:data data segment db &#39;welcome to masm!</description>
    </item>
    
    <item>
      <title>一个有意思的汇编程序 ——其实就是一个根据位移进行转移的应用=_=</title>
      <link>http://liuxueyang.github.io/posts/%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F-%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sun, 06 Oct 2013 14:00:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E4%B8%80%E4%B8%AA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F-%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>分析一下这个程序=_=
assume cs:code code segment mov ax, 4c00h int 21h start: mov ax, 0 s: nop nop mov di, offset s mov si, offset s2 mov ax, cs:[si] mov cs:[di], ax s0: jmp short s s1: mov ax, 0 int 21h mov ax, 0 s2: jmp short s1 nop code ends end start  开始，一眼看去，这个程序应该会陷入死循环吧。。</description>
    </item>
    
    <item>
      <title>实验七——王爽…………我写的最长的一个汇编程序==</title>
      <link>http://liuxueyang.github.io/posts/%E5%AE%9E%E9%AA%8C%E4%B8%83%E7%8E%8B%E7%88%BD%E6%88%91%E5%86%99%E7%9A%84%E6%9C%80%E9%95%BF%E7%9A%84%E4%B8%80%E4%B8%AA%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sun, 06 Oct 2013 00:20:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%AE%9E%E9%AA%8C%E4%B8%83%E7%8E%8B%E7%88%BD%E6%88%91%E5%86%99%E7%9A%84%E6%9C%80%E9%95%BF%E7%9A%84%E4%B8%80%E4%B8%AA%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F/</guid>
      <description>这是我到目前为止写的最长的汇编程序了。
assume cs:sad, ds:data, ss:stack stack segment stack ends data segment db &#39;1975&#39;, &#39;1976&#39;, &#39;1977&#39;, &#39;1978&#39;, &#39;1979&#39;, &#39;1980&#39;, &#39;1981&#39;, &#39;1982&#39;, &#39;1983&#39; db &#39;1984&#39;, &#39;1985&#39;, &#39;1986&#39;, &#39;1987&#39;, &#39;1988&#39;, &#39;1989&#39;, &#39;1990&#39;, &#39;1991&#39;, &#39;1992&#39; db &#39;1993&#39;, &#39;1994&#39;, &#39;1995&#39; ; 21 years -- 54h bytes dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514 dd 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000 ; income in 21 years -- 54h bytes dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226 dw 11542, 14430, 15257, 17800 ; staff in 21 years -- 2ah bytes data ends table segment db 21 dup (&#39;year summ ne ?</description>
    </item>
    
    <item>
      <title>bx, bp, si, di寄存器的使用规则</title>
      <link>http://liuxueyang.github.io/posts/bx-bp-si-di%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99/</link>
      <pubDate>Sat, 05 Oct 2013 18:40:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/bx-bp-si-di%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99/</guid>
      <description>首先，都可以单独使用。
另外，组合使用的情况下：
记住这张图片就行了=_=
意思就是，bx只能和si，di组合。bp只能和si，di组合。</description>
    </item>
    
    <item>
      <title>更灵活的定位内存地址的方法 ——将每个单词的前四个字母改为大写</title>
      <link>http://liuxueyang.github.io/posts/%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95-%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E5%89%8D%E5%9B%9B%E4%B8%AA%E5%AD%97%E6%AF%8D%E6%94%B9%E4%B8%BA%E5%A4%A7%E5%86%99/</link>
      <pubDate>Sat, 05 Oct 2013 15:32:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95-%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E5%89%8D%E5%9B%9B%E4%B8%AA%E5%AD%97%E6%AF%8D%E6%94%B9%E4%B8%BA%E5%A4%A7%E5%86%99/</guid>
      <description>很简单的一个程序
assume cs:code, ss:stack, ds:data data segment db &#39;1. display &#39; db &#39;2.</description>
    </item>
    
    <item>
      <title>更灵活的定位内存地址的方法——大小写转换</title>
      <link>http://liuxueyang.github.io/posts/%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Fri, 04 Oct 2013 23:46:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2/</guid>
      <description>如下：
;BasiC to BASIC ;MinIX to minix assume cs:code, ds:data data segment db &#39;BaSiC&#39; db &#39;MinIX&#39; data ends code segment start: mov ax, data mov ds, ax mov bx, 0 mov cx, 5 s: mov al, 0[bx] and al, 11011111b mov 0[bx], al mov al, 5[bx] or al, 00100000b mov 5[bx], al inc bx loop s mov ax, 4c00h int 21h code ends end start  很简单的一个程序。</description>
    </item>
    
    <item>
      <title>向内存0:200~0:23f依次传送数据0~3fh</title>
      <link>http://liuxueyang.github.io/posts/%E5%90%91%E5%86%85%E5%AD%980-200-0-23f%E4%BE%9D%E6%AC%A1%E4%BC%A0%E9%80%81%E6%95%B0%E6%8D%AE0-3fh/</link>
      <pubDate>Fri, 04 Oct 2013 14:23:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%90%91%E5%86%85%E5%AD%980-200-0-23f%E4%BE%9D%E6%AC%A1%E4%BC%A0%E9%80%81%E6%95%B0%E6%8D%AE0-3fh/</guid>
      <description>只能用字节为单位传送了。
assume cs:sad sad segment start: mov ax, 20h mov ds, ax mov bx, 0 mov cx, 40h s: mov [bx], bl inc bl loop s mov ax, 4c00h int 21h sad ends end  我只能优化到这里了。用了7条指令。</description>
    </item>
    
    <item>
      <title>将内存ffff:0~ffff:b中的数据拷贝到0:200~0:20b中</title>
      <link>http://liuxueyang.github.io/posts/%E5%B0%86%E5%86%85%E5%AD%98ffff-0-ffff-b%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E5%88%B00-200-0-20b%E4%B8%AD/</link>
      <pubDate>Fri, 04 Oct 2013 14:12:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%B0%86%E5%86%85%E5%AD%98ffff-0-ffff-b%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E5%88%B00-200-0-20b%E4%B8%AD/</guid>
      <description>我是按照字，也就是2个字节拷贝的。
这样就可以让循环减半==
assume cs:sad sad segment start: mov ax, 0ffffh mov ds, ax mov bx, 0h mov ax, 20h mov es, ax mov cx, 7h s: mov ax, ds:[bx] mov es:[bx], ax add bx, 2 loop s mov ax, 4c00h int 21h sad ends end  刚听到句歌词：</description>
    </item>
    
    <item>
      <title>计算ffff:0~ffff:b数据的和，结果存在dx中</title>
      <link>http://liuxueyang.github.io/posts/%E8%AE%A1%E7%AE%97ffff-0-ffff-b%E6%95%B0%E6%8D%AE%E7%9A%84%E5%92%8C%E7%BB%93%E6%9E%9C%E5%AD%98%E5%9C%A8dx%E4%B8%AD/</link>
      <pubDate>Fri, 04 Oct 2013 12:28:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E8%AE%A1%E7%AE%97ffff-0-ffff-b%E6%95%B0%E6%8D%AE%E7%9A%84%E5%92%8C%E7%BB%93%E6%9E%9C%E5%AD%98%E5%9C%A8dx%E4%B8%AD/</guid>
      <description>代码：
assume cs:sad sad segment start: mov ax, 0ffffh mov ds, ax mov dx, 0 ; add ds:0bh~ds:1h mov cx, 0bh s: mov ah, 0 mov bx, cx mov al, ds:[bx] add dx, ax loop s ; add ds:0h mov bh, 0 mov bl, ds:[0] add dx, bx mov ax, 4c00h int 21h sad ends end  自己写的==</description>
    </item>
    
    <item>
      <title>debug不过的程序</title>
      <link>http://liuxueyang.github.io/posts/debug%E4%B8%8D%E8%BF%87%E7%9A%84%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Fri, 04 Oct 2013 12:25:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/debug%E4%B8%8D%E8%BF%87%E7%9A%84%E7%A8%8B%E5%BA%8F/</guid>
      <description>下面的程序debug是不能通过的。
至于为什么我还不知道。
assume cs:codesg codesg segment start: mov ax,2000h mov ss, ax mov sp, 0 add sp, 4 pop ax pop bx push ax push bx pop ax pop bx mov ax, 4c00h int 21h codesg ends end  这个问题留在这里，以后解决。</description>
    </item>
    
    <item>
      <title>栈段 ——满是疑问==</title>
      <link>http://liuxueyang.github.io/posts/%E6%A0%88%E6%AE%B5-%E6%BB%A1%E6%98%AF%E7%96%91%E9%97%AE/</link>
      <pubDate>Thu, 03 Oct 2013 19:14:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E6%A0%88%E6%AE%B5-%E6%BB%A1%E6%98%AF%E7%96%91%E9%97%AE/</guid>
      <description>遇到一个问题
比如：
用栈操作将10000H~1000FH中的8个字，逆序拷贝到2000H~2000FH中。
写出以下代码：
mov ax, 2000h mov ds, ax mov ax, f00h mov ss, ax mov sp, 1000h pop [e] pop [c] pop [a] pop [8] pop [6] pop [4] pop [2] pop [0]  开始我还以为可能是栈空间太小，跟以前一样的问题，特意把栈的短地址缩小到f00h，可是还是结果不对，跟踪之后我发现，</description>
    </item>
    
    <item>
      <title>CPU的栈机制的一个小问题</title>
      <link>http://liuxueyang.github.io/posts/cpu%E7%9A%84%E6%A0%88%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 03 Oct 2013 16:10:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/cpu%E7%9A%84%E6%A0%88%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</guid>
      <description>比如要实现下面这个功能。
我们如果要在10000H处写入自行数据2266H，不能用“mov 内存单元， 寄存器”这类指令。怎么做？
代码：
mov ax, 1000h mov ss, ax mov sp, 2 mov ax, 2266h push ax  这段代码，如果是初学，看起来挺对的，一点也没错。</description>
    </item>
    
    <item>
      <title>codeforces Simple Molecules</title>
      <link>http://liuxueyang.github.io/posts/codeforces-simple-molecules/</link>
      <pubDate>Wed, 02 Oct 2013 22:17:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-simple-molecules/</guid>
      <description>link:http://codeforces.com/contest/344/problem/B
刚开始想复杂了。一开始就想当然地以为可以有多个点，其实，人家题目要求只有3个点啊！
然后题目就简单了。
A、B、C代表原子的化合价
x、y、z代表原子之间的化学键
首先x+y+z一定为偶数，否则不可能有解。
那么可以列出一个三元一次的方程组，由3个方程组成，可以求出唯一解。
判断有解的唯一限制条件是：不能出现负数。
#include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>codeforces Magnets</title>
      <link>http://liuxueyang.github.io/posts/codeforces-magnets/</link>
      <pubDate>Wed, 02 Oct 2013 21:39:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-magnets/</guid>
      <description>link: http://codeforces.com/contest/344/problem/A
这道题目很简单。
把输入的01 和10 当做整数，如果相邻两个数字相等的话，那么就属于同一组，否则，就新增加了一组。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>codeforces Expecting Trouble</title>
      <link>http://liuxueyang.github.io/posts/codeforces-expecting-trouble/</link>
      <pubDate>Wed, 02 Oct 2013 21:23:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-expecting-trouble/</guid>
      <description>link:http://codeforces.com/contest/345/problem/A
写完这道题目才发现这场比赛只能用Ada语言提交==
好吧，逗我玩呢
考的是数学期望公式，二项分布的期望E=np
C++代码：（我可不会Ada……=_=）
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int main(void) { char a[51]; double p; #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>空结构体大小是多少？</title>
      <link>http://liuxueyang.github.io/posts/%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91/</link>
      <pubDate>Wed, 02 Oct 2013 19:00:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F%E6%98%AF%E5%A4%9A%E5%B0%91/</guid>
      <description>/* 在VC中，空结构体大小是1。 在gcc中，空结构体大小是0。 */ #include &amp;lt;cstdio&amp;gt; struct student { }stu; int main(void) { printf(&amp;quot;%d\n&amp;quot;, sizeof stu); return 0; }  不同的平台不一样。</description>
    </item>
    
    <item>
      <title>strncpy基本用法</title>
      <link>http://liuxueyang.github.io/posts/strncpy%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link>
      <pubDate>Wed, 02 Oct 2013 09:50:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/strncpy%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid>
      <description>见百度百科。
注意这句话：
（c/c++）复制src中的内容（字符，数字、汉字&amp;hellip;.）到dest，复制多少由num的值决定，返回指向dest的指针。如果遇到null字符（&amp;rsquo;\0&amp;rsquo;），且还没有到num个字符时，就用（num - n）（n是遇到null字符前已经有的非null字符个数）个null字符附加到destination。注意：并不是添加到destination的最后，而是紧跟着由source中复制而来的字符后面。
示例程序：
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdlib&amp;gt; int main(void) { // char *greeting = &amp;quot;hello&amp;quot;; // char *temp = (char*)malloc(6); // strncpy(temp, greeting, 3); // strncpy(temp + 3, &amp;quot;p!</description>
    </item>
    
    <item>
      <title>大三就这么欢乐地开始了</title>
      <link>http://liuxueyang.github.io/posts/%E5%A4%A7%E4%B8%89%E5%B0%B1%E8%BF%99%E4%B9%88%E6%AC%A2%E4%B9%90%E5%9C%B0%E5%BC%80%E5%A7%8B%E4%BA%86/</link>
      <pubDate>Tue, 24 Sep 2013 13:16:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%A4%A7%E4%B8%89%E5%B0%B1%E8%BF%99%E4%B9%88%E6%AC%A2%E4%B9%90%E5%9C%B0%E5%BC%80%E5%A7%8B%E4%BA%86/</guid>
      <description>前天晚上，补考成绩出来。数字逻辑补考挂了。果然。胸中即使有千万只cnm在奔腾也于事无补了。那天晚上在教务系统上看了成绩知道没过之后，跟舍友骂了几句无比kd的老师，发了几句牢骚，然后当做没事儿似的，继续去做家教了……
　昨天，问了一起补考的两个同学，果然，也都没过。大家异口同声的骂了一句**就是个xx，然后早上去院楼找负责选课的老师选上重修的课。答案是，老师不在，下午再来。天空还下着小雨。下午，又跑了一趟，结果发现，别的班的数字逻辑只有3个学分，我们原来的有4个，这样一来，核心课程就少了一个学分，所以，我必须还要再选一门，所以我只能再选一门专业任选课，3个学分的数值分析，为什么我们的数字逻辑是4个学分呢？因为我们的课程旁边写着H，我一直以为代表英语教学，结果老师说，那个代表High，高级，所以呢，院里给你们配的都是最好的老师，嗯，我们点了点头，带着某种微笑。当时就在想，为什么我们班里没有一个人认为这货好？其实还算幸运，有个班的数字逻辑课和我原来的课不冲突，可以选，否则我就只能大四上学期再修这个了……想想都觉得可怕。所以说，我就多了两门课。这样的话，加一块也就24个学分。差一个学分满。
　所以说，课表一下子就充实了。大三就这么欢乐地开始了。
　跟同学说，这学期真他妈的充实=_=
　昨天晚上还有个软件设计基础实验课。要求是学习MFC，然后自己写个小软件。属于老师一点也不教，自己看然后交实验报告的那种课。以前很讨厌MFC这些东西，现在觉得其实貌似也不错，不如认真学一下这货，闲着也是闲着，学着 写个项目神马的。从现在开始，好好学一下MFC吧。又想起一句话，当你排斥一个东西的时候，你就失去了向它学习的机会。</description>
    </item>
    
    <item>
      <title>中秋</title>
      <link>http://liuxueyang.github.io/posts/%E4%B8%AD%E7%A7%8B/</link>
      <pubDate>Thu, 19 Sep 2013 00:35:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E4%B8%AD%E7%A7%8B/</guid>
      <description>开始写这篇随笔的时候，中秋刚刚来临1分钟。
　前几天看到开复的了癌症，当时就在感慨，生命多么脆弱而宝贵啊，不管别的东西怎么样，不过是身外之物，身体和健康才是最重要的啊。记得开复诊断结果出来后，自己在微博上发了一句话：原来，在癌症面前，人人平等。是啊，在命运面前，所有人都是平等的，一样渺小与无助。然后过了几天又忘了这事儿了。刚才无意翻报纸，又看到一条新闻，开复在台湾接受化疗，全身有20多处肿瘤，得病原因据称是作息不规律长期熬夜，以及压力过大导致。只是感觉，每个人都是凡人，要做出非凡的成就，一定需要付出很多，只是那些都不为人所知罢了，付出的代价甚至都无法估量，比如生命和健康。
　一句话，珍惜生命吧。
　最近生活比较凌乱。陷入了极度的空虚和无聊，所以就想到了去做家教。上周日，上了一下午课，一个感觉，累。昨天，嗯，是昨天，过了12点了，下午又找了另一份家教，晚上就去了，又看到了高中的数学，现在感觉，这些题目好亲切啊，很久不这么认真做题目了啊，也许，当初高中那么单纯的生活，才是最幸福的吧，虽然每天沉浸在那些上面，但是那段时间真的是一个人全身心投入学习的一段时期。可惜，再也不会有了。现在，完全不一样了呢。从来没有静下心来坐上两个钟头去认真做题。
　做家教，是下下策吧，花这些时间，虽然一个小时可以得到45元或者50元，但是那又怎么样呢，这些时间，本该去做自己真正想做的事情啊，尤其是在大学的这段时间，可惜，现在，或者最近，什么也不想做，学习，没什么动力。目前先这样吧。对了，还有，挣够了钱，换个手机~^_^差不多两周就足够了~哈哈
　最近，调整状态。</description>
    </item>
    
    <item>
      <title>Candy Store</title>
      <link>http://liuxueyang.github.io/posts/candy-store/</link>
      <pubDate>Wed, 18 Sep 2013 00:55:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/candy-store/</guid>
      <description>Candy Store Time Limit: 30000ms, Special Time Limit:75000ms, Memory Limit:65536KB Total submit users: 6, Accepted users: 6 Problem 12624 : No special judgement Problem description You are walking with a friend, when you pass a candy store.</description>
    </item>
    
    <item>
      <title>Do It Wrong, Get It Right</title>
      <link>http://liuxueyang.github.io/posts/do-it-wrong-get-it-right/</link>
      <pubDate>Wed, 18 Sep 2013 00:53:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/do-it-wrong-get-it-right/</guid>
      <description>Do It Wrong, Get It Right Time Limit: 5000ms, Special Time Limit:12500ms, Memory Limit:65536KB Total submit users: 7, Accepted users: 6 Problem 12627 : No special judgement Problem description In elementary school, students learn to subtract fractions by first getting a common denominator and then subtracting the numerators.</description>
    </item>
    
    <item>
      <title>hdu4737 A Bit Fun ——O(n)做法、错误的做法 &#43; 正确做法</title>
      <link>http://liuxueyang.github.io/posts/hdu4737-a-bit-fun-o-n-%E5%81%9A%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E5%81%9A%E6%B3%95-%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95/</link>
      <pubDate>Sun, 15 Sep 2013 13:31:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu4737-a-bit-fun-o-n-%E5%81%9A%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E5%81%9A%E6%B3%95-%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95/</guid>
      <description>囧== 下面的做法是错误的。下午在路上突然明白了==
哎，到现在还是只知道暴力的做法，囧爆了：http://www.cnblogs.com/liuxueyang/p/3322197.html
类似于前序和的那种思想。
b数组代表前序或，c数组代表后序或。
O(N)预处理出数组b和数组c
在从前往后扫一遍O(N)的复杂度，求出ans
如图：
可以发现c[Head] &amp;amp; b[Tail] 就可以求出任意区间内的f(Head, Tail)，可以知道，整个数组里面每个元素进入区间一次，出去一次，所以是O(N)的复杂度。</description>
    </item>
    
    <item>
      <title>hdu4737 A Bit Fun</title>
      <link>http://liuxueyang.github.io/posts/hdu4737-a-bit-fun/</link>
      <pubDate>Sun, 15 Sep 2013 10:26:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu4737-a-bit-fun/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4737
暴力可以过啊。O(N^2)的复杂度。
#include &amp;lt;cstdio&amp;gt; int a[100001]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>codeforces 199a</title>
      <link>http://liuxueyang.github.io/posts/codeforces-199a/</link>
      <pubDate>Thu, 12 Sep 2013 19:16:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-199a/</guid>
      <description>link:http://codeforces.com/contest/342/problem/A
恩恩，读错题了。人家是at most 7，我理解成了at lease 7。好欢乐~
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; int cnt[8]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>读书笔记4</title>
      <link>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B04/</link>
      <pubDate>Thu, 05 Sep 2013 00:21:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B04/</guid>
      <description>今天一天看完一本推理小说w_w
《预知梦》 作者：东野圭吾 ——推理小说
讲了5个故事：
预知梦：一个男子童年时梦到一个女孩是她将来的妻子。17年后，竟然相同名字的女孩出现了。跟踪+骚扰之。真相，女孩的妈妈A在17年前出轨，那个男子B有一个小女孩，后来这个女孩死了，之前A对这个小女孩很好，送给了她一个布娃娃，小女孩给布娃娃取了一个名字，叫礼美。女孩死后，布娃娃送给了那个小男孩，之前小男孩经常和小女孩一起玩，也许这就留下了心理阴影。之后，A生了个女孩，起了个名字叫礼美，可能是无意识的，也可能是有意识的。A意识到男孩的出现，必然会让17年前的事情暴露，所以诱导男孩晚上闯入女孩房间，自己拿步枪杀之，未遂。 见到幽魂：爱摄影的女子A不巧拍到了车祸，勒索。最后被肇事者情侣陷害，为了伪造完美的不在场证明，女方扮成A的样子出现在一个地方，同时男方在A的房间内杀之。 骚灵：所谓骚灵不过是房子和下水管道的共振现象。凶手为了老太太的巨额一场把老太太杀死，被经常看老太太的男子A发现，接着A被杀死，在屋子里挖了一个坑，把尸体藏在里面。最后比较令人感动的是，老太太生前把自己的卡式银行保险箱钥匙给了素不相识但是经常去看望她照顾她的男子A，保险箱里面有巨额存折+遗书，明确写着遗产全部赠与男子A，只可惜…… 鬼火之谜：工厂主人为了挽救工厂前一个月内投了好几份保险，然后自己伪装成他杀的自杀，目的是得到保险金，他没跟妻子说，知道妻子肯定不会同意的，更悲剧的是，妻子察觉到了，暗中协助之，并且让警方开始把目标锁定自己，然后自己再拿出完美的不在场证明。唉，只能说，可能是被逼的没办法了吧。至少，厂主是值得尊敬的，为了别人献出了自己宝贵的生命。就像天才侦探+物理学家汤川说的那句：我倒是希望他们拿到那份保险金呢。也许他们不会把真想说出去吧。因为一年之内的自杀不能得到保险赔偿。所谓鬼火，就是厂长试验自杀方法的时候的火苗，方式很复杂，用两根弓箭线+通电+安眠药。好吧，天才的手段。 少女篇：很复杂。觉得没意思。两对夫妻，涉及到两个出轨。⊙﹏⊙b汗 大概就是一个女子以死威胁，假装自杀，结果真的“自杀”了，当然，其实是被谋杀了。所谓少女，就是10岁的女孩在晚上恰好看到了女子之前试验自杀方式的样子，结果后来真的发生了。为什么被谋杀呢？动机：假装自杀一定不会成功，那么女子就成了最大的威胁。  这本书写的还不错w_w</description>
    </item>
    
    <item>
      <title>codeforces 340C Tourist Problem</title>
      <link>http://liuxueyang.github.io/posts/codeforces-340c-tourist-problem/</link>
      <pubDate>Wed, 04 Sep 2013 00:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-340c-tourist-problem/</guid>
      <description>link:http://codeforces.com/problemset/problem/340/C
开始一点也没思路，赛后看别人写的代码那么短，可是不知道怎么推出来的啊！
后来明白了。
首先考虑第一个数字，就是和0想减的内个。那么剩下的n-1个数字有(n-1)!个排列方式。所以呢，在n!个式子里面，第一个位置的和就是：a1 * (n-1)! + a2 * (n-1)! + &amp;hellip;&amp;hellip; + an * (n-1)!</description>
    </item>
    
    <item>
      <title>cf340D Bubble Sort Graph</title>
      <link>http://liuxueyang.github.io/posts/cf340d-bubble-sort-graph/</link>
      <pubDate>Wed, 04 Sep 2013 00:36:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/cf340d-bubble-sort-graph/</guid>
      <description>link:http://codeforces.com/problemset/problem/340/D
感觉很好的一道题目。
认真思考，发现，逆序的数字对一定有边相连。所以，题目要求没有边相连的最大的集合的点的个数，其实就是找原来的序列的最长上升子序列！
/* * Filename: tourist.cpp * Created: 09/01/2013 09:07:05 AM * Author: liuxueyang (lxy), zypz457@sina.</description>
    </item>
    
    <item>
      <title>读书笔记3</title>
      <link>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03/</link>
      <pubDate>Tue, 03 Sep 2013 23:04:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B03/</guid>
      <description>这段时间懒得写博客了。
还是写一点吧。
最近看完的书：
《天才在左，疯子在右》 作者：高铭 ——心理学科普类
超级有意思的一本书，现在开始明白为什么有很多人都对心理学感兴趣了，人的精神世界真的很奇妙。
世界上有太多的未知，我们都被未知奴役着。只能怀着敬畏的心态，面对这个充满神奇的世界吧。有太多超出我们想象的东西了，也有太多不能解释的东西了。
《目送》 作者：龙应台 ——散文、随笔</description>
    </item>
    
    <item>
      <title>hdu4497 GCD and LCM ——素数分解&#43;计数</title>
      <link>http://liuxueyang.github.io/posts/hdu4497-gcd-and-lcm-%E7%B4%A0%E6%95%B0%E5%88%86%E8%A7%A3-%E8%AE%A1%E6%95%B0/</link>
      <pubDate>Mon, 26 Aug 2013 00:09:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu4497-gcd-and-lcm-%E7%B4%A0%E6%95%B0%E5%88%86%E8%A7%A3-%E8%AE%A1%E6%95%B0/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4497
如果G%L != 0，说明一定无解。
把K = G / L质数分解，G / L = p1^t1 * p2^t2 * p3^t3 * ……；同时 x/= L, y/= L, z/=L，不影响结果。</description>
    </item>
    
    <item>
      <title>poj1026 Cipher ——置换群</title>
      <link>http://liuxueyang.github.io/posts/poj1026-cipher-%E7%BD%AE%E6%8D%A2%E7%BE%A4/</link>
      <pubDate>Sun, 25 Aug 2013 08:55:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1026-cipher-%E7%BD%AE%E6%8D%A2%E7%BE%A4/</guid>
      <description>link:http://poj.org/problem?id=1026
其实这道题目和poj2369这道题目一样。
都是基础的置换群题目。把那道题目理解了，这道题就没问题了。
不过我的方法貌似比较挫，或者处理方法效率不高，比较慢……
就是对每个数字求出循环节，用rec[]保存，然后用k%rec[]得到余数，
再模拟这个余数次就得到了目标位置。
/* ID: zypz4571 LANG: C++ TASK: decode.</description>
    </item>
    
    <item>
      <title>poj2369 Permutations ——置换群</title>
      <link>http://liuxueyang.github.io/posts/poj2369-permutations-%E7%BD%AE%E6%8D%A2%E7%BE%A4/</link>
      <pubDate>Sat, 24 Aug 2013 17:44:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2369-permutations-%E7%BD%AE%E6%8D%A2%E7%BE%A4/</guid>
      <description>link:http://poj.org/problem?id=2369
置换群，最简单的那种。
找所有数字循环节的最小公倍数。
/* ID: zypz4571 LANG: C++ TASK: permutations.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int a[1111]; bool flag[1111]; int gcd(int x, int y) { return y == 0 ?</description>
    </item>
    
    <item>
      <title>2009年到2013年甲子园ED</title>
      <link>http://liuxueyang.github.io/posts/2009%E5%B9%B4%E5%88%B02013%E5%B9%B4%E7%94%B2%E5%AD%90%E5%9B%ADed/</link>
      <pubDate>Fri, 23 Aug 2013 11:47:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2009%E5%B9%B4%E5%88%B02013%E5%B9%B4%E7%94%B2%E5%AD%90%E5%9B%ADed/</guid>
      <description>2009年
http://v.youku.com/v_show/id_XMTY3MTM4NjQw.html
2010年 最喜欢的一个！看过N遍
http://v.youku.com/v_show/id_XMjAwMzEwMDI4.html
2011年
http://v.youku.com/v_show/id_XMjk3NTQ4OTky.html
也不错！
2012年 超级好听啊~^_^比10年的还好，看过N+1遍……o(╯□╰)o</description>
    </item>
    
    <item>
      <title>使用STL离散化</title>
      <link>http://liuxueyang.github.io/posts/%E4%BD%BF%E7%94%A8stl%E7%A6%BB%E6%95%A3%E5%8C%96/</link>
      <pubDate>Thu, 22 Aug 2013 09:47:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E4%BD%BF%E7%94%A8stl%E7%A6%BB%E6%95%A3%E5%8C%96/</guid>
      <description>把原来的数组a复制一份拷贝b 用sort先把数组a排序 用unique消除a里面重复的元素 对于b中的每一个元素，用lower_bound找到它在a中的位置，也就是离散化之后的编号。 没了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int main(void) { int a[6] = {15, 14, 11, 20, 13, 13}, b[111]; for (int i=0; i &amp;lt; 6; ++i) b[i] = a[i]; sort(a, a+6); int len = unique(a, a+6) - a; for (int i = 0;i &amp;lt; 6; ++i) b[i] = lower_bound(a, a+len, b[i]) - a + 1; for (int i = 0; i &amp;lt; 6; ++i) printf(&amp;quot;%d &amp;quot;, b[i]); printf(&amp;quot;\n&amp;quot;); return 0; }  嗨！中村。</description>
    </item>
    
    <item>
      <title>读书笔记2</title>
      <link>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02/</link>
      <pubDate>Thu, 22 Aug 2013 07:59:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B02/</guid>
      <description>从17日下午到21日中午，用三天多的时间第一次完整地看完了《TOUCH》這部經典漫畫，看到结尾的时候，有点后悔了，其实，我应该再看慢一点的，经典作品，这么快就看完总觉得很可惜啊o(╯□╰)o。
26卷，每卷185页左右，总共大約4810页，照这个节奏，如果kpw不是触屏的，按键会不会残了！？
只是柏叶教练的一句话到现在还记忆犹新：我喜欢夏天啊。
《TOUCH》經典片段：（有很多安達充式的幽默~）
很久很久以前，在某个地方……有一只戴着捕手面具的肥猪。
认识和也真是一件自豪地事情呢。
认识我呢？
是个笑话
……
走吧，小胖！</description>
    </item>
    
    <item>
      <title>hdu4691 Front compression ——暴力 || 后缀数组</title>
      <link>http://liuxueyang.github.io/posts/hdu4691-front-compression-%E6%9A%B4%E5%8A%9B-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 21 Aug 2013 17:08:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu4691-front-compression-%E6%9A%B4%E5%8A%9B-%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4691
暴力，数据明显太水了吧，n=10^5, O(n^2)的复杂度哎喂。想让大家暴力写直接让n=1000不就得了么，这算什么。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; char a[111111], b[11111]; //#define LL long long #define LL __int64 int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu4690 EBCDIC ——水题，考耐心</title>
      <link>http://liuxueyang.github.io/posts/hdu4690-ebcdic-%E6%B0%B4%E9%A2%98%E8%80%83%E8%80%90%E5%BF%83/</link>
      <pubDate>Tue, 20 Aug 2013 20:17:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu4690-ebcdic-%E6%B0%B4%E9%A2%98%E8%80%83%E8%80%90%E5%BF%83/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4690
考的是耐心何细心啊，用map把两个表格映射一下就行~
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; string A[16][16] = { &amp;quot;NUL&amp;quot;,&amp;quot;SOH&amp;quot;,&amp;quot;STX&amp;quot;,&amp;quot;ETX&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;HT&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;DEL&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;VT&amp;quot;,&amp;quot;FF&amp;quot;,&amp;quot;CR&amp;quot;,&amp;quot;SO&amp;quot;,&amp;quot;SI&amp;quot;, &amp;quot;DLE&amp;quot;,&amp;quot;DC1&amp;quot;,&amp;quot;DC2&amp;quot;,&amp;quot;DC3&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;BS&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;CAN&amp;quot;,&amp;quot;EM&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;IFS&amp;quot;,&amp;quot;IGS&amp;quot;,&amp;quot;IRS&amp;quot;,&amp;quot;IUS ITB&amp;quot;, &amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;LF&amp;quot;,&amp;quot;ETB&amp;quot;,&amp;quot;ESC&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;ENQ&amp;quot;,&amp;quot;ACK&amp;quot;,&amp;quot;BEL&amp;quot;, &amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;SYN&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;EOT&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;DC4&amp;quot;,&amp;quot;NAK&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;SUB&amp;quot;, &amp;quot;SP&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;.</description>
    </item>
    
    <item>
      <title>hdu4686 Arc of Dream ——构造矩阵&#43;快速幂</title>
      <link>http://liuxueyang.github.io/posts/hdu4686-arc-of-dream-%E6%9E%84%E9%80%A0%E7%9F%A9%E9%98%B5-%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Tue, 20 Aug 2013 20:12:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu4686-arc-of-dream-%E6%9E%84%E9%80%A0%E7%9F%A9%E9%98%B5-%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>link: http://acm.hdu.edu.cn/showproblem.php?pid=4686
构造出来的矩阵是这样的：根据题目的ai * bi = ……，可以发现 矩阵1 * 矩阵3 = 矩阵2。然后就是矩阵快速幂了。</description>
    </item>
    
    <item>
      <title>就说一句</title>
      <link>http://liuxueyang.github.io/posts/%E5%B0%B1%E8%AF%B4%E4%B8%80%E5%8F%A5/</link>
      <pubDate>Tue, 20 Aug 2013 10:09:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%B0%B1%E8%AF%B4%E4%B8%80%E5%8F%A5/</guid>
      <description>做了一年ACM，今天才顿悟，为什么还一直处于这么渣的阶段，原来是打开方式不对！
更多的是看例题，写实现，思考算法，体会算法思想，而不是想都不想就上去飞快的敲代码，然后找无穷无尽的BUG！
所以，以后多想，多看论文，少敲键盘吧。如果一个算法没理解就去做题，基本是必然会写错的，即使是小错也会浪费很多时间。</description>
    </item>
    
    <item>
      <title>ural 1057Amount of Degrees ——数位DP</title>
      <link>http://liuxueyang.github.io/posts/ural-1057amount-of-degrees-%E6%95%B0%E4%BD%8Ddp/</link>
      <pubDate>Tue, 20 Aug 2013 09:26:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/ural-1057amount-of-degrees-%E6%95%B0%E4%BD%8Ddp/</guid>
      <description>link:http://acm.timus.ru/problem.aspx?space=1&amp;amp;num=1057
论文： 浅谈数位类统计问题 刘聪
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int a[33][33]; int bto2(int x, int b) { int tm[33], cnt = 0, ans = 0; while (x) { tm[cnt++] = x % b; x /= b; } for (int i = cnt - 1; i &amp;gt;= 0; --i) { if (tm[i] &amp;amp;&amp;amp; (tm[i] !</description>
    </item>
    
    <item>
      <title>codeforces mysterious present 最长上升子序列&#43;倒序打印路径</title>
      <link>http://liuxueyang.github.io/posts/codeforces-mysterious-present-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-%E5%80%92%E5%BA%8F%E6%89%93%E5%8D%B0%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Mon, 19 Aug 2013 15:22:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-mysterious-present-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-%E5%80%92%E5%BA%8F%E6%89%93%E5%8D%B0%E8%B7%AF%E5%BE%84/</guid>
      <description>link:http://codeforces.com/problemset/problem/4/D
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int n,w,h,cnt,ans,d[5009],path[5009],End; bool flag; typedef struct node { int W,H,In; bool operator &amp;lt; (const node &amp;amp;other) const { if(W!</description>
    </item>
    
    <item>
      <title>读书笔记1</title>
      <link>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Sun, 18 Aug 2013 14:09:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B01/</guid>
      <description>不想说什么了，今天一大早来机房，就为了写这两天的读书笔记，做点摘抄什么的，马不停蹄，人不停爪地敲了一个多小时，手都抽筋了，写完的时候，添加标签的时候，界面一刷新，然后什么都没有了！有想砸电脑的冲动啊。博客园的后台编辑器支持自动保存的，不过只支持IE9内核以上的和chrome以及firefox的浏览器，好吧。算我倒霉了。还是简要记录一下吧，早上写的一堆白写了。不忍心。
8月16日中午kpw到货，激动啊。一直很后悔的就是大学里面没有怎么读书，很多想读的书都没有看过，所以剩下的时间里多看看书吧。
8月16日
《我所理解的生活》韩寒
一下午+晚上读完了，很可惜，很多文章都是看过的，或者是再韩寒的博客上或者是在读者青年文摘上。不过总的来说还是不错的。
8月17日
《小王子》
小学的时候就看过这本书，大一的时候看过一遍英文版的，上午读完了一遍，每一次读都有不同的感受，尤其是在不同的阶段，不同的心境下。很美丽的一个童话。
昨晚看一然酱的kindle，好吧，好多技术方面的书啊，linux,python,Haskell各种啊，我的里面从汉书到韩寒到漫画都有啊，一本学习的书都没有啊，这就是传说中的茶具么？好吧，其实即使有学习的书，我想按照我这个阅读的优先级，我也是永远也不会看的o(╯□╰)o其实kindle除了看小说，看散文漫画什么的超级方便以外，看技术的书确实也不方便啊，尤其是需要翻来翻去的那种书。
一天之中最宁静的时光，就是深夜躺在楼顶，伴着月光，静静地看书，困了就昏睡过去，凌晨醒来，一边欣赏着美丽的朝霞，一边继续懒散地看书，然后一天又开始了。</description>
    </item>
    
    <item>
      <title>codeforces105d Bag of mice ——概率DP</title>
      <link>http://liuxueyang.github.io/posts/codeforces105d-bag-of-mice-%E6%A6%82%E7%8E%87dp/</link>
      <pubDate>Sun, 18 Aug 2013 11:09:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces105d-bag-of-mice-%E6%A6%82%E7%8E%87dp/</guid>
      <description>Link:
http://codeforces.com/problemset/problem/148/D
Refer to:
http://www.cnblogs.com/kuangbin/archive/2012/10/04/2711184.html
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; double a[1111][1111]; int main(void) { int w,b; #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>zoj3551 Bloodsucker ——概率DP</title>
      <link>http://liuxueyang.github.io/posts/zoj3551-bloodsucker-%E6%A6%82%E7%8E%87dp/</link>
      <pubDate>Sun, 18 Aug 2013 10:19:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj3551-bloodsucker-%E6%A6%82%E7%8E%87dp/</guid>
      <description>Link: http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=4530
A[i]数组表示当吸血鬼有 I 个的时候，还需要的天数。可以列出方程：
A[i] = p1(a[i+1]+1) + (1-p1)(a[i]+1) p1=(i*(n-i))p / (n(n-1)/2)</description>
    </item>
    
    <item>
      <title>codeforces298c</title>
      <link>http://liuxueyang.github.io/posts/codeforces298c/</link>
      <pubDate>Sat, 17 Aug 2013 10:40:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces298c/</guid>
      <description>link:http://codeforces.com/problemset/problem/298/C 这道题目可以看出来我智商确实拙计
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; char a[1111],b[1111]; int main(void) { scanf(&amp;quot;%s%s&amp;quot;,a,b); int lena=strlen(a),lenb=strlen(b),cnt1=0,cnt2=0; for(int i=0;i&amp;lt;lena;++i) if(a[i]==&#39;1&#39;) cnt1++; for(int i=0;i&amp;lt;lenb;++i) if(b[i]==&#39;1&#39;) cnt2++; bool flag=true; if(cnt1%2==1) cnt1++; if(cnt1&amp;lt;cnt2) flag=false; if(flag) printf(&amp;quot;YES\n&amp;quot;); else printf(&amp;quot;NO\n&amp;quot;); return 0; }  拙计o(╯□╰)o</description>
    </item>
    
    <item>
      <title>poj1458 Common Subsequence ——最长公共子序列</title>
      <link>http://liuxueyang.github.io/posts/poj1458-common-subsequence-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sat, 17 Aug 2013 10:38:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1458-common-subsequence-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>link:http://poj.org/problem?id=1458 最基础的那种
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int sad[1111][1111];char apple[1111],pear[1111]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>codeforces194b</title>
      <link>http://liuxueyang.github.io/posts/codeforces194b/</link>
      <pubDate>Thu, 15 Aug 2013 19:00:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces194b/</guid>
      <description>link:http://codeforces.com/problemset/problem/334/B
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int main(void) { set&amp;lt;int&amp;gt; sadx, sady; int x[9] ,y[9] ; bool flag = true; for (int i=0;i&amp;lt;8;++i) { scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;x[i],&amp;amp;y[i]); sadx.</description>
    </item>
    
    <item>
      <title>codeforces194a</title>
      <link>http://liuxueyang.github.io/posts/codeforces194a/</link>
      <pubDate>Thu, 15 Aug 2013 18:53:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces194a/</guid>
      <description>link:http://codeforces.com/contest/334/problem/A 很有意思的一道构造题。发现CF上经常出这种不难但是很不错的构造题。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int main(void) { int n; while (~scanf(&amp;quot;%d&amp;quot;,&amp;amp;n)) for (int i=1;i&amp;lt;=n*n/2;++i) { for (int j=1;j&amp;lt;=n/2;++j) { printf(&amp;quot;%d %d &amp;quot;,i,n*n-i+1); ++i; } i--; printf(&amp;quot;\n&amp;quot;); } return 0; }  o(╯□╰)o 官方解题报告上面写的很明白 1　n^2 2　n^2-1 .</description>
    </item>
    
    <item>
      <title>codeforces195c</title>
      <link>http://liuxueyang.github.io/posts/codeforces195c/</link>
      <pubDate>Thu, 15 Aug 2013 18:41:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces195c/</guid>
      <description>link:http://codeforces.com/problemset/problem/336/C 从大到小枚举，如果对应的二进制位不等于0，就加进来，最后的sum如果%2^k==0那么就是合法的。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int a[111111]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>codeforces195a</title>
      <link>http://liuxueyang.github.io/posts/codeforces195a/</link>
      <pubDate>Thu, 15 Aug 2013 18:36:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces195a/</guid>
      <description>link:http://codeforces.com/problemset/problem/336/A 很简单的一道题目，当初有个单词不认识，isosceles原来意思是等腰的o(╯□╰)o
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu4671 Backup Plan ——构造题</title>
      <link>http://liuxueyang.github.io/posts/hdu4671-backup-plan-%E6%9E%84%E9%80%A0%E9%A2%98/</link>
      <pubDate>Thu, 15 Aug 2013 18:31:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu4671-backup-plan-%E6%9E%84%E9%80%A0%E9%A2%98/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4671 其实是不难的那种构造题，先排第一列，第二列从后往前选。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int sad[111], fun[111][111]; int main(void) { int n, m; while (~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m)) { for(int i=1;i&amp;lt;=n;++i) { sad[i]=m/n; if(i&amp;lt;=m%n) sad[i]++; } int row=1; for(int i=1;i&amp;lt;=n;++i) { int k=n; for(int j=1;j&amp;lt;=sad[i];++j) { while (i==k||k==0) {if(i==k) k--; if(k==0) k=n;} fun[row][0]=i; fun[row][1]=k; k--; row++; } } for(int i=1;i&amp;lt;=m;++i) { printf(&amp;quot;%d %d&amp;quot;,fun[i][0],fun[i][1]); for(int j=1;j&amp;lt;=n;++j) { if(j!</description>
    </item>
    
    <item>
      <title>hdu4666 Hyperspace ——曼哈顿距离</title>
      <link>http://liuxueyang.github.io/posts/hdu4666-hyperspace-%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Thu, 15 Aug 2013 18:26:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu4666-hyperspace-%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4666 这题学会了怎么处理曼哈顿距离。 比如维数是k，那么每个点有2^k个状态，求出在每个状态下，所有点的最大值，最小值，求他们的差，从中找到最大值就行。 开始觉得不好处理的是，删除的时候怎么办。比如要删除一个点，我可以在2^k个中的每个状态里面先找到这个点在这个状态下的值，删除这个值就行了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; multiset&amp;lt;int&amp;gt; a[44]; int sad[66666][10],will[66666][44]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>poj3181 Dollar Dayz ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/poj3181-dollar-dayz-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 18:14:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj3181-dollar-dayz-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://poj.org/problem?id=3181 本来很常规的一道完全背包，比较有意思的一点是，结果会超int，更有意思的解决方法是，不用高精度，用两个整型的拼接起来就行了。ORZ
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; typedef unsigned long long ULL; ULL dp[1111], dp1[1111]; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>uva147 Dollars      ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/uva147-dollars------%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 18:03:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva147-dollars------%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=83 和完全背包一样的思想。 有两个trick： 没了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; long long d[33333]; int a[11]={5,10,20,50,100,200,500,1000,2000,5000,10000}; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>uva674 Coin Change ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/uva674-coin-change-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:59:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva674-coin-change-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=615 和完全背包一样的思想。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int a[5]={1,5,10,25,50}; int f[7777]; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu2191 悼念512汶川大地震     ——多重背包</title>
      <link>http://liuxueyang.github.io/posts/hdu2191-%E6%82%BC%E5%BF%B5512%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%87-----%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:54:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu2191-%E6%82%BC%E5%BF%B5512%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%87-----%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=2191 最简单的那种
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int n, V, t, f[111], c[111], w[111], m[111]; void zeropack(int c, int w) { for (int v=V; v&amp;gt;=c; --v) { f[v]=max(f[v],f[v-c]+w); } return; } void completepack(int c, int w) { for (int v=c;v&amp;lt;=V;++v) f[v]=max(f[v],f[v-c]+w); return; } void multipack(int c, int w, int m) { if (c*m &amp;gt;= V) { completepack(c,w); return; } int k=1; while (k&amp;lt;m) { zeropack(c*k,w*k); m-=k; k*=2; } zeropack(c*m,w*m); return; } int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu1059 Dividing ——多重背包</title>
      <link>http://liuxueyang.github.io/posts/hdu1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=1059 最简单的那种
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int V,m[6],c[6],w[6],f[66666]; void zeropack(int c, int w) { for (int v=V;v&amp;gt;=c;--v) f[v]=max(f[v],f[v-c]+w); return; } void completepack(int c,int w) { for(int v=c;v&amp;lt;=V;++v) f[v]=max(f[v],f[v-c]+w); return; } void multipack(int c,int w,int m) { if(c*m&amp;gt;=V) { completepack(c,w); return; } int k=1; while (k&amp;lt;m) { zeropack(k*c,k*w); m-=k; k*=2; } zeropack(c*m,w*m); return; } int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu1114 Piggy-Bank ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/hdu1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:47:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=1114 只不过求得是最小值。没什么可说的，连我都会做……o(╯□╰)o
/* ID: zypz4571 LANG: C++ TASK: pig.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int f[11111],c[555],w[555], V, n; void completepack(int c,int w) { for(int v=c;v&amp;lt;=V;++v) f[v]=min(f[v],f[v-c]+w); } int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>zoj3623 Battle Ships ——完全背包？简单DP！|| 泛化背包</title>
      <link>http://liuxueyang.github.io/posts/zoj3623-battle-ships-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%AE%80%E5%8D%95dp-%E6%B3%9B%E5%8C%96%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:43:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj3623-battle-ships-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%AE%80%E5%8D%95dp-%E6%B3%9B%E5%8C%96%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3623 看起来像完全背包，但是物品价值是变化的，所以很多人搞的很复杂。 晚上的代码要么很复杂，有一个代码虽然很简洁在zoj可以过，但是是错误的。求教lyl神犇，果然思想很深刻，抓住乐问题的本质，想法比网上搜到的所有博客里面的做法都简洁。 事实上，就是简单的DP，抓住一个技巧：让时间倒流，也就是说，把时间反过来考虑，先在将来把船造好，然后在过去用船攻击，哈哈，太巧秒了，说起来很别扭，很有意思，dp[j+time[i]]=max(dp[j]+j*time[i])；dp[j]表示在j这个时间，所造成的最大伤害。这样就可以枚举时间，在每个特定的时间内，枚举船的种类，找到最大值。最终在dp[]数组里面找到符合条件的并且时间最少的解。 只能说，ORZ…… 后来好不容易想明白了。茶具从哪里来……
/* ID: zypz4571 LANG: C++ TASK: battle.</description>
    </item>
    
    <item>
      <title>poj3249 Test for Job  ——拓扑&#43;DP</title>
      <link>http://liuxueyang.github.io/posts/poj3249-test-for-job--%E6%8B%93%E6%89%91&#43;dp/</link>
      <pubDate>Thu, 15 Aug 2013 17:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj3249-test-for-job--%E6%8B%93%E6%89%91&#43;dp/</guid>
      <description>link:http://poj.org/problem?id=3249 在拓扑排序的过程中进行状态转移，dp[i]表示从起点到 i 这个点所得到的的最大值。比如从u点到v点，dp[v]=max(dp[v], dp[u]+a[v]) a[]数组是点的价值，最终的dp[]数组里面的最大值就是所求的。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; #define N 111111 using namespace std; int WO[N],NI[N],dp[N],TA[N]; vector&amp;lt;int&amp;gt; V[N]; queue&amp;lt;int&amp;gt; QU; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu3033 I love sneakers!        分组背包变形</title>
      <link>http://liuxueyang.github.io/posts/hdu3033-i-love-sneakers--------%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E5%8F%98%E5%BD%A2/</link>
      <pubDate>Sun, 11 Aug 2013 18:24:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu3033-i-love-sneakers--------%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E5%8F%98%E5%BD%A2/</guid>
      <description>分组背包要求每一组里面只能选一个，这个题目要求每一组里面至少选一个物品。 dp[i, j] 表示前 i 组里面在每组至少放进一个物品的情况下，当花费 j 的时候，所得到的的最大价值。这个状态可以由三个状态转移过来： a[i, j].b表示第 i 组第 j 个物品的花费，v表示背包容量。 初始化： 如果一种物品都不放，那么对应的所有的背包容量都是0，也就是：dp[0, 0~M] = 0； 其他的情况，都初始化成-INF。</description>
    </item>
    
    <item>
      <title>hdu1712 ACboy needs your help    分组背包</title>
      <link>http://liuxueyang.github.io/posts/hdu1712-acboy-needs-your-help----%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</link>
      <pubDate>Sun, 11 Aug 2013 16:20:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1712-acboy-needs-your-help----%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</guid>
      <description>最基础的分组背包~
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int dp[102], a[102][102]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>当我把电脑500G硬盘格式化了的时候，在想些什么</title>
      <link>http://liuxueyang.github.io/posts/%E5%BD%93%E6%88%91%E6%8A%8A%E7%94%B5%E8%84%91500g%E7%A1%AC%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BA%86%E7%9A%84%E6%97%B6%E5%80%99%E5%9C%A8%E6%83%B3%E4%BA%9B%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sun, 11 Aug 2013 15:01:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%BD%93%E6%88%91%E6%8A%8A%E7%94%B5%E8%84%91500g%E7%A1%AC%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BA%86%E7%9A%84%E6%97%B6%E5%80%99%E5%9C%A8%E6%83%B3%E4%BA%9B%E4%BB%80%E4%B9%88/</guid>
      <description>所以我就想重新尝试一下怎么装多系统，bootloader,MBR到底是怎么回事儿。 简要记录一下： 首先，在可以作为启动盘的Ｕ盘里面，备份一份可以用的WinXP镜像+校园网客户端安装文件+驱动精灵安装文件。然后再说别的。 我的硬盘初步规划是这样的：把硬盘分成4个分区，3P+1E。也就是3个主分区，1个扩展分区。每个50G。硬盘主分区最多有4个，为了以后装Linux，我分了3个主分区，一个用来装WinXP，另外两个装Ubuntu，CentOS。扩展分区再划分出几个逻辑分区：分出100G作为WinXP里面的D盘，装软件；再分出100G作为WinXP里面的E盘，存文档。足够用。剩下的100+G，分出1G作为Ubuntu的swap分区，再分出1G作为CentOS的swap分区。剩下的作为空闲分区备用。 这样三个主分区编号分别是：/dev/sda1 /dev/sda2 /dev/sda3 D，E两个盘的编号是：/dev/sda5 /dev/sda6 两个swap分区的编号是：/dev/sda7 /dev/sda8 先装winXP系统，找一个Ghost版的，把U盘用大白菜制作成启动盘，进入PE，还原系统就行了。 然后装Ubuntu，自己有一张安装盘，12.</description>
    </item>
    
    <item>
      <title>hdu2955 Robberies 　０１背包＋概率</title>
      <link>http://liuxueyang.github.io/posts/hdu2955-robberies-%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85%E6%A6%82%E7%8E%87/</link>
      <pubDate>Tue, 06 Aug 2013 11:06:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu2955-robberies-%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85%E6%A6%82%E7%8E%87/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=2955 首先，这个题目的背包容量不能是概率．１．精度不清楚．２．把概率相加有什么意义呢？所以，转换一下，把所有银行的珠宝和当作背包容量，把小偷安全的概率当作物品价值．可以先求出背包尽可能满的情况下，安全概率最大的解．然后在这些解里面，找出安全概率满足大于１－Ｐ的并且价值最大的就行． 题目读清楚．人给的是被抓住的概率和每个银行被抓住的概率．这个是不能直接用的．比如连续偷几个银行，就要分别算出安全的概率，这样概率就可以直接相乘了． 只要要偷的几个银行的安全概率的积大于１－P就行．
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int V, n, c[11111]; double w[11111], f[11111]; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>uva562 Dividing coins   01背包</title>
      <link>http://liuxueyang.github.io/posts/uva562-dividing-coins---01%E8%83%8C%E5%8C%85/</link>
      <pubDate>Tue, 06 Aug 2013 10:45:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva562-dividing-coins---01%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=503 分成２半，并且两半的差距最小，背包的体积变成V/2
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int V, c[111], w[111], f[55555], n; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>uva624 CD　　　０１背包&#43;输出最优解</title>
      <link>http://liuxueyang.github.io/posts/uva624-cd%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85&#43;%E8%BE%93%E5%87%BA%E6%9C%80%E4%BC%98%E8%A7%A3/</link>
      <pubDate>Tue, 06 Aug 2013 10:41:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva624-cd%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85&#43;%E8%BE%93%E5%87%BA%E6%9C%80%E4%BC%98%E8%A7%A3/</guid>
      <description>link:http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=565 用一个二维数组g[i][v]表示：当状态转移到v的时候，第i个物品是不是用到，如果用到标记１，否则标记０． 输出路径的时候，注意，从物品编号０一直到n-1.如果某个物品被用到了，g[i][v]里面的v，就要减去这个物品的体积，然后继续往下找．
/* * ===================================================================================== * Filename: cd.cpp * Created: 04/08/2013 15:21:34 * Author: liuxueyang (lxy), 1459917536@qq.</description>
    </item>
    
    <item>
      <title>hdu2546　饭卡　　　　０１背包</title>
      <link>http://liuxueyang.github.io/posts/hdu2546%E9%A5%AD%E5%8D%A1%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85/</link>
      <pubDate>Tue, 06 Aug 2013 10:31:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu2546%E9%A5%AD%E5%8D%A1%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=2546 也算一个贪心的想法吧． 先把总钱数减去５，再把价值最大的挑出来．然后用０１背包．最终买下挑出来的那个价值最大的商品．这样的话，我就实现了最终用最少的钱数买了价值最多的商品，剩下钱数当然也是最少了．
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int main(void) { ios::sync_with_stdio(false); int n, V; int c[1111], f[1111]; #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>sgu259　Printed PR　　　　贪心</title>
      <link>http://liuxueyang.github.io/posts/sgu259printed-pr%E8%B4%AA%E5%BF%83/</link>
      <pubDate>Tue, 06 Aug 2013 10:27:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/sgu259printed-pr%E8%B4%AA%E5%BF%83/</guid>
      <description>link:http://acm.sgu.ru/problem.php?contest=0&amp;amp;problem=259 思路就是贪心． 首先要读懂题目，输入的方式，把样例读懂． 第一，打印的总时间一定．需要做的就是送出的时间尽可能的重合，这样总时间就会更少．所以，送出时间长的要尽可能的先打印，按照送出时间从大到小排序就可以了．
/* * ===================================================================================== * Filename: 259.cpp * Created: 06/08/2013 10:15:09 * Author: liuxueyang (lxy), 1459917536@qq.</description>
    </item>
    
    <item>
      <title>hdu4632 Palindrome subsequence     ——区间动态规划</title>
      <link>http://liuxueyang.github.io/posts/hdu4632-palindrome-subsequence-----%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Sat, 03 Aug 2013 16:19:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu4632-palindrome-subsequence-----%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4632 refer to: o(╯□╰)o……明明百度找的题解，然后后来就找不到我看的那份了，这位哥们对不住了……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; char a[1111]; int dp[1111][1111]; const int MOD = 10007; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu4642 Fliping game        ——博弈</title>
      <link>http://liuxueyang.github.io/posts/hdu4642-fliping-game--------%E5%8D%9A%E5%BC%88/</link>
      <pubDate>Sat, 03 Aug 2013 10:52:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu4642-fliping-game--------%E5%8D%9A%E5%BC%88/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4642 refer to: http://www.cnblogs.com/jackge/archive/2013/08/01/3231573.html 这道题目很有意思。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu4639 hehe      ——斐波纳契数列，找规律</title>
      <link>http://liuxueyang.github.io/posts/hdu4639-hehe------%E6%96%90%E6%B3%A2%E7%BA%B3%E5%A5%91%E6%95%B0%E5%88%97%E6%89%BE%E8%A7%84%E5%BE%8B/</link>
      <pubDate>Sat, 03 Aug 2013 10:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu4639-hehe------%E6%96%90%E6%B3%A2%E7%BA%B3%E5%A5%91%E6%95%B0%E5%88%97%E6%89%BE%E8%A7%84%E5%BE%8B/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4639 refer to: http://blog.csdn.net/dongdongzhang_/article/details/9706259 http://www.cnblogs.com/wuhenqs/archive/2013/08/01/3230987.html
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; const int MOD = 10007; char a[11111]; long long fi[11111]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>codefoces round193a</title>
      <link>http://liuxueyang.github.io/posts/codefoces-round193a/</link>
      <pubDate>Thu, 25 Jul 2013 05:33:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codefoces-round193a/</guid>
      <description>link: http://codeforces.com/contest/332/problem/A /* ID: zypz4571 LANG: C++ TASK: 193a.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; char a[2222]; int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>codeforces 192e</title>
      <link>http://liuxueyang.github.io/posts/codeforces-192e/</link>
      <pubDate>Wed, 24 Jul 2013 21:09:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-192e/</guid>
      <description>link: http://codeforces.com/contest/330/problem/E
/* ID: zypz4571 LANG: C++ TASK: 192e.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; map&amp;lt;pair&amp;lt;int,int&amp;gt;,bool&amp;gt; coll; int a[100009]; int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE //freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>abbyy cup a</title>
      <link>http://liuxueyang.github.io/posts/abbyy-cup-a/</link>
      <pubDate>Wed, 24 Jul 2013 21:04:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/abbyy-cup-a/</guid>
      <description>link: http://codeforces.com/contest/331/problem/A2
/* ID: zypz4571 LANG: C++ TASK: abby_a.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; long long int a[300009], sum[300009]; map&amp;lt;int, int&amp;gt; coll; int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>年中总结</title>
      <link>http://liuxueyang.github.io/posts/%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 22 Jul 2013 20:53:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/</guid>
      <description>一年过去一半了，也有半年不回家了，25号就回家了，刚订好票。这半年，总结一下吧。 6月的考试：　——痛苦 这学期最终果然还是挂了一科。数字逻辑，呵呵，没什么可说的，本来就没有一天认真看过书，实在对这货没兴趣。 别的科目。 概率论，靠着考前一天多的通宵+运气+RP+老师比较好，最终竟然有81分……就我这个学习态度……囧 数据结构，本来挺重要的一门课，但老师超水，貌似我上过的课加一块也就差不多七八节的样子……老师水，最后也有80 计算理论，本来也很有深度的一个课程，很抽象，很偏重理论，博士教的，呵呵&amp;gt;&amp;lt;反正我是没怎么学，靠着考前一晚上通宵+运气+RP+%&amp;amp;@最终竟然也有80。。没什么说的。 高级英语，这学期真的没学英语啊，都是水过去的啊，囧，75分，很满足了其实。以后就没有英语课了…… 西班牙语，一然酱帮忙选上的，挺不错的，只是貌似没有很多时间学的样子……最后老师给开卷，78没挂就行了 体育，一个学分，哈哈。这个挺得意的，虽然没打过篮球，但还是考试的时候RP爆发，3步上篮全场来回两趟竟然跑了27秒！！也就是大概95分的成绩，我自己都惊呆了，哎，RP爆发没办法~然后引体向上，满分，因为大家做的都不标准，我也来了个不标准的，做13个还是很容易嘛。以后就没有体育课了……虽然我一直都想逃体育课。。。最后98.</description>
    </item>
    
    <item>
      <title>codeforces 192a</title>
      <link>http://liuxueyang.github.io/posts/codeforces-192a/</link>
      <pubDate>Mon, 22 Jul 2013 03:09:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-192a/</guid>
      <description>link: http://codeforces.com/contest/330/problem/A brute force. /* ID: zypz4571 LANG: C++ TASK: 191a.</description>
    </item>
    
    <item>
      <title>codeforces 192b</title>
      <link>http://liuxueyang.github.io/posts/codeforces-192b/</link>
      <pubDate>Mon, 22 Jul 2013 03:07:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-192b/</guid>
      <description>link: http://codeforces.com/contest/330/problem/B I think the problem is hard at first. However, when you think deep in it you will find it is so easy.</description>
    </item>
    
    <item>
      <title>codeforces 192 c</title>
      <link>http://liuxueyang.github.io/posts/codeforces-192-c/</link>
      <pubDate>Mon, 22 Jul 2013 03:02:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-192-c/</guid>
      <description>link: http://codeforces.com/contest/330/problem/C broute force but you must be careful about some tricks and think about all the instances</description>
    </item>
    
    <item>
      <title>codeforces 192 D</title>
      <link>http://liuxueyang.github.io/posts/codeforces-192-d/</link>
      <pubDate>Mon, 22 Jul 2013 02:58:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-192-d/</guid>
      <description>link: http://codeforces.com/contest/330/problem/D The discription looks so long, but the problem is simple if you can grasp the problem quickly.</description>
    </item>
    
    <item>
      <title>codeforces magic five －－快速幂模</title>
      <link>http://liuxueyang.github.io/posts/codeforces-magic-five-%E5%BF%AB%E9%80%9F%E5%B9%82%E6%A8%A1/</link>
      <pubDate>Fri, 19 Jul 2013 16:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-magic-five-%E5%BF%AB%E9%80%9F%E5%B9%82%E6%A8%A1/</guid>
      <description>题目链接：http://codeforces.com/contest/327/problem/C 首先先算出一个周期里面的值，保存在ans里面，就是平常的快速幂模m做法． 然后要计算一个公式，比如有k个部分，那么对于没一个位置i, 都有2^i + 2^(i+n) + &amp;hellip; + 2^(i+(k-1)*n) = 2^i(1 + 2^n + &amp;hellip; + 2^((k-1)*n)) = 2^i * (1-2^(n*k))/(1-2^n) 所以结果就是ans * (1-2^(n*k))/(1-2^n) % MOD; 然后就是关键计算(1-2^(n*k))/(1-2^n) % MOD； 用到费马小定理a^(p-1)同余于1(mod 1)．p是一个质数，那么a^(p-2) * a 同余于１(mod 1) ，所以a 的逆元就是 a^(p-2) MOD是一个质数,所以(1-2^(n*k))/(1-2^n) % MOD = (2^(n*k)-1)/(2^n-1) % MOD = (2^(n*k)-1)%MOD * ((2^n-1)^(MOD-2))%MOD</description>
    </item>
    
    <item>
      <title>codeforces hungry sequence  水题</title>
      <link>http://liuxueyang.github.io/posts/codeforces-hungry-sequence--%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Fri, 19 Jul 2013 01:07:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-hungry-sequence--%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://codeforces.com/problemset/problem/327/B 这道题目虽然超级简单，但是当初我还真的没有想出来做法，囧，看完别人的代码恍然大悟。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cmath&amp;gt; int main(void) { int n; scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); for (int i = n+1; i &amp;lt;= n+n; ++i) { printf(&amp;quot;%d&amp;quot;, i); if (i !</description>
    </item>
    
    <item>
      <title>Codeforces Flipping game 动态规划基础</title>
      <link>http://liuxueyang.github.io/posts/codeforces-flipping-game-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 19 Jul 2013 01:05:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-flipping-game-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/</guid>
      <description>题目链接：http://codeforces.com/problemset/problem/327/A 这道题目有O(N^3)的做法，这里转化为动态规划求解，复杂度是O(N)
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; using namespace std; #define INF 0x3f3f3f3f int a[102], b[102], c[102]; int main ( void ) { int n, n1=0, cnt=0; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { n1 = cnt = 0; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); for (int i=1; i&amp;lt;=n; ++i){ scanf(&amp;quot;%d&amp;quot;,a+i); if(a[i]) n1++; if (a[i]) b[i]=-1; else b[i]=1; } c[0] = 0; for (int i = 1; i &amp;lt;= n; ++i) { c[i] = c[i-1] + b[i]; } int Max = -INF, Min = c[0]; for (int i = 1; i &amp;lt;= n; ++i) { if (c[i] - Min &amp;gt; Max) Max = c[i]-Min; if (c[i] &amp;lt; Min) Min = c[i]; } printf(&amp;quot;%d\n&amp;quot;,n1+Max); } return 0; }  转化为子序列的最大连续和</description>
    </item>
    
    <item>
      <title>Testing Round #8  A. IQ Test   水题</title>
      <link>http://liuxueyang.github.io/posts/testing-round-#8--a.-iq-test---%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Fri, 19 Jul 2013 00:58:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/testing-round-#8--a.-iq-test---%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://codeforces.com/problemset/problem/328/A 这道题目wa了一次，注意这句话：
You should also print 42 if the next element of progression is not integer.</description>
    </item>
    
    <item>
      <title>Codeforces Testing Round #8 B. Sheldon and Ice Pieces 水题</title>
      <link>http://liuxueyang.github.io/posts/codeforces-testing-round-#8-b.-sheldon-and-ice-pieces-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Thu, 18 Jul 2013 18:50:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-testing-round-#8-b.-sheldon-and-ice-pieces-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://codeforces.com/problemset/problem/328/B 水题~
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; char n[10], a[202]; int b[13], c[13]; int main(void) { //freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>sgu548 Dragons and Princesses　　　贪心＋优先队列</title>
      <link>http://liuxueyang.github.io/posts/sgu548-dragons-and-princesses%E8%B4%AA%E5%BF%83%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</link>
      <pubDate>Thu, 18 Jul 2013 17:53:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/sgu548-dragons-and-princesses%E8%B4%AA%E5%BF%83%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</guid>
      <description>题目链接：http://acm.sgu.ru/problem.php?contest=0&amp;amp;problem=548 题目意思： 有一个骑士，要经过n个房间，开始在第一个房间，每个房间里面有龙或者公主，遇到龙，可以决定杀或者不杀，如果杀，就可以得到相应的珠宝；如果遇到公主，如果这个骑士此时杀过的龙的数目大于等于公主的美貌值，那么这个骑士必须marry这个公主，不能拒绝．．^_^，但是骑士的真爱是在最后一个房间里面的公主，问骑士能不能到达最后一个房间？如果能的话，求出能够到达最后一个房间的情况下，得到的最大的珠宝数． 做法： 优先队列＋贪心． 遇到龙就杀，用优先队列维护得到的珠宝数目，遇到公主就检查目前的杀的龙的数目是不是大于等于公主的美貌值，如果大于等于，就把有限队列里面珠宝值小的房间出队，直到杀的龙的数目小于美貌值为止．
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; struct Node { int pos, n; bool operator &amp;lt; (const Node &amp;amp;other) const { return n &amp;lt; other.</description>
    </item>
    
    <item>
      <title>sgu546 Ternary Password</title>
      <link>http://liuxueyang.github.io/posts/sgu546-ternary-password/</link>
      <pubDate>Thu, 18 Jul 2013 17:42:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/sgu546-ternary-password/</guid>
      <description>题目链接：http://acm.sgu.ru/problem.php?contest=0&amp;amp;problem=546 这题还好，１Ｙ，考虑情况周全，就没问题了，还好提交之前把想到的情况都测试了一遍．．
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; char s[202]; int n, a, b, a0[202], b0[202]; int main(void) { //freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>sgu551 Preparing Problem</title>
      <link>http://liuxueyang.github.io/posts/sgu551-preparing-problem/</link>
      <pubDate>Thu, 18 Jul 2013 17:39:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/sgu551-preparing-problem/</guid>
      <description>题目链接：http://acm.sgu.ru/problem.php?contest=0&amp;amp;problem=551 呵呵，题目读的没错，可惜理解错了．．＝＝
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #define LL long long using namespace std; int n, t1, t2; int gcd(int a, int b) { return b == 0 ?</description>
    </item>
    
    <item>
      <title>uestc1888 Birthday Party 　　　组合数学，乘法原理</title>
      <link>http://liuxueyang.github.io/posts/uestc1888-birthday-party-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E4%B9%98%E6%B3%95%E5%8E%9F%E7%90%86/</link>
      <pubDate>Thu, 18 Jul 2013 17:26:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uestc1888-birthday-party-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E4%B9%98%E6%B3%95%E5%8E%9F%E7%90%86/</guid>
      <description>题目链接：http://acm.hust.edu.cn/vjudge/contest/view.action?cid=25539#problem/G 题目意思： 有n个人，每个人有一个礼物，每个人能拿自己礼物，n个人随机送礼物，给一个数字k,求出可以找到k个人，满足：这ｋ个人里面，第一个人把礼物给第二个人，第二个人把礼物给第三个人，以此类推，第ｋ个人把礼物给第１个人．求满足这个条件的概率． 组合数学： 满足条件的一组ｋ个人称为一个ｋ环，注意：可能有多个ｋ环！先考虑至少形成一个ｋ环的情况：A(n,k) * (n-1)^(n-k) / (k * (n-1)^(n)) == A(n, k) / (k * (n-1)^k) ；然后在考虑至少形成m个环的情况． 设至少形成m个环的概率是：f(m) = A(n, km)/(k^mm!</description>
    </item>
    
    <item>
      <title>usaco Milking Cows</title>
      <link>http://liuxueyang.github.io/posts/usaco-milking-cows/</link>
      <pubDate>Sun, 14 Jul 2013 18:03:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/usaco-milking-cows/</guid>
      <description>题目链接：http://cerberus.delos.com:791/usacoprob2?a=bv3dg9ejwKm&amp;amp;S=milk2 这题目不是线段树，直接模拟
/* ID: zypz4571 LANG: C++ TASK: milk2 */ #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; struct Node { int s, t; }a[5002]; bool cmp(const Node &amp;amp;a, const Node &amp;amp;b) { return a.</description>
    </item>
    
    <item>
      <title>usaco Section1.1 Broken Necklace</title>
      <link>http://liuxueyang.github.io/posts/usaco-section1.1-broken-necklace/</link>
      <pubDate>Sun, 14 Jul 2013 11:24:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/usaco-section1.1-broken-necklace/</guid>
      <description>题目链接：http://cerberus.delos.com:790/usacoprob2?a=75WI6aQtaO2&amp;amp;S=beads 1Y这道题目没什么，就是情况多一点，麻烦一点=_=
/* ID: zypz4571 LANG: C++ TASK: beads */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #define INF 0x3f3f3f3f #define mid int m=(l+r)/2 using namespace std; int main ( int argc, char *argv[] ) { freopen(&amp;quot;beads.</description>
    </item>
    
    <item>
      <title>vimrc配置文件_version1.0_&#43;pathogen, taglist, wordcomplete插件说明</title>
      <link>http://liuxueyang.github.io/posts/vimrc%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6_version1.0_&#43;pathogen-taglist-wordcomplete%E6%8F%92%E4%BB%B6%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Sat, 13 Jul 2013 06:43:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/vimrc%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6_version1.0_&#43;pathogen-taglist-wordcomplete%E6%8F%92%E4%BB%B6%E8%AF%B4%E6%98%8E/</guid>
      <description>为了表示对Ruchee的感谢，首先这是Ruchee的个人网站：http://www.ruchee.com/index.html，他的以前很多的代码都放到Git里面了，里面有链接。 看了整整一天，刚开始学习vim的时候就是用的Ruchee的vimrc脚本，现在终于可以自己写一点了，又认真看了一下Ruchee原来的脚本，虽然还有一些不太懂，但还是赶脚好腻害的样子。 然后自己又加了一点自己东西：——适用于mac, linux平台
&amp;quot;Copyright 2013 Xueyang Liu, all rights reserved.</description>
    </item>
    
    <item>
      <title>高斯消元</title>
      <link>http://liuxueyang.github.io/posts/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/</link>
      <pubDate>Thu, 11 Jul 2013 22:21:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/</guid>
      <description>输入线性方程组的维数，然后随即生成一定有解的线性方程组的增广矩阵，求出解，然后输出时间和方程组的解，以及和标准解的误差（其实就是和标准解的方差）。 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;ctime&amp;gt; using namespace std; const double eps=1e-9; const int MAX=20000; double ans[MAX]; int n; double **inputdata; double *result; /* 输出标准解 */ void printresult() { for(int i=0;i&amp;lt;n;i++) printf(&amp;quot;%.</description>
    </item>
    
    <item>
      <title>tyvj1022 - 进制转换 ——进制为负数</title>
      <link>http://liuxueyang.github.io/posts/tyvj1022---%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-%E8%BF%9B%E5%88%B6%E4%B8%BA%E8%B4%9F%E6%95%B0/</link>
      <pubDate>Mon, 08 Jul 2013 23:33:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/tyvj1022---%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-%E8%BF%9B%E5%88%B6%E4%B8%BA%E8%B4%9F%E6%95%B0/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1022
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cmath&amp;gt; long long int n, k, r; int a[100]; int main(void) { scanf(&amp;quot;%lld&amp;quot;,&amp;amp;n); int j=0; if(!</description>
    </item>
    
    <item>
      <title>tyvj1023 - 奶牛的锻炼 ——DP</title>
      <link>http://liuxueyang.github.io/posts/tyvj1023---%E5%A5%B6%E7%89%9B%E7%9A%84%E9%94%BB%E7%82%BC-dp/</link>
      <pubDate>Mon, 08 Jul 2013 23:31:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/tyvj1023---%E5%A5%B6%E7%89%9B%E7%9A%84%E9%94%BB%E7%82%BC-dp/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1023
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; int a[2002],f[2002][502]; int main(void) { //freopen(&amp;quot;in1.</description>
    </item>
    
    <item>
      <title>tyvj1018 - 阶乘统计 ——暴力</title>
      <link>http://liuxueyang.github.io/posts/tyvj1018---%E9%98%B6%E4%B9%98%E7%BB%9F%E8%AE%A1-%E6%9A%B4%E5%8A%9B/</link>
      <pubDate>Sun, 07 Jul 2013 23:46:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/tyvj1018---%E9%98%B6%E4%B9%98%E7%BB%9F%E8%AE%A1-%E6%9A%B4%E5%8A%9B/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1018 范围只有20，在long long Int范围内。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; int main(void) { freopen(&amp;quot;in1.</description>
    </item>
    
    <item>
      <title>tyvj1017 - 冗余关系 ——并查集</title>
      <link>http://liuxueyang.github.io/posts/tyvj1017---%E5%86%97%E4%BD%99%E5%85%B3%E7%B3%BB-%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <pubDate>Sun, 07 Jul 2013 23:22:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/tyvj1017---%E5%86%97%E4%BD%99%E5%85%B3%E7%B3%BB-%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1017 并查集
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; int parent[1001],n,m; void init() {for(int i=1;i&amp;lt;=m;++i)parent[i]=-1; } int Find(int x) {int s; for(s=x;parent[s]&amp;gt;=0;s=parent[s]);while (s!</description>
    </item>
    
    <item>
      <title>tyvj1015 - 公路乘车  ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/tyvj1015---%E5%85%AC%E8%B7%AF%E4%B9%98%E8%BD%A6--%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Sun, 07 Jul 2013 21:14:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/tyvj1015---%E5%85%AC%E8%B7%AF%E4%B9%98%E8%BD%A6--%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1015 完全背包
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int c[11],f[101]; int main(void) { freopen(&amp;quot;in1.</description>
    </item>
    
    <item>
      <title>6号赛车的故事  ——韩寒</title>
      <link>http://liuxueyang.github.io/posts/6%E5%8F%B7%E8%B5%9B%E8%BD%A6%E7%9A%84%E6%95%85%E4%BA%8B--%E9%9F%A9%E5%AF%92/</link>
      <pubDate>Sun, 07 Jul 2013 20:21:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/6%E5%8F%B7%E8%B5%9B%E8%BD%A6%E7%9A%84%E6%95%85%E4%BA%8B--%E9%9F%A9%E5%AF%92/</guid>
      <description>转自韩寒腾讯微博</description>
    </item>
    
    <item>
      <title>时间怎样地行走    ——迟子建</title>
      <link>http://liuxueyang.github.io/posts/%E6%97%B6%E9%97%B4%E6%80%8E%E6%A0%B7%E5%9C%B0%E8%A1%8C%E8%B5%B0----%E8%BF%9F%E5%AD%90%E5%BB%BA/</link>
      <pubDate>Sun, 07 Jul 2013 20:04:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E6%97%B6%E9%97%B4%E6%80%8E%E6%A0%B7%E5%9C%B0%E8%A1%8C%E8%B5%B0----%E8%BF%9F%E5%AD%90%E5%BB%BA/</guid>
      <description>时间怎样地行走 迟子建 墙上的挂钟，曾是我童年最爱着的一道风景。我对它有一种说不出的崇拜因为它掌管着时间，我们的作息似乎都受着它的支配。到了指定的时间，我们得起床上学，得做课间操，得被父母吆喝着去睡觉。虽然说有的时候我们还没睡够不想起床，在户外的月光下还没有戏耍够不想回屋睡觉，都必须因为时间的关系而听从父母的吩咐。他们理直气壮呵斥我们的话与挂钟息息相关：“都几点了，还不起床！”要么就是：“都几点了，还在外面疯玩，快睡觉去！”这时候，我觉得挂钟就是一个拿着烟袋磕着我们脑门的狠心的老头，又凶又倔，真想把他给掀翻在地，让它永远不行走。在我的想象中，它就是一个看不见形影的家长，严厉而又古板。但有时候它也是温情的，在除夕夜里，它的每一声脚步都给我们带来快乐，我们可以在子时钟声敲响后得到梦寐以求的压岁钱，想着用这钱可以买糖果来甜甜自己的嘴，真想在雪地上畅快地打几个滚。 我那时天真地以为时间是被一双神秘的大手放在挂钟里的。它每时每刻地行走着，走得不慌不忙，气定神凝，不会因为贪恋窗外鸟语花香的美景而放慢脚步，也不会因为北风肆虐大雪纷飞而加快脚步。它的脚，是世界上最能禁得起诱惑的脚，从来都是循着固定的轨迹行走。我喜欢听它前行的声音总是一个节，好像一首温馨的摇篮曲。时间在挂钟里，与我们一同经历着风霜雨雪、潮起潮落。 我上初中以后，手表就比较普及了。我看见时间躲在一个小小的圆盘里，在手腕上跳舞。它跳得静悄悄的，不像墙上的挂钟那么清脆悦耳，“滴答——滴答——”的声音不绝于耳。手表里的时间给我一种鬼鬼崇崇的感觉，少了几分气势和威严，所以明明到了上课时间，我还会磨蹭一两分钟再进教室，手表里的时间也就因此显得有些落寞。 后来，生活变得丰富多彩了，时间栖身的地方就多了。项链坠可以隐藏着时间，台历上镶嵌着时间，玩具里放置着时间，至于电脑和手提电话，只要我们一打开它们，率先映入眼帘的就有时间。时间如繁星一样到处闪烁着，它越来越多，也就越来越显得匆匆了。 十几年前的一天，我在北京第一次发现了时间的痕迹。我在梳头时发现一根白发，它在清晨的曙光中像一道明的雪一样刺痛了我的眼睛。我知道时间其实一直在我的头发里行走，只不过它这一次露出了痕迹而已。我还看见，时间在母亲的口腔里行走，她的牙齿脱落得越来越多。我明白时间让花朵绽放的时候，也会让人的眼角绽放出花朵——鱼尾纹。 时间让一棵青春的小树越来越枝繁叶茂，让车轮的辐条越来越沾染上锈链，让一座老屋逐渐驼了背。时间好似变戏法的魔术师，突然让一个活生生的人瞬间消失在他们辛勤劳作过的土地上，我的祖父、外祖父和父亲，就让时间给无声地接走了，再也看不到他们的脚印，只能在清冷的梦中见到他们依稀的身影。他们不在了，可时间还在，它总是持之以恒激情澎湃地行走着——在我们看不到的角落，在我们不经意走过的地方，在日月星辰中，在梦中。 我终于明白挂钟上的时间和手表里的时间只是时间的一个表象而已，它存在于更丰富的日常生活中。只要我们在行走，时间就会行走。我们和时间如同一对伴侣，相依相偎着，不朽的它会在我们不知不觉间，引领着我们一直走到地老天荒。 </description>
    </item>
    
    <item>
      <title>泥泞 ——迟子建</title>
      <link>http://liuxueyang.github.io/posts/%E6%B3%A5%E6%B3%9E-%E8%BF%9F%E5%AD%90%E5%BB%BA/</link>
      <pubDate>Sun, 07 Jul 2013 19:53:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E6%B3%A5%E6%B3%9E-%E8%BF%9F%E5%AD%90%E5%BB%BA/</guid>
      <description>泥泞 迟子建　北方的初春是肮脏的，这肮脏当然缘自于我们曾经热烈赞美过的纯洁无瑕的雪。在北方漫长的冬季里，寒冷催生了一场又一场的雪，它们自天庭伸开美丽的触角，纤柔地飘落到大地上，使整个北方沉沦于一个冰清玉洁的世界中。如果你在飞雪中行进在街头，看着枝条濡着雪绒的树，看着教堂屋顶的白雪，看着银色的无限延伸着的道路，你的内心便会洋溢着一股激情：为着那无与伦比的壮丽或者是苍凉。然而春风来了。春风使积雪融化，它们在消融的过程中容颜苍老、憔悴，仿佛一个即将撒手人寰的老妇人：雪在这时候将它的两重性毫无保留地暴露出来：它的美丽依附于寒冷，因而它是一种静止的美、脆弱的美；当寒冷已经成为西天的落霞，和风丽日映照它们时，它的丑陋才无奈地呈现。纯美之极的事物是没有的，因而我还是热爱雪。爱它的美丽、单纯，也爱它的脆弱和被迫的消失。当然，更热爱它们消融时给这大地制造的空前的泥泞。小巷里泥水遍布；排水沟因为融雪后污水的加入而增大流量，哗哗地响；燕子在潮湿的空气里衔着湿泥在檐下筑巢；鸡、鸭、鹅、狗将它们游荡小巷的爪印带回主人家的小院，使院子里印满无数爪形的泥印章，宛如月下松树庞大的投影；老人在走路时不小心失了手杖，那手杖被拾起时就成了泥手杖；孩子在小巷奔跑嬉闹时不慎将嘴里含着的糖掉到泥水中了，他便失神地望着那泥水呜呜地哭，而窥视到这一幕的孩子的母亲却快意地笑起来…… 这是我童年时常常经历的情景，它的背景是北方的一个小山村，时间当然是泥泞不堪的早春时光了。　我热爱这种浑然天成的泥泞。泥泞常常使我联想到俄罗斯这个伟大的民族，罗蒙诺索夫、柴可夫斯基、陀思妥耶夫斯基、托尔斯泰、蒲宁、普希金就是踏着泥泞一步步朝我们走来的。俄罗斯的艺术洋溢着一股高贵、博大、阴郁、不屈不挠的精神气息，不能不说与这种春日的泥泞有关。泥泞诞生了跋涉者，它给忍辱负重者以光明和力量，给苦难者以和平和勇气？一个伟大的民族需要泥泞的磨砺和锻炼，它会使人的脊梁永远不弯，使人在艰难的跋涉中懂得土地的可爱、博大和不可丧失，懂得祖国之于人的真正含义：当我们爱脚下的泥泞时，说明我们已经拥抱了一种精神。　如今在北方的城市所感受到的泥泞已经不像童年时那么深重了：但是在融雪的时节，我走在农贸市场的土路上，仍然能遭遇那种久违的泥泞。泥泞中的废纸、草屑、烂菜叶、鱼的内脏等等杂物若隐若现着，一股腐烂的气味扑入鼻息。这感觉当然比不得在永远有绿地环绕的西子湖畔撑一把伞在烟雨淳淳中耽于幻想来得惬意，但它仍然能使我陷入另一种怀想，想起木轮车沉重地辗过它时所溅起的泥珠，想起北方的人民跋涉其中的艰难的背影，想起我们曾有过的苦难和屈辱，我为双脚仍然能触摸到它而感到欣慰。　我们不会永远回头重温历史，我们也不会刻意制造一种泥泞让它出现在未来的道路上，但是，当我们在被细雨洗刷过的青石板路上走倦了，当我们面对着无边的落叶茫然不知所措时，当我们的笔面对白纸不再有激情而苍白无力时，我们是否渴望着在泥泞中跋涉一回呢？为此，我们真应该感谢雪，它诞生了寂静、单纯、一览无余的美，也诞生了肮脏、使人警醒给人力量的泥泞。因此它是举世无双的。 http://sanwenzx.com/jingdian/mingjia/2009/9283.html 这是高中语文阅读理解的一篇文章，当初就觉得很好，现在看还是很有感觉啊。</description>
    </item>
    
    <item>
      <title>tyvj1014 - 乘法游戏  ——记忆化搜索DP</title>
      <link>http://liuxueyang.github.io/posts/tyvj1014---%E4%B9%98%E6%B3%95%E6%B8%B8%E6%88%8F--%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2dp/</link>
      <pubDate>Sun, 07 Jul 2013 17:28:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/tyvj1014---%E4%B9%98%E6%B3%95%E6%B8%B8%E6%88%8F--%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2dp/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1014 f[i][j]表示区间［i，j］所得到的最小值。 不断地划分区间，把结果保存起来。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; long long int f[101][101];int a[101], i, j, n, INF=0x7f7f7f7f; void dfs(int l, int r) { if(r-l&amp;lt;=1) {f[l][r]=0; return;} if(f[l][r]!</description>
    </item>
    
    <item>
      <title>tyvj1013 - 找啊找啊找GF  ——二维背包变种</title>
      <link>http://liuxueyang.github.io/posts/tyvj1013---%E6%89%BE%E5%95%8A%E6%89%BE%E5%95%8A%E6%89%BEgf--%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85%E5%8F%98%E7%A7%8D/</link>
      <pubDate>Sun, 07 Jul 2013 16:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/tyvj1013---%E6%89%BE%E5%95%8A%E6%89%BE%E5%95%8A%E6%89%BEgf--%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85%E5%8F%98%E7%A7%8D/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1013 好吧，这题没节操=_= 状态f[u,v,i]表示：消费u的人民币和v的人品同时泡到i个mm所需要的最少时间。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; int f[101][101][101], r[101], rp[101], t[101], rmb, RP, n, INF=0x7f7f7f7f; int main(void) { freopen(&amp;quot;in1.</description>
    </item>
    
    <item>
      <title>tyvj1012 P1012 - 火柴棒等式  ——暴力枚举</title>
      <link>http://liuxueyang.github.io/posts/tyvj1012-p1012---%E7%81%AB%E6%9F%B4%E6%A3%92%E7%AD%89%E5%BC%8F--%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/</link>
      <pubDate>Sun, 07 Jul 2013 11:37:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/tyvj1012-p1012---%E7%81%AB%E6%9F%B4%E6%A3%92%E7%AD%89%E5%BC%8F--%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1012 可以发现：最大的数字绝对不超过999，只要枚举出0～999所有数字需要的火柴数，然后再枚举C和A，得到B＝C-A，看看三个数字的火柴数目是否等于n就可以了。
#include &amp;lt;cstdio&amp;gt; int a[10] = {6,2,5,5,4,5,6,3,7,6},b[1000],n,cnt; int main(void) { freopen(&amp;quot;in1.</description>
    </item>
    
    <item>
      <title>tyvj1011 - 传纸条  ——DP</title>
      <link>http://liuxueyang.github.io/posts/tyvj1011---%E4%BC%A0%E7%BA%B8%E6%9D%A1--dp/</link>
      <pubDate>Sun, 07 Jul 2013 11:32:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/tyvj1011---%E4%BC%A0%E7%BA%B8%E6%9D%A1--dp/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1011 状态转移方程： f[k,x1,x2] = max(f[k-1,x1,x2],f[k-1,x1-1,x2],f[k-1,x1-1,x2-1],f[k-1,x1,x2-1]) + a[y1,x1] + a[y2,x2]; f[k,x1,x2]表示，第K步的时候，一条路的横坐标是x1,另一条路的横坐标是x2的时候所得到的最优解。另外，还要考虑一下，当x1==x2的时候的情况，这个时候，只能允许一条路走到那个位置。</description>
    </item>
    
    <item>
      <title>tyvj1004 滑雪</title>
      <link>http://liuxueyang.github.io/posts/tyvj1004-%E6%BB%91%E9%9B%AA/</link>
      <pubDate>Sat, 06 Jul 2013 15:06:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/tyvj1004-%E6%BB%91%E9%9B%AA/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1004 记忆化搜索
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int m[102][102], dp[102][102], r, C; int dfs(int x, int y) { if (dp[x][y] &amp;gt; 0) return dp[x][y]; dp[x][y]=1; int a,b,c,d; a=b=c=d=0; if (x-1&amp;gt;=1 &amp;amp;&amp;amp; m[x-1][y] &amp;lt; m[x][y]) a = dfs(x-1,y); if (x+1&amp;lt;=r &amp;amp;&amp;amp; m[x+1][y] &amp;lt; m[x][y]) b = dfs(x+1,y); if (y-1&amp;gt;=1 &amp;amp;&amp;amp; m[x][y-1] &amp;lt; m[x][y]) c = dfs(x,y-1); if (y+1&amp;lt;=C &amp;amp;&amp;amp; m[x][y+1] &amp;lt; m[x][y]) d = dfs(x,y+1); dp[x][y] = max(max(a,b),max(c,d))+1; return dp[x][y]; } int main(void) { int Max; freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>《一个人的村庄》 ——刘亮程</title>
      <link>http://liuxueyang.github.io/posts/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9D%91%E5%BA%84-%E5%88%98%E4%BA%AE%E7%A8%8B/</link>
      <pubDate>Thu, 04 Jul 2013 13:27:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E6%9D%91%E5%BA%84-%E5%88%98%E4%BA%AE%E7%A8%8B/</guid>
      <description>一个人的村庄： 剩下的事情　他们都回去了，我一个留在野地上看守麦垛。得有一个月时间他们才能忙完村里的活，腾出手回来打麦子。野地离村子有大半天的路，也就是说，一个人不能在一天内往返一次野地。这是大概两天的路程，你硬要一天走完，说不定你走到什么地方，天突然黑了，剩下的路可就不好走了。谁都不想走到最后，剩下一截子黑路。是不是？　紧张的麦收结束了。同样的劳动，又在其他什么地方重新开始，这我能想得出。我知道村庄周围有几块地。他们给我留下够吃一个月的面和米，留下不够炒两顿菜的小半瓶清油。给我安排活儿的人，临走时又追加了一句：别老闲着望天，看有没有剩下的活儿主动干干。　第二天，我在麦茬地走了一圈，发现好多活儿没有干完，麦子没割完，麦捆没有拉完。可是麦收结束了，人都回去了。　在麦地南边，扔着一大捆麦子。显然是拉麦捆的人故意漏装的。地西头则整齐地长着半垅麦子。即使割完的麦垅，也在最后剩下那么一两镰，不好看地长在那里。似乎人干到最后已没有一丝耐心和力气。　我能想到这个剩下半拢麦子的人，肯定是最后一个离开地头的。在那个下午的斜阳里；没割倒的半拢麦子，一直望着扔下它们的那个人，走到麦地另一头，走进或蹲或站的一堆人里，再也认不出来。　麦地太大。从一头几乎望不到另一头。割麦的人一人把一城，不抬头地往前赶，一直割到天色渐晚，割到四周没有了镰声，抬起头，发现其他人早割完回去了，剩下他孤零零的一场。他有点急了，弯下腰猛割几镰，又茫然地停住，地里没一个人。干没干完都没人管了。没人知道他没干完，也没人知道他干完了。验收这件事的人回去了。他一下泄了气，瘫坐在麦茬上，楞了会儿神：球，不干了。　我或许能查出这个活儿没干完的人。　我已经知道他是谁。　但我不能把他喊回来，把剩下的麦子割完。这件事已经结束，更紧迫的劳动在别处开始。剩下的事情不再重要。　以后几天，我干着许多人干剩下的事情。一个人在空荡荡的麦地里转来转去。我想许多轰轰烈烈的大事之后，都会有一个收尾的人，他远远地跟在人们后头，干着他们自以为干完的事情。许多事情都一样，开始干的人很多，到了最后，便成了某一个人的。　远离村人　我每天的事：早晨起来望一眼麦垛。总共五大垛，一溜排开。整个白天可以不管它们。到了下午，天黑之前，再朝四野里望一望，看有无可疑的东西朝这边移动。　这片大野隐藏着许多东西。一个人，五垛麦子，也是其中的隐匿者，谁也不愿让谁发现。即使是树，也都蹲着长，躯干一曲再曲，枝桠匐着地伸展；我从没在荒野上看见一棵像杨树一样高扬着头、招摇而长的植物。有一种东西压着万物的头，也压抑着我。　有几个下午我注意到西边的荒野中有一个黑影。在不断地变大。我看不清那是什么东西，它孤独地蹲在那里；让我几个晚上没睡好觉。若有个东西在你身旁越变越小最后消失了，你或许一点不会在意。有个东西在你身边突然大起来，变得巨大无比，你便会感到惊慌和恐惧。　早晨天刚亮我便爬起来，看见那个黑影又长大了一些。再看麦垛，似乎一夜间矮了许多。我有点担心，扛着锨小心翼翼地走过去，穿过麦地走了一阵，才看清楚，是一棵树。一棵枯死的老树突然长出许多枝条和叶子。我围着树转了一圈。许多叶子是昨晚上才长出来的，我能感觉到它的枝枝叶叶还在长，而且会长得更加蓬蓬勃勃。我想这棵老树的某一条根，一定扎到了土地深处的一个旺水层。　能让一棵树长得粗壮兴旺的地方，也一定会让一个人活得像模像样。往回走时，我暗暗记住了这个地方。那时，我刚刚开始模糊地意识到，我已经放任自己像植物一样去随意生长。我的胳膊太细，腿也不粗，胆子也不大，需要长的东西很多。多少年来我似乎忘记了生长。　随着剩下的活儿一点一点地干完，莫名的空虚感开始笼罩着草棚，活儿干完了，镰刀和铁锨扔到一边。孤单成了一件事情。寂寞和恐惧成了一件大事情。　我第一次感到自己是一个，而它们&amp;ndash;成群的、连片的、成堆的对着我。我的群落在几十里外的太平渠村里。此时此刻，我的村民帮不了我，朋友和亲人帮不了我。　我的寂寞和恐惧从村里带来的。　每个人最后都是独自面对剩下的寂寞和恐惧，无论在人群中还是在荒野上。那是他一个人的。　就像一粒虫、一棵草在它浩荡的群落中孤单地面对自己的那份欢乐和痛苦。其他的虫、草不知道。　一棵树枯死了，提前进入了比生更漫长的无花无叶的枯木期。其他的树还活着，枝繁叶茂。阳光照在绿叶上，也照在一棵柏树上。我们看不见一棵柏树在阳光中生长着什么。它埋在地深处的根在向什么地方延伸。死亡以后的事情，我们不知道。　一个人死了，我们把它搁过去&amp;ndash;埋掉。　我们在坟墓旁边往下活。活着活着，就会觉得不对劲：这条路是谁留下的。那件事谁做过了。这句话谁说过。那个女人谁爱过&amp;hellip;&amp;hellip;　我在村人中生活了几十年，什么事都经过了，再呆下去，也不会有啥新鲜事。剩下的几十年，我想在花草中度过，在虫鸟水土中度过。我不知道这样行不行，或许村里人会把我喊回去，让我娶个女人生养孩子。让我翻地，种下一年的麦子。他们不会让我闲下来，他们必做的事情，也必然是我的事情。他们不会知道，在我心中，这些事情早就结束了。　如果我还有什么剩下要做的事情，那就是一棵草的事情，一粒虫的事情，一片云的事情。　我在野地上还有十几天时间，也可能更长。我正好远离村人，做点自己的事情。　风把人刮歪　刮了一夜大风，我在半夜被风喊醒。风在草棚和麦垛上发出恐怖的怪叫，类似女人不舒畅的哭喊。这些突兀地出现在荒野中的草棚麦垛，绊住了风的腿，扯住了风的衣裳，缠住了风的头发，让它追不上前面的风。她撕扯，哭喊。喊得满天地都是风声。　我把头伸出草棚，黑暗中隐约有几件东西在地上滚动，滚得极快，一晃就不见了。是风把麦垛刮走了。我不清楚刮走了多少，也只能看着它刮走。我比一捆麦大不了多少，一出去可能就找不见自己了。风朝着村子那边刮。如果风不在中途拐弯，一捆一捆的麦子会在风中跑回村子。明早村人醒来，看见了一捆捆麦子躲在墙根，像回来的家畜一样。　每年都有几场大风经过村庄。风把人刮歪。又把歪长的树刮直。风从不同方向来，人和草木往哪边斜不由自主。能做到的只是在每一场风后，把自己扶直。一棵树在各种各样的风中变得扭曲，古里古怪。你几乎可以看出它沧桑躯干上的哪个弯是南风吹的，哪个拐是北风刮的。但它最终高大粗壮地立在土地上，无论南风北风都无力动摇它。　我们村边就有几棵这样的大树，村里也有几个这样的人。我太年轻，根扎得不深，躯干也不结实。担心自己会被一场大风刮跑，像一棵草一片树叶，随风千里，飘落到一个陌生地方。也不管你喜不喜欢，愿不愿意，风把你一扔就不见了。你没地方去找风的麻烦，刮风的时候满世界都是风，风一停就只剩下空气。天空若无其事，大地也像什么都没发生。只有你的命运被改变了，莫名其妙地落在另一个地方。你只好等另一场相反的风把自己刮回去。可能一等多年，再没有一场能刮起你的大风。你在等待飞翔的时间里不情愿地长大，变得沉重无比。　去年，我在一场风中看见很久以前从我们家榆树上刮走的一片树叶，又从远处刮回来。它在空中翻了几个跟头，摇摇晃晃地落在窗台上。那场风刚好在我们村里停住，像是猛然刹了车。许多东西从天上往下掉，有纸片&amp;ndash;写字的和没写字的纸片、布条、头发和毛，更多的是树叶。我在纷纷下落的东西中认出了我们家榆树上的一片树叶。我赶忙抓住它，平放在手中。这片叶子的边缘已有几处损伤，原先背阴的一面被晒得有些发白&amp;ndash;它在什么地方经受了什么样的阳光？另一面粘着些褐黄的黏土。我不知道它被刮了多远又被另一场风刮回来，一路上经过了多少地方，这些地方都是我从没去过的。它飘回来了，这是极少数的一片叶子。　风是空气在跑。一场风一过，一个地方原有的空气便跑光了，有些气味再闻不到，有些东西再看不到&amp;ndash;昨天弥漫村巷的谁家炒菜的肉香，昨晚被一个人独享的女人的体香，下午晾在树上忘收的一块布，早上放在窗台上写着几句话的一张纸。风把一个村庄酝酿许久的，被一村人吸进呼出弄出特殊味道的一窝子空气，整个地搬运到百里千里外的另一个地方。　每一场风后，都会有几朵我们不认识的云，停留在村庄上头，模样怪怪的，颜色生生的，弄不清啥意思。短期内如果没风，这几云就会?</description>
    </item>
    
    <item>
      <title>uva 11020 - Efficient Solutions ——平衡BST</title>
      <link>http://liuxueyang.github.io/posts/uva-11020---efficient-solutions-%E5%B9%B3%E8%A1%A1bst/</link>
      <pubDate>Thu, 04 Jul 2013 00:25:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva-11020---efficient-solutions-%E5%B9%B3%E8%A1%A1bst/</guid>
      <description>链接：http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=1961 训练指南page228
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;set&amp;gt; using namespace std; struct Point { int a, b; bool operator &amp;lt; (const Point &amp;amp; other) const { return (a &amp;lt; other.</description>
    </item>
    
    <item>
      <title>Codeforces Round #190 (Div. 2)  B. Ciel and Flowers</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-#190-div.-2--b.-ciel-and-flowers/</link>
      <pubDate>Wed, 03 Jul 2013 14:14:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-round-#190-div.-2--b.-ciel-and-flowers/</guid>
      <description>链接：http://codeforces.com/contest/322/problem/B 这题做错了。没考虑周全。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; int main(void) { int r, g, b; while (~scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;r, &amp;amp;g, &amp;amp;b)) { int x = r % 3, y = g % 3, z = b % 3, Max = max(x, max(y, z)), cnt =r/3+g/3+b/3; if (Max == 1) { if (x == y &amp;amp;&amp;amp; y == z &amp;amp;&amp;amp; x == 1) cnt++; } if (Max == 2) { if (x + y + z == 4) { if (x*y*z) cnt++; else if (!</description>
    </item>
    
    <item>
      <title>hdu3308  线段树——区间合并</title>
      <link>http://liuxueyang.github.io/posts/hdu3308--%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</link>
      <pubDate>Wed, 03 Jul 2013 14:10:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu3308--%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</guid>
      <description>更新一个点； 求某个区间的最长连续上升序列； 链接：http://acm.hdu.edu.cn/showproblem.php?pid=3308
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define maxn 100009 #define mid int m=(l+r)&amp;gt;&amp;gt;1 int num[maxn], lsum[maxn&amp;lt;&amp;lt;2], rsum[maxn&amp;lt;&amp;lt;2], msum[maxn&amp;lt;&amp;lt;2], n, m, p, v, a, b; void pushup(int o, int l, int r) { mid; if (num[m] &amp;lt; num[m+1]) { lsum[o] = (lsum[o&amp;lt;&amp;lt;1] == m+1-l) ?</description>
    </item>
    
    <item>
      <title>线段树，区间更新</title>
      <link>http://liuxueyang.github.io/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Wed, 03 Jul 2013 14:08:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E6%9B%B4%E6%96%B0/</guid>
      <description>把一个区间内的值全部修改为一个确定值； 计算某个区间内的最大值，最小值，和。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; #define INF 0x7f7f7f7f #define Max 600000 long long a[Max], setv[Max], minv[Max], maxv[Max], sumv[Max], _max, _min, _sum, v; int y1,y2; bool flagv[Max]; inline void maintain(int o, int L, int R) { if (flagv[o]) minv[o] = maxv[o] = setv[o], sumv[o] = (R-L+1)*setv[o]; else if (R &amp;gt; L) minv[o] = min(minv[o*2], minv[o*2+1]), maxv[o] = max(maxv[o*2], maxv[o*2+1]), sumv[o] = sumv[o*2] + sumv[o*2+1]; } void build(int o, int L, int R) { if (L == R) scanf(&amp;quot;%lld&amp;quot;, a+o), minv[o] = maxv[o] = sumv[o] = setv[o] = a[o]; else {int M = L + (R-L)/2; build(o&amp;lt;&amp;lt;1, L, M), build(o*2+1, M+1, R), maintain(o, L, R);} flagv[o] = false; } inline void pushdown(int o) { if (flagv[o]) setv[o&amp;lt;&amp;lt;1] = setv[o&amp;lt;&amp;lt;1|1] = setv[o], flagv[o&amp;lt;&amp;lt;1] = flagv[o&amp;lt;&amp;lt;1|1] = true, flagv[o] = false; } void update(int o, int L, int R) { if (y1 &amp;lt;= L &amp;amp;&amp;amp; y2 &amp;gt;= R) setv[o] = v, flagv[o] = true; else { int M = L + (R-L)/2; pushdown(o); if (y1 &amp;lt;= M) update(o&amp;lt;&amp;lt;1, L, M); else maintain(o&amp;lt;&amp;lt;1, L, M); if (y2 &amp;gt; M) update(o&amp;lt;&amp;lt;1|1, M+1, R); else maintain(o&amp;lt;&amp;lt;1|1, M+1, R); } maintain(o, L, R); } void query(int o, int L, int R) { if (flagv[o]) _sum += setv[o]*(min(y2, R) - max(y1, L) + 1), _min = min(_min, setv[o]), _max = max(_max, setv[o]); else if (y1 &amp;lt;= L &amp;amp;&amp;amp; y2 &amp;gt;= R) _sum += sumv[o], _min = min(_min, minv[o]), _max = max(_max, maxv[o]); else {int M = L + (R-L)/2; if (y1 &amp;lt;= M) query(o&amp;lt;&amp;lt;1, L, M); if (y2 &amp;gt; M) query(o&amp;lt;&amp;lt;1|1, M+1, R);} } int main(void) { freopen(&amp;quot;input.</description>
    </item>
    
    <item>
      <title>vim 被墙</title>
      <link>http://liuxueyang.github.io/posts/vim-%E8%A2%AB%E5%A2%99/</link>
      <pubDate>Thu, 27 Jun 2013 21:49:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/vim-%E8%A2%AB%E5%A2%99/</guid>
      <description>我只能说，呵呵。还好这货可以进。 http://vim.wendal.net/ </description>
    </item>
    
    <item>
      <title>ubuntu12.04 修复Grub2</title>
      <link>http://liuxueyang.github.io/posts/ubuntu12.04-%E4%BF%AE%E5%A4%8Dgrub2/</link>
      <pubDate>Thu, 27 Jun 2013 20:39:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/ubuntu12.04-%E4%BF%AE%E5%A4%8Dgrub2/</guid>
      <description>电脑双系统，但是把win7重装了之后，会发现grub坏了，只能进入win7。 遇到过好几次，虽然每次都成功解决问题了，但是都花费了不少时间。 所以，总结一下，基本是从网上找到的方法，有的行不通，有的可以。就我的尝试，总结了一下对我的电脑来说，比较有效的方法。 首先说明：我的boot分区没有单独分区！ 第一步： 用光盘进入Ubuntu LiveCD，打开终端，
sudo fdisk -l  找到 id 是83的那行，可惜我的有两个：/dev/sda3 和 /dev/sda8 。一般的应该有一行的……囧，可能是装系统的时候没搞好o(╯□╰)o 后来尝试发现，用 /dev/sda3 才是正确的。记住这个号码，考虑到一般性，这里记为/dev/sdaX 第二步：sudo -i 获得root权限 mkdir /media/tempdir   挂载：</description>
    </item>
    
    <item>
      <title>点头1010 只包含因子2 3 5的数</title>
      <link>http://liuxueyang.github.io/posts/%E7%82%B9%E5%A4%B41010-%E5%8F%AA%E5%8C%85%E5%90%AB%E5%9B%A0%E5%AD%902-3-5%E7%9A%84%E6%95%B0/</link>
      <pubDate>Sat, 15 Jun 2013 17:24:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E7%82%B9%E5%A4%B41010-%E5%8F%AA%E5%8C%85%E5%90%AB%E5%9B%A0%E5%AD%902-3-5%E7%9A%84%E6%95%B0/</guid>
      <description>题目链接：http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1010 题目思路： 想想怎么打表吧，还有，只需要存下满足要求的数字，要求的数字可以表示为：(2^x*3^y*5^z)，然后可以发现：2^60&amp;gt;10^18，所以，枚举的上限是60*60*60，大约是216000，实际上，只有1万多。枚举的方法就是以前做过的题目了：http://poj.org/problem?id=1338 然后就是二分查找，边界比较纠结。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdlib&amp;gt; #define LL long long #define MAXN 216000+10 #define min(a,b) ((a)&amp;lt;(b)?</description>
    </item>
    
    <item>
      <title>准备期末考试 博客不更了</title>
      <link>http://liuxueyang.github.io/posts/%E5%87%86%E5%A4%87%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95-%E5%8D%9A%E5%AE%A2%E4%B8%8D%E6%9B%B4%E4%BA%86/</link>
      <pubDate>Sat, 08 Jun 2013 18:48:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%87%86%E5%A4%87%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95-%E5%8D%9A%E5%AE%A2%E4%B8%8D%E6%9B%B4%E4%BA%86/</guid>
      <description>今天高考结束了……大家都考得挺好的吧，祝福他们。 高考结束后，马上又将会有这么一群孩子，迫不及待的扔下书包，去聚餐，通宵上网，旅行，KTV，闲逛，狂欢……认为自己终于解放了……殊不知，你们离开的，就是天堂。 认真准备期末考试，虽然还是有的时候忍不住会写代码，囧。昨天CF做得真的挫了。这就是一周不写程序的后果，呵呵。坚决不写程序了，准备考试！实在无聊看看python，haskell什么的……</description>
    </item>
    
    <item>
      <title>Codeforces Round #187 (Div. 2) B. Sereja and Array</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-#187-div.-2-b.-sereja-and-array/</link>
      <pubDate>Sat, 08 Jun 2013 18:38:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-round-#187-div.-2-b.-sereja-and-array/</guid>
      <description>题目链接：http://codeforces.com/contest/315/problem/B 开始以为线段树，汗……原来是道水题
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;queue&amp;gt; using namespace std; typedef struct Po { int d, a; }Po; Po p[100000+10]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;187b.</description>
    </item>
    
    <item>
      <title>Codeforces Round #187 (Div. 2) A. Sereja and Bottles</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-#187-div.-2-a.-sereja-and-bottles/</link>
      <pubDate>Sat, 08 Jun 2013 18:35:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-round-#187-div.-2-a.-sereja-and-bottles/</guid>
      <description>题目链接：http://codeforces.com/contest/315/problem/A 这到题目比赛的时候过了，赛后WA了……虽然很简单，但是还是没想太清楚
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; #define MAX 103 int a[MAX], b[MAX]; int main(void) { int n; #ifndef ONLINE_JUDGE freopen(&amp;quot;187a.</description>
    </item>
    
    <item>
      <title>NYOJ5 Binary String Matching ——KMP</title>
      <link>http://liuxueyang.github.io/posts/nyoj5-binary-string-matching-kmp/</link>
      <pubDate>Mon, 03 Jun 2013 01:38:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/nyoj5-binary-string-matching-kmp/</guid>
      <description>题目链接：http://acm.nyist.net/JudgeOnline/problem.php?pid=5 题目思路： 典型的KMP，关键就是修改一下，找到了模式串p之后，继续从大的串s里面模式串开始的位置的下一个位置开始找下一个。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; char p[1000], s[1000]; int next[1000]; void getnext() { int i = 0, j = -1, len = strlen(p); next[0] = -1; while (i &amp;lt; len - 1) { if (j == -1 || p[j] == p[i]) { j++; i++; next[i] = j; } else j = next[j]; } } int kmp() { int i = -1, j = -1, lenp = strlen(p), lens = strlen(s); getnext(); int num = 0; while (i &amp;lt; lens) { if (j == -1 || s[i] == p[j]) {++i; ++j;} else j = next[j]; if (j == lenp) {i-=j; j = -1; num++;} } return num; } int main(void) { int n; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) while (n--){ scanf(&amp;quot;%s%s&amp;quot;, p, s); printf(&amp;quot;%d\n&amp;quot;, kmp()); } return 0; }  复习了一下KMP，很有意思~ 看到了一个STL的方法，碉堡了…… #include &amp;lt;cstdio&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; string s, p; int main(void) { int n; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { while (n--) { cin &amp;gt;&amp;gt; p &amp;gt;&amp;gt; s; int num = 0; unsigned ans = 0; ans = s.</description>
    </item>
    
    <item>
      <title>KMP示例程序</title>
      <link>http://liuxueyang.github.io/posts/kmp%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Mon, 03 Jun 2013 01:28:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/kmp%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/</guid>
      <description>输入： 数字N，然后是N组数据，每一组数据第一行是模式串p，第二行是一个大的字符创s，如果在s里面出现了p，那么输出p第一次出现的位置，否则输出No #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; char p[1000], s[1000]; int next[1000]; void getnext() { int i = 0, j = -1, len = strlen(p); next[0] = -1; while (i &amp;lt; len - 1) { if (j == -1 || p[j] == p[i]) { j++; i++; next[i] = j; } else j = next[j]; } } int kmp() { int i = -1, j = -1, lenp = strlen(p), lens = strlen(s); getnext(); while (j !</description>
    </item>
    
    <item>
      <title>hdu1420 Prepared for New Acmer ——快速幂</title>
      <link>http://liuxueyang.github.io/posts/hdu1420-prepared-for-new-acmer-%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Sat, 01 Jun 2013 19:33:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1420-prepared-for-new-acmer-%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1420 题目大意： 中文题。 题目思路： 赤裸裸的快速幂。呵呵
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; #define LL long long LL m; LL Po(LL a, LL b) { LL ans = 1; while (b) { if (b&amp;amp;1) { ans = (ans * a) % m; b--; } b /= 2; a = a * a % m; } return ans; } int main(void) { LL n, a, b; #ifndef ONLINE_JUDGE freopen(&amp;quot;1420.</description>
    </item>
    
    <item>
      <title>hdu1257 最少拦截系统 ——DP么？</title>
      <link>http://liuxueyang.github.io/posts/hdu1257-%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F-dp%E4%B9%88/</link>
      <pubDate>Sat, 01 Jun 2013 18:43:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1257-%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F-dp%E4%B9%88/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1257 题目大意： 中文的…… 题目思路： 人家说是DP，求最长不升子序列的个数。好吧……我不是那么做的。 我的思路是，从前往后扫一遍，访问过的标记为true，记录一下个数就ＯＫ了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int b[1000]; bool a[1000]; int main(void) { int n; #ifndef ONLINE_JUDGE freopen(&amp;quot;1257.</description>
    </item>
    
    <item>
      <title>Codeforces Round #185 (Div. 2) B. Archer</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-#185-div.-2-b.-archer/</link>
      <pubDate>Fri, 31 May 2013 11:10:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-round-#185-div.-2-b.-archer/</guid>
      <description>题目链接：http://codeforces.com/problemset/problem/312/B 题目大意： 很简短，不解释了。 题目思路： 开始怎么也读不懂题意，以为求期望呢，想不开……后来问了别人才知道，原来就是求概率，也没说多少个回合，所以就是求极限…… 所以，这货就是一道很简洁的概率题，推个公式就好了。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; int main(void) { int a, b, c, d; double p1, p2, ans; scanf(&amp;quot;%d%d%d%d&amp;quot;, &amp;amp;a, &amp;amp;b, &amp;amp;c, &amp;amp;d); p1 = 1.</description>
    </item>
    
    <item>
      <title>Codeforces Round #186 (Div. 2) C. Ilya and Matrix</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-#186-div.-2-c.-ilya-and-matrix/</link>
      <pubDate>Fri, 31 May 2013 11:04:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-round-#186-div.-2-c.-ilya-and-matrix/</guid>
      <description>题目链接：http://codeforces.com/problemset/problem/313/C 题目大意： 还是看原题吧，意思不难懂。 题目思路： 开始一直没有想法，后来听一然酱讲了才好不容易搞懂，赶脚好神奇。 构造的思路应该算贪心，先把前4大的数字排列到最先划分的4个方格里面，然后再依次把后面比较大的数字依次填充到这四个方格里空着的小格子里面，直到所有的格子填满为止，为什么这个思路是正确的呢？还是模拟一下4*4的格子就差不多理解了吧。 但是关键是怎么算出递归得到的结果？一然酱的思路很巧妙，先把数字逆序排列，再把前序和算出来，目的是方便后面的求和，然后从递归的最底层开始考虑。最底层肯定是所有的数字都包括，也就是前N个数字的和，再往上走，就是前N/4个数字的和，直到N&amp;lt;1为止。碉堡了…… #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; #define LL long long int const int MAX = 1000000*2+10; LL a[MAX], ans, n; bool cmp2(LL a, LL b) { return a &amp;gt; b; } int main(void) { while (~scanf(&amp;quot;%I64d&amp;quot;, &amp;amp;n)) { int i; for (i = 0; i &amp;lt; n; ++i) scanf(&amp;quot;%I64d&amp;quot;, a+i); sort(a, a+n, cmp2); for (i = 1; i &amp;lt; n; ++i) a[i] += a[i-1]; ans = 0; while (n &amp;gt;= 1) { ans += a[n-1]; n = n &amp;gt;&amp;gt; 2; } printf(&amp;quot;%I64d\n&amp;quot;, ans); } return 0 ; }   然后就是注意一下类型用LL…… 这回跟一然酱去网吧做CF，感触颇深，看人家神牛怎么做比赛的，给跪……谢谢一然酱~ </description>
    </item>
    
    <item>
      <title>Codeforces Round #185 (Div. 1) A. The Closest Pair</title>
      <link>http://liuxueyang.github.io/posts/codeforces-round-#185-div.-1-a.-the-closest-pair/</link>
      <pubDate>Thu, 30 May 2013 00:05:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-round-#185-div.-1-a.-the-closest-pair/</guid>
      <description>题目链接：http://codeforces.com/problemset/problem/311/A 题目大意： 题目很短，不解释了。^_^ 题目思路： 开始感觉很难，没思路。看了解题报告，发现原来是道水题嘛。程序里面有个break语句，要让循环次数达到最大，并且循环次数容易计算，只需要让这个break;永远不会执行就可以了。也就是说，可以让p[j].x - p[i].x &amp;gt;= d 永远不成立，只需要让p[j].x - p[i].</description>
    </item>
    
    <item>
      <title>The Unique MST ——最小生成树的唯一性</title>
      <link>http://liuxueyang.github.io/posts/the-unique-mst-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7/</link>
      <pubDate>Sun, 26 May 2013 23:58:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/the-unique-mst-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7/</guid>
      <description>题目链接：http://acm.hust.edu.cn/vjudge/contest/view.action?cid=24534#problem/C 题目大意： 判断最小生成树是否唯一。 题目思路： 对于如果有一条边A在最小生成树里面，并且存在和这条边权值一样的另外一条边B，那么再次求最小生成树的时候，把A去掉，看看求出的最小生成树是不是和原来的最小生成树权值一样。如果一样，就是不唯一，否则就刚才去掉的加进来，然后再找下一条这样的边。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define MAXN 110 #define MAXM 5009 typedef struct edge { int u, v, w, used, del, equal; bool operator &amp;lt; (const edge &amp;amp;other) const { return w &amp;lt; other.</description>
    </item>
    
    <item>
      <title>Constructing Roads ——最小生成树</title>
      <link>http://liuxueyang.github.io/posts/constructing-roads-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <pubDate>Sun, 26 May 2013 23:52:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/constructing-roads-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <description>题目链接：http://acm.hust.edu.cn/vjudge/contest/view.action?cid=24534#problem/B 题目大意： 给邻接矩阵，和已经建立好的几条边。求最小生成树权值。 题目思路： 方法就是把已将建立好的边的权值赋值为0即可。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define MAXN 110 #define MAXM 5009 typedef struct edge { int u, v, w; bool operator &amp;lt; (const edge &amp;amp;other) const { return w &amp;lt; other.</description>
    </item>
    
    <item>
      <title>Agri-Net ——最小生成树</title>
      <link>http://liuxueyang.github.io/posts/agri-net-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</link>
      <pubDate>Sun, 26 May 2013 23:50:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/agri-net-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</guid>
      <description>题目链接：http://acm.hust.edu.cn/vjudge/contest/view.action?cid=24534#problem/A 题目大意： 给定无向图，邻接矩阵。求最小生成树权值。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define MAXN 110 #define MAXM 5009 typedef struct edge { int u, v, w; bool operator &amp;lt; (const edge &amp;amp;other) const { return w &amp;lt; other.</description>
    </item>
    
    <item>
      <title>hdu1176 免费馅饼 ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu1176-%E5%85%8D%E8%B4%B9%E9%A6%85%E9%A5%BC-dp/</link>
      <pubDate>Sat, 25 May 2013 17:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1176-%E5%85%8D%E8%B4%B9%E9%A6%85%E9%A5%BC-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1176 题目大意： 中文题…… 题目思路： 类似于 Triangle 。d[i][j] 表示 i 时间在 j 位置的所得到的价值。然后就像 Triangle 一样从下往上递推。最终求在0秒的时候，在5位置上的值。 ＷＡ了两次，当初求的是0秒的时候，所有位置上的最大值，，这显然是不对的。因为起始位置是5啊。</description>
    </item>
    
    <item>
      <title>poj1018 Communication System ——贪心&#43;枚举</title>
      <link>http://liuxueyang.github.io/posts/poj1018-communication-system-%E8%B4%AA%E5%BF%83&#43;%E6%9E%9A%E4%B8%BE/</link>
      <pubDate>Sat, 25 May 2013 06:16:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1018-communication-system-%E8%B4%AA%E5%BF%83&#43;%E6%9E%9A%E4%B8%BE/</guid>
      <description>题目链接：http://poj.org/problem?id=1018 题目大意： 有n种设备，每种设备有mi个选择，每种设备选择一个，每个设备都有一个带宽值和价钱，要求每种设备选择一个，最终选择的n个设备里面，带宽B是这n个设备里面所有带宽的最小值吗，价钱P为这n个设备价钱的和，求B/P的最大值。 题目思路： 这题开始没读懂题意，后来搜的题意之后才明白。然后没有思路……看了人家的思路，貌似懂了……然后就开始写，写跪了……开始的方法是，求出所有这n种设备里面每种设备的带宽的最小值，依次枚举这些最小值就可以了。总是WA…… 昨天纠结一晚上，今天早上又想了一下，发现原来的想法是有问题的，应该一直枚举到所有n中设备里面每种带宽的最大值的最小值。第一：保证这n种设备每一种都可以选上。第二：虽然枚举的B值比原来大了，所得到的的价钱不小于我原来的做法所得到的的价钱，但是，重点来了：B也增大了啊！有木有！所以，这就是我当初没有想到的！ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define MAXN 0x7fffffff #define MINN -MAXN const int MAX = 100+10; typedef struct node { int p, b, cnt; bool operator &amp;lt; (const node &amp;amp; other ) const { if (p !</description>
    </item>
    
    <item>
      <title>设置zsh为系统默认shell</title>
      <link>http://liuxueyang.github.io/posts/%E8%AE%BE%E7%BD%AEzsh%E4%B8%BA%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4shell/</link>
      <pubDate>Fri, 24 May 2013 18:47:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E8%AE%BE%E7%BD%AEzsh%E4%B8%BA%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4shell/</guid>
      <description>whereis zsh 就会显示zsh的路径，一般是 /bin/zsh 然后输入 chsh -s /bin/zsh 会提示输入密码，然后重新登录就好了～ 同样，如果设置其它的shell，也是类似的做法。</description>
    </item>
    
    <item>
      <title>hdu2069 Coin Change ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu2069-coin-change-dp/</link>
      <pubDate>Fri, 24 May 2013 11:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu2069-coin-change-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2069 题目大意： 给一个数字，用1, 5, 10， 25, 50 这五种硬币，最多用100枚，有多少种组合方式。 题目思路： 这道题和之前的题目不同，有了硬币个数的限制，所以需要加上一维表示硬币的个数就可以了。d[i][j]表示价值为 i 的最多用 j 枚硬币有多少中组合方式。很多人用母函数做，感觉DP做简单多了…… 参考博客：http://www.</description>
    </item>
    
    <item>
      <title>2013年5月23日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8823%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Thu, 23 May 2013 23:46:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8823%E6%97%A5-%E6%99%B4/</guid>
      <description>最近长沙的天气啊，不是下雨就是下雨……无语O__O&amp;rdquo;… 今天晚上终于去跑步了，穿上跑鞋，还有差不多半年没有穿过的棒球队队服，去跑步吧~ 开始感觉不错，节奏还不错，跑得略快，到一半的时候，感觉有点吃不消啊，还好后来放慢速度，把节奏调整好了，继续跑着，又是一个月明风清的晚上，湘江边对面的灯光很美，就那么不快不慢地跑着，多好，人生一大幸事啊。夏天来了，汗水，激情，奋斗，梦想，青春，就是这样的吧，加油 最后还是跑完全程5K了。虽然也许永远也达不到高中的时候48分钟跑完10K的那种状态了，但是跑步也不全是为了速度或者成绩，高兴就行了，实力是在不知不觉中增长的。 说好了晚上回宿舍就补作业不写程序的，结果……不知不觉写了一晚上的程序，，然后就跑步去了，，回来就十点半了……又写了会儿程序，，就到现在了……果然还是没写作业啊……要交作业了还没有预习完有木有……果然是要通宵补作业了么…… 学习时间可以少，但是效率一定要高！ 身边总有些人在无私地帮助我，鼓励我，谢谢你们~</description>
    </item>
    
    <item>
      <title>hdu1398 Square Coins ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu1398-square-coins-dp/</link>
      <pubDate>Thu, 23 May 2013 23:20:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1398-square-coins-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1398 题目大意： 给一个数字，不大于300，求有多少种用完全平方数表示这个数字的方法 题目思路： 方法跟hdu1283一样一样的……只需要把那道题目的代码稍微改一下就可以过了 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n) &amp;amp;&amp;amp; n) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &amp;lt;= floor(sqrt(n)); ++i) { for (j = i*i; j &amp;lt;= n; ++j) { d[j] += d[j-i*i]; } } printf(&amp;quot;%lld\n&amp;quot;, d[n]); } } int main(void) { solve(); return 0; }   因为题目的范围很小嘛，只有300。 </description>
    </item>
    
    <item>
      <title>hdu1284 钱币兑换问题 ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu1284-%E9%92%B1%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-dp/</link>
      <pubDate>Thu, 23 May 2013 20:39:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1284-%E9%92%B1%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1284 题目大意： 中文题…… 题目思路： 只有3个硬币，范围是32768，可以一个一个枚举硬币，如果只放价值为1的硬币，从d[1]递推到d[n]；如果再加上价值为2的硬币，那么就从d[2]递推到d[n]；在加上价值为3的硬币，就从d[3]递推到d[n].递推公式是d[j] = d[j] + d[j-i]； d[j]表示j有几种只用1，2, 3这三个数字的拆分方法，i 就是硬币的价值。 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &amp;lt;= 3; ++i) { for (j = i; j &amp;lt;= n; ++j) { d[j] += d[j-i]; } } printf(&amp;quot;%lld\n&amp;quot;, d[n]); } } int main(void) { solve(); return 0; }   参考博客：http://www.</description>
    </item>
    
    <item>
      <title>hdu1028 Ignatius and the Princess III ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu1028-ignatius-and-the-princess-iii-dp/</link>
      <pubDate>Thu, 23 May 2013 19:48:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1028-ignatius-and-the-princess-iii-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1028 题目大意：　整数拆分，给一个整数n,求它有多少种拆分方法。 题目思路： 做法一： d[i][j]表示把整数 i 拆成最多 j 个数字所具有的方法数。那么 if (i &amp;gt;ｊ)　d[i][j] = d[i-j][j] + d[i][j-1]; 意思就是如果i&amp;gt;j，那么有两种方式：一种是先把i里面分理处j个1，然后再把i-j拆成最多i-j个数字；另一种是把i拆分成最多j-1个数字。 if (i &amp;lt; j) d[i][j] = d[i][i]; 意思就是如果i&amp;lt;j，那么这种情况和把数字i最多拆成i个数字的是一样的。 if (i == j) d[i][j] = d[i][j-1] + 1; 意思就是如果i==j，那么可以把数字i拆分成j-1个数字，也可以把数字i拆分成i个1（这个就是那个1的意义） #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; #define LL long long int d[140][140], n; void init() { while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { int i, j; memset(d, 0, sizeof(d)); for (i = 0; i &amp;lt;= n; ++i) d[i][1] = d[1][i] = 1; for (i = 2; i &amp;lt;= n; ++i) { for (j = 1; j &amp;lt;= n; ++j) { if (i &amp;gt; j) d[i][j] = d[i-j][j] + d[i][j-1]; else if (i == j) d[i][j] = 1 + d[i][j-1]; else d[i][j] = d[i][i]; } } cout &amp;lt;&amp;lt; d[n][n] &amp;lt;&amp;lt; endl; } } int main(void) { init(); return 0 ; }   剩下的就是考虑一下边界，比如当 i 或者 j 等于1的时候，显然都是只有一种拆分情况。 做法二： 借用hdu1284这道题的方法，也可以做这道题目，因为n的范围是120嘛,两个算法的复杂度都是O(n^2)的，当然可以了。只需要把hdu1284的代码里面把3改成n，这题就过了…… #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &amp;lt;= n; ++i) { for (j = i; j &amp;lt;= n; ++j) { d[j] += d[j-i]; } } printf(&amp;quot;%lld\n&amp;quot;, d[n]); } } int main(void) { solve(); return 0; }   优化到了一维数组，这个方法碉堡了…… 参考博客：http://www.</description>
    </item>
    
    <item>
      <title>hdu1394 Minimum Inversion Number ——线段树</title>
      <link>http://liuxueyang.github.io/posts/hdu1394-minimum-inversion-number-%E7%BA%BF%E6%AE%B5%E6%A0%91/</link>
      <pubDate>Thu, 23 May 2013 18:25:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1394-minimum-inversion-number-%E7%BA%BF%E6%AE%B5%E6%A0%91/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1394 题目大意： 给定一个0到ｎ-1的数字组成的序列，它的逆序数，然后把第一个数字放到末尾，得到一个新的序列，再求逆序数，再把新序列的第一个数字放到末尾，一直这样做，求所有这些序列的逆序数的最小值。 题目思路： 可以先求出起初的序列的逆序数。然后根据逆序数的定义，把一个数字从开头移动到末尾，逆序数的改变量是什么？求出这个改变量，然后剩下的所有序列的逆序数就都求出来了。 这样考虑：一个数字 ｂ[i] 在开头，比它大的数字有 ｂ[i] 个，也就是说和这个数字组成了 ｂ[i] 个逆序，把它放到最后，这个数字可以组成 n-1-ｂ[i] 个逆序，所以逆序数的增量是 n - 1 - ｂ[i] - ｂ[i] ，这样就可以根据原来的序列的逆序数求出剩下的所有序列的逆序数了～</description>
    </item>
    
    <item>
      <title>poj2299 Ultra-QuickSort ——线段树</title>
      <link>http://liuxueyang.github.io/posts/poj2299-ultra-quicksort-%E7%BA%BF%E6%AE%B5%E6%A0%91/</link>
      <pubDate>Thu, 23 May 2013 14:40:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2299-ultra-quicksort-%E7%BA%BF%E6%AE%B5%E6%A0%91/</guid>
      <description>题目链接：http://poj.org/problem?id=2299 题目大意： 给n个任意的数字，把他们排序，求最少的交换次数。 题目思路： 开始没想法。后来zjl一说才知道。原来就是求逆序数！每一个数字前面有多少比它小的，这个数字就至少要交换多少次。所以，只需要求这列数字的逆序数就可以！好神奇 还有一个，就是每个数字的范围比较大，开始我还在想开数组貌似放不下，后来zjl说离散化……好吧，果然，我肿么没想到o(╯□╰)o感觉挺自然的想法啊…… 剩下的就是原来做过的题目了……甚至比原来做过的还简单 最后一个问题就是，最后的结果应该是long long 的，稍微算一下就知道，最大值(2*10^11)超过了4个字节的整型范围(4 * 10^9)，long long 范围是(1*10^19)，所以输出要按照long long 输出……这个问题以后一定要注意，判断一下数字的范围！别傻乎乎地就用int…… //#define LOCAL #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 500000+10; typedef struct node { int val, index; bool operator &amp;lt; (const node &amp;amp; other) const { return val &amp;lt; other.</description>
    </item>
    
    <item>
      <title>入门经典 7.1.1 除法</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-7.1.1-%E9%99%A4%E6%B3%95/</link>
      <pubDate>Wed, 22 May 2013 18:32:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-7.1.1-%E9%99%A4%E6%B3%95/</guid>
      <description>开始没思路，但是仔细思考一下，发现可以枚举，然后找一下上界和下界，可以知道范围并不大。我的枚举量是将近50000的样子，书上说枚举量可以降低到10000……没懂，再想一下
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;map&amp;gt; using namespace std; map&amp;lt;int, bool&amp;gt; mymap; void solve(int i) { while (i) { mymap[i%10] = true; i /= 10; } } void init() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { for (i = 1200; i &amp;lt; 50000; ++i) { if ((i*n)/10000 == 0 || (i*n)/10000 &amp;gt;= 10) continue; mymap.</description>
    </item>
    
    <item>
      <title>uva11078 Open Credit System</title>
      <link>http://liuxueyang.github.io/posts/uva11078-open-credit-system/</link>
      <pubDate>Tue, 21 May 2013 18:26:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva11078-open-credit-system/</guid>
      <description>题目链接：http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=2019 题目大意： 给一个长度为n的序列，求Ai - Aj (i &amp;lt; j)的最大值。序列的长度最大是10^5 题目思路： 动态维护某一个数字之前的最大值，不断更新之。同时不断更新结果ans，更新的方法是ans和当前数字之前的最大值与这个数字作差，取其中的最大值。时间复杂度O(N),空间复杂度O(1)</description>
    </item>
    
    <item>
      <title>uva11462 Age Sort ——计数排序</title>
      <link>http://liuxueyang.github.io/posts/uva11462-age-sort-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 21 May 2013 17:00:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva11462-age-sort-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</guid>
      <description>题目链接：http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=2457 题目大意： 给很多个范围在１到１００之内的数字，数量最多有2*10^6个，排序输出。 题目思路： 数组很大，超内存。不能快排。所以采用计数排序
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; int a[120]; void solve() { int n, tmp, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { if (!</description>
    </item>
    
    <item>
      <title>USACO Friday the Thirteenth ——水题</title>
      <link>http://liuxueyang.github.io/posts/usaco-friday-the-thirteenth-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Tue, 21 May 2013 14:40:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/usaco-friday-the-thirteenth-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://cerberus.delos.com:790/usacoprob2?a=EYxUgMg3whp&amp;amp;S=friday 题目大意： 意思比较简单。求1900年到1900+N年的每个月的13号落在了星期几。输出13号落在一个星期的每一天的次数。 题目思路： 方法一： 有个蔡勒公式： 这个公式可以根据某天的日期，算出这一天是星期几，套用一下就行了。 公式中的符號含義如下： ——选自维基百科 /* ID: zypz457 LANG: C++ TASK: friday */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; int n; int cnt[7]; int cal(int y, int m, int d) { int month = m, c; if (month == 1) { month = 13; y--; } else if (month == 2) { month = 14; y--; } else {month = m;} m = month; c = y/100; y = y%100; int ans = (y + y/4 + floor(c/4) -2*c + floor(26*(m+1)/10) + d - 1); ans = (ans%7 + 7) % 7; return ans; } void solve() { scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); memset(cnt, 0, sizeof(cnt)); int y, j, i, month, ans; for (i = 0; i &amp;lt; n; ++i) { y = i + 1900; for (j = 1; j &amp;lt;= 12; ++j) { ans = cal(y, j, 13); cnt[ans]++; } } printf(&amp;quot;%d &amp;quot;, cnt[6]); for (i = 0; i &amp;lt; 5; ++i) printf(&amp;quot;%d &amp;quot;, cnt[i]); printf(&amp;quot;%d\n&amp;quot;, cnt[5]); } int main(void) { freopen(&amp;quot;friday.</description>
    </item>
    
    <item>
      <title>USACO Greedy Gift Givers ——水题</title>
      <link>http://liuxueyang.github.io/posts/usaco-greedy-gift-givers-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Tue, 21 May 2013 13:05:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/usaco-greedy-gift-givers-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://cerberus.delos.com:790/usacoprob2?S=gift1&amp;amp;a=nR34fDHld4J 题目大意：http://blog.sina.com.cn/s/blog_63d0cab00100h1rx.html 赶脚这货考的是英语……
/* ID: zypz457 LANG: C++ TASK: gift1 */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;map&amp;gt; using namespace std; int n; map&amp;lt;string, int&amp;gt; mymap; int wei[15][2]; string name[20]; void init() { int i; freopen(&amp;quot;gift1.</description>
    </item>
    
    <item>
      <title>USACO Your Ride Is Here ——水题</title>
      <link>http://liuxueyang.github.io/posts/usaco-your-ride-is-here-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Tue, 21 May 2013 11:47:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/usaco-your-ride-is-here-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://cerberus.delos.com:790/usacoprob2?a=nR34fDHld4J&amp;amp;S=ride 人家说USACO的题目适合入门……我还是先刷这个吧…… 这道题目主要是学了一下USACO里面的文件输入输出格式
/* ID: zypz457 TASK: ride LANG: C++ */ #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;fstream&amp;gt; using namespace std; int main(void) { ifstream fin(&amp;quot;ride.</description>
    </item>
    
    <item>
      <title>NYOJ16 矩形嵌套 ——DP入门题</title>
      <link>http://liuxueyang.github.io/posts/nyoj16-%E7%9F%A9%E5%BD%A2%E5%B5%8C%E5%A5%97-dp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 20 May 2013 21:34:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/nyoj16-%E7%9F%A9%E5%BD%A2%E5%B5%8C%E5%A5%97-dp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.nyist.net/JudgeOnline/problem.php?pid=16 题目大意： 中文题…… 题目思路： 方法一： 先按照长和宽进行二级排序，然后转化成最长上升子序列求解。时间复杂度O(N^2)，数据范围1000.
#include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; const int MAX = 1000+10; typedef struct node { int x, y; bool operator &amp;lt; (const node &amp;amp;other) const { if (x !</description>
    </item>
    
    <item>
      <title>poj1163 The Triangle ——DP入门题</title>
      <link>http://liuxueyang.github.io/posts/poj1163-the-triangle-dp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 20 May 2013 16:42:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1163-the-triangle-dp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1163 题目思路： 从三角形的底部开始考虑
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; const int MAX = 100; int a[MAX][MAX], dp[MAX][MAX]; int main(void) { //freopen(&amp;quot;1163.</description>
    </item>
    
    <item>
      <title>csu1290 Random Integers ——DP入门题&amp;&amp;比赛残留题</title>
      <link>http://liuxueyang.github.io/posts/csu1290-random-integers-dp%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/</link>
      <pubDate>Sun, 19 May 2013 17:07:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/csu1290-random-integers-dp%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/</guid>
      <description>题目链接：http://122.207.68.93/OnlineJudge/problem.php?id=1290 题目大意： 从K个不同的数字里面有放回地随机选N次，求选到的不同的数字的种类的期望。 题目思路： 这题不能用概率公式推导。因为有很多项的阶乘，应该会超double范围。应该用DP做。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; const int MAX=1000+10; double dp[MAX][MAX]; int main(void) { int i, j, k, t; double N, K; scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); while (t--) { scanf(&amp;quot;%lf%lf&amp;quot;, &amp;amp;K, &amp;amp;N); double sum = 0.</description>
    </item>
    
    <item>
      <title>poj3070 Fibonacci ——矩阵快速幂</title>
      <link>http://liuxueyang.github.io/posts/poj3070-fibonacci-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Sun, 19 May 2013 01:38:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj3070-fibonacci-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>题目链接：http://poj.org/problem?id=3070 题目大意： 求第N项的Fibonacci数的后四位。 题目思路： 根据公式： 用矩阵快速幂就OK，模板题……但还是TLE了一次，原因是题目要求输入-1结束，我没看到……o(╯□╰)o
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; const int MAX = 2; const int M = 10000; typedef struct { int m[MAX][MAX]; }Matrix; Matrix a, per; int n; void init() { int i , j; for (i = 0; i &amp;lt; n; ++i) { for (j = 0; j &amp;lt; n; ++j) { per.</description>
    </item>
    
    <item>
      <title>WPS for Ubuntu!</title>
      <link>http://liuxueyang.github.io/posts/wps-for-ubuntu/</link>
      <pubDate>Sat, 18 May 2013 19:28:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/wps-for-ubuntu/</guid>
      <description>好兴奋！终于可以在Ubunt下面看word和ppt了～ 虽然WPS for Linux貌似还不那么稳定，但是刚安装好感觉还不错，目前感觉很爽！ 下载地址：http://community.wps.cn/download/ 下载的时候下载deb包，然后用软件中心安装就ＯＫ 然后安装好后，发现少字体，只需要安装上那些字体就行了，地址：http://bbs.wps.cn/thread-22355435-1-1.html wps的论坛，看9楼神贴。金山快盘里面的下载地址http://www.kuaipan.cn/file/id_19418406138675408.htm 依然是用软件中心安装字体，好兴奋～</description>
    </item>
    
    <item>
      <title>ubuntu下歌词显示软件</title>
      <link>http://liuxueyang.github.io/posts/ubuntu%E4%B8%8B%E6%AD%8C%E8%AF%8D%E6%98%BE%E7%A4%BA%E8%BD%AF%E4%BB%B6/</link>
      <pubDate>Sat, 18 May 2013 18:56:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/ubuntu%E4%B8%8B%E6%AD%8C%E8%AF%8D%E6%98%BE%E7%A4%BA%E8%BD%AF%E4%BB%B6/</guid>
      <description>软件的名字是：osd-lyrics https://code.google.com/p/osd-lyrics/ 感觉很不错，支持ＶＬＣ 安装方法：https://code.google.com/p/osd-lyrics/wiki/InstallUbuntu</description>
    </item>
    
    <item>
      <title>zoj2136 &amp;&amp; poj2533 Longest Ordered Subsequence ——最长上升子序列经典DP</title>
      <link>http://liuxueyang.github.io/posts/zoj2136--poj2533-longest-ordered-subsequence-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E7%BB%8F%E5%85%B8dp/</link>
      <pubDate>Thu, 16 May 2013 12:44:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj2136--poj2533-longest-ordered-subsequence-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E7%BB%8F%E5%85%B8dp/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1136  http://poj.org/problem?id=2533 题目大意：RT 题目思路： maxlen[j]表示，到j位置，最长的上升子序列的长度。时间复杂度O（N^2），数据范围是1000 参考解题报告：http://www.slyar.com/blog/longest-ordered-subsequence.html zoj:
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int str[1000], maxlen[1001], p[1001]; int main(void){ #ifdef LOCAL freopen(&amp;quot;lis.</description>
    </item>
    
    <item>
      <title>ural1057 Amount of Degrees ——数位DP</title>
      <link>http://liuxueyang.github.io/posts/ural1057-amount-of-degrees-%E6%95%B0%E4%BD%8Ddp/</link>
      <pubDate>Wed, 15 May 2013 16:30:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/ural1057-amount-of-degrees-%E6%95%B0%E4%BD%8Ddp/</guid>
      <description>题目链接：http://acm.timus.ru/problem.aspx?space=1&amp;amp;num=1057 题目大意： 意思就是给一个区间[x, y]，求这个区间内有多少个恰好可以被k个b的不同次幂的数之和表示出来的数字的个数。 题目思路： 只需要求区间[0, m]内的恰好可以被k个b的不同次幂的数之和表示出来的数字的个数，定义这个函数是solve(m, k, b)。题目要求的就是：solve(y, k, b) - solve(x - 1, k, b)。 思路就是，转化成二进制考虑。把这个区间内的某个数字表示成b进制，要求的数字是转化成b进制之后，每一位的数字均为0或者1，这样的数字。 画一棵完全二叉树，根节点是0，左子节点是0，右子节点是1，高度从0开始记起，整棵树的根节点不用。则f[i][j]表示，高度为i的二叉树里面恰好含有j个1的数字的个数。那么就有： f[i][j] = f[i-1][j-1] + f[i-1][j] 意思就是高度为i的树包含的数字里面，符合条件的数字的数目等于左右两棵子树的和。 当然数组f[i&amp;hellip;n][0]都要初始化为1，因为长度为i&amp;hellip;n的并且含有0个1的数字的个数总为1.</description>
    </item>
    
    <item>
      <title>uva133 The Dole Queue 循环队列模拟</title>
      <link>http://liuxueyang.github.io/posts/uva133-the-dole-queue-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Tue, 14 May 2013 11:01:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva133-the-dole-queue-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E6%A8%A1%E6%8B%9F/</guid>
      <description>题目链接：http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=69 题目大意： 1到n按照逆时针的顺序围成一个环，一个人逆时针从1开始数k个数字，另一个人顺时针从n开始数m个数字，每次两个人最终数到的数字输出，并且把他们从原来的环里面删除，如果两个人数到的数字不同，输出一对，如果相同，输出这个数字。不管重复上面的做法，直到n个数字全部被删除。 题目思路： 模拟题，代码弱，写了很久，写不出来，就是感觉比较麻烦，看了人家的代码，做法很好！http://blog.csdn.net/actoy/article/details/8747826
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;uva133.</description>
    </item>
    
    <item>
      <title>uva127 ``Accordian&#39;&#39; Patience ——链表模拟题</title>
      <link>http://liuxueyang.github.io/posts/uva127-accordian-patience-%E9%93%BE%E8%A1%A8%E6%A8%A1%E6%8B%9F%E9%A2%98/</link>
      <pubDate>Mon, 13 May 2013 19:10:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva127-accordian-patience-%E9%93%BE%E8%A1%A8%E6%A8%A1%E6%8B%9F%E9%A2%98/</guid>
      <description>题目链接：http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=103&amp;amp;page=show_problem&amp;amp;problem=63 题目大意：神牛讲的很清楚~http://blog.csdn.net/camelwombat/article/details/5949508 感觉还是首先要读懂题目意思，这个也是有难度的 题目思路： 用数组模拟链表，考的是代码能力，关键是逻辑关系搞清楚，然后再敲，再就是细节问题，代码有一点小错就需要调很久。 参考这位神牛的思路写的……http://blog.csdn.net/goomaple/article/details/7802686
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; typedef struct node{ int len; char rank[54], suit[54]; }node; node card[54]; void eachmove(int pos, int step) { int Len = card[pos-step].</description>
    </item>
    
    <item>
      <title>2013年5月13日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8813%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Mon, 13 May 2013 02:18:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8813%E6%97%A5-%E6%99%B4/</guid>
      <description>今天，，，好吧……是昨天。。。西班牙语课很有收获啊，慢慢入门了~ 上完课急急忙忙地去做了一下所谓的校赛，发现如果没有书，单凭自己做，还是有很多基础的东西敲不出来啊，呵呵，知道为什么这么弱了。 晚上去跑步了，状态还不错，至少跑完全程了，5km不多不少。回公寓的时候，见识到了传说中猛于虎的城管，跟卖夜宵的小贩打起来了，同样的情景见过无数次了，就在公寓门口，唉，这些社会的阴暗面…………谁都不容易，不说了。 洗洗睡吧，明天有课。好好奋斗。 很久之前就很喜欢的一个视频：
　Tell me why</description>
    </item>
    
    <item>
      <title>poj1272 棋盘问题 ——DFS入门题</title>
      <link>http://liuxueyang.github.io/posts/poj1272-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 13 May 2013 01:52:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1272-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1321 题目大意： 中文题，省了…… 题目思路： 感觉搜索题目还是要多做，很多东西都是开始看起来很复杂，其实根本就没有那么复杂，比如说这道，实际上就比较基础，可是，自己还是做不出来……o(╯□╰)o 这道题目需要注意的一点就是：先DFS一行，然后要注意，要考虑当前行不放，直接DFS下一行！这个情况赶脚还是比较不容易想到的，虽然做完之后感觉也挺自然啊，可是……当初为毛想不到。。。就是思维的问题吧……代码看的是这位仁兄的：http://fuliang.iteye.com/blog/398700ＴＨＸ……＾＿＾
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 10; char m[MAX][MAX];int cnt, n, k, sum; bool p[MAX]; bool judge(int i, int j) { if (p[j] == false &amp;amp;&amp;amp; m[i][j] == &#39;#&#39;) return true; else return false; } void dfs(int x) { if (sum == k) {cnt++; return;} if (x &amp;gt;= n) return; int i; for (i = 0; i &amp;lt; n; ++i) { if (judge(x, i)) { p[i] = true; sum++; dfs(x+1); p[i] = false; sum--; } } dfs(x + 1); } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;poj1321.</description>
    </item>
    
    <item>
      <title>hdu1272 小希的迷宫 ——并查集无向图判环</title>
      <link>http://liuxueyang.github.io/posts/hdu1272-%E5%B0%8F%E5%B8%8C%E7%9A%84%E8%BF%B7%E5%AE%AB-%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%97%A0%E5%90%91%E5%9B%BE%E5%88%A4%E7%8E%AF/</link>
      <pubDate>Sun, 12 May 2013 23:44:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1272-%E5%B0%8F%E5%B8%8C%E7%9A%84%E8%BF%B7%E5%AE%AB-%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%97%A0%E5%90%91%E5%9B%BE%E5%88%A4%E7%8E%AF/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1272 题目大意： 给一个无向图，判断是不是有环，有就输出No，否则输出Yes 题目思路： 用并查集，开始还天真地以为要用拓扑排序，好吧……虽然那个也可以做，可是为什么不用简单的方法呢？
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 100000+10; int parent[MAX]; bool flag; void init() { for (int i = 1; i&amp;lt;=MAX; ++i) parent[i] = -1; } int find(int x) { int s; for (s = x; parent[s] !</description>
    </item>
    
    <item>
      <title>hdu1028 Ignatius and the Princess III &amp;&amp; hdu2082 找单词 &amp;&amp; poj1664 放苹果 &amp;&amp; noj1046 正整数划分问题——整数划分</title>
      <link>http://liuxueyang.github.io/posts/hdu1028-ignatius-and-the-princess-iii--hdu2082-%E6%89%BE%E5%8D%95%E8%AF%8D--poj1664-%E6%94%BE%E8%8B%B9%E6%9E%9C--noj1046-%E6%AD%A3%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86/</link>
      <pubDate>Sun, 12 May 2013 20:37:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1028-ignatius-and-the-princess-iii--hdu2082-%E6%89%BE%E5%8D%95%E8%AF%8D--poj1664-%E6%94%BE%E8%8B%B9%E6%9E%9C--noj1046-%E6%AD%A3%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86/</guid>
      <description>这种问题有两种做法，DP和母函数。 hdu1028 Ignatius and the Princess III 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1028 DP做法：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu1028.</description>
    </item>
    
    <item>
      <title>2013年5月11日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8811%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Sat, 11 May 2013 23:33:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8811%E6%97%A5-%E6%99%B4/</guid>
      <description>10日 晴 晚上去跑步了，起跑的时候竟然有一种狂喜的感觉，停跑半个月了，今天第一次跑，兴奋中……哈哈，开始感觉节奏还保持地不错，天气也不错，凉快，这么好的天气憋在宿舍里面绝对是对生命的一种浪费啊！快到终点的时候，直接冲刺了大约500米的样子，虽然完全打乱了节奏，但还是很爽的感觉，^_^然后后来完全没有节奏了，，也没关系，边走边跑着回来了~ 11日 晴 又是一个大晴天，前几天一直下雨，甚至有暴雨，这两天终于晴了。一天就刷了一下水题，没什么收获，概率论也木有复习……图书馆人超多，刚进去就出来了，，回机房做题，一整天效率太低了有木有！晚上实在没有心情去跑步了，加上今晚湘江边有烟花，一想到放完烟花后的烟雾，还是算了。。明天再跑吧o(╯□╰)o</description>
    </item>
    
    <item>
      <title>2013年5月11日zoj比赛残留题 zoj5000 Density of Power Network &amp;&amp; zoj5002 Friends</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8811%E6%97%A5zoj%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98-zoj5000-density-of-power-network--zoj5002-friends/</link>
      <pubDate>Sat, 11 May 2013 20:21:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8811%E6%97%A5zoj%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98-zoj5000-density-of-power-network--zoj5002-friends/</guid>
      <description>两道水题。直接暴力。数据范围都不大，还没有过，等哪天zoj把题目挂出来了再交。 Density of Power Network 题目链接：http://acm.zju.edu.cn/onlinejudge/showContestProblem.do?problemId=5000
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int edge[502][502], a[502], b[502]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;zoj5000.</description>
    </item>
    
    <item>
      <title>2013年5月11日 zoj比赛三道水题：zoj4998 Break Standard Weight &amp;&amp; zoj5004 Hard to Play &amp;&amp; zoj5006 Java Beans</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8811%E6%97%A5-zoj%E6%AF%94%E8%B5%9B%E4%B8%89%E9%81%93%E6%B0%B4%E9%A2%98zoj4998-break-standard-weight--zoj5004-hard-to-play--zoj5006-java-beans/</link>
      <pubDate>Sat, 11 May 2013 18:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8811%E6%97%A5-zoj%E6%AF%94%E8%B5%9B%E4%B8%89%E9%81%93%E6%B0%B4%E9%A2%98zoj4998-break-standard-weight--zoj5004-hard-to-play--zoj5006-java-beans/</guid>
      <description>都是水题，特别水的内种，题目意思、思路神马滴就不说了…… Break Standard Weight 题目链接：http://acm.zju.edu.cn/onlinejudge/showContestProblem.do?problemId=4998 范围只有100，并且只有3个数字，直接枚举，代码好挫……o(╯□╰)o 只有一个需要注意的地方，就是绝对值为0的时候要考虑到！因为如果绝对值为0，那么根本就称不出什么重量来。。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; map&amp;lt;int, bool&amp;gt;mymap; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;zoj4998.</description>
    </item>
    
    <item>
      <title>Dijkstra算法示例程序_1</title>
      <link>http://liuxueyang.github.io/posts/dijkstra%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_1/</link>
      <pubDate>Sat, 11 May 2013 10:32:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/dijkstra%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_1/</guid>
      <description>好几天不写程序的结果就是以前的东西都忘得差不多了……o(╯□╰)o
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 20; int S[MAX], dist[MAX], path[MAX], edge[MAX][MAX]; int n; void Dijkstra(int v0) { int i, j, k; for (i = 0; i &amp;lt;n ; ++i) { dist[i] = edge[v0][i]; S[i] = 0; if (i !</description>
    </item>
    
    <item>
      <title>hdu2577 How to Type ——DP入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu2577-how-to-type-dp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Fri, 10 May 2013 20:49:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu2577-how-to-type-dp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2577 题目大意： 一个人打字，有小写字母，有大写字母，并且要求打完字以后要把CapsLock键关掉。求最少的按键次数。 题目思路： dp[i][0]表示打到第 i 个字母的时候，CapsLock键是关着的；　dp[i][1]表示打到第 i 个字母的时候，CapsLock键是开着的； 然后就是判断下一个字母是大写字母还是小写字母，如果是小写字母，dp[i+1][0] = min(dp[i][0] + 1, dp[i][1] + 2); 表示，要求下一个状态CapsLock关着，那么前一个状态如果是关着的，直接打字母就可以了，所以只需要加1，如果是开着的，就要先把CapsLock关掉，然后再打字母，所以需要加2.</description>
    </item>
    
    <item>
      <title>zoj3702 Gibonacci number ——找规律</title>
      <link>http://liuxueyang.github.io/posts/zoj3702-gibonacci-number-%E6%89%BE%E8%A7%84%E5%BE%8B/</link>
      <pubDate>Tue, 07 May 2013 23:31:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj3702-gibonacci-number-%E6%89%BE%E8%A7%84%E5%BE%8B/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3702 题目大意： 给一个数列，第一项是1，给第 i 项，这个数列满足斐波那契数列的那种性质。问是不是存在，如果存在输出第 j 项，否则输出 -1 题目思路： 找规律，这个数列每一项和原来的斐波那契数列的差值是原来的斐波那契数列的倍数。</description>
    </item>
    
    <item>
      <title>zoj3696  Alien&#39;s Organ ——概率题</title>
      <link>http://liuxueyang.github.io/posts/zoj3696--aliens-organ-%E6%A6%82%E7%8E%87%E9%A2%98/</link>
      <pubDate>Tue, 07 May 2013 23:27:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj3696--aliens-organ-%E6%A6%82%E7%8E%87%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3696 题目大意： 就是一个东西，随机产生器官，一天产生的数量的期望是x,求一天内产生个数小于等于N的概率 题目思路： 泊松分布。概率论得好好学。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;math.</description>
    </item>
    
    <item>
      <title>poj1122&amp;&amp;zoj1053 FDNY to the Rescue! ——最短路入门题_Dijkstra算法</title>
      <link>http://liuxueyang.github.io/posts/poj1122zoj1053-fdny-to-the-rescue-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 06 May 2013 19:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1122zoj1053-fdny-to-the-rescue-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1122　http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=53 题目大意： 给定一个有向图，一个终点S，求多个点到这个点S的最短距离和对应的路径，把最短路排序后输出。 题目思路： 点的范围是20.可以一个一个用Dijkstra。。唯一的新意就是有多个点还需要按照路径长度排序，同时还要输出对应的路径，考的就是代码能力。用结构体存就可以。注意是有向图，开始就以为是无向图，怎么算最短路都不对。。赶脚这题不难，没什么思维难度，但是做OJ上这题的人却比较少，可能有一个原因，题目比较长，然后读完题目之后觉得没什么意思就不做了。。很简单的一个东西搞这么长的题目，也许就是考的读题吧。。貌似如果不是看的书上的翻译，我也没耐心读题。。。唉，读题确实是关键的一关。 然后这道题目，Poj上是单case，比较好过，然后数据也貌似比较弱，因为是单case，所以有一个输入的细节就特别好处理。开始Poj一下就过了，还沾沾自喜，结果把单case换成多case的时候，在zoj上交就Segmentation Fault……原来我最初处理输入个数不确定的数字的时候用了 while(~scanf())这种方法，很显然，这货只适用于单case。然后就想，该怎么处理这种输入数字个数不确定的输入呢？看了网上的一个思路，http://blog.csdn.net/yzldw333/article/details/7858172 哈哈，原来这么简单，就是以前做过的么，按照字符串处理就行了，，，好吧，，原来自己就是怕麻烦，这种方法想都没想。。然后就改了，，还是Segmentation Fault……继续调试，查错。。忍不住看了一下别人的代码，http://www.</description>
    </item>
    
    <item>
      <title>zoj2750 Idiomatic Phrases Game ——最短路入门题_Dijkstra算法</title>
      <link>http://liuxueyang.github.io/posts/zoj2750-idiomatic-phrases-game-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 05 May 2013 22:43:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj2750-idiomatic-phrases-game-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1750 题目大意： 成语接龙游戏。给定n个单词，每个单词前面先给一个权值，表示由这个单词找到下一个单词所需要花费的时间。问从第一个单词至少要花多少时间才能找到最后一个单词。如果不能找到，输出-1 题目思路： 如果一个单词的最后一个字和另一个成语的第一个字一样的话。那么就可以连一个有向边。就是求一个最短路。注意：题目中说成语至少三个字，别想当然地以为成语就是4个字的……开始没注意到，后来才改的。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MINN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 1000+10; int dist[MAX], S[MAX], n, wei[MAX], edge[MAX][MAX]; char start[MAX][10], end[MAX][10], ch[50]; void Dijkstra(int u0) { int i, j; for (i = 1; i &amp;lt;= n; ++i) { S[i] = 0; dist[i] = edge[u0][i]; } S[u0] = 1; dist[u0] = 0; int u; for (i = 1; i &amp;lt; n; ++i) { int Min = MAXN; u = 1; for (j = 1; j &amp;lt;= n; ++j) { if (S[j] == 0 &amp;amp;&amp;amp; dist[j] &amp;lt; Min) { Min = dist[j]; u = j; } } S[u] = 1; for (j = 1; j &amp;lt;= n; ++j) { if (S[j] == 0 &amp;amp;&amp;amp; edge[u][j] !</description>
    </item>
    
    <item>
      <title>poj1135&amp;&amp;zoj1298 Domino Effect ——最短路入门题_Dijkstra算法</title>
      <link>http://liuxueyang.github.io/posts/poj1135zoj1298-domino-effect-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 05 May 2013 03:18:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1135zoj1298-domino-effect-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1135　http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=298 题目大意： 有n个多米诺骨牌，有m条边，推倒第1张牌，以这个点为端点边上的的牌同时倒，问最后倒下的那张牌是哪张，并且求出时间。如果正好是端点上的牌，输出端点序号，否则需要输出这个点在哪两个端点之间。 题目思路： 假设骨牌倒下的速度是1.这样就可以用距离表征时间了。 如果最后倒下的牌正好是端点处的。那么就很好理解了，就是求所有点到这个点的最短路的最大值。设为Max1 如果最后倒下的是某两个端点之间的牌。那么就要认真想想了。比如是A点和B点之间的。可以先分别求出到A点的时间，和到B点的时间。然后再加上A和B之间的距离。所得的和就是从起点1到达最后终点的时间的两倍！为什么捏？可以这么思考：两个人，速度都是1，从起点开始，以同样的速度行走，然后在同一时刻到达同一点，那么他们所花的时间的和就是从起点到终点的距离的两倍嘛。不管他们分别到达A点和B点的先后顺序，总之，他们最后的效果都是相遇了！对于每一条边，都求出对应的时间。得到最大值，设为Max2 如果Max2 &amp;gt; Max1 说明什么捏？说明了：两个人仅仅到达某些端点，并不能相遇有木有！还需要再走一段路程，在某两个端点之间的某处相遇！并且，这两个端点就是当Max2最大的时候的两个端点。 如果两者相等或者Max1 &amp;gt; Max2 说明什么捏？其实貌似不能大于……因为，Max1就是起点到达所有点的最短距离的最大值嘛，而Max2是每条边上时间的最大值，然后可以发现，除了第一种情况，每条边上时间的最大值其实就是到达这条边的其中一个端点的时间的最大值……所以呢，Max1不能大于Max2.</description>
    </item>
    
    <item>
      <title>Dijkstra算法示例程序</title>
      <link>http://liuxueyang.github.io/posts/dijkstra%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sat, 04 May 2013 22:16:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/dijkstra%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/</guid>
      <description>输入：一个有向图，顶点个数 n ,然后是每条边的起点，终点，权值。顶点序号从0开始，-1 -1 -1表示结束。 输出：顶点0到其他各顶点的最短路径长度，并输出对应的最短路径。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 20; int S[MAX], dist[MAX], path[MAX], edge[MAX][MAX]; int n; void Dijkstra(int v0) { int i, j, k; for (i = 0; i &amp;lt; n; ++i) { dist[i] = edge[v0][i]; S[i] = 0; if (i !</description>
    </item>
    
    <item>
      <title>poj1679 The Unique MST ——判断最小生成树是否唯一_kruscal算法</title>
      <link>http://liuxueyang.github.io/posts/poj1679-the-unique-mst-%E5%88%A4%E6%96%AD%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80_kruscal%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 04 May 2013 21:57:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1679-the-unique-mst-%E5%88%A4%E6%96%AD%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80_kruscal%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1679 题目大意： 判断一个连通的无向图的最小生成树是不是唯一的，如果唯一，输出最小生成树的权值，否者输出“Not Unique!” 题目思路： 这题目看的书上的，其实，最开始我的想法是，在求最小生成树的过程中，如果扩展到某一个点的时候，有多种选择，也就是说，有多个权值相同的边可以选择，那么就break掉，说明最小生成树不唯一。其实这是有问题的，因为，很可能在这权值相同的边当中，只能选择其中一条，如果选择其它的就得不到最小生成树，这就是一个反例。所以原来的做法是错误的。 书上的做法是，首先，预处理，看每个边是不是有别的边的权值和它一样的，有的话就标记一下，用结构体里面的equal表示，然后用kruscal算法求一遍最小生成树，并且把这棵最小生成树里面的边都标记一下，用结构体里面的used表示，然后，对于那种有其他边和它权值相同的那种边，同时这条边在第一次求的最小生成树里面，我们就把它删除，做法就是用结构体里面的del标记，然后再次求一遍最小生成树，不用del被标记的边，这样如果求出来的最小生成树的权值和原来的一样，说明最小生成树不唯一，break; 然后就OK了，唉，其实这是很自然的一个想法~
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 100+10; typedef struct Edge { int u, v, w, equal, used, del; bool operator &amp;lt; (const Edge &amp;amp;other) const { return w &amp;lt; other.</description>
    </item>
    
    <item>
      <title>poj2048&amp;&amp;zoj1751 Highways ——最小生成树入门题_Prim算法</title>
      <link>http://liuxueyang.github.io/posts/poj2048zoj1751-highways-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 04 May 2013 01:25:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2048zoj1751-highways-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1751 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1048 题目大意： 给定n个点的坐标。还有m对已经相连的点的编号。求连接这n个点的总权值最小的一棵生成树，输出还需要连接的点的编号。 题目思路： 这道题目和以前做过的poj2421是一样的。这里采用了那篇博客里面的第一种方法。幸运的是，在poj上1A了。但是在zoj上，因为输入输出格式有一些不一样，卡了一下，到最后我也没明白“If no new highways need to be built (all towns are already connected), then the output should be created but it should be empty.</description>
    </item>
    
    <item>
      <title>poj2349 Arctic Network ——最小生成树入门题_Prim算法</title>
      <link>http://liuxueyang.github.io/posts/poj2349-arctic-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 03 May 2013 23:36:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2349-arctic-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=2349 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=914 题目大意： 有一些炮台，如果这个炮台有卫星接收器，那么任意两个有卫星接收器的炮台可以通信，不受距离限制；否者，两个炮台之间只能通过对讲机通信，这是受距离限制的。要买一种对讲机，用在需要的炮台上，要求所有炮台两两之间可以直接或者间接通信，问要买通信距离至少为多少的对讲机可以满足要求。输入：S卫星接收器的数量，P炮台的数量，然后是P行，每行代表一个炮台的坐标。输出要求的对讲机的通信距离D。 题目思路： 题目意思比较难懂。关键是satellite channel的安放方法，注意，它是放在炮台上的，只要这个炮台上有这货，它就可以和任何也有这货的炮台通信。明白这一点，然后就简单了。有S个卫星接收器，那么就可以减少S-1个距离开销。要让D尽可能小，就让这S-1个距离开销最大，所以，想法就是，求这些点的最小生成树，然后把所选的边排序，第S大的边的权值就是所求。 开始题意没搞懂。关键是“Any two outposts with a satellite channel can communicate via the satellite, regardless of their location.</description>
    </item>
    
    <item>
      <title>poj1789 Truck History ——最小生成树入门题_Prim算法</title>
      <link>http://liuxueyang.github.io/posts/poj1789-truck-history-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 03 May 2013 16:00:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1789-truck-history-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1789 题目大意： 输入一个数字n，然后输入n个长度为7的字符串，从任意一个字符串开始派生，直到派生出所有的字符串，两个字符串的距离规定为他们对应位置不相等的字母的个数，求出一种派生方案，使得派生方案的优劣值最大，并输出这个优劣值。优劣值的定义是：1/Σ(to,td)d(to,td) 表示对所有派生对的距离求和，再取倒数。 题目了思路： 要让优劣值最大，只需要距离之和最小，把7个字符串看成7个点，每两个点有一个距离，目的就是求权值最小的生成树，其实就是最小生成树。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 2000+10; char a[MAX][MAX]; int edge[MAX][MAX]; int n, lowcost[MAX]; void prim(int u0) { int sum = 0, i, j, k; for (i = 1; i &amp;lt;= n; ++i) lowcost[i] = edge[u0][i]; lowcost[u0] = -1; for (i = 1; i &amp;lt; n; ++i) { int v = -1, min = MAXN; for (j = 1; j &amp;lt;= n; ++j) { if (lowcost[j] !</description>
    </item>
    
    <item>
      <title>zoj1586 QS Network ——最小生成树入门题_Prim算法</title>
      <link>http://liuxueyang.github.io/posts/zoj1586-qs-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 03 May 2013 01:59:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj1586-qs-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=586 题目大意： 题目意思比较难懂。看书上的翻译竟然没有看懂，还是打开OJ，看英文的原题。看了两遍的样子，终于差不多懂了。 QS是一种生物，要完成通信，需要设备，每个QS需要的设备的价格不同，并且，这种设备只能在两个QS之间用一次，也就是说，如果一个QS需要和3个QS通信的话，它就必须得买3个设备，同时，对方三个也必须买对应的适合自己的设备。同时，每两个QS之间是有距离的，要完成通信还需要网线，给出每两个QS之间的网线的价值。求一棵生成树，使得所需要的费用最少。数据范围：所有数据都在1000以内。 题目思路： 根据这种设备的特性，每个设备只能和另外一个QS通信，所以呢，建图的时候，每条边的权值就是网线的费用，加上这条边的两个端点的QS所需设备的费用的和。这样，就转化成了常规的最小生成树的问题。因为只需要求出最小费用，所以，可以不必记录prim过程中要选的边的顶点编号，也就是说，可以省略nearvex数组，用lowcost数组就可以实现。如果lowcost[i]的值是-1，则代表已经选择了这个点，否则，lowcost[i]依然表示集合T1内的顶点 i 距离集合T内个顶点权值最小的边的权值。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 1000+10; int edge[MAX][MAX], lowcost[MAX]; int t, n, pri[MAX]; void prim(int u0) { int sum = 0, i, j, v; for (i = 1; i &amp;lt;= n; ++i) lowcost[i] = edge[u0][i]; lowcost[u0] = -1; for (i = 1; i &amp;lt; n; ++i) { int min = MAXN; v = -1; for (j = 1; j &amp;lt;= n; ++j) { if (min &amp;gt; lowcost[j] &amp;amp;&amp;amp; lowcost[j] !</description>
    </item>
    
    <item>
      <title>最小生成树示例程序_Prim算法</title>
      <link>http://liuxueyang.github.io/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_prim%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 03 May 2013 01:04:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_prim%E7%AE%97%E6%B3%95/</guid>
      <description>输入：顶点个数n和边数m，然后是m条边的数据。u v w 分别代表两个顶点和权值。顶点从1开始记起。 输出：一次选择的各条边和最小生成树的权。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 100; int n, m, lowcost[MAX], nearvex[MAX], edge[MAX][MAX]; void prim(int u0) { int i, j, sum = 0; for (i = 1; i &amp;lt;= n; ++i) { lowcost[i] = edge[u0][i]; nearvex[i] = u0; } nearvex[u0] = -1; for (i = 1; i &amp;lt; n; ++i) { int min = MAXN, v = -1; for (j = 1; j &amp;lt;= n; ++j) { if (nearvex[j] !</description>
    </item>
    
    <item>
      <title>poj2421 Constructing Roads ——最小生成树入门题_Kruscal算法</title>
      <link>http://liuxueyang.github.io/posts/poj2421-constructing-roads-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 02 May 2013 10:17:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2421-constructing-roads-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=2421 题目大意： 给定一个矩阵，第 i 行第 j 列表示点 i 和点 j　的距离是ｓ［ｉ］［ｊ］。然后输入Ｑ，下面Ｑ行，每行两个数字ａ，ｂ表示点ａ和点ｂ已经有路相连。求需要至少再修多长的路，可以构成一棵生成树。输出需要在修的路的总长度。 题目思路： 转化为最小生成树求解。有两种思路： １）把已经相连的两个点的权值设置为０，这样，就可以直接求最小生成树了。因为kruscal的过程中，一定会选择到已经相连的这些点，因为它们的权值是0嘛，同时，即使把它们的权值加上，也不会影响结果。这个方法我好不容易想出来了，可是还有一个问题，就是：输入a b 后，如何定位到相应的边，并把这个边的权值设置为0？开始的时候，是暴力找，超时了，然后自己想各种方法，还求出来个公式，用a,b,N,表示出边的编号。最后还是超时了。。看网上别人恰好有人也是这么个思路，但是他是怎么定位边，并把边的权值设置为0的，没仔细看，不知道为什么人家就用这种方法过了…… 2）第二种思路，如果a b 已经相连，很简单，只要它俩的根节点不同，就把它两个合并不就可以了么，这样，kruscal的过程中，就不会再加入这些已经存在的边的权值了。剩下的就是纯的kruscal问题。这个方法很好！看的别人的想法。然后自己写了一下，RE了一次，原因是，合并a b 的时候，没有判断他们的根节点是否不同。。</description>
    </item>
    
    <item>
      <title>hoj12616 Median Tree ——最小生成树入门题&amp;&amp;比赛残留题_Kruscal算法</title>
      <link>http://liuxueyang.github.io/posts/hoj12616-median-tree-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 01 May 2013 21:43:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hoj12616-median-tree-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://acm.hnu.cn/online/?action=problem&amp;amp;type=show&amp;amp;id=12616 题目大意： 给n个点,m条边，求一棵生成树，使得这个生成树的边的权值的中位数最小。输出这个中位数。 题目思路： 和poj1861&amp;amp;&amp;amp;zoj1542的思路是一样的。可以证明要求的树就是最小生成树。然后就是中位数的概念：长度为N的数列的中位数，就是(N+1)/2位置的数字。百度百科里面貌似不是严格的中位数的概念。 开始写了一遍按照那种不严格的中位数的定义写的。过了。kruscal的过程中，只需要计算到(n-1+1)/2-1的那一条边即可退出。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int n, m; const int em = 10000+10, vm = 1000+10; typedef struct Edge { int u, v, w; bool operator &amp;lt; (const Edge &amp;amp;other) const { return w &amp;lt; other.</description>
    </item>
    
    <item>
      <title>poj1861&amp;&amp;zoj1542 Network ——最小生成树入门题_Kruscal算法</title>
      <link>http://liuxueyang.github.io/posts/poj1861zoj1542-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 01 May 2013 20:52:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1861zoj1542-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1861 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=542 题目大意： 给n个点，m条边。求一棵生成树，并且满足任意两点之间的距离的最大值最小。输出这个最大值，然后输出树的边的数量，最后输出树的每条边。 题目思路： 其实就是求最小生成树。关键就是证明，对于一个图的最小生成树来说，它的最大边满足在所有的生成树的最大边里最小。这是可以理解的。简单思考一下：假设最小生成树不满足这个条件。那么就是说，存在另一棵生成树，它的最大边的值比最小生成树还小，但是它的权值之和可能比最小生成树大，但是这表明，构造最小生成树的时候，存在一步，选择边的时候，没有选择权值最小的，这是不可能的。所以矛盾。所以假设不成立。所以，问题就转化成了常规的求最小生成树的问题了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 1000+10; const int MAX1 = 15000+10; typedef struct Edge { int u, v, w; bool operator &amp;lt; (const Edge &amp;amp;other) const { return w &amp;lt; other.</description>
    </item>
    
    <item>
      <title>zoj1203 Swordfish ——最小生成树入门题_Kruscal算法</title>
      <link>http://liuxueyang.github.io/posts/zoj1203-swordfish-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 01 May 2013 13:36:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj1203-swordfish-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=203 题目大意： 给定N个点的坐标，求经过这N个点的路线长度总和的最小值。 题目思路： 求出任意两点之间的距离，然后就是最小生成树。 写的过程中还是遇到了三个问题，有一个局部变量没有初始化；没有把边按照权值排序；另外就是没有看输出，每两个case之间有一个空行。这里有一个十分常见的问题，就是最后一个case后面没有空行。否则会PE。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; typedef struct Edge { int u, v; double w; bool operator &amp;lt; (const Edge &amp;amp;other) const { return w &amp;lt; other.</description>
    </item>
    
    <item>
      <title>最小生成树示例程序_Kruscal算法</title>
      <link>http://liuxueyang.github.io/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_kruscal%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 01 May 2013 12:08:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_kruscal%E7%AE%97%E6%B3%95/</guid>
      <description>输入：顶点个数n和边数m，然后输入m行，每行输入格式：u v w 分别表示两个顶点和这个边的权值，顶点序号从1开始 输出：一次选择的各条边和最终的最小生成树的权值
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define MAXN 1000 #define MAXM 1000 int parent[MAXN], n, m; typedef struct Edge { int u, v, w; bool operator &amp;lt; (const Edge &amp;amp;other) const { return w &amp;lt; other.</description>
    </item>
    
    <item>
      <title>poj1094&amp;&amp;zoj1060 Sorting It All Out ——拓扑排序入门题</title>
      <link>http://liuxueyang.github.io/posts/poj1094zoj1060-sorting-it-all-out-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Wed, 01 May 2013 01:23:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1094zoj1060-sorting-it-all-out-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1094 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=60 题目大意： 输入两个整数，n, m 分别表示以下的字母在字母表前 n 个字母范围内，有 m 行，每行描述一个大小关系，只有小于号。如果从开始到某一个关系式可以确定最终的序列，就输出确定的序列。如果得到矛盾，就输出到此经历的几个关系式。如果最终都没有确定，就输出序列不能确定的信息。 题目思路： 边读入，边建图，每读入一条表达式，就拓扑排序判断是不是可以确定最后的序列了。如果可以得到最后包含全部n个字母的序列，后面的表达式只需要输入，但是不需要处理了。如果过程中到达一个表达式的时候，找到了一个环，就说明肯定不能确定最后的序列了。也不需要处理后面的表达式了。如果一直都没有确定，就一直处理。 这题大体上的思路是这样，但是还是有一些细节没有处理好。最严重的就是：如何在中间的过程中去判断环。不能单纯地比较弹栈的顶点个数和 n 的大小，因为可能读入的顶点个数还没有到达 ｎ的时候，就已经出现环了，这样，以后的输入就不用处理了。如何处理呢？我的方法就是，当前剩下的点当中，是不是还存在度数大于０的点，用ｂｕｇ标记，因为这个ｂｕｇ调试了好久。。如果存在的话，就说明返回－１，表示存在环。为什么会出现这个ｂｕｇ呢？因为这个涉及到到第几条表达式出现矛盾的问题。 主要还是思维不严谨，虽然后来测试数据过了，但还是不知道哪里错了，后来自己出了几组数据才发现那个ｂｕｇ。这题做了好久，有的人一下就过了，可是我却卡了两天……教训就是：遇到ｂｕｇ了不能慌，分析一下是不是自己当初的想法错了，还是哪个细节没有处理好。即使有一个细节处理不好，程序最后都会崩溃。还有就是，可能自己的处理方法不好，导致最后的ｂｕｇ超多，代码也超级繁琐……一开始就应该想清楚，有没有更好的处理办法，尤其是一些细节问题。</description>
    </item>
    
    <item>
      <title>poj2585&amp;&amp;zoj2193 Window Pains ——拓扑排序入门题</title>
      <link>http://liuxueyang.github.io/posts/poj2585zoj2193-window-pains-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Tue, 30 Apr 2013 19:15:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2585zoj2193-window-pains-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=2585 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2193 题目大意： 有9个窗口，每个窗口占4个格子，并且每个窗口的位置是固定的。如果重叠的话，在前面的窗口会覆盖另一种窗口，这9个窗口在4*4的矩阵里面，给出一种矩阵的格局。问这中格局是不是合法的。 题目思路： 还是看的书上的。刚开始一点也没有思路。方法就是：16个格子，每个格子可能会存在哪几种窗口，这是可以枚举出来的。针对输入的矩阵，那么可以判断，每一个格子会覆盖哪几种窗口，如果这种窗口在16个格子里面出现过，那么就可以判断当前这个格子一定覆盖了它，那么就可以用一条有向边连接当前窗口和被覆盖的窗口。这样，就可以得到一个图。在16个格子里面没有出现过的窗口我们可以不考虑。得到有向图后，发现，如果存在一个有向环，那么就一定是不合理的，因为这表明，一种窗口A覆盖了另一种窗口B，同时B又覆盖了A，这是不可能的。所以这个矩阵就是不合法的。反之，如果不存在有向环，就是合法的。这样，就转化为用拓扑排序判断环的问题了。先建图，再判断环。 写了两遍，其中出现各种BUG…… 第一遍：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; string cover[4][4]; int a[10][10];bool g[10][10];int id[10]; map&amp;lt;int, bool&amp;gt;mymap; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;poj2585.</description>
    </item>
    
    <item>
      <title>hoj12614 Dictionary ——拓扑排序找环&amp;&amp;比赛残留题</title>
      <link>http://liuxueyang.github.io/posts/hoj12614-dictionary-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E6%89%BE%E7%8E%AF%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/</link>
      <pubDate>Mon, 29 Apr 2013 16:48:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hoj12614-dictionary-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E6%89%BE%E7%8E%AF%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/</guid>
      <description>题目链接：http://acm.hnu.cn/online/?action=problem&amp;amp;type=show&amp;amp;id=12614&amp;amp;courseid=247 题目大意： 有一种字典。把字典中的符号映射到英文字母。输入一个n，然后是n行映射后的单词，判断这n个单词是不是符合字典序，所谓字典序就是前面的单词可以是后面的单词的前缀，并且这n个单词符合字符串排序后的顺序，这是针对原来的字母的，而不是映射之后的字母。 题目思路： 需要考虑映射之后的字母的相对顺序，来考虑是不是在原来的字母表中是不是符合字典序。 这道题目开始没看懂，最关键的第一段描述没有注意到，结果样例都看不懂。纠结了好久。但是涉及到前缀，觉得应该是字典树。 后来终于注意到第一段了，终于理解题目意思了。悲剧的是，还是纠结在字典树上面，老是在这方面想。没有思路。知道考虑相对顺序，但是不知道怎么映射……过程中llh其实提到了一下两个字母的相对顺序可以用边表示，可是，我没有继续往下想！后来听人家说，可以建图，然后找环。唉，原来就是llh那样想的。 回来之后，认真想了一下。方法是：预处理的过程中判断是不是出现这种情况：后面的单词是前面的单词的前缀，这是不符合条件的。同时在预处理的过程中建图，用临界表，如果一个字母A在另一个字母B的后面，就把B插入到A的出边表里面。然后就是在这个图里面找环，如果出现环了，就是不符合条件的。找环的方法就是刚刚做过的拓扑排序的方法。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int n; char a[509][17]; struct ArcNode { int to; struct ArcNode *next; }; ArcNode *List[50]; int Count[50]; bool topsort() { int i = 0, j, k, top = -1; ArcNode *temp; bool flag = false; for (i = 0; i &amp;lt; 26; ++i) { if (Count[i] == 0) { Count[i] = top; top = i; } } for (i = 0; i &amp;lt; 26; ++i) { if (top == -1) { flag = true; break; } j = top; top = Count[top]; temp = List[j]; while (temp) { k = temp-&amp;gt;to; Count[k]--; if (Count[k] == 0) { Count[k] = top; top = k; } temp = temp-&amp;gt;next; } } if (flag) return false; else return true; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hnu247.</description>
    </item>
    
    <item>
      <title>拓扑排序示例程序</title>
      <link>http://liuxueyang.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sun, 28 Apr 2013 01:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/</guid>
      <description>输入：顶点个数n，边数m，然后是m行，表示每条边的起点和终点u, v 表示从顶点u到顶点v的一条有向边。输入0 0 表示结束。 输出：如果不存在有向环，则输出一个拓扑有序序列；否则，输出“Netword has a cycle!” #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int n, m, Count[100], i, j, top, out[100]; struct ArcNode{ int to; struct ArcNode *next; }; ArcNode *List[100]; void topsort() { ArcNode *temp; top = -1; int k, len = 0; bool flag = true; for (i = 0; i &amp;lt; n; ++i) { if (Count[i] == 0) { Count[i] = top; top = i; } } for (i = 0; i &amp;lt; n; ++i) { k = top; if (k == -1) { flag = false; break; } top = Count[k]; temp = List[k]; out[len++] = k + 1; while (temp !</description>
    </item>
    
    <item>
      <title>邻接表示例程序</title>
      <link>http://liuxueyang.github.io/posts/%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sat, 27 Apr 2013 22:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/</guid>
      <description>输入：n，m代表顶点数目和边数。然后m行，代表每个边的起点和终点。0 0 表示结束。 输出：第一行为n个正整数，表示每个点的出度；第二行为n个正整数，表示每个点的入度。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 100; struct ArcNode{ // 边节点 int adjvex; ArcNode *nextarc; }; struct VNode{ // 顶点 int data; ArcNode *head1; // 出边表表头指针 ArcNode *head2; // 入边表表头指针 }; struct LGraph{ // 临界表结构体 VNode vertexs[MAX]; // 顶点数组 int vexnum, arcnum; }; LGraph lg; void CreateLG() { int i = 0; ArcNode *pi; int v1, v2; //scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;lg.</description>
    </item>
    
    <item>
      <title>2013年4月26日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8826%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Fri, 26 Apr 2013 22:53:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8826%E6%97%A5-%E6%99%B4/</guid>
      <description>25日 晚上去图书馆还书，没去跑步。开始读TAOCP，^_^ 26日 都起跑了才发现脚貌似有点儿受伤，大脚趾有些疼的感觉。乖乖回来了o(╯□╰)o 看来得休息几天了。 今天晚上自习的时候开始考虑要不要考研，以前的想法都是坚决不考研的，但是现在，唉……我也不知道该怎么办，总之，不想这些了，现在还是好好学习数学，英语，还有专业课，到时候想考就拼一下。目前最重要的是认真做比赛，还要努力把数学英语搞好，这货哪里都用得到。把自己的基础打好，各种技术都要自己去学，不管以后是去考研还是去找工作，都有好处，具体怎么样，以后的事情以后再说，现在想这些都没用。 纯粹胡思乱想…… 人生貌似有些迷茫了又。。迟早要面对，所谓选择和机会，都是留给认真准备的人的。什么都不会，感觉无路可走…… 看到一句话：当你倒了一杯热水，准备去喝的时候，发现水已经凉了，那么恭喜你，你已经进入状态了。</description>
    </item>
    
    <item>
      <title>2013年4月24日 阴转晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8824%E6%97%A5-%E9%98%B4%E8%BD%AC%E6%99%B4/</link>
      <pubDate>Thu, 25 Apr 2013 02:09:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8824%E6%97%A5-%E9%98%B4%E8%BD%AC%E6%99%B4/</guid>
      <description>晚上有一些冷，开始起跑的时候状态就不好，中途产生了厌跑的心理，这种事情是最可怕的，尤其是这种情况，体力跟不上，还有一些负面情绪，最后在中途停下来了，悲剧了……其实跑步的时候，最大的敌人就是自己，如何战胜自己。后来就是跑跑停停，最后还是勉强跑完了。。 唉，我承认自己的意志力可能永远没有人家强，比如高中同学shiwei，从心底里佩服这种人，能够一上午一动不动地趴桌子上做题。现在还能想起那么专注的情景，似乎外界早已经和自己无关，这种状态我貌似很少有，自从上大学以来。。真的。 不是玩手机，就是看书的时候，看一会儿就看不下去了……唉，心太浮躁了。 也许是电脑用太多了，干什么都想追求速度，电脑卡一点儿就受不了，学什么东西都想一下就学会，从来没有沉下心来认真思考过，没有全神贯注地学习过，最后也是欲速不达。 最近几天睡觉都比较早，除了今天为了补英语作业。。都没有什么时间写代码。在机房的时间也荒废了很多，不是上网了，就是干别的了，反正是时间就这么一点一点地流逝了。时间不等人。</description>
    </item>
    
    <item>
      <title>hdu2795 Billboard ——线段树入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu2795-billboard-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Wed, 24 Apr 2013 09:30:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu2795-billboard-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2795 题目大意： 高度为h,长度为w的板子，贴n个海报，每个海报的高度都为1，长度由n个整数给出。贴海报的原则是，从高到低，优先选高的，从左到右，优先选右边的位置。起初每个海报在板子上所在的行数。 题目思路： 建立一棵叶子节点有h个的线段树，每个节点代表这个区间内的最大值，最开始，叶子节点都是w。然后每插入一个值就插入到叶子节点，输出叶子节点的值，然后更新父节点。 这道题目的难点是，要想到建立线段树，把模型抽象出来。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 200000+10; int a[MAX&amp;lt;&amp;lt;2], n, h, w, b[MAX]; void pushup(int rt) { a[rt] = max(a[rt&amp;lt;&amp;lt;1], a[rt&amp;lt;&amp;lt;1|1]); } void build(int l, int r, int rt) { if (l == r) { a[rt] = w; return; } int m = (l + r) &amp;gt;&amp;gt; 1; build(lson); build(rson); pushup(rt); } void update(int p, int k, int l, int r, int rt) { if (l == r) { a[rt] -= k; return; } int m = (l + r) &amp;gt;&amp;gt; 1; if (p &amp;lt;= m) update(p, k, lson); else update(p, k, rson); pushup(rt); } int query(int k, int l, int r, int rt) { if (l == r) { return l; } int m = (l + r) &amp;gt;&amp;gt; 1, ret = 0; /* if (a[rt&amp;lt;&amp;lt;1] &amp;gt;= k) ret = query(k, lson); else ret = query(k, rson); */ if (a[rt] &amp;gt;= k) { if (a[rt&amp;lt;&amp;lt;1] &amp;gt;= k) ret = query(k, lson); else ret = query(k, rson); } else return 0; return ret; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu2795.</description>
    </item>
    
    <item>
      <title>2013年4月23日 雨</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8823%E6%97%A5-%E9%9B%A8/</link>
      <pubDate>Wed, 24 Apr 2013 08:31:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8823%E6%97%A5-%E9%9B%A8/</guid>
      <description>22日 雨 晚上下雨，没跑成…… 23日 阴转雨 晚上跑步出门的时候，有一些小雨点，但是貌似好几天没跑了，所以，还是起跑了。状态还差不多，天气也挺凉快，到终点的时候，悲剧了，开始下雨了。。还有2500+m的路程。。唉，浑身上下都是汗水和雨水。最终还是回来了，可怜我的P3……进水了还没挂o(╯□╰)o晚上回去赶紧洗澡，换衣服……</description>
    </item>
    
    <item>
      <title>hdu1394 Minimum Inversion Number ——线段树入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu1394-minimum-inversion-number-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Tue, 23 Apr 2013 23:23:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1394-minimum-inversion-number-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1394 题目大意： 给一个数字由0~n-1这n个数字组成的数列，不断地把第一个数字移动到最后，一共得到n个数列。求这n个数列中，逆序数最小是多少。 题目思路： 首先，建一棵线段树，每个节点表示这个区间内已经插入的数字的个数，开始初始化为0.然后没读入一个数字，把这个数字插入得到线段树的叶子节点，然后向上更新父节点。这样，在建树的过程中，就可以统计出每个逆序数，也就是说，可以再插入每个数字的时候，查找已经插入的数字当中，比这个数字大的数字有多少个，直到最后就可以求出这个数列的逆序数。 然后，利用数列的性质。因为每次都是把第一个数字移动到最后，比如这个数字是a，那么显然，比这个数字小的有a个，比这个数字大的有n-1-a个；因为这个数字在最前面，所以当前这个数字的逆序数是a，把这个数字移动到最后之后，这个数字的逆序数是n-1-a，逆序数增加量：n-1-a-a。这样就可以由原来的数列的逆序数求出所有数列的逆序数。好神奇~
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 5000+10; int a[MAX&amp;lt;&amp;lt;2], n, b[MAX]; void pushup(int rt) { a[rt] = a[rt&amp;lt;&amp;lt;1] + a[rt&amp;lt;&amp;lt;1|1]; } void build(int l, int r, int rt) { if (l == r) { a[rt] = 0; return; } int m = (l + r) &amp;gt;&amp;gt; 1; build(lson); build(rson); pushup(rt); } void update(int p, int l, int r, int rt) { if (l == r) { a[rt]++; return; } int m = (l + r) &amp;gt;&amp;gt; 1; if (p &amp;lt;= m) update(p, lson); else update(p, rson); pushup(rt); } int query(int L, int R, int l, int r, int rt) { if (L &amp;lt;= l &amp;amp;&amp;amp; R &amp;gt;= r) { return a[rt]; } int m = (l + r) &amp;gt;&amp;gt; 1, ret = 0; if (L &amp;lt;= m) ret += query(L, R, lson); if (R &amp;gt; m) ret += query(L, R, rson); return ret; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu1394.</description>
    </item>
    
    <item>
      <title>hdu1754 I Hate It &amp;&amp; hdu1166 敌兵布阵 ——线段树复习</title>
      <link>http://liuxueyang.github.io/posts/hdu1754-i-hate-it--hdu1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Tue, 23 Apr 2013 14:54:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1754-i-hate-it--hdu1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A4%8D%E4%B9%A0/</guid>
      <description>题目链接： http://acm.hdu.edu.cn/showproblem.php?pid=1754　 http://acm.hdu.edu.cn/showproblem.php?pid=1166 都是最基础的线段树，考的知识点就是点更新，区间求和，区间求最大值。再次学线段树，感觉理解加深了一些。 但是写的时候还是会出现各种奇葩的错误。唉。 hdu1754
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 200000+10; int gra[MAX&amp;lt;&amp;lt;2], m , n; void pushup(int rt) { gra[rt] = max(gra[rt&amp;lt;&amp;lt;1], gra[rt&amp;lt;&amp;lt;1|1]); } void build(int l, int r, int rt) { if (l == r) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;gra[rt]); return; } int m = (l + r) &amp;gt;&amp;gt; 1; build(lson); build(rson); pushup(rt); } void update(int p, int k, int l, int r, int rt) { if (l == r) { gra[rt] = k; return; } int m = (l + r) &amp;gt;&amp;gt; 1; if (p &amp;lt;= m) update(p, k, lson); else update(p, k, rson); pushup(rt); } int query(int L, int R, int l, int r, int rt) { if (L &amp;lt;= l &amp;amp;&amp;amp; R &amp;gt;= r) { return gra[rt]; } int m = (l + r) &amp;gt;&amp;gt; 1, ret = 0; if (L &amp;lt;= m) ret = max(ret, query(L, R, lson)); if (R &amp;gt; m) ret = max(ret, query(L, R, rson)); return ret; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu1754.</description>
    </item>
    
    <item>
      <title>poj2478 ——欧拉函数入门题</title>
      <link>http://liuxueyang.github.io/posts/poj2478-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 22 Apr 2013 12:58:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2478-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=2478 题目大意： 给你一个数列f(N)，这个数列是由一系列不能约分的分数 a / b (0 &amp;lt; a &amp;lt; b &amp;lt;= n 且 (a,b) = 1)按照递增的顺序排列而成的。输入一个N，求这个数列中元素的个数。 题目思路： 因为题目只需要求出元素的个数，所以，把分母相同的放在一起，然后就发现规律了，其实就是求从2到 n 的欧拉函数的和。范围只有10^6，可以打表预处理。思路很清晰。因为要反复用欧拉函数，所以比较快的方法是用递推的方法求。 for (i = 1; i &amp;lt;= maxn; ++i) f[i] = i; for (i = 2; i &amp;lt;= maxn; i+=2) f[i] /= 2; for (i = 3; i &amp;lt;= maxn; i+=2){ if (f[i] == i){ for (j = i; j &amp;lt;= maxn; j+=i){ f[j] = f[j] / i * (i - 1); } } }  　这个方法和筛法求素数比较类似，貌似就是那个思想。模拟一下什么就懂了。这里也用到了欧拉函数的性质：φ(n) = n * (1 - 1/p1) * (1 - 1/p2) * …… * (1 - 1/pk)。</description>
    </item>
    
    <item>
      <title>poj2407 Relatives ——欧拉函数入门题</title>
      <link>http://liuxueyang.github.io/posts/poj2407-relatives-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 22 Apr 2013 08:36:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2407-relatives-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=2407 题目大意： 这个题目就是欧拉函数的定义，求一个数字的欧拉函数。 题目思路： 用公式：φ(n) = n * (1-1/p1) * (1-1/p2) * …… * (1-1/pk)。</description>
    </item>
    
    <item>
      <title>poj2480 Longge&#39;s problem ——积性函数入门题</title>
      <link>http://liuxueyang.github.io/posts/poj2480-longges-problem-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 21 Apr 2013 23:45:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2480-longges-problem-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=2480 题目大意： 给定一个数字N，求∑gcd(i, N) 1&amp;lt;=i &amp;lt;=N 的值。 题目思路： x是一个数字，m与n互素，则gcd(x,m*n) = gcd(x, m) * gcd(x, n) 令g(y) = gcd(x, y) 那么g(y)是一个积性函数。令f(N) = ∑gcd(i, N) 满足gcd(x, n) = 1 的个数是欧拉函数φ(n)，那么可以知道，满足gcd(x, n) = p 的个数可以这么求：x 和 n 同时除以 p ，那么gcd(x/p, n/p) = 1 ，那么个数就是φ(n/p)。 分解N = p1^a1 * p2^a2 * …… *pn^an ，则f(N) = f(p1^a1 * p2^a2 * …… *pn^an) = f(p1^a1) * f(p2^a2) * …… * f(pn^an)； 可以枚举pi^ai的因数，对于f(pi^ai) = 1 * φ(pi^ai) + pi * φ(pi^(ai-1)) + pi^2 * φ(pi^(ai-2)) + …… + pi^(ai-1) * φ(pi) + pi^ai * φ(1)； 根据φ(pi^ai) = pi^ai - pi^(ai-1)，那么可以化简上面的式子：f(pi^ai) = ai * pi^ai + ai * pi^(ai-1) + pi^ai = pi^ai * (ai + ai/pi + 1)； 所以，f(N) = N * (a1 + a1/p1 + 1) * (a2 + a2/p2 + 1) * …… * (an + an/pn + 1)。 这题当然不是自己想出来的，但是学习了一下积性函数，看的神牛的解题代码：http://hi.</description>
    </item>
    
    <item>
      <title>2013年4月21日 阴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8821%E6%97%A5-%E9%98%B4/</link>
      <pubDate>Sun, 21 Apr 2013 23:04:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8821%E6%97%A5-%E9%98%B4/</guid>
      <description>19日 晚上挑战赛，输了，回宿舍很晚了，没去跑步。 20日 今天状态不是很好，中途P3还没电了……虽然跑得很慢，但还是跑完全程了~ 21日 晚上校队讨论，回去10点多了，没去跑步。今天上午上西班牙语选修课，很有意思~中南赛没能去，唉。以后挑战赛坚决不能输！</description>
    </item>
    
    <item>
      <title>uestc1824 Judgment Day ——比赛残留题</title>
      <link>http://liuxueyang.github.io/posts/uestc1824-judgment-day-%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/</link>
      <pubDate>Sat, 20 Apr 2013 09:30:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uestc1824-judgment-day-%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/</guid>
      <description>题目链接：http://www.acm.uestc.edu.cn/problem.php?pid=1824 题目大意： 给一个大的字符串，给一个数字n，然后给出n个小的字符串，在大的字符串里面每个字母只能选一次，问最多可以组成多少个小的字符串。小的字符串最多有10个，每个小字符串和大字符串长度最多10000。 题目思路： 因为最多有10个小的字符串，从10个里面选，最多有1024种选法。因为字符串只包含26个小写字母，可以统计每个小字符串里面的每个小写字母的个数，这样，复杂度大约在10×26×1024,是10^5的范围，可以枚举。 比如对于n个字符串，最多有1&amp;lt;&amp;lt;n种，用 x 从1枚举到1&amp;lt;&amp;lt;n - 1，然后用 j 从 0 枚举到n-1，用 1 &amp;lt;&amp;lt; j 和 x 相与，如果为1,则 j +1 表示第 j + 1 个人被选上了，判断它是不是能被选上，如果能被选上，那么 cnt++，再和max相比较，最后得到max。</description>
    </item>
    
    <item>
      <title>2013年4月19日 四校联赛挑战赛总结</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8819%E6%97%A5-%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B%E6%8C%91%E6%88%98%E8%B5%9B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 20 Apr 2013 09:06:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8819%E6%97%A5-%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B%E6%8C%91%E6%88%98%E8%B5%9B%E6%80%BB%E7%BB%93/</guid>
      <description>卡在了水题上。后面的题目就不用说了，根本就没看。平时学习的东西根本就没有用上，简单题这一关就过不了。 唯一需要注意的就是，一道题目，有了想法，自己先把能考虑到的情况都考虑周全，不要指望和队友讨论再讨论一下，有的时候队友在思考自己的想法，没有时间，所以自己一定要考虑周全，再敲代码，千万不要有一个想法就敲，快写完的时候发现错了……就悲剧了。还有就是，读题，这次我就读错了一道题目，把队友坑了，虽然后来队友发现了，但我们三个还是都没有想法，比较坑的是，这题可以枚举，因为是10个人，范围很小。我们三个都没有注意到这一点。llh本来当时还问了一下范围，我看题的时候看到了10人，后来忘了，，就说题目没有给……我去……以后一定不能出现这种情况！ 然后就是代码能力，千万不能把代码敲错，比如赛后敲一道题目，思路很清晰，但是敲的时候就错了，调试很久，后来才发现，原来是自己命名的变量用错了，还有一些地方写错了……浪费很多时间，照这个情况，就算这道题目比赛的时候知道怎么做，也不一定能敲出来，虽然就是枚举。 比赛的时候过得第二道题目，我的想法是错的，llh有另一个想法，敲完后不知道哪里错了，虽然给我讲了，但是还是不太理解，最后还是因为一个小细节没处理好。不是想法的问题。当初我能够仔细按照那个想法做一下就好了，以后队友讲想法的时候认真理解。 总的来说，还是水题都过不了。第一：没有想法。第二，代码能力。第三，好好学STL，有的时候，切水题用STL很方便。至于没有想法这个问题，只有多练习，多思考，一般的水题都不会太难，考察的关键是思路和代码能力。 zsl神牛昨天跟我说，每次比赛都要好好总结，比赛后没过的题目都要过了，只要校队有人过的，都必须过，没人过的，也要过几道，如果校队的人都比不过，到了现场赛就不用说了！唉，确实是这样。谢谢sl学长。 这次挑战赛又输了，四校联赛又不能去了，我们队从来没有赢过Babel。唉，太窝囊了…… 从现在起，坚决不能再输给他们了！ 5月份就去南京邀请赛了，我不知道为什么我们从来没有赢过Babel却可以去南京，但是，既然让我们队去了，就别想别的，不要让大家失望，认真珍惜这次出去的机会！</description>
    </item>
    
    <item>
      <title>poj2001 Shortest Prefixes ——字典树复习</title>
      <link>http://liuxueyang.github.io/posts/poj2001-shortest-prefixes-%E5%AD%97%E5%85%B8%E6%A0%91%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Fri, 19 Apr 2013 15:46:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2001-shortest-prefixes-%E5%AD%97%E5%85%B8%E6%A0%91%E5%A4%8D%E4%B9%A0/</guid>
      <description>题目链接：http://poj.org/problem?id=2001 这道题目以前写过，复习一下字典树，再写一遍……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; char a[1000+10][30], base = &#39;a&#39;; const int lo = 26; typedef struct trie{ int num; bool terminal; struct trie *son[lo]; }trie; trie *newtrie(){ trie *pnt = new trie; pnt-&amp;gt;num = 1; pnt-&amp;gt;terminal = false; for (int i = 0; i &amp;lt; lo; ++i) pnt-&amp;gt;son[i] = NULL; return pnt; } void insert(char str[], trie *pnt, int len){ trie *tem = pnt; for (int i= 0; i &amp;lt; len; ++i){ if (tem-&amp;gt;son[str[i]-base] !</description>
    </item>
    
    <item>
      <title>poj1298 The Hardest Problem Ever ——水题</title>
      <link>http://liuxueyang.github.io/posts/poj1298-the-hardest-problem-ever-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Fri, 19 Apr 2013 14:18:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1298-the-hardest-problem-ever-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1298 题目大意： 字母映射。太简单了。不说了。感脚都不好意思在博客里面写……水题一次最多切3道，再多就没意思了……也没有意义…… 题目思路： 为了学习ＳＴＬ，用的ｍａｐ。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; map&amp;lt;char, char&amp;gt; mymap; string a, b, c; char aa[10000]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;1298.</description>
    </item>
    
    <item>
      <title>poj3087 Shuffle&#39;m Up ——水题</title>
      <link>http://liuxueyang.github.io/posts/poj3087-shufflem-up-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Fri, 19 Apr 2013 13:53:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj3087-shufflem-up-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=3087 题目大意： 给定长度都为Ｃ两个字符串，Ｓ１，Ｓ2，和一个要求的结果字符串ＳＳ。先把Ｓ２的最下面一张牌放在最下面，然后Ｓ１，Ｓ２交错的叠放，得到Ｓ，再把Ｓ最下面的Ｃ个字符赋值给Ｓ１，把剩下的赋值给Ｓ２，再次重复上面的过程。最后求出要得到ＳＳ，需要几步这样的过程。 题目思路： 开始以为是用ＳＴＬ的栈，后来才发现根本用不到，直接用字符串模拟就可以了。为了学习一下ＳＴＬ，用的是ｓｔｒｉｎｇ类。只要比较当前得到的字符串和要得到的字符串是不是相等就可以了。如果永远也得不到要得到的字符串，那么就一定存在Ｓ１和Ｓ２和原来的Ｓ１和Ｓ２都对应相等，其实这道题目的难点就在这里。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;3087.</description>
    </item>
    
    <item>
      <title>poj1002 487-3279 ——水题</title>
      <link>http://liuxueyang.github.io/posts/poj1002-487-3279-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Fri, 19 Apr 2013 11:22:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1002-487-3279-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1002 题目大意： 给定一组电话号码，如果是包括字母，那么就映射到数字，统计相同的电话号码个数大于1的号码，按照从小到大的顺序输出，并且输出相应的个数。 题目思路： 因为电话号码最多又7位数字，在整数范围内，把每个读入的电话号码转化成整数，用一个ｍａｐ记录是不是出现过，如果出现过，就把相应的ｍａｐ记录加1,如果没有出现过，就把这个数字放进一个数组ａｒｒ里面，这样ａｒｒ里面的数字是不重复的。最后把ａｒｒ排序，对于每一个数组元素，输出相应的ｍａｐ记录，也就是它出现过的次数。 输出的时候，按照整数输出，但是要注意，开始要输出3位，如果前面有0的话，按照整数输出就不行，所以要控制格式，用ｐｒｉｎｔｆ（“%03ｄ”）；这样的格式，表示前面要补齐0；卡住了，看得以前的代码才想到这种情况，还是思维不严谨 啊～
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MINN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int arr[100000+10]; map&amp;lt;char, int&amp;gt; ma; char pri[10]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;poj1002.</description>
    </item>
    
    <item>
      <title>2013年4月18日 雨</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8818%E6%97%A5-%E9%9B%A8/</link>
      <pubDate>Thu, 18 Apr 2013 23:46:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8818%E6%97%A5-%E9%9B%A8/</guid>
      <description>今天跑步状态超好，呼吸，速度都控制得很好，不知不觉就跑完全程了，还有一种意犹未尽的感觉。O(∩_∩)O哈哈~ 刚刚发现，其实自己每天的跑步路程也不过5200米，赶脚弱爆了……~唉，继续加油吧~~</description>
    </item>
    
    <item>
      <title>2013年4月17日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8817%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Wed, 17 Apr 2013 23:37:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8817%E6%97%A5-%E6%99%B4/</guid>
      <description>今天跑步状态不错。起跑的时候正好遇到两个哥们在一起跑，我去……还跑得挺快，遇到高手了，但是正好也有了动力，紧跟着跑，状态还不错，跑得挺爽，好久没这么有激情地跑过了，然后不到一半的时候，一哥们干脆停下来了……挺悲剧的，唉，只要一停下来，就基本跑不起来了，然后就剩下我跟另一个人跑，那人很强悍，以那个速度，一直那么跑，不带减速的，然后我心理想：这回遇到真正的高手了。他同时也在加速，我有点儿撑不住，但是还是尽力坚持，因为我知道，只要距离拉远了，再跟上就不可能了，一直这么坚持了一段时间，心里想着，当一个人的平均速度和别人本来就有差距的时候，注定是没有赢得希望的，因为人家以正常的速度跑，习惯了，你以人家的速度跑，一般很快就到了极点，好的情况就是距离被拉远，自己速度放慢，调整自己，直到平稳下来，以自己正常的速度跑；比较悲剧的情况是，到了自己的极点，透支了体力，干脆停下来了。但我还是坚持跟上，不让自己和对方的距离拉大，努力和对方的距离，不超过两三秒的样子，再到后来，那哥们停下来了，我去……这……唉，悲剧了，然后我就可耻地轻松地超过了人家o(╯□╰)o 其实那人挺强的，以他那个速度，我不可能像他那样坚持那么长的距离，但是我还是坚持下来了，运气好~O(∩_∩)O哈哈~ 然后我就继续以那个速度跑到了终点，太爽了，好久不这么畅快地跑了，稍微休息一下，原路返回，显然没有那么多体力了，所以就以超慢的速度，跑回来了，当做调整一下。 其实，在比赛的过程中，尤其是有一个人快要超过你的时候，很多人都是适当加快速度，给对方以心理压力，但是，过度逞强，完全打乱了自己的节奏就得不偿失了，最终很可能被别人超过，甚至自己体力透支，不得不停下来，当你因为别人改变自己的节奏，一开始你就输了，即使最终赢了，也没有发挥出自己最好的状态。跑步的过程中，很大一部分比的是心理和意志力，如果实力和体力相差不大的话。 其实，有一个比你强的人在你前面，确实能让跑步的效果更好，但是，更多的时候是自己一个人跑，当没有别人带着你的时候，你要学会自己调整，呼吸和心态。毕竟，跑步是自己的事情，没有人能帮你。别的事情也一样…… 最近事情超多，比较忙，甚至写程序的时间也很少了，只有提高自己的效率，写程序就要认真写，做作业就要全神贯注地做，不能三心二意，平时的零碎时间可以想想算法，认真体会算法的思想，尤其是，养成一开始就养成不依赖模板的习惯，自己手敲，多敲几遍，每次敲的时候都会有不同的错误，但是在这个过程中，也加深了自己对算法的理解。一道题目不会做，不要急着去翻人家的解题报告，自己多想想，或者有思路了，代码敲出来了，但是有怎么也找不出来的bug，这个时候可以先放一放，过几天再拿出来敲一遍，或许就豁然开朗了，很多问题都是自己当时陷入了思维误区，或者长时间想一个问题，把自己搞糊涂了，过一段时间再想，再分析一下就感觉思路更清晰了。不要一个bug找好久，效率很低，也耽误了学习新知识的时间。同时也注意多培养自己的代码能力，一道题目好不容易有想法了，但是敲出来的代码就是有各种bug，这就反映出了自己的代码能力和代码习惯，有的人代码习惯比较好，虽然敲得比较慢，但是能够1A，这种比我这种很快敲出来，但bug无数的好多了……我去…… 说实话，很惊讶，我们队竟然有机会去南京的邀请赛……RP值爆发了，好有压力，所以，什么也不想了，加油!</description>
    </item>
    
    <item>
      <title>Snakes &amp; Ladders ——BFS入门题</title>
      <link>http://liuxueyang.github.io/posts/snakes--ladders-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Wed, 17 Apr 2013 09:28:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/snakes--ladders-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=116&amp;amp;page=show_problem&amp;amp;problem=555 题目大意： 给一个棋盘，分布着蛇和梯子，投骰子确定走的步数，问最少投几次骰子可以到达终点，到达蛇头就回到蛇尾，到达梯子底部就上升到梯子顶部。 思路： BFS，到达每一个节点都可以扩展出6个节点，判断终点是不是到达过，如果到达过，退出循环。 这题WA了……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int D, N , S, L, a[23*23], b[23*23]; typedef struct La{ int start, end; }La; La la[120]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;arb.</description>
    </item>
    
    <item>
      <title>poj1006 Biorhythms ——中国剩余定理入门题</title>
      <link>http://liuxueyang.github.io/posts/poj1006-biorhythms-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Wed, 17 Apr 2013 02:20:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1006-biorhythms-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1006 题目大意： 人体有三个周期，23，28，33. 对于每个周期分别给出从第0天开始，这三个周期的高潮出现的一个日期，不一定是第一次，p , e , i 。给出一个天数 d 表示今年已经过去了多少天，计算在这 d 天之后，三个高潮同时出现的那一天距离现在还有多少天。 思路： 23， 28， 33 是两两互素的，题目意思就是求一个数字 x ，使得这个数字 x 和 p 对23同余，同时 x 和 e 对28同余，同时 x 和 i 对33同余。所以可以用中国剩余定理解。 这是一个同余方程组。 x = p(mod 23); x = e (mod 28); x = i(mod 33); 这里的&amp;rsquo;=&amp;lsquo;代表同余符号。 因为求的是大于d的，所以，当求得的解小于等于d的时候，要加上模 23*28*33；直到解大于d为止。</description>
    </item>
    
    <item>
      <title>2013年4月16日 阴转晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8816%E6%97%A5-%E9%98%B4%E8%BD%AC%E6%99%B4/</link>
      <pubDate>Tue, 16 Apr 2013 22:42:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8816%E6%97%A5-%E9%98%B4%E8%BD%AC%E6%99%B4/</guid>
      <description>今天跑步状态两个字：完美！ 从一开始就感觉跑得比较快，并且节奏和呼吸都控制得比较好，本来觉得可能跑不完全程，结果连自己都很惊讶，竟然以那样的速度跑完了全程，时间大约40分钟，路程貌似是最长的一次，好神奇。可能是今天身体状态比较好，再加上心理状态比较积极，好久没有跑得这么酣畅淋漓了！ 其实跑步的过程中，最重要的是战胜自己的心理，通过了这一关，剩下的就都不是问题了，有时候甚至会惊讶于自己竟然 能够跑这么远，起初这都是不曾想象过的。 总之今天跑步的速度堪比当年高中时候的跑步速度，O(∩_∩)O哈哈~太爽了 ACM其实只是一个比赛，当做一种爱好吧，全力以赴，不为别的，只因为兴趣而已，解决问题的成就感是最吸引人的~在ACM上强加上一些别的东西反而觉得很没意思了……不单单是做题，最重要的是培养自己独立思考和解决问题的能力，奖项只是附加品，不是全部。千万不要舍本逐末。</description>
    </item>
    
    <item>
      <title>2013年4月15日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8815%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Tue, 16 Apr 2013 00:49:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8815%E6%97%A5-%E6%99%B4/</guid>
      <description>13日 晴 那天去中南比赛，回来比较累，下午睡了一觉，晚上去跑步，然后喝了一口水，我去……跑的过程中各种纠结，，唉，全程不舒服，走走停停，很不爽。 14日 晴 天气比较好，可惜，晚上校队有讨论，回到宿舍已经10点半了，这个时候的湘江边几乎没什么人了，貌似还有点儿害怕~长沙这种，地方嘛，^_^ 跑一半路程就回来了，一点儿也没意思，o(╯□╰)o 后来权当散步了。。。。 最近几天貌似状态不好啊。 15日 晴，小雨 晚上去跑步，开始有一哥们儿在我后面跑，赶脚好有动力，O(∩_∩)O哈哈~所以开始速度比较快，跑到后期那哥们儿从另一条路走了，每个人的路线都不一样啊，后来一直自己跑，回来的路上，突然下起了雨，悲剧了，还是雨点儿特别大的那种，然后继续跑，最担心的是手机和P3进水了……o(╯□╰)o不过还好，不到几分钟，雨就停了，后来觉得没什么意思，走走停停地回来了…… 今天为yr酱他当初每天做几道题，不算水题，答曰：10+。我……难道这就是境界的差别么？唉，不可同日而语 难道大神们都是这么练出来的么？好吧，ORZ……加油吧，显然是做的太慢了。。 妈妈说，在ACM界有三种人可以生存下来：1.</description>
    </item>
    
    <item>
      <title>uva10591 - Happy Number ——水题</title>
      <link>http://liuxueyang.github.io/posts/uva10591---happy-number-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Mon, 15 Apr 2013 23:35:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva10591---happy-number-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=1532 题目大意： 给一个数字，各位数字的平方和相加，依次循环，如果最后得到1，那么这个数字就是happy number，如果不能，就是unhappy number。 思路： 因为题目范围只有10^9，所以可以暴力求解，数字的平方和最大是9*9*9=729，可以用一个数组标记这个数字是否被访问过。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int visit[1000]; int solve(int n){ int m = 0; while (n){ m += (n%10)*(n%10); n /= 10; } return m; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;uva10591.</description>
    </item>
    
    <item>
      <title>hdu2098 不要62 ——数位DP入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu2098-%E4%B8%8D%E8%A6%8162-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 15 Apr 2013 21:24:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu2098-%E4%B8%8D%E8%A6%8162-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2089 题目大意： 含有4或者62的数字是不吉利数字，给一个区间，[m, n]，求这个区间内的除了不吉利数字以外的数字的数目。 思路： 由于数据范围只有1~1000000，可以暴力，水题，但是为了练习一下数位DP，没有把它当水题做…… 看的是这个人的代码：http://blog.csdn.net/acm_cxlove/article/details/7819907# 和hdu3555那道题目相似，但是多了一个条件，多了一个不含有4的条件，讨论一下。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; LL dp[8][3]; int a[8], b[8]; bool flag; int solve(int k){ int len = 0; LL temp = k; while (k){ a[++len] = k % 10; k /= 10; } LL ans = 0; int last = 0; flag = false; a[len+1] = 0; for (int i = len; i &amp;gt;= 1; --i){ ans += dp[i-1][2] * a[i]; if (flag){ans += dp[i-1][0] * a[i];} //高位位填4，低位的不管 if (!</description>
    </item>
    
    <item>
      <title>hdu1202 The calculation of GPA ——水题</title>
      <link>http://liuxueyang.github.io/posts/hdu1202-the-calculation-of-gpa-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Mon, 15 Apr 2013 20:39:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1202-the-calculation-of-gpa-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1202 题目大意：先计算出学分和点数的乘积的和，然后在除以学分之和。 思路： 很简单。只能说这道题目比较坑……不说什么了 本来是早上起来想写道水题，练练手，结果碰见这种题目，刚才我还无聊的测试了很多次，交了N遍，发现这么个坑的问题，感觉这种题目很没有意思……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu1202.</description>
    </item>
    
    <item>
      <title>uestc1307 windy数 ——数位DP入门题</title>
      <link>http://liuxueyang.github.io/posts/uestc1307-windy%E6%95%B0-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 15 Apr 2013 19:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uestc1307-windy%E6%95%B0-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.uestc.edu.cn/problem.php?pid=1307  题目大意： 不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。windy想知道，在A和B之间，包括A和B，总共有多少个windy数？ 思路： 具体解释代码中有。看的这个人的代码：http://blog.csdn.net/acm_cxlove/article/details/7819907# 然后自己又分析了一下，终于明白了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int dp[15][10], a[15]; // 这个函数求的是区间（0，n）内的个数 LL solve(int n){ int len = 0; LL ans = 0; while (n){ a[++len] = n % 10; n /= 10; }int i, j; a[len+1] = 0; // 长度为1~len-1 for (i = 1; i &amp;lt;= len-1; ++i) for (j = 1; j &amp;lt;= 9; ++j) // 注意j从1开始，因为最高位不能是0！ ans += dp[i][j]; // debug了好久！！！ // 长度为len，但是最高位是a[len] - 1 for (i = 1; i &amp;lt;= a[len] - 1; ++i) ans += dp[len][i]; // 长度为len，但是最高位是a[len] for (i = len - 1; i &amp;gt;= 1; --i){ for (j = 0; j &amp;lt; a[i]; ++j) if (abs(a[i+1] - j) &amp;gt;= 2) ans += dp[i][j]; if (abs(a[i] - a[i+1]) &amp;lt; 2) break; } return ans; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;uestcoj1307.</description>
    </item>
    
    <item>
      <title>hdu3555 Bomb ——数位DP入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu3555-bomb-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 14 Apr 2013 11:23:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu3555-bomb-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=3555 题目大意： 给一个数字n,范围在1~2^63-1，求1~n之间含有49的数字有多少个。 思路： 经典的数位DP，学习了一下，看的别人的代码：http://www.cnblogs.com/luyi0619/archive/2011/04/29/2033117.html 状态转移： dp[i][0]代表长度为 i 并且不含有49的数字的个数； dp[i][1]代表长度为 i 并且不含有49，但是最高位是9的数字的个数； dp[i][2]代表长度为 i 并且含有49的数字的个数。 数组 a[i] 从低位到高位存储 n 的每一位数字。 则：dp[i][0] = dp[i-1][0] * a[i] - dp[i-1][1]; 表示长度为 i 的不含有49的数字的个数等于长度为 i - 1 的不含有49的数字的个数*当前的数字，因为这个位置可以填0~a[i] - 1，然后再减去长度为 i - 1 的最高位是9的数字的个数，因为如果长度为 i - 1 的最高位是9的话，那么高一位就不能填4了，否则就组成了49。 dp[i][1] = dp[i-1][0]; 表示长度为 i 的并且不含有49同时最高位是9的数字的个数等于，长度为 i - 1 的不含有49的数字的个数，因为只要在它的高一位加上一个9就可以了。 dp[i][2] = dp[i-1][2] * a[i] + dp[i-1][1]; 表示长度为 i 的含有49的数字的个数等于，长度为 i - 1 的数字的个数*当前的数字，再加上长度为 i - 1 的并且不含有49同时最高位是9的数字的个数，因为这个时候，只要在高一位加上一个4就可以了，这样在最高的两位就组成了一个49。 做法是从数字的高位向低位扫描，对于第 i 位， 其实这个题目还有一个地方不懂，就是为什么要在输入 n 后，要把 n 加1。想了一下特例，比如输入49，按照上面的做法，在第3步，并不会把符合条件的数字加上，因为4不是严格大于4，最后的执行结果就是0，但是如果加上1之后，n就变成了50，这样第3步恰好可以执行，结果就是正确的了。但是对于一般的情况，还是不知道为什么要把n加1……o(╯□╰)o 这题还是卡了很久，照着别人的代码敲的，死活过不了，然后又找了一份代码：http://blog.</description>
    </item>
    
    <item>
      <title>2013年4月12日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8812%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Sat, 13 Apr 2013 02:49:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%8812%E6%97%A5-%E6%99%B4/</guid>
      <description>休息了两天，今天本来想好好跑一下，结果还没有出公寓就岔气了……后来全程都不爽，一直岔气，想起一句话：比赛中的错误往往是在起跑后的两分钟内犯下的，甚至是在第一分钟内。后来跑得还算好吧，但是没有了节奏感，明天希望状态好一点儿~</description>
    </item>
    
    <item>
      <title>zoj2913 Bus Pass ——BFS入门题</title>
      <link>http://liuxueyang.github.io/posts/zoj2913-bus-pass-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sat, 13 Apr 2013 01:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj2913-bus-pass-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1912 题目大意： 有很多个地区，有几条公交线经过一些地区，求出一个地区，满足，使这个地区到这些公交线上的所有公交站的距离中的最大值，最小。（这里的距离指的是两点之间的边数） 思路： 对于这些公交站中的每一个点，BFS，求出出当前点外，其他所有点到这个点的最小距离，然后对于公交站上的其他点，也进行同样地操作，不断更新所有点到公交站上的当前点的最小距离的较大值，然后遍历所有点，求出距离最小的一个点。用res1数组存储。res数组的作用是对于公交线上的每个点，BFS其他点的时候，临时存放其他点到这个公交站的最小距离，然后在与res1数组进行比较，用来更新res1数组。 注意： visited数组，标记这个是不是被访问过，并且标记的顺序要想清楚！把这个点入队的时候就要标记它被访问了，而不是它出队的时候再标记！这是因为，如果两天点同时和一个点相邻，如果等点出队的时候在标记的话，就会产生这个点被访问两次的情况，这个问题让我纠结了一个星期……我去……
比如这种情况，Ｃ和Ａ，Ｂ同时相邻，假如：先访问Ａ，ｒｅｓ［Ｂ］　＝　ｒｅｓ［Ｃ］　＝　２，把Ａ标记，然后出队；再访问Ｂ，ｒｅｓ［Ｃ］　＝　３，Ｃ的值显然是不对的，所以，当把Ｂ，Ｃ两个点入队的时候，就把他们标记为已经访问，就可以了…… 做这个题目感触挺大的，首先，写代码要全神贯注，不能有一点儿疏忽，否则很容易犯那种超级难找出来的隐蔽的错误，一定要考虑明白再写；然后就是数组的下标什么的，养成好习惯，到底什么时候该从０开始，什么时候该从１开始，我觉得从１开始比较保险，因为有的时候会用到编号，比如这道题目，点的标号从１开始；最后就是思考这种题目应该如何存储题目给的信息，这个东西是看的书上的思想； 自己写代码比看着人家的代码写感觉和收获是完全不一样的。</description>
    </item>
    
    <item>
      <title>一个bug，持续更新……</title>
      <link>http://liuxueyang.github.io/posts/%E4%B8%80%E4%B8%AAbug%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Fri, 12 Apr 2013 19:48:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E4%B8%80%E4%B8%AAbug%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</guid>
      <description> scanf(&amp;ldquo;%d%d&amp;rdquo;, &amp;amp;n, &amp;amp;mz[n]); 这样的写法是不对的…… 全局变量不要和局部变量命名成相同的名字，尤其是循环变量不要设置成全局的，很危险。 数组要初始化，尤其是多case的时候 写代码的时候要全神贯注，千万不要因为一时的疏忽，出现一个最难发现的最弱智的bug…… 还有，memset(a, 1, sizeof(a));貌似有错……慎用。注：这货只能用4个字节都相同的整数！比如，0x7f7f7f7f 或者 0x3f3f3f3f 有一点最受不了的就是：为什么最近输入老是忘了写取地址符？果然是敲代码敲得少了么…… 输入格式，要用%lld还是%I64d，也可以用cin,cout如果输入量比较少的话。 D = 3；1 &amp;lt;&amp;lt; D - 1 的结果是什么？注意优先级！有位运算的需要加上括号！ ==不要写成=，以前以为自己肯定不会犯这种错误，谁知道……唉 初始化技术变量，尤其是多case的时候 当多个case运行不对的时候，尝试一下只输入一个case，因为可能是多case的过程中，变量没有初始化 尤其是开数组的时候，千万不能把大小写错了，或者，当出现运行都出现系统错误的时候，可能是数组越界了，看一下开数组的时候是不是开小了，或者是数字打错了。 代码错了，自己想办法出数据测试，其实是一种十分重要的能力。 写线段树的时候，计算中点的时候，int M = L + (R-L)&amp;gt;&amp;gt;1；这么写是不对的。。至于为什么，我也不知道。。反正因为这货卡了好久== 直接这么写就行：int M = L+(R-L)/2；  </description>
    </item>
    
    <item>
      <title>2013年4月9日 阴转小雨</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%889%E6%97%A5-%E9%98%B4%E8%BD%AC%E5%B0%8F%E9%9B%A8/</link>
      <pubDate>Wed, 10 Apr 2013 07:37:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%889%E6%97%A5-%E9%98%B4%E8%BD%AC%E5%B0%8F%E9%9B%A8/</guid>
      <description>下午下雨，晚上去跑步，半路上下小雨点，开始犹豫要不要继续往前跑，最后到一半路程的时候就往回走了，结果又不下雨了，长沙的鬼天气，跑着一点儿也不爽，状态很不好，可能是该休息一两天了，后期的时候干脆就当散步了，走回来了…… 不过雨后的湘江边确实空气也挺好，一边走边思考问题，也是一种不错的享受～</description>
    </item>
    
    <item>
      <title>2013年4月8日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%888%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Tue, 09 Apr 2013 02:05:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%888%E6%97%A5-%E6%99%B4/</guid>
      <description>今天跑步很悲剧，遇到极点了，中途各种不想跑，各种累，但还是坚持下来了，嗯，跑步嘛，总会有这种时候，尤其是今天下午也比较热，这种时候，最重要的就是两个字：坚持。不管怎么样，千万不能停下来，如果一停下来，基本就跑步不起来了…… 加油~</description>
    </item>
    
    <item>
      <title>zoj 1649 Rescue ——BFS入门题</title>
      <link>http://liuxueyang.github.io/posts/zoj-1649-rescue-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 08 Apr 2013 20:21:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-1649-rescue-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=649 题意： 给一个字符矩阵，‘#’代表墙壁，&amp;rsquo;.&amp;lsquo;代表空格，‘x’代表有警察的空格，&amp;rsquo;r&amp;rsquo;和&amp;rsquo;a&amp;rsquo;分别代表一屌丝，并且&amp;rsquo;r&amp;rsquo;要到&amp;rsquo;a&amp;rsquo;那里去串门儿，r走一个空格花费单位时间1，走一个有警察的空格需要先干掉警察，话费单位时间1，然后再走过去，也就是共花费时间2，请问屌丝r到屌丝a那里去最少花费的时间。 思路： 首先要搞明白一个问题：就是路径最短的路不一定花费时间最少。这是可以理解的，比如，一条很短但是有很多警察，另一条路很长，但是没有警察，很有可能是第二条路花费时间少。用深搜？貌似不太合适，因为你一条路径访问过一个点后，另一条路径很可能也会访问这个点，并且时间较少。关键是深搜找到的接不一定是最优的。所以，考虑用广搜解。这道题最朴素的广搜显然不行，也就是说，仅仅求步数最少的不可行，需要加上访问时间这个附加条件。 用一个结构体数组存储每个点的信息，包括坐标，到达这个点所需要的最短时间，从起点开始搜，先访问起点，然后把起点出队，如果从一个点A到达下一个点B的当前所需时间比这个点现在标记的时间少，则把这个点入队，然后判断点A的另一个方向上的下一个点。这样，总有一天队列会为空，这是因为，某个点不可能被访问无数次，也就是说，某个点不可能无数次入队，因为到达某个点所需要的时间一定是有个最小值的，所以BFS一定可以结束，并且最后找到的点‘a’的信息一定是最优解。输出就可以了，如果无解，因为初始化到达所有点所需时间都是MAXN，所以，如果点‘a’的时间信息如果等于MAXN，那么说明无解。 第一次做深搜，这道题开始不知道怎么做，看了书上的思路，坚持没看代码，自己又想了想，就试着开始写，好神奇，竟然1A了！！！
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MINN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; typedef struct point{ int a, b, t; }point; point p[220][220], st, en; char s[220][220]; int n, m, T, si, sj, di, dj; queue&amp;lt;point&amp;gt; qt; void bfs(){ qt.</description>
    </item>
    
    <item>
      <title>2013年4月7日 晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%887%E6%97%A5-%E6%99%B4/</link>
      <pubDate>Mon, 08 Apr 2013 07:26:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%887%E6%97%A5-%E6%99%B4/</guid>
      <description>昨天补概率论作业，没时间写，补上~ 今天天气很好，但是下午最后一节有课，所以打算晚上9点钟去跑步。 不得不说，晚上的湘江边很美，尤其是天气很好的晚上，春天，也许是最适合跑步的季节，不冷不热，微风习习，一路上还看见不少跑步的男男女女，有的是为了锻炼身体，有的是为了减肥，有的单纯是因为爱好。 今天跑步状态不错，很稳，时间，速度都控制得很准，正好半小时。然后在湘江边做了一下拉伸，稍微休息了一下，欣赏了一下美景，就心满意足地回来了。 其实，晚上去跑步也别有一种感觉。以后，下午最后一节有课就晚上去跑，否则就下午。 附上一段代码：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;.</description>
    </item>
    
    <item>
      <title>speedcell&#39;s SPFA</title>
      <link>http://liuxueyang.github.io/posts/speedcells-spfa/</link>
      <pubDate>Sun, 07 Apr 2013 19:21:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/speedcells-spfa/</guid>
      <description>版权永久属于speedcell，神代码，给跪了……yr酱V5…… 这东西虽然还没有学，先收藏起来~ 多谢yr酱……O(∩_∩)O哈哈~
/* Author : Speedcell Update : 2013-03-24 Version : soppYcell 2.</description>
    </item>
    
    <item>
      <title>zoj 2165 Red and Black ——BFS入门题</title>
      <link>http://liuxueyang.github.io/posts/zoj-2165-red-and-black-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 07 Apr 2013 19:06:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-2165-red-and-black-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1165 题意： 给一个字符矩阵，“.”代表黑色格子，“#”代表红色格子，有一个起点“@”，它属于黑色格子，一个人从起点出发，只能走黑色格子，并且只能上下左右走，不能对角线走，问这个人能走到的黑色格子有多少个。输出个数。输入W，H，代表有W列，H行，然后输入一个字符矩阵，输出能走到的最多的黑色格子的个数，包括起点。 思路： 这个题目很简单，和zoj 2110 类似，但是这道题目比那道简单多了，不用剪枝，不用恢复现场，直接深搜就可以。首先找到起点，然后从起点出发，判断这个点是不是被访问过，如果被访问过，就return；否则判断这个格子是不是黑色格子或者是起点，如果是，就cnt++，然后标记这个格子已经被访问过，如果不是，return; 如果没有return，就在这个点的四个方向继续深搜。思路很清晰。1A。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; int w, h, cnt = 0; char s[22][22]; bool flag[22][22]; int dir[4][2] = {{0,1},{1,0},{-1,0},{0,-1}}; void dfs(int i, int j){ if (i &amp;lt;= 0 || j &amp;lt;= 0 || i &amp;gt; h || j &amp;gt; w) return; if (flag[i][j]) return; if (s[i][j] == &#39;.</description>
    </item>
    
    <item>
      <title>zoj 2412 Farm Irrigation ——DFS入门题</title>
      <link>http://liuxueyang.github.io/posts/zoj-2412-farm-irrigation-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 07 Apr 2013 12:48:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-2412-farm-irrigation-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1412 题意： 有11种正方形，每种正方形里面对应一种形状的水管，不同的的正方形一用A到K表示，给一个矩阵，问至少需要多少个水源可以使矩形中所有的地方都可以被灌溉，如果两个相邻的正方形的水管正好对口，那么这两个正方形可以共用一个水源。 思路： 开始感觉很复杂，明显可以DFS做，但是感觉比较麻烦，关键是怎么处理题目中的条件。 首先，处理11种不同的水管，分4个方向，1表示有接口，0表示没有接口。用一个二维数组存所有种类的水管。 然后，把输入的字符转化成数字，可以再输入的时候边输入边处理，用字符减去字符“A”就可以了，对应的上面给11中不同水管中的一种。以上这两个处理方法要注意，学习一下，稍微看了一下别人的代码才想到的。这种看似比较简单的处理，往往给解题带来比较大的方便。 最后，就是如何深搜了。这个要考虑清楚。用一个flag二维数组表示是否访问过这个方格。深搜的时候，如果访问到它时，先判断它是否被访问过，然后立刻标记为已访问。然后就是判断当前方格的四个方向是不是有接口，如果某个方向有接口的话，就判断这个方向上的下一个方格中，和当前方格相邻的边是不是有接口，如果有接口，则继续深搜这个相邻的点。这里有个处理：（k+2）%4，意味着，比如：当前方格如果右边有接口，则判断右边的方格的左边的边是不是有接口，其它情况一样。然后就是主函数里面的dfs外面的for循环，思想和以前做过的zoj 1709是一样的，就是搜到某个点的时候，用一个mrk标记一下，把和它有关系的点都搜完，如果有符合条件的，mrk会改变，然后就cnt++用来计数，这种题目是相似的，都是要求符合条件的点相邻。 有一个细节，就是矩阵的数组还是从1开始吧，数组稍微开大一点儿，这样在深搜下一个方向的时候，就不会因为数组越界出错了。这个问题以前没有注意到。</description>
    </item>
    
    <item>
      <title>2013年4月6日四校联赛总结</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%886%E6%97%A5%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 07 Apr 2013 10:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%886%E6%97%A5%E5%9B%9B%E6%A0%A1%E8%81%94%E8%B5%9B%E6%80%BB%E7%BB%93/</guid>
      <description>昨天的四校联赛比赛很失败，整场比赛我似乎都没有做题，也没有几乎敲键盘，差点儿爆零……最后还是队友过了一道，很对不起队友，糗……最近都在看课本，敲键盘不多，都没有感觉了，水题也想不到该怎么做…… 最大的问题是没有准确分析复杂度，两道题目明显可以暴力的，可是就是没有想到，开始也分析了一下复杂度，但是貌似觉得很大，就没有往下去想，以后不能想当然，准确分析复杂度后再想解决办法。 yr说的对，最重要的是学会如何在逆境中最大化地利用有限资源的那种能力。也许现在学的东西还不多，但是，你把学过的东西真正掌握了嘛？你是不是在比赛的时候真正把学过的东西最大化地用上了？你是不是发挥出了平时训练出来的能力？ yr给的建议：学知识的顺序还是按照白书的顺序来吧。书太多了，自己竟然把白书给忘了……先把例题切掉，打一下基础。</description>
    </item>
    
    <item>
      <title>2013年4月6日  晴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%886%E6%97%A5--%E6%99%B4/</link>
      <pubDate>Sun, 07 Apr 2013 01:26:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%886%E6%97%A5--%E6%99%B4/</guid>
      <description>比赛完去跑步，今天天气很好，有温和的阳光，还有微微的风，跑步正合适，开始还是跑得有点儿快……中途前面还有骑直行车的，然后动力就来了，速度加快了，紧跟着自行车，跑得比较爽，也不感觉特别累，明显比前两天跑得快，路程比以前长，但是还是比平常快了整整五分钟！唉，先慢慢来吧，先不追求速度，关键是跑得高兴。^_^ 阳春三月，江边有很多放风筝的，哈哈，突然发现春天真的来了。 所有的不愉快，都随风而去……温和的阳光里，跑步结束，望着天上各种各样的风筝，变得豁达起来。周围的三五成群的人们，都在享受这春光，多美好的境界。</description>
    </item>
    
    <item>
      <title>zoj 1709 Oil Deposits ——DFS入门题</title>
      <link>http://liuxueyang.github.io/posts/zoj-1709-oil-deposits-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 07 Apr 2013 00:23:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-1709-oil-deposits-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=709 题目大意： 给一个矩阵，*代表空地，@代表油田，并且@如果水平，竖直，对角线相邻的话就认为是一块油田，问有多少块油田。 思路就是DFS，从第一个字符开始搜，找到一个@就标记一下，cnt++，然后看它的八个方向上是不是有@，如果有，全部标记为*，不需要恢复现场。然后输出cnt的值就行了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; char s[110][110]; bool flag; int cnt, n, m; int dir[8][2] = {{0,1},{0,-1},{-1,0},{1,0},{1,1},{-1,1},{1,-1},{-1,-1}}; void dfs(int i, int j){ if (i &amp;lt; 0 || j &amp;lt; 0 || i &amp;gt; m || j &amp;gt; n) return; if (s[i][j] == &#39;*&#39;) return; if (s[i][j] == &#39;@&#39;) flag = true; s[i][j] = &#39;*&#39;; for (int k = 0; k &amp;lt; 8; ++k){ if (s[i+dir[k][0]][j+dir[k][1]] == &#39;@&#39;){ dfs(i+dir[k][0], j+dir[k][1]); } } } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;zoj1709.</description>
    </item>
    
    <item>
      <title>zoj 2110 Tempter of the Bone ——DFS&#43;剪枝</title>
      <link>http://liuxueyang.github.io/posts/zoj-2110-tempter-of-the-bone-dfs&#43;%E5%89%AA%E6%9E%9D/</link>
      <pubDate>Sat, 06 Apr 2013 23:20:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-2110-tempter-of-the-bone-dfs&#43;%E5%89%AA%E6%9E%9D/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1110 题意： 给一个矩阵，‘X’代表墙壁，‘.’代表空格，‘S’代表起始位置，‘D’代表终点。从起点开始，每个空格只许经过一次，求在规定的时间t的时候，能否正好到达终点。每走一个花费1个单位时间。输入n,m,t，分别代表矩阵的行，列，规定的时间。 思路： 深度优先搜索，从起点开始，按照四个方向搜索，判断某个方向的下一个方格如果不是墙壁的话，就把它标为墙壁，然后从这个点继续往下搜索，如果从这个点往下搜索失败后，就要把这个点标记回原来的空格符号：‘.’。然后尝试下一个方向。直到i == di, j == dj, t == T的时候，表示搜索成功，flag = true; return; 其中si sj 是起点位置，di dj是终点位置，T是当前所花费的时间。 然后还有几处剪枝：如果这个矩阵的空格的数目小于等于时间t，那么不可能成功。这在主函数里面可以剪枝。在dfs的过程中，如果发现剩余的时间小于当前位置到终点的最小距离，可以直接判断搜索失败；如果剩余的时间和当前位置到终点的最小时间的差值是奇数的话，可以判断搜索一定失败，可以剪枝，如果是偶数的话，则可能成功。 今天突然发现，以前写的解题报告太搓了……向kedebug的博客学习，O(∩_∩)O哈哈~加油</description>
    </item>
    
    <item>
      <title>2013年4月5日  雨，阴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%885%E6%97%A5--%E9%9B%A8%E9%98%B4/</link>
      <pubDate>Sat, 06 Apr 2013 00:05:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%885%E6%97%A5--%E9%9B%A8%E9%98%B4/</guid>
      <description>上午下雨，还好下午下得不那么大了，4点半的时候正好去跑步，还飘着小雨点儿，不过不影响跑步，还是前天一样，开始的时候跑得过快了，有点儿吃不消的感觉，今天跑的比较多，虽然实跑时间也是整整半小时，但明显比前天跑得远，Google告诉我大概有7000米的样子，现在不追求速度，跑得高兴就行啦。 跑步的过程中，今天感觉不错，尤其是后半段，整个人完全处于那种比较好的状态，脑袋里什么也不想，只注意着自己的呼吸，耳边只有音乐，眼前只有远方的风景，天气还下着小雨，湘江上烟雨迷蒙，好有诗意~还刮着风，开始是逆风，回来虽然顺风，但一点儿感觉也没有，还不如逆风跑舒服。 跑完之后做了一下拉伸，在江边休息了一下，雨还在下着，身上的外套早已湿透了，南方的雨就是这样，斜风细雨不须归…… 今天跑步的时候听《时光》有一种特殊的感觉。 时光 ——许巍　在阳光温暖的春天走在这城市的人群中在不知不觉的一瞬间又想 起你&amp;hellip;&amp;hellip;你是记忆中最美的春天是我难以再回去的昨天你像鲜花那样地绽放让我 心动&amp;hellip;&amp;hellip;We~sayWe~say~~We~say~~We~say~~在阳光温暖的春天走在这城市的人群中在不知不觉的一瞬间又想 起你&amp;hellip;&amp;hellip;也许就在这一瞬间你的笑容依然如晚霞般在川流不息的时光中神采 飞扬&amp;hellip;&amp;hellip; We~say~~We~say~~We~say~~We~say~~~~</description>
    </item>
    
    <item>
      <title>hdu 1059 Dividing ——多重背包复习</title>
      <link>http://liuxueyang.github.io/posts/hdu-1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Fri, 05 Apr 2013 12:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E5%A4%8D%E4%B9%A0/</guid>
      <description>Dividing
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 11367 Accepted Submission(s): 3168</description>
    </item>
    
    <item>
      <title>2013年4月4日  雨</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%884%E6%97%A5--%E9%9B%A8/</link>
      <pubDate>Fri, 05 Apr 2013 03:37:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%884%E6%97%A5--%E9%9B%A8/</guid>
      <description>清明时节雨纷纷，从中午开始就一直下雨……跑步自然没有跑成，这是让我惊奇的是，今天竟然没有感觉到大腿酸痛，，还好好的，，这不科学……本来是很久不运动了的，o(╯□╰)o 中午看到一本中文版《跑者世界》心里满是欣喜，高中时候就听说过这本杂志，村上君还提到过，只是一直没见过哪里卖，然后就跑到综合楼自习的时候看，，好吧……无语了，说实话，这本可能不是真正的《Runner&amp;rsquo;s world》，手上这本杂志唯一吸引我的就是他的封面了……内容明显是各种广告。。 希望明天不下雨，继续跑步！ 发点儿牢骚。最近脑袋里面老是不知不觉地就冒出那些个破事儿……唉，没出息。。还是多干点儿正事儿吧，实在无聊，那就多读点儿闲书吧！这么好的日子，何必让自己那么纠结呢。 中午睡午觉的时候，又想起，明年暑假我就大四了啊，就该找工作了，就该面对各种了，可是，我准备好了么？</description>
    </item>
    
    <item>
      <title>2013年4月3日  小雨，阴</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%883%E6%97%A5--%E5%B0%8F%E9%9B%A8%E9%98%B4/</link>
      <pubDate>Thu, 04 Apr 2013 01:46:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B44%E6%9C%883%E6%97%A5--%E5%B0%8F%E9%9B%A8%E9%98%B4/</guid>
      <description>今天第一次跑步，从下午5点开始，大约跑了半个小时。各种爽啊，又找回了从前那种感觉，只不过一开始跑的时候有点儿兴奋，跑的有点儿快了，到后来有点儿撑不住……坐等明天腿部肌肉酸痛，哈哈，不管那么多了，人生得意须尽欢不是么~ 尤其是今天的天气，湘江上弥漫着水雾，恰好刚刚下过一点儿小雨，空气湿漉漉的，跑步的过程中，真的像梦境一般，周围是安静的，只注意着自己的呼吸，耳机的音乐，前进的脚步声……这种时候适合冥想，向往禅的境界。突然发现，也许自己最大的损失就是没有早些坚持跑步锻炼，在跑步的过程中，那样的状态，是什么也不能达到的，这就是人生的意义么。 有时候，自己就那么不知不觉地跑着，过了一段时间，突然发现，自己竟然跑了这么远了，竟然到了这个原来看似很遥远的地方；还有的时候，感觉还没怎么跑，然后发现自己早就已经看不到起点了，想要回去已经不是那么容易了。 刚回到公寓，天气就下起雨来了，好吧……我的运气要不要这么好啊！恰好去食堂吃饭，出来雨停了，O(∩_∩)O哈哈~ 突然发现，自己一天当中，最有意义，利用最充分的时间就是出去跑步的这段时间，尤其是跑完后，似乎一切都豁然开朗了，什么都想通了。 穿着专业跑鞋跑步确实爽，还有当初买的那个飞利浦的GoGear就是为了跑步的时候用的，遗憾的是一直都没有派上真正的用场，现在用着超爽。 最近的一些事情很多次让我想起了《当我跑步时，我在想些什么》里面村上君的那句话：原来大家都是一样的啊，哈哈。其实很多事情面前，每个人都是一样的，你遇到的困难别人也遇到过，所以，加油吧！没什么大不了的不是么。</description>
    </item>
    
    <item>
      <title>2013年3月zoj月赛总结</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B43%E6%9C%88zoj%E6%9C%88%E8%B5%9B%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 03 Apr 2013 02:55:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B43%E6%9C%88zoj%E6%9C%88%E8%B5%9B%E6%80%BB%E7%BB%93/</guid>
      <description>周日的比赛，一直没有时间写，补上。 唉，其实菜鸟也没什么可总结的，无非都是什么都不会，但每次比赛后还是留下一点儿东西吧，不管有木有用…… 当然是没有任何悬念地被虐。然后就木有然后了…… 整场比赛只做了一道水题，并且还是比赛最后才A的，就是前面博客写过的那个楼外楼的那道 。另外还有一道，是DP+快速幂，好像是chosing number，clj好不容易把DP的部分做出来了，只可惜，我不会快速幂……泪……所以这两天才赶紧把快速幂看了。然后第一题，可以转化成线段树，以前的线段树题目都白写了，真正遇到题目的时候还是不会做，其实就算还记得也写不出来，因为据说要先把题目中树的每个节点编号，然后就转化成线段树了，很明显，那个转化我不会……然后还有一道DP，虽然一直都知道DP狠重要，但还是一直以来都没有认真做过，以后好好做DP，别的还有组合数学题，貌似 还有一个图论题，这些东西都没接触过…… 赶紧加油吧，慢慢积累，有计划，然后坚持不懈。</description>
    </item>
    
    <item>
      <title>poj 1995 Raising Modulo Numbers ——快速幂</title>
      <link>http://liuxueyang.github.io/posts/poj-1995-raising-modulo-numbers-%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Tue, 02 Apr 2013 17:47:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-1995-raising-modulo-numbers-%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; int m; LL power(LL a, LL k){ LL ans = 1; while (k){ if (k&amp;amp;1){ ans = (ans * a) % m; k--; } k &amp;gt;&amp;gt;= 1; a = (a*a)%m; } return ans; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;1995.</description>
    </item>
    
    <item>
      <title>poj 3233 Matrix Power Series ——矩阵快速幂&#43;二分求解</title>
      <link>http://liuxueyang.github.io/posts/poj-3233-matrix-power-series-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82&#43;%E4%BA%8C%E5%88%86%E6%B1%82%E8%A7%A3/</link>
      <pubDate>Tue, 02 Apr 2013 17:06:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-3233-matrix-power-series-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82&#43;%E4%BA%8C%E5%88%86%E6%B1%82%E8%A7%A3/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define LL long long #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 typedef struct matrix{ int a[33][33]; }matrix; matrix A, B, per; int m, k, n; void init(){ scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;k, &amp;amp;m); for (int i = 0; i &amp;lt; n; ++i){ for (int j = 0; j &amp;lt; n; ++j){ scanf(&amp;quot;%d&amp;quot;, &amp;amp;A.</description>
    </item>
    
    <item>
      <title>zoj 3693 Happy Great BG</title>
      <link>http://liuxueyang.github.io/posts/zoj-3693-happy-great-bg/</link>
      <pubDate>Sun, 31 Mar 2013 22:26:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-3693-happy-great-bg/</guid>
      <description>The summer training of ZJU ICPC in July is about to end.</description>
    </item>
    
    <item>
      <title>hdu 2035 人见人爱A^B ——同余的简单性质</title>
      <link>http://liuxueyang.github.io/posts/hdu-2035-%E4%BA%BA%E8%A7%81%E4%BA%BA%E7%88%B1ab-%E5%90%8C%E4%BD%99%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%A7%E8%B4%A8/</link>
      <pubDate>Sun, 31 Mar 2013 22:19:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-2035-%E4%BA%BA%E8%A7%81%E4%BA%BA%E7%88%B1ab-%E5%90%8C%E4%BD%99%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%A7%E8%B4%A8/</guid>
      <description>Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others)Total Submission(s): 15572 Accepted Submission(s): 11012 </description>
    </item>
    
    <item>
      <title>hdu 1021 Fibonacci Again   ——同余的简单性质</title>
      <link>http://liuxueyang.github.io/posts/hdu-1021-fibonacci-again---%E5%90%8C%E4%BD%99%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%A7%E8%B4%A8/</link>
      <pubDate>Sun, 31 Mar 2013 22:12:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1021-fibonacci-again---%E5%90%8C%E4%BD%99%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%A7%E8%B4%A8/</guid>
      <description>Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others)Total Submission(s): 26755 Accepted Submission(s): 12950 </description>
    </item>
    
    <item>
      <title>2013/03/30 国防科技大学 第十六届“银河之光”文化节ACM-ICPC程序设计竞赛 总结</title>
      <link>http://liuxueyang.github.io/posts/2013-03-30-%E5%9B%BD%E9%98%B2%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6-%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8A%E9%93%B6%E6%B2%B3%E4%B9%8B%E5%85%89%E6%96%87%E5%8C%96%E8%8A%82acm-icpc%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sat, 30 Mar 2013 21:48:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013-03-30-%E5%9B%BD%E9%98%B2%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6-%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8A%E9%93%B6%E6%B2%B3%E4%B9%8B%E5%85%89%E6%96%87%E5%8C%96%E8%8A%82acm-icpc%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E6%80%BB%E7%BB%93/</guid>
      <description>今天去国防科技大学参加他们学校的校内选拔赛，是个人赛。有一些教训，总结一下。 第一题，大数相加，很明显的模板题，自己平时还真的没写过……现场手敲，基本思路知道，但是自己还是太天真了，忘了进位，WA了一次，然后改的过程中还是出现各种错误，可能是因为着急，看人家过的那么快，有点儿不淡定，最后还是过了。　然后，去看一道数学题，很天真的TLE了…… 然后，做另一道水题，名字叫E. High Tree，就是有点儿麻烦，思路很简单，求一个函数的积分，然后好不容易敲出来了，但是各种WA……各种测试数据都能过，自己也想了一些测试数据，但还是WA…… 然后就去做别人过了的题，篮球的那道，开始也看到了，貌似很复杂的样子，然后又认真想了一下，原来就是高一的物理题，想着我是不是想简单了，然后就敲了，WA了，本来读题的时候注意到了给的角度是角度制的，可能需要转换，然后写的时候就忘了……然后就改了一下，然后又发现还有别的小错误，本来公式都列对了，但是敲的时候，忘了写一个小步骤……汗……然后就过了…… 继续看那道E题，最后实在看不出哪里错了，下定决心自己重新写一遍！按照差不多的思路敲了一遍，但是某些处理方法不同，还是WA，各种纠结，绞尽脑汁，终于想到了一种没有考虑的情况，就是指数为x和常数也有可能有指数的那种情况，狂喜，赶紧加上，交了，WA……然后继续改，然后就一直卡了…… 看别的其他人过的题目，明显没有思路，知识存储不够…… 然后就一直那么卡着……那道题目一直想，各种情况，越想越复杂。。一直痛苦到最后……2题。。 后来才知道，有一道背包的题目，最近刚看的背包，容易么，可惜那道题目根本就没有看……一直在纠结E题……以后得改。 总结一下主要发现的问题： 1.</description>
    </item>
    
    <item>
      <title>nefu118 n!后面有多少个0 数论</title>
      <link>http://liuxueyang.github.io/posts/nefu118-n%E5%90%8E%E9%9D%A2%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA0-%E6%95%B0%E8%AE%BA/</link>
      <pubDate>Sat, 30 Mar 2013 02:25:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/nefu118-n%E5%90%8E%E9%9D%A2%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AA0-%E6%95%B0%E8%AE%BA/</guid>
      <description>数论题。统计n!里面有多少个素数5即可。公式：[n/p] + [n/p^2] + [n/p^3] + …… 然后发现一个很无语的问题，nefu上面不能用这个：
#ifndef ONLINE_JUDGE freopen(&amp;quot;nefu118.</description>
    </item>
    
    <item>
      <title>hdu 1712 ACboy needs your help 分组背包</title>
      <link>http://liuxueyang.github.io/posts/hdu-1712-acboy-needs-your-help-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</link>
      <pubDate>Fri, 29 Mar 2013 15:08:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1712-acboy-needs-your-help-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</guid>
      <description>ACboy needs your help
Time Limit: 1000&amp;frasl;1000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 2403 Accepted Submission(s): 1223</description>
    </item>
    
    <item>
      <title>hdu 2159 FATE 二维背包</title>
      <link>http://liuxueyang.github.io/posts/hdu-2159-fate-%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85/</link>
      <pubDate>Fri, 29 Mar 2013 13:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-2159-fate-%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85/</guid>
      <description>FATE
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 4682 Accepted Submission(s): 2105</description>
    </item>
    
    <item>
      <title>poj 1014 Dividing 多重背包</title>
      <link>http://liuxueyang.github.io/posts/poj-1014-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 28 Mar 2013 20:59:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-1014-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; int f[120000+10], V; const int MAX = 0x3f3f3f3f; void zeropack(int c, int w){ for (int v = V; v &amp;gt;= c; --v){ f[v] = max(f[v], f[v-c] + w); } } void completepack(int c, int w){ for (int v = c; v &amp;lt;= V; ++v){ f[v] = max(f[v], f[v-c] + w); } } int main(void){ int a[7], cnt = 1; #ifndef ONLINE_JUDGE freopen(&amp;quot;1014.</description>
    </item>
    
    <item>
      <title>hdu 1114 Piggy-Bank 完全背包</title>
      <link>http://liuxueyang.github.io/posts/hdu-1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 28 Mar 2013 12:14:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>Piggy-Bank
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 6841 Accepted Submission(s): 3375</description>
    </item>
    
    <item>
      <title>hdu 2602 Bone Collector 01背包</title>
      <link>http://liuxueyang.github.io/posts/hdu-2602-bone-collector-01%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 28 Mar 2013 10:34:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-2602-bone-collector-01%E8%83%8C%E5%8C%85/</guid>
      <description>Bone Collector
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 17590 Accepted Submission(s): 6954</description>
    </item>
    
    <item>
      <title>zoj 3410 Layton&#39;s Escape</title>
      <link>http://liuxueyang.github.io/posts/zoj-3410-laytons-escape/</link>
      <pubDate>Thu, 21 Mar 2013 10:59:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-3410-laytons-escape/</guid>
      <description>Professor Layton is a renowned archaeologist from London&amp;rsquo;s Gressenheller University. He and his apprentice Luke has solved various mysteries in different places.</description>
    </item>
    
    <item>
      <title>zoj 3409 KKV</title>
      <link>http://liuxueyang.github.io/posts/zoj-3409-kkv/</link>
      <pubDate>Wed, 20 Mar 2013 21:43:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-3409-kkv/</guid>
      <description>KKV (short for Kinetic Kill Vehicle), a new kind of projectile, is a powerful weapon and has a great ability to move in the space.</description>
    </item>
    
    <item>
      <title>zoj 3406 Another Very Easy Task</title>
      <link>http://liuxueyang.github.io/posts/zoj-3406-another-very-easy-task/</link>
      <pubDate>Tue, 19 Mar 2013 21:46:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-3406-another-very-easy-task/</guid>
      <description>This task is so easy that the description is omitted.</description>
    </item>
    
    <item>
      <title>zoj 3407 Doraemon&#39;s Cake Machine</title>
      <link>http://liuxueyang.github.io/posts/zoj-3407-doraemons-cake-machine/</link>
      <pubDate>Tue, 19 Mar 2013 21:42:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-3407-doraemons-cake-machine/</guid>
      <description>One day, N kids got one cake (a cylinder in shape).</description>
    </item>
    
    <item>
      <title>poj 1061 青蛙的约会  ——扩展欧几里得</title>
      <link>http://liuxueyang.github.io/posts/poj-1061-%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A--%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</link>
      <pubDate>Mon, 18 Mar 2013 16:13:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-1061-%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A--%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstring&amp;gt; #define LL long long int LL exgcd(LL a, LL b, LL &amp;amp;x, LL &amp;amp;y){ if (b == 0){ x = 1; y = 0; return a; } LL r = exgcd(b, a%b, x, y); LL t = x; x = y; y = t - a / b * y; return r; } LL gcd(LL a, LL b){ return b ==0?</description>
    </item>
    
    <item>
      <title>uva 11991 - Easy Problem from Rujia Liu?</title>
      <link>http://liuxueyang.github.io/posts/uva-11991---easy-problem-from-rujia-liu/</link>
      <pubDate>Sat, 16 Mar 2013 18:31:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva-11991---easy-problem-from-rujia-liu/</guid>
      <description>Though Rujia Liu usually sets hard problems for contests (for example, regional contests like Xi&amp;rsquo;an 2006, Beijing 2007 and Wuhan 2009, or UVa OJ contests like Rujia Liu&amp;rsquo;s Presents 1 and 2), he occasionally sets easy problem (for example, &amp;lsquo;the Coco-Cola Store&amp;rsquo; in UVa OJ), to encourage more people to solve his problems :D Given an array, your task is to find the k-th occurrence (from left to right) of an integer v.</description>
    </item>
    
    <item>
      <title>uva 11995 - I Can Guess the Data Structure!</title>
      <link>http://liuxueyang.github.io/posts/uva-11995---i-can-guess-the-data-structure/</link>
      <pubDate>Sat, 16 Mar 2013 14:30:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva-11995---i-can-guess-the-data-structure/</guid>
      <description>There is a bag-like data structure, supporting two operations: Throw an element x into the bag.</description>
    </item>
    
    <item>
      <title>hdu 1065 I Think I Need a Houseboat</title>
      <link>http://liuxueyang.github.io/posts/hdu-1065-i-think-i-need-a-houseboat/</link>
      <pubDate>Fri, 15 Mar 2013 19:24:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1065-i-think-i-need-a-houseboat/</guid>
      <description>I Think I Need a Houseboat
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 5929 Accepted Submission(s): 1761</description>
    </item>
    
    <item>
      <title>hdu 1214 圆桌会议</title>
      <link>http://liuxueyang.github.io/posts/hdu-1214-%E5%9C%86%E6%A1%8C%E4%BC%9A%E8%AE%AE/</link>
      <pubDate>Fri, 15 Mar 2013 19:22:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1214-%E5%9C%86%E6%A1%8C%E4%BC%9A%E8%AE%AE/</guid>
      <description>圆桌会议
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 2179 Accepted Submission(s): 1490</description>
    </item>
    
    <item>
      <title>hdu 1056 HangOver</title>
      <link>http://liuxueyang.github.io/posts/hdu-1056-hangover/</link>
      <pubDate>Fri, 15 Mar 2013 11:01:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1056-hangover/</guid>
      <description>HangOver
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 7186 Accepted Submission(s): 2884</description>
    </item>
    
    <item>
      <title>poj 1659 Frogs&#39; Neighborhood</title>
      <link>http://liuxueyang.github.io/posts/poj-1659-frogs-neighborhood/</link>
      <pubDate>Wed, 13 Mar 2013 21:37:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-1659-frogs-neighborhood/</guid>
      <description>Frogs&amp;rsquo; Neighborhood Time Limit: 5000MS Memory Limit: 10000K Total Submissions: 5599 Accepted: 2419 Special Judge</description>
    </item>
    
    <item>
      <title>poj 3225 Help with Intervals</title>
      <link>http://liuxueyang.github.io/posts/poj-3225-help-with-intervals/</link>
      <pubDate>Wed, 13 Mar 2013 21:35:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-3225-help-with-intervals/</guid>
      <description>Description Input Output Sample Input Sample Output #include &amp;lt;cstdio&amp;gt; using namespace std; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 const int maxn = 65535*2+10; int cover[maxn&amp;lt;&amp;lt;2],xorm[maxn&amp;lt;&amp;lt;2]; bool hash[maxn+10]; void fxor(int rt){ if (cover[rt] !</description>
    </item>
    
    <item>
      <title>hdu 1040 As Easy As A&#43;B</title>
      <link>http://liuxueyang.github.io/posts/hdu-1040-as-easy-as-a&#43;b/</link>
      <pubDate>Wed, 13 Mar 2013 21:23:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1040-as-easy-as-a&#43;b/</guid>
      <description>As Easy As A+B
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 26401 Accepted Submission(s): 11218</description>
    </item>
    
    <item>
      <title>hdu 1018 Big Number</title>
      <link>http://liuxueyang.github.io/posts/hdu-1018-big-number/</link>
      <pubDate>Wed, 13 Mar 2013 21:12:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1018-big-number/</guid>
      <description>Big Number
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 18525 Accepted Submission(s): 8292</description>
    </item>
    
    <item>
      <title>hdu 1028 Ignatius and the Princess III</title>
      <link>http://liuxueyang.github.io/posts/hdu-1028-ignatius-and-the-princess-iii/</link>
      <pubDate>Wed, 13 Mar 2013 21:09:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1028-ignatius-and-the-princess-iii/</guid>
      <description>Ignatius and the Princess III
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 8447 Accepted Submission(s): 6009</description>
    </item>
    
    <item>
      <title>hdu 1019 Least Common Multiple</title>
      <link>http://liuxueyang.github.io/posts/hdu-1019-least-common-multiple/</link>
      <pubDate>Wed, 13 Mar 2013 09:18:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1019-least-common-multiple/</guid>
      <description>Least Common Multiple
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 21158 Accepted Submission(s): 7899</description>
    </item>
    
    <item>
      <title>hdu 1061 Rightmost Digit</title>
      <link>http://liuxueyang.github.io/posts/hdu-1061-rightmost-digit/</link>
      <pubDate>Wed, 13 Mar 2013 08:40:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1061-rightmost-digit/</guid>
      <description>Rightmost Digit
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 22887 Accepted Submission(s): 8739</description>
    </item>
    
    <item>
      <title>hdu 1212 Big Number</title>
      <link>http://liuxueyang.github.io/posts/hdu-1212-big-number/</link>
      <pubDate>Tue, 12 Mar 2013 22:01:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1212-big-number/</guid>
      <description>Big Number
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 3386 Accepted Submission(s): 2305</description>
    </item>
    
    <item>
      <title>hdu 1164 Eddy&#39;s research I</title>
      <link>http://liuxueyang.github.io/posts/hdu-1164-eddys-research-i/</link>
      <pubDate>Tue, 12 Mar 2013 21:21:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1164-eddys-research-i/</guid>
      <description>Eddy&amp;rsquo;s research I
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 4452 Accepted Submission(s): 2680</description>
    </item>
    
    <item>
      <title>hdu 1097 A hard puzzle</title>
      <link>http://liuxueyang.github.io/posts/hdu-1097-a-hard-puzzle/</link>
      <pubDate>Tue, 12 Mar 2013 16:19:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1097-a-hard-puzzle/</guid>
      <description>A hard puzzle
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 21925 Accepted Submission(s): 7696</description>
    </item>
    
    <item>
      <title>hdu 1108 最小公倍数</title>
      <link>http://liuxueyang.github.io/posts/hdu-1108-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</link>
      <pubDate>Tue, 12 Mar 2013 14:35:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1108-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</guid>
      <description>最小公倍数
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 24145 Accepted Submission(s): 13180</description>
    </item>
    
    <item>
      <title>hdu 1039 Easier Done Than Said?</title>
      <link>http://liuxueyang.github.io/posts/hdu-1039-easier-done-than-said/</link>
      <pubDate>Tue, 12 Mar 2013 14:32:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1039-easier-done-than-said/</guid>
      <description>Easier Done Than Said?
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 5021 Accepted Submission(s): 2535</description>
    </item>
    
    <item>
      <title>hdu 1113 Word Amalgamation</title>
      <link>http://liuxueyang.github.io/posts/hdu-1113-word-amalgamation/</link>
      <pubDate>Tue, 12 Mar 2013 14:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1113-word-amalgamation/</guid>
      <description>Word Amalgamation
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 1834 Accepted Submission(s): 854</description>
    </item>
    
    <item>
      <title>CF 281A Word Capitalization</title>
      <link>http://liuxueyang.github.io/posts/cf-281a-word-capitalization/</link>
      <pubDate>Mon, 11 Mar 2013 20:34:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/cf-281a-word-capitalization/</guid>
      <description>A. Word Capitalization time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output</description>
    </item>
    
    <item>
      <title>CF 142B T-primes</title>
      <link>http://liuxueyang.github.io/posts/cf-142b-t-primes/</link>
      <pubDate>Sun, 10 Mar 2013 16:36:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/cf-142b-t-primes/</guid>
      <description>B. T-primes time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output</description>
    </item>
    
    <item>
      <title>CF 230A Dragons</title>
      <link>http://liuxueyang.github.io/posts/cf-230a-dragons/</link>
      <pubDate>Sun, 10 Mar 2013 16:30:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/cf-230a-dragons/</guid>
      <description>C - Dragons Time Limit:2000MS Memory Limit:262144KB 64bit IO Format:%I64d &amp;amp; %I64u Submit Status Practice CodeForces 230A</description>
    </item>
    
    <item>
      <title>CF 231A Team</title>
      <link>http://liuxueyang.github.io/posts/cf-231a-team/</link>
      <pubDate>Sun, 10 Mar 2013 16:28:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/cf-231a-team/</guid>
      <description>A - Team Time Limit:2000MS Memory Limit:262144KB 64bit IO Format:%I64d &amp;amp; %I64u Submit Status Practice CodeForces 231A</description>
    </item>
    
    <item>
      <title>hdu4484 Hailstone HOTPO ——水题</title>
      <link>http://liuxueyang.github.io/posts/hdu4484-hailstone-hotpo-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Sun, 10 Mar 2013 16:21:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu4484-hailstone-hotpo-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=4484 题目思路： 直接模拟即可
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int cal(int n) { int Max = n; while (n!</description>
    </item>
    
    <item>
      <title>Casting</title>
      <link>http://liuxueyang.github.io/posts/casting/</link>
      <pubDate>Sun, 10 Mar 2013 16:16:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/casting/</guid>
      <description>#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; char a[10000000+10]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif int t; scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); while (t--){ int s, b; scanf(&amp;quot;%d%d%s&amp;quot;, &amp;amp;s, &amp;amp;b, a); int len = strlen(a), po = 1, temp = 0; for (int i = len-1; i &amp;gt;= 0; --i){ temp += (a[i]-&#39;0&#39;) * po; temp %= (b-1); } printf(&amp;quot;%d %d\n&amp;quot;, s, temp); } return 0; }  求在某个进制的数字的余数，没卡。</description>
    </item>
    
    <item>
      <title>Mystery</title>
      <link>http://liuxueyang.github.io/posts/mystery/</link>
      <pubDate>Sun, 10 Mar 2013 16:14:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/mystery/</guid>
      <description>#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; char a[200]; int b[800]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif int t; scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); while (t--){ int s; scanf(&amp;quot;%d&amp;quot;, &amp;amp;s); getchar(); gets(a); int n; scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); for (int i = 0; i &amp;lt; n; ++i) scanf(&amp;quot;%d&amp;quot;, b+i); printf(&amp;quot;%d &amp;quot;, s); int po = 0, len = strlen(a); for (int i = 0; i &amp;lt; n; ++i) { po = po + b[i]; if (po &amp;gt;= len) po = po % len; else if (po &amp;lt; 0) po = (po + len); printf(&amp;quot;%c&amp;quot;, a[po]); } printf(&amp;quot;\n&amp;quot;); } return 0; }  题目不难，就是卡了很久，最后才发现，原来是输入的文件里面写错了，多打了一个空格……次奥……</description>
    </item>
    
    <item>
      <title>poj1579 Function Run Fun</title>
      <link>http://liuxueyang.github.io/posts/poj1579-function-run-fun/</link>
      <pubDate>Fri, 08 Mar 2013 13:38:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1579-function-run-fun/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int ww[22][22][22]; int w(int a, int b, int c){ if (a &amp;lt;= 0 || b &amp;lt;= 0 || c &amp;lt;= 0) return 1; if (a &amp;gt; 20 || b &amp;gt; 20 || c &amp;gt; 20) return w(20, 20, 20); if (ww[a][b][c] &amp;gt; 0) return ww[a][b][c]; if (a &amp;lt; b &amp;amp;&amp;amp; b &amp;lt; c) return ww[a][b][c] = w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c); else return ww[a][b][c] = w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1); } int main(void){ int a, b, c; #ifndef ONLINE_JUDGE freopen(&amp;quot;poj1759.</description>
    </item>
    
    <item>
      <title>poj 2528 Mayor&#39;s posters</title>
      <link>http://liuxueyang.github.io/posts/poj-2528-mayors-posters/</link>
      <pubDate>Tue, 05 Mar 2013 15:40:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-2528-mayors-posters/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 const int maxn = 111111; int li[maxn], ri[maxn], x[maxn*3], col[maxn&amp;lt;&amp;lt;4], cnt; bool hash[maxn]; void PushDown(int rt){ if (col[rt] !</description>
    </item>
    
    <item>
      <title>poj 3468 A Simple Problem with Integers</title>
      <link>http://liuxueyang.github.io/posts/poj-3468-a-simple-problem-with-integers/</link>
      <pubDate>Mon, 04 Mar 2013 19:14:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-3468-a-simple-problem-with-integers/</guid>
      <description>A Simple Problem with Integers Time Limit: 5000MS Memory Limit: 131072K Total Submissions:40260 Accepted: 11693 Case Time Limit: 2000MS</description>
    </item>
    
    <item>
      <title>hdu 1698 Just a Hook</title>
      <link>http://liuxueyang.github.io/posts/hdu-1698-just-a-hook/</link>
      <pubDate>Mon, 04 Mar 2013 01:36:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1698-just-a-hook/</guid>
      <description>Just a Hook
Time Limit: 4000&amp;frasl;2000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 10792 Accepted Submission(s): 5328</description>
    </item>
    
    <item>
      <title>poj 2828 Buy Tickets</title>
      <link>http://liuxueyang.github.io/posts/poj-2828-buy-tickets/</link>
      <pubDate>Sat, 02 Mar 2013 21:01:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-2828-buy-tickets/</guid>
      <description>Description Input Output Sample Input Sample Output 这道题目想法很重要，先建树，每个节点表示这个区间内的空的位置的数量，然后，从后往前读，Pos的值表示这个人前面有多少个空位，之所以从后往前读，是因为这样每个人的位置是确定的，以后就不用移动了，以后直接在树里面查找空位就可以了。 具体实现见代码：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 const int maxn = 222222; int tree[maxn&amp;lt;&amp;lt;2], val[maxn], pos[maxn], ans[maxn]; int id; void build(int l, int r, int rt){ tree[rt] = r - l + 1; if (l == r) {return;} int m = (l + r) &amp;gt;&amp;gt; 1; build(lson); build(rson); } void update(int p, int l, int r, int rt){ tree[rt]--; if (l == r){id = l-1; return;} int m = (l + r) &amp;gt;&amp;gt; 1; if (tree[rt&amp;lt;&amp;lt;1] &amp;gt;= p) update(p, lson); else {p -= tree[rt&amp;lt;&amp;lt;1]; update(p, rson);} } int main(void){ int n; #ifndef ONLINE_JUDGE freopen(&amp;quot;poj2828.</description>
    </item>
    
    <item>
      <title>hdu 2795 Billboard</title>
      <link>http://liuxueyang.github.io/posts/hdu-2795-billboard/</link>
      <pubDate>Sat, 02 Mar 2013 19:25:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-2795-billboard/</guid>
      <description>Billboard
Time Limit: 20000&amp;frasl;8000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 5912 Accepted Submission(s): 2682</description>
    </item>
    
    <item>
      <title>hdu 1394 Minimum Inversion Number</title>
      <link>http://liuxueyang.github.io/posts/hdu-1394-minimum-inversion-number/</link>
      <pubDate>Sat, 02 Mar 2013 18:00:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1394-minimum-inversion-number/</guid>
      <description>Minimum Inversion Number
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 5892 Accepted Submission(s): 3587</description>
    </item>
    
    <item>
      <title>poj 2945 Find the Clones</title>
      <link>http://liuxueyang.github.io/posts/poj-2945-find-the-clones/</link>
      <pubDate>Wed, 27 Feb 2013 23:50:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-2945-find-the-clones/</guid>
      <description>Find the Clones Time Limit: 5000MS Memory Limit: 65536K Total Submissions: 6265 Accepted: 2328</description>
    </item>
    
    <item>
      <title>poj 1056 IMMEDIATE DECODABILITY</title>
      <link>http://liuxueyang.github.io/posts/poj-1056-immediate-decodability/</link>
      <pubDate>Wed, 27 Feb 2013 19:05:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-1056-immediate-decodability/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; const int sonnum = 2, base = &#39;0&#39;; struct Trie { int num; bool terminal; Trie *son[sonnum]; }; Trie *NewTrie() { Trie *temp = new Trie; temp-&amp;gt;num = 1; temp-&amp;gt;terminal = false; for (int i = 0; i &amp;lt; sonnum; ++i) temp-&amp;gt;son[i] = NULL; return temp; } bool Insert(Trie *pnt, char *s, int len) { Trie *temp = pnt; bool mrk = true; for (int i = 0; i &amp;lt; len; ++i) { if (temp-&amp;gt;son[s[i]-base] == NULL) temp-&amp;gt;son[s[i]-base] = NewTrie(); else { temp-&amp;gt;son[s[i]-base]-&amp;gt;num++; if (temp-&amp;gt;son[s[i]-base]-&amp;gt;terminal == true) mrk = false; } temp = temp-&amp;gt;son[s[i]-base]; } temp-&amp;gt;terminal = true; return mrk; } int main(void) { Trie *tree; char a[20]; int cnt = 1; #ifndef ONLINE_JUDGE freopen(&amp;quot;poj2056.</description>
    </item>
    
    <item>
      <title>poj 2503 Babelfish</title>
      <link>http://liuxueyang.github.io/posts/poj-2503-babelfish/</link>
      <pubDate>Wed, 27 Feb 2013 00:28:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-2503-babelfish/</guid>
      <description>Babelfish Time Limit: 3000MS Memory Limit: 65536K Total Submissions: 26498 Accepted: 11378</description>
    </item>
    
    <item>
      <title>poj 2001 Shortest Prefixes ——字典树入门</title>
      <link>http://liuxueyang.github.io/posts/poj-2001-shortest-prefixes-%E5%AD%97%E5%85%B8%E6%A0%91%E5%85%A5%E9%97%A8/</link>
      <pubDate>Tue, 26 Feb 2013 23:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-2001-shortest-prefixes-%E5%AD%97%E5%85%B8%E6%A0%91%E5%85%A5%E9%97%A8/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; char a[1000+10][25]; const int sonnum = 26, base = &#39;a&#39;; struct Trie { int num; bool terminal; struct Trie *son[sonnum]; }; Trie *NewTrie() { Trie *temp = new Trie; temp-&amp;gt;num = 1; temp-&amp;gt;terminal = false; for (int i = 0; i &amp;lt; sonnum; ++i) temp-&amp;gt;son[i] = NULL; return temp; } void Insert(Trie *pnt, char *s, int len) { Trie *temp = pnt; for (int i = 0; i &amp;lt; len; ++i) { if (temp-&amp;gt;son[s[i]-base] == NULL) temp-&amp;gt;son[s[i]-base] = NewTrie(); else temp-&amp;gt;son[s[i]-base]-&amp;gt;num++; temp = temp-&amp;gt;son[s[i]-base]; } temp-&amp;gt;terminal = true; } Trie *Find(Trie *pnt, char *s, int len) { Trie *temp = pnt; for (int i = 0; i &amp;lt; len; ++i) { if (temp-&amp;gt;son[s[i]-base]-&amp;gt;num == 1) { printf(&amp;quot;%c&amp;quot;, s[i]); return temp; } printf(&amp;quot;%c&amp;quot;, s[i]); temp = temp-&amp;gt;son[s[i]-base]; } return temp; } int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;poj2001.</description>
    </item>
    
    <item>
      <title>CF271 C. Secret</title>
      <link>http://liuxueyang.github.io/posts/cf271-c.-secret/</link>
      <pubDate>Fri, 15 Feb 2013 17:14:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/cf271-c.-secret/</guid>
      <description>C. Secret time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output</description>
    </item>
    
    <item>
      <title>CF271 A. Beautiful Year</title>
      <link>http://liuxueyang.github.io/posts/cf271-a.-beautiful-year/</link>
      <pubDate>Fri, 15 Feb 2013 16:10:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/cf271-a.-beautiful-year/</guid>
      <description>A. Beautiful Year time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output</description>
    </item>
    
    <item>
      <title>CF271 B. Prime Matrix</title>
      <link>http://liuxueyang.github.io/posts/cf271-b.-prime-matrix/</link>
      <pubDate>Fri, 15 Feb 2013 16:06:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/cf271-b.-prime-matrix/</guid>
      <description>B. Prime Matrix time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output</description>
    </item>
    
    <item>
      <title>poj 2752</title>
      <link>http://liuxueyang.github.io/posts/poj-2752/</link>
      <pubDate>Wed, 30 Jan 2013 20:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-2752/</guid>
      <description>题目链接：http://poj.org/problem?id=2752 #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #define N 400000 using namespace std; char s[N]; int next[N], a[N]; void getnext(char *p, int *next) { int i = 0, j = -1, len = strlen(p); next[0] = -1; while (i &amp;lt; len) { if (j == -1 || p[j] == p[i]) { i++; j++; next[i] = j; } else j = next[j]; } } int main(void) { freopen(&amp;quot;poj2752.</description>
    </item>
    
    <item>
      <title>CF266 B. Queue at the School</title>
      <link>http://liuxueyang.github.io/posts/cf266-b.-queue-at-the-school/</link>
      <pubDate>Wed, 23 Jan 2013 10:23:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/cf266-b.-queue-at-the-school/</guid>
      <description>B. Queue at the School time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output</description>
    </item>
    
    <item>
      <title>CF266 A. Stones on the Table</title>
      <link>http://liuxueyang.github.io/posts/cf266-a.-stones-on-the-table/</link>
      <pubDate>Wed, 23 Jan 2013 10:19:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/cf266-a.-stones-on-the-table/</guid>
      <description>A. Stones on the Table time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output</description>
    </item>
    
    <item>
      <title>hdu 1046</title>
      <link>http://liuxueyang.github.io/posts/hdu-1046/</link>
      <pubDate>Tue, 22 Jan 2013 09:30:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1046/</guid>
      <description>Gridland
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 2455 Accepted Submission(s): 1168</description>
    </item>
    
    <item>
      <title>hdu 1048</title>
      <link>http://liuxueyang.github.io/posts/hdu-1048/</link>
      <pubDate>Tue, 22 Jan 2013 09:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1048/</guid>
      <description>The Hardest Problem Ever
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 11459 Accepted Submission(s): 5165</description>
    </item>
    
    <item>
      <title>hdu 1049</title>
      <link>http://liuxueyang.github.io/posts/hdu-1049/</link>
      <pubDate>Tue, 22 Jan 2013 09:28:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1049/</guid>
      <description>Climbing Worm
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 8745 Accepted Submission(s): 5659</description>
    </item>
    
    <item>
      <title>hdu 1064</title>
      <link>http://liuxueyang.github.io/posts/hdu-1064/</link>
      <pubDate>Tue, 22 Jan 2013 09:27:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1064/</guid>
      <description>Financial Management
Time Limit: 400&amp;frasl;200 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 6666 Accepted Submission(s): 4157</description>
    </item>
    
    <item>
      <title>hdu 1144</title>
      <link>http://liuxueyang.github.io/posts/hdu-1144/</link>
      <pubDate>Tue, 22 Jan 2013 09:26:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1144/</guid>
      <description>Prerequisites?
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 634 Accepted Submission(s): 401</description>
    </item>
    
    <item>
      <title>hdu 1076</title>
      <link>http://liuxueyang.github.io/posts/hdu-1076/</link>
      <pubDate>Tue, 22 Jan 2013 09:24:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1076/</guid>
      <description>An Easy Task
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 10133 Accepted Submission(s): 6291</description>
    </item>
    
    <item>
      <title>hdu 1196</title>
      <link>http://liuxueyang.github.io/posts/hdu-1196/</link>
      <pubDate>Tue, 22 Jan 2013 09:23:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1196/</guid>
      <description>Lowest Bit
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 5440 Accepted Submission(s): 3963</description>
    </item>
    
    <item>
      <title>hdu 1201</title>
      <link>http://liuxueyang.github.io/posts/hdu-1201/</link>
      <pubDate>Tue, 22 Jan 2013 09:22:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1201/</guid>
      <description>18岁生日
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 12363 Accepted Submission(s): 3885</description>
    </item>
    
    <item>
      <title>CodeForce 264 A. Escape from Stones</title>
      <link>http://liuxueyang.github.io/posts/codeforce-264-a.-escape-from-stones/</link>
      <pubDate>Mon, 21 Jan 2013 10:53:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforce-264-a.-escape-from-stones/</guid>
      <description>A. Escape from Stones time limit per test 2 seconds memory limit per test 256 megabytes input standard input output standard output</description>
    </item>
    
    <item>
      <title>hdu 1062 Text Reverse</title>
      <link>http://liuxueyang.github.io/posts/hdu-1062-text-reverse/</link>
      <pubDate>Fri, 18 Jan 2013 02:12:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1062-text-reverse/</guid>
      <description>Text Reverse
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 10835 Accepted Submission(s): 4104</description>
    </item>
    
    <item>
      <title>A. Roma and Lucky Numbers</title>
      <link>http://liuxueyang.github.io/posts/a.-roma-and-lucky-numbers/</link>
      <pubDate>Tue, 15 Jan 2013 10:56:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/a.-roma-and-lucky-numbers/</guid>
      <description>A. Roma and Lucky Numbers time limit per test 1 second memory limit per test 256 megabytes input standard input output standard output</description>
    </item>
    
    <item>
      <title>hdu 1999 不可摸数</title>
      <link>http://liuxueyang.github.io/posts/hdu-1999-%E4%B8%8D%E5%8F%AF%E6%91%B8%E6%95%B0/</link>
      <pubDate>Fri, 11 Jan 2013 11:15:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1999-%E4%B8%8D%E5%8F%AF%E6%91%B8%E6%95%B0/</guid>
      <description>Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others)Total Submission(s): 5821 Accepted Submission(s): 1524 数学题，输入n，判断n是不是不可摸数。 设t = n - 1。 如果t是素数的话，那么要使得S(m) = n，只要m = t * t即可，此时m的真因子有：1, t。则S(m) = t + 1 = n，也就是说n可摸 如果t不是素数，但是t可以表示成两个素数的和的话，设 i 是素数，并且t = i + (t-i)，其中 t-i 也是素数。那么要使得S(m) = n，只要m = i * (t - i) 即可，此时，m 的真因子有：1, i , t - i 。则S(m) = 1 + i + t - i = t + 1 = n，也就是说 n 可摸 （这里注意：t - i !</description>
    </item>
    
    <item>
      <title>ftime使用</title>
      <link>http://liuxueyang.github.io/posts/ftime%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 23 Dec 2012 21:34:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/ftime%E4%BD%BF%E7%94%A8/</guid>
      <description>t2.time获取秒，t2.millitm获取毫秒。详见网站： http://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/timeb.h.html </description>
    </item>
    
    <item>
      <title>vim 缩进技巧</title>
      <link>http://liuxueyang.github.io/posts/vim-%E7%BC%A9%E8%BF%9B%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Sun, 16 Dec 2012 13:05:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/vim-%E7%BC%A9%E8%BF%9B%E6%8A%80%E5%B7%A7/</guid>
      <description>缩进：n, m &amp;gt; 表示从n行到m行缩进　缩出用 &amp;gt; n &amp;gt; 表示从当前行起,再往下数n行，缩进 缩出用 &amp;gt; n ==表示从当前行起，再往下数n-1行，自动排版 自动排版：G=gg</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.3.3 二进制生成子集</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.3.3-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%94%9F%E6%88%90%E5%AD%90%E9%9B%86/</link>
      <pubDate>Sat, 15 Dec 2012 14:30:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.3.3-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%94%9F%E6%88%90%E5%AD%90%E9%9B%86/</guid>
      <description>多简洁的位运算！</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.3.2 位向量生成子集</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.3.2-%E4%BD%8D%E5%90%91%E9%87%8F%E7%94%9F%E6%88%90%E5%AD%90%E9%9B%86/</link>
      <pubDate>Sat, 15 Dec 2012 13:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.3.2-%E4%BD%8D%E5%90%91%E9%87%8F%E7%94%9F%E6%88%90%E5%AD%90%E9%9B%86/</guid>
      <description>比增量构造要复杂，但是想法简洁</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.3.1 增量构造生成子集</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.3.1-%E5%A2%9E%E9%87%8F%E6%9E%84%E9%80%A0%E7%94%9F%E6%88%90%E5%AD%90%E9%9B%86/</link>
      <pubDate>Sat, 15 Dec 2012 13:06:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.3.1-%E5%A2%9E%E9%87%8F%E6%9E%84%E9%80%A0%E7%94%9F%E6%88%90%E5%AD%90%E9%9B%86/</guid>
      <description>体会递归的想法，其实挺巧妙的。</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.2.4 生成的排列，STL实现</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.2.4-%E7%94%9F%E6%88%90%E7%9A%84%E6%8E%92%E5%88%97stl%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 15 Dec 2012 12:04:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.2.4-%E7%94%9F%E6%88%90%E7%9A%84%E6%8E%92%E5%88%97stl%E5%AE%9E%E7%8E%B0/</guid>
      <description>实现很简洁，强大的STL</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.2.2 生成可重集的排列</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.2.2-%E7%94%9F%E6%88%90%E5%8F%AF%E9%87%8D%E9%9B%86%E7%9A%84%E6%8E%92%E5%88%97/</link>
      <pubDate>Sat, 15 Dec 2012 11:41:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.2.2-%E7%94%9F%E6%88%90%E5%8F%AF%E9%87%8D%E9%9B%86%E7%9A%84%E6%8E%92%E5%88%97/</guid>
      <description>先把数列排序，再修改以前的程序。
注意体会for里面的条件</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.2.1 生成1到N的排列</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.2.1-%E7%94%9F%E6%88%901%E5%88%B0n%E7%9A%84%E6%8E%92%E5%88%97/</link>
      <pubDate>Sat, 15 Dec 2012 10:08:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.2.1-%E7%94%9F%E6%88%901%E5%88%B0n%E7%9A%84%E6%8E%92%E5%88%97/</guid>
      <description>注意多体会递归的想法</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.7.4 双基回文数</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.7.4-%E5%8F%8C%E5%9F%BA%E5%9B%9E%E6%96%87%E6%95%B0/</link>
      <pubDate>Fri, 14 Dec 2012 20:57:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.7.4-%E5%8F%8C%E5%9F%BA%E5%9B%9E%E6%96%87%E6%95%B0/</guid>
      <description>双基回文数很多，所以可以暴力。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;iomanip&amp;gt; using namespace std; int trans(int n, int base) { int a[100], i = 1; a[0]=n%base; n/=base; while (n) { a[i++]=n%base; n/=base; } int len = i; int mrk = 1; for (i = 0; i &amp;lt; len; ++i) { if (a[i] !</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.7.3 分数拆分</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.7.3-%E5%88%86%E6%95%B0%E6%8B%86%E5%88%86/</link>
      <pubDate>Fri, 14 Dec 2012 20:00:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.7.3-%E5%88%86%E6%95%B0%E6%8B%86%E5%88%86/</guid>
      <description>找出x,y的范围，枚举就可以了
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; int main(void) { int k; #ifndef ONLINE_JUDGE freopen(&amp;quot;in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;k)) { for (int i = k+1; i &amp;lt;= 2*k; ++i) { if ((k*i)/(i-k)%1==0) printf(&amp;quot;1/%d = 1/%d + 1/%d\n&amp;quot;, k, (k*i)/(i-k), i); } } return 0; }   </description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.7.2 最大乘积</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.7.2-%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</link>
      <pubDate>Fri, 14 Dec 2012 19:40:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.7.2-%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/</guid>
      <description>因为范围只有18个数字，所以可以枚举起点和终点。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; long long int f(int a[], int start, int end) { long long int sum = 1; for (int i = start; i &amp;lt; end + 1; ++i) { sum *= a[i]; } return sum; } int main(void) { int n, a[20]; #ifndef ONLINE_JUDGE freopen(&amp;quot;in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { for (int i = 0; i &amp;lt; n; ++i) scanf(&amp;quot;%d&amp;quot;, &amp;amp;a[i]); long long int sum=-1; for (int i = 0; i &amp;lt; n; ++i) { for (int j = i; j &amp;lt; n; ++j) { if (f(a, i, j) &amp;gt; sum) sum = f(a, i, j); } } printf(&amp;quot;%lld\n&amp;quot;, sum); } return 0; }  根据数据范围，估算一下能不能暴力</description>
    </item>
    
    <item>
      <title>入门经典 第七章 7.7.1 除法</title>
      <link>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.7.1-%E9%99%A4%E6%B3%95/</link>
      <pubDate>Fri, 14 Dec 2012 19:21:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-%E7%AC%AC%E4%B8%83%E7%AB%A0-7.7.1-%E9%99%A4%E6%B3%95/</guid>
      <description>这道题目还是卡了很久，原因是要考虑0是不是出现过，要标记。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;math.</description>
    </item>
    
    <item>
      <title>gdb调试方法简要总结</title>
      <link>http://liuxueyang.github.io/posts/gdb%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 14 Dec 2012 09:02:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/gdb%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93/</guid>
      <description>在编译的时候加上 -g 选项，如： g++ -Wall -g test.cpp -o test 开始调试： gdb test 基本命令： l 显示代码，是list的简写 b 插入断点，是break的简写 n 下一步，是next的简写 s 单步运行，是stepinto的简写，可以进入函数内部 p 打印，是print的简写，可以打印变量 disp 在每一步运行中显示要求的变量，是display的简写 d disp 编号 删除指定编号的display，d是delete的简写 dis disp 编号 禁止指定编号的display，dis是disable的简写 en disp 编号 恢复指定编号的display，en是enable的简写 u 行号 运行到指定行号</description>
    </item>
    
    <item>
      <title>重载运算符 [] 实现寻找数组的第K大的元素</title>
      <link>http://liuxueyang.github.io/posts/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6--%E5%AE%9E%E7%8E%B0%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Fri, 14 Dec 2012 08:52:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6--%E5%AE%9E%E7%8E%B0%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>方法是利用快排的想法，效率O(N)
/* * use the method of quicksort. The time efficiency is * O(N).</description>
    </item>
    
    <item>
      <title>创建一个类，重载运算符实现多项式的加，减，乘运算</title>
      <link>http://liuxueyang.github.io/posts/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E8%BF%90%E7%AE%97/</link>
      <pubDate>Fri, 14 Dec 2012 08:44:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B1%BB%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E8%BF%90%E7%AE%97/</guid>
      <description>唉，我太弱了，这么个简单的东西，还是用数组写的，却因为各种错误，弄了一个晚上，C++还得好好学啊，各种语法，要弄清楚。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; class Polynomial { public: Polynomial(int = 0); friend istream &amp;amp; operator &amp;gt;&amp;gt; (istream &amp;amp; input, Polynomial &amp;amp; pl); friend ostream &amp;amp; operator &amp;lt;&amp;lt; (ostream &amp;amp; output, Polynomial &amp;amp; pl); Polynomial &amp;amp; operator += (Polynomial &amp;amp; add); Polynomial &amp;amp; operator -= (Polynomial &amp;amp; add); Polynomial &amp;amp; operator - (Polynomial &amp;amp; add); Polynomial &amp;amp; operator * (Polynomial &amp;amp;); Polynomial &amp;amp; operator + (Polynomial &amp;amp; add); Polynomial &amp;amp; operator *= (Polynomial &amp;amp;); Polynomial &amp;amp; operator = (Polynomial &amp;amp; right); Polynomial &amp;amp; test(Polynomial &amp;amp; right); private: int *a; int size, num; }; Polynomial &amp;amp; Polynomial::operator *= (Polynomial &amp;amp; mu) { Polynomial b, c; c = *this; b = *this; for (int j=0,r=0; j&amp;lt;b.</description>
    </item>
    
    <item>
      <title>Hanoi</title>
      <link>http://liuxueyang.github.io/posts/hanoi/</link>
      <pubDate>Wed, 12 Dec 2012 09:19:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hanoi/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; int step = 1; void move(char from, char to) { printf(&amp;quot;%d: %c-&amp;gt;%c\n&amp;quot;, step++, from, to); } void h(int n, char from, char via, char to) { if (n == 1) {move(from, to); return;} h(n-1, from, to, via); move(from, to); h(n-1, via, from, to); } int main(void) { int n; while (cin &amp;gt;&amp;gt; n) { step = 1; h(n, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;); } return 0; }  挺简单的一个Hanoi程序</description>
    </item>
    
    <item>
      <title>tips</title>
      <link>http://liuxueyang.github.io/posts/tips/</link>
      <pubDate>Mon, 10 Dec 2012 13:35:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/tips/</guid>
      <description>其实，一天过完之后，你真应该问问自己，今天自己干嘛了？还记得昨天你干了什么吗？前天呢？ 如果你记不起来，那你多半是在混日子。</description>
    </item>
    
    <item>
      <title>数组名和指针相同吗？</title>
      <link>http://liuxueyang.github.io/posts/%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%90%8C%E5%90%97/</link>
      <pubDate>Tue, 04 Dec 2012 19:13:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%8C%87%E9%92%88%E7%9B%B8%E5%90%8C%E5%90%97/</guid>
      <description>/* 数组名和指针相同吗？ */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; int a[][3] = {{1, 2, 3}, {1, 2, 3}, {4, 5, 6}, {3, 4, 5}}; int sizef(int b[][3]) { cout &amp;lt;&amp;lt; sizeof(b) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; sizeof(b[0]) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; sizeof(b)/sizeof(b[0]) &amp;lt;&amp;lt; endl; } int main(void) { // int a[][3] = {{1, 2, 3}, {1, 2, 3}, {4, 5, 6}, {3, 4, 5}}; cout &amp;lt;&amp;lt; sizeof(a) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; sizeof(a[0]) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; sizeof(a)/sizeof(a[0]) &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;quot;***********&amp;quot; &amp;lt;&amp;lt; endl; sizef(a); // cout &amp;lt;&amp;lt; sizef(a) &amp;lt;&amp;lt; endl; system(&amp;quot;pause&amp;quot;); return 0; }  上面的程序的结果是： 48 12 4</description>
    </item>
    
    <item>
      <title>zoj 2110 Tempter of the Bone</title>
      <link>http://liuxueyang.github.io/posts/zoj-2110-tempter-of-the-bone/</link>
      <pubDate>Thu, 29 Nov 2012 14:10:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-2110-tempter-of-the-bone/</guid>
      <description>The doggie found a bone in an ancient maze, which fascinated him a lot.</description>
    </item>
    
    <item>
      <title>Erlang_3</title>
      <link>http://liuxueyang.github.io/posts/erlang_3/</link>
      <pubDate>Tue, 27 Nov 2012 15:45:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/erlang_3/</guid>
      <description>计算阶乘两种写法：
-module(continue). -export([factor/1]). factor(0) -&amp;gt; 1; factor(N) -&amp;gt; N * factor(N - 1).</description>
    </item>
    
    <item>
      <title>Erlang_2</title>
      <link>http://liuxueyang.github.io/posts/erlang_2/</link>
      <pubDate>Tue, 27 Nov 2012 15:35:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/erlang_2/</guid>
      <description>1.函数 举个例子：判断一个数字是奇数还是偶数
-module(rev). -export([even/1]). even(Value) -&amp;gt; if Value rem 2 == 1 -&amp;gt; odd; Value rem 2 == 0 -&amp;gt; even end.</description>
    </item>
    
    <item>
      <title>bash 改为 vim 输入模式</title>
      <link>http://liuxueyang.github.io/posts/bash-%E6%94%B9%E4%B8%BA-vim-%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 26 Nov 2012 01:16:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/bash-%E6%94%B9%E4%B8%BA-vim-%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>打开文件：vim ~/.bashrc 加上这条语句：set -o vi &amp;gt;&amp;gt; ~/.bashrc</description>
    </item>
    
    <item>
      <title>Erlang_1</title>
      <link>http://liuxueyang.github.io/posts/erlang_1/</link>
      <pubDate>Sat, 24 Nov 2012 19:56:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/erlang_1/</guid>
      <description>1.在终端运行的时候末尾要输入 . 号 2.数学运算符：
 加法 正号 减法 负号 乘法 / 浮点除法 div 整数除法 rem 整数取余 3.</description>
    </item>
    
    <item>
      <title>hdu 1161 Eddy&#39;s mistakes</title>
      <link>http://liuxueyang.github.io/posts/hdu-1161-eddys-mistakes/</link>
      <pubDate>Fri, 23 Nov 2012 18:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1161-eddys-mistakes/</guid>
      <description>Eddy&amp;rsquo;s mistakes
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 5189 Accepted Submission(s): 2956</description>
    </item>
    
    <item>
      <title>hdu 1166 敌兵布阵</title>
      <link>http://liuxueyang.github.io/posts/hdu-1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5/</link>
      <pubDate>Fri, 23 Nov 2012 18:46:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5/</guid>
      <description>敌兵布阵
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 22041 Accepted Submission(s): 9654</description>
    </item>
    
    <item>
      <title>hdu1754 I Hate It ——线段数入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu1754-i-hate-it-%E7%BA%BF%E6%AE%B5%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Fri, 23 Nov 2012 18:42:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1754-i-hate-it-%E7%BA%BF%E6%AE%B5%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1754
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #define maxn 200000&amp;lt;&amp;lt;2 //#define max(a,b) ((a)&amp;gt;(b)?</description>
    </item>
    
    <item>
      <title>ubuntu 12.04 安装之后的配置问题</title>
      <link>http://liuxueyang.github.io/posts/ubuntu-12.04-%E5%AE%89%E8%A3%85%E4%B9%8B%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 20 Nov 2012 12:07:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/ubuntu-12.04-%E5%AE%89%E8%A3%85%E4%B9%8B%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</guid>
      <description>首先换软件源。 如果安装vim的时候出现问题，比如： Reading package lists&amp;hellip; DoneBuilding dependency tree Reading state information&amp;hellip; DonePackage vim is not available, but is referred to by another package.</description>
    </item>
    
    <item>
      <title>ubuntu12.04 iNodeClient 连校园网</title>
      <link>http://liuxueyang.github.io/posts/ubuntu12.04-inodeclient-%E8%BF%9E%E6%A0%A1%E5%9B%AD%E7%BD%91/</link>
      <pubDate>Mon, 12 Nov 2012 22:46:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/ubuntu12.04-inodeclient-%E8%BF%9E%E6%A0%A1%E5%9B%AD%E7%BD%91/</guid>
      <description>百度文库里面有一个文档，叫做”ubuntu_12.04_安装_iNodeClient_教程“，按照那个做，安装上之后然后发现能通过身份验证，但是连不上网，继续执行下面的操作。 sudo chmod -R 777 /home/suruibin/iNodeClient（后面这个路径改成你自己的安装目录）
进入目录 cd iNodeClient 安装：sudo .</description>
    </item>
    
    <item>
      <title>uva 537 - Artificial Intelligence?</title>
      <link>http://liuxueyang.github.io/posts/uva-537---artificial-intelligence/</link>
      <pubDate>Fri, 09 Nov 2012 23:42:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva-537---artificial-intelligence/</guid>
      <description>Physics teachers in high school often think that problems given as text are more demanding than pure computations.</description>
    </item>
    
    <item>
      <title>vim 配置 转载</title>
      <link>http://liuxueyang.github.io/posts/vim-%E9%85%8D%E7%BD%AE-%E8%BD%AC%E8%BD%BD/</link>
      <pubDate>Fri, 09 Nov 2012 08:23:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/vim-%E9%85%8D%E7%BD%AE-%E8%BD%AC%E8%BD%BD/</guid>
      <description>一个比较偷懒的方法是执行一下命令： cd /etc/vim sudo vi vimrc 然后把里面的注释去掉就可以了,但是里面的配置不太全。 原文链接 http://www.oschina.net/code/snippet_103341_9644 linux 平台：</description>
    </item>
    
    <item>
      <title>uva 10010 - Where&#39;s Waldorf?</title>
      <link>http://liuxueyang.github.io/posts/uva-10010---wheres-waldorf/</link>
      <pubDate>Fri, 09 Nov 2012 07:57:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva-10010---wheres-waldorf/</guid>
      <description>Given a m by n grid of letters, ( ), and a list of words, find the location in the grid at which the word can be found.</description>
    </item>
    
    <item>
      <title>uva 253 - Cube painting</title>
      <link>http://liuxueyang.github.io/posts/uva-253---cube-painting/</link>
      <pubDate>Thu, 08 Nov 2012 22:07:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva-253---cube-painting/</guid>
      <description>We have a machine for painting cubes. It is supplied with three different colors: blue, red and green.</description>
    </item>
    
    <item>
      <title>uva 10161 - Ant on a Chessboard</title>
      <link>http://liuxueyang.github.io/posts/uva-10161---ant-on-a-chessboard/</link>
      <pubDate>Thu, 08 Nov 2012 21:13:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva-10161---ant-on-a-chessboard/</guid>
      <description>One day, an ant called Alice came to an M*M chessboard.</description>
    </item>
    
    <item>
      <title>uva 113 - Power of Cryptography</title>
      <link>http://liuxueyang.github.io/posts/uva-113---power-of-cryptography/</link>
      <pubDate>Thu, 08 Nov 2012 00:07:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva-113---power-of-cryptography/</guid>
      <description>Current work in cryptography involves (among other things) large prime numbers and computing powers of numbers modulo functions of these primes.</description>
    </item>
    
    <item>
      <title>uva 621 - Secret Research</title>
      <link>http://liuxueyang.github.io/posts/uva-621---secret-research/</link>
      <pubDate>Wed, 07 Nov 2012 23:32:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva-621---secret-research/</guid>
      <description>At a certain laboratory results of secret research are thoroughly encrypted.</description>
    </item>
    
    <item>
      <title>uva 107 - The Cat in the Hat</title>
      <link>http://liuxueyang.github.io/posts/uva-107---the-cat-in-the-hat/</link>
      <pubDate>Wed, 07 Nov 2012 21:46:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva-107---the-cat-in-the-hat/</guid>
      <description>(An homage to Theodore Seuss Geisel) The Cat in the Hat is a nasty creature,But the striped hat he is wearing has a rather nifty feature.</description>
    </item>
    
    <item>
      <title>uva 10790 - How Many Points of Intersection?</title>
      <link>http://liuxueyang.github.io/posts/uva-10790---how-many-points-of-intersection/</link>
      <pubDate>Wed, 07 Nov 2012 00:12:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva-10790---how-many-points-of-intersection/</guid>
      <description>We have two rows. There are a dots on the top row and b dots on the bottom row.</description>
    </item>
    
    <item>
      <title>uva 11044 Searching for Nessy</title>
      <link>http://liuxueyang.github.io/posts/uva-11044-searching-for-nessy/</link>
      <pubDate>Tue, 06 Nov 2012 23:57:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva-11044-searching-for-nessy/</guid>
      <description>The Loch Ness Monsteris a mysterious and unidentified animal said to inhabit Loch Ness, a large deep freshwater loch near the city of Inverness in northern Scotland.</description>
    </item>
    
    <item>
      <title>uva 573 The Snail</title>
      <link>http://liuxueyang.github.io/posts/uva-573-the-snail/</link>
      <pubDate>Tue, 06 Nov 2012 23:54:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva-573-the-snail/</guid>
      <description>The Snail
A snail is at the bottom of a 6-foot well and wants to climb to the top.</description>
    </item>
    
    <item>
      <title>lost</title>
      <link>http://liuxueyang.github.io/posts/lost/</link>
      <pubDate>Tue, 06 Nov 2012 14:27:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/lost/</guid>
      <description>从今年暑假7月15日开始学ACM到现在已经快4个月了，水平还是那么的水。。。照这样下去，明年的这个时候该是什么样子，，唉。。 从开始到现在走了不少弯路，明显把太多时间花在了做水题上，也没有做多少总结，根本没有去认真学一下正经的算法，其实算法才是最重要的，把算法学好需要很长的时间积累，不是短期内就可以搞定的。以后少做水题，多学算法，针对学习的算法多练习，平均每天做3题比较合适，还有，多总结，经常用的算法多写几遍，熟练，代码要精简。 好好加油吧，再坚持一阵子，虽然不知道以后会变成怎样。 看书要有针对性地看。做ACM，关键是态度，人家做IOI的，不也是高中生吗，人家照样比大学生强。至于队友，LLH明年大四肯定就不做了，这让我颇有压力，希望在大二这一年剩下的时间里面好好做，争取能取得一点成绩，这样也算少留下一点遗憾吧。明年我还要不要继续做下去，再说。也许会，也许不会。 让时间决定。</description>
    </item>
    
    <item>
      <title>转载  ACM训练计划</title>
      <link>http://liuxueyang.github.io/posts/%E8%BD%AC%E8%BD%BD--acm%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92/</link>
      <pubDate>Tue, 06 Nov 2012 12:43:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E8%BD%AC%E8%BD%BD--acm%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92/</guid>
      <description>看完人家的博客，发现任重道远。。。 一位高手对我的建议： 一般要做到50行以内的程序不用调试、100行以内的二分钟内调试成功.acm主要是考算法的，主要时间是花在思考算法上，不是花在写程序与debug上。 下面给个计划你练练： 第一阶段：练经典常用算法，下面的每个算法给我打上十到二十遍，同时自己精简代码，因为太常用，所以要练到写时不用想，10-15分钟内打完，甚至关掉显示器都可以把程序打出来. 1.最短路(Floyd、Dijstra,BellmanFord) 2.最小生成树(先写个prim,kruscal要用并查集，不好写) 3.大数（高精度）加减乘除 4.二分查找. (代码可在五行以内) 5.</description>
    </item>
    
    <item>
      <title>uva10177 (2/3/4)-D Sqr/Rects/Cubes/Boxes?</title>
      <link>http://liuxueyang.github.io/posts/uva10177-2-3-4-d-sqr-rects-cubes-boxes/</link>
      <pubDate>Mon, 05 Nov 2012 19:37:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva10177-2-3-4-d-sqr-rects-cubes-boxes/</guid>
      <description>Problem J (2/3/4)-D Sqr/Rects/Cubes/Boxes? Input: standard input Output: standard output Time Limit: 2 seconds You can see a (4x4) grid below.</description>
    </item>
    
    <item>
      <title>uva 100 The 3n&#43;1 problem</title>
      <link>http://liuxueyang.github.io/posts/uva-100-the-3n&#43;1-problem/</link>
      <pubDate>Mon, 05 Nov 2012 10:48:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva-100-the-3n&#43;1-problem/</guid>
      <description>Problems in Computer Science are often classified as belonging to a certain class of problems (e.</description>
    </item>
    
    <item>
      <title>uva 10038 Jolly Jumpers</title>
      <link>http://liuxueyang.github.io/posts/uva-10038-jolly-jumpers/</link>
      <pubDate>Mon, 05 Nov 2012 10:42:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva-10038-jolly-jumpers/</guid>
      <description>A sequence of n &amp;gt; 0 integers is called a jolly jumper if the absolute values of the difference between successive elements take on all the values 1 through n-1.</description>
    </item>
    
    <item>
      <title>从今天起，好好写博客，好好总结</title>
      <link>http://liuxueyang.github.io/posts/%E4%BB%8E%E4%BB%8A%E5%A4%A9%E8%B5%B7%E5%A5%BD%E5%A5%BD%E5%86%99%E5%8D%9A%E5%AE%A2%E5%A5%BD%E5%A5%BD%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 05 Nov 2012 08:06:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/%E4%BB%8E%E4%BB%8A%E5%A4%A9%E8%B5%B7%E5%A5%BD%E5%A5%BD%E5%86%99%E5%8D%9A%E5%AE%A2%E5%A5%BD%E5%A5%BD%E6%80%BB%E7%BB%93/</guid>
      <description>每天找出一段时间总结一下自己今天学习过的知识，写博客是一个比较好的方法，坚持下去吧。 每天都要有一点进步 ！</description>
    </item>
    
  </channel>
</rss>