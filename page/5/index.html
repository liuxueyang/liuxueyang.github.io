<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.20.1" />
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>黑历史 &middot; liuxueyang</title>

  
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/highlight/sunburst.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://liuxueyang.github.io/touch-icon-144-precomposed.png">
  <link href="http://liuxueyang.github.io/favicon.png" rel="icon">

  
  
  
  <link href="http://liuxueyang.github.io/index.xml" rel="alternate" type="application/rss+xml" title="黑历史 &middot; liuxueyang" />

  <meta name="description" content="This is my Notes">
  <meta name="keywords" content="Notes,Diary">
  
</head>
<body class="theme-base-08">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
        <img src="https://www.gravatar.com/avatar/2e3a2be066049f38f7a3f80eff0a5400?s=200"
             alt="gravatar" title="liuxueyang">
      
      <h1>liuxueyang</h1>
      <p class="lead">THE LAST ONE.</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="http://liuxueyang.github.io/">Blog</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="http://github.com/liuxueyang"><i class="fa fa-github-square fa-3x"></i></a>
      
      
      
      
      
      
      
      
      </li>
    </ul>

    

    <p>Copyright &copy; 2017 <a href="http://liuxueyang.github.io/license/">License</a><br/>
       Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>
  </div>
</div>


<div class="content container">
  <div class="posts">
    
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/07/25/spoj-segment-tree-akvqld03---how-to-handle-the-fans/">spoj, segment tree: AKVQLD03 - How to Handle the Fans</a>
      </h1>
      <span class="post-date">Jul 25, 2016 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/07/25/spoj-segment-tree-akvqld03---how-to-handle-the-fans/#disqus_thread">Comments</a>
      </span>
      
      Problem Link
平常的线段树点更新和区间查询
#include &lt;iostream&gt; #include &lt;string.h&gt; using namespace std; struct SegmentTreeNode { // fields on the node long long sum; void assignLeaf(int value) { sum = value; } void merge(SegmentTreeNode &amp;left, SegmentTreeNode &amp;right) { sum = left.sum + right.sum; } long long getValue() { return sum; } }; template &lt;class T, class V&gt; class SegmentTree { SegmentTreeNode *nodes; int N; public: SegmentTree(T arr[], int N) { this-&gt;N = N; nodes = new SegmentTreeNode[getSegmentTreeSize(N)]; buildTree(arr, 1, 0, N - 1); } ~SegmentTree() { delete[] nodes; } V getValue(int lo, int hi) { SegmentTreeNode result = getValue(1, 0, N - 1, lo, hi); return result.
      <a href="http://liuxueyang.github.io/blog/2016/07/25/spoj-segment-tree-akvqld03---how-to-handle-the-fans/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/07/25/segment-tree-lazy-propagation-codechef-flipping-coins/">segment tree, lazy propagation, codechef: Flipping Coins</a>
      </h1>
      <span class="post-date">Jul 25, 2016 &middot; 3 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/07/25/segment-tree-lazy-propagation-codechef-flipping-coins/#disqus_thread">Comments</a>
      </span>
      
      Problem Link
平常的线段树区间更新、区间查询加上懒惰更新
// 2016/07/24 22:01:19 PM // Sabastian #include &lt;iostream&gt; #include &lt;math.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; using namespace std; typedef long long ll; typedef struct TreeNode { int start, end; ll total; bool lazy; TreeNode() : total(0), lazy(false) {} void merge(TreeNode &amp; left, TreeNode &amp; right) { total = (left.lazy ? left.end - left.start + 1 - left.total : left.total) + (right.lazy ? right.end - right.start + 1 - right.
      <a href="http://liuxueyang.github.io/blog/2016/07/25/segment-tree-lazy-propagation-codechef-flipping-coins/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/07/11/iterm2-%E6%9F%A5%E7%9C%8B%E5%9B%BE%E7%89%87/">iTerm2 查看图片</a>
      </h1>
      <span class="post-date">Jul 11, 2016 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/07/11/iterm2-%E6%9F%A5%E7%9C%8B%E5%9B%BE%E7%89%87/#disqus_thread">Comments</a>
      </span>
      
      首先是，OS X El Capitan的几个截图技巧：
 ⌘ + ⇪ + 3 ：全屏截图，并且把截图保存在桌面。 ⌘ + ⇪ + 4 ：区域截图，可以自由拖动大小，松开触摸板自动保存截图到桌面。 ⌘ + ⇪ + 4 ，然后，单击空格键，可以选定窗口截图。（这么好用的快捷键我很长时间都不知道……） ⌘ + ⇪ + 4，然后用触摸板选定一个矩形区域，然后，按住空格键，再拖动鼠标，就可以发现，矩形区域跟随鼠标移动，但是大小不变。 ⌘ + ⇪ + 4，选定一个矩形区域，然后，按住 ⇪ 键，然后鼠标如果在左右方向移动，那么你可以发现矩形区域高度被锁定；如果在按住 ⇪ 键的同时，鼠标在上下方向移动，那么左右方向被锁定。 ⌘ + ⇪ + 4，选定一个矩形区域，按住 ⇪ 和 ⌥ 键，再拖动鼠标，可以发现，矩形区域在锁定一个方向的基础上，在水平或者数值方向上呈对称性变化。  在终端里面的时候，有时需要查看一下图片到底是不是想要的那一张，然而并不想在打开finder看，所以，这个功能就比较有用了，如图：
更多用法，看这里
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/07/03/poj3320-jessicas-reading-problem/">POJ3320 Jessica&#39;s Reading Problem</a>
      </h1>
      <span class="post-date">Jul 3, 2016 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/07/03/poj3320-jessicas-reading-problem/#disqus_thread">Comments</a>
      </span>
      
      Problem Jessica&rsquo;s Reading Problem
Solution 方法和Subsequence一样，只是增加一个计数的步骤。
Code C++ #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;set&gt; using namespace std; const int MAX_N = 100 * 10000 + 1; int a[MAX_N], n; set&lt;int&gt; idea; map&lt;int, int&gt; num_idea; void solve() { idea.clear(); num_idea.clear(); for (int i = 0; i &lt; n; ++i) { idea.insert(a[i]); } int all_ideas = (int)idea.size(); int s = 0, t = 0, cnt = 0, ans = n + 1; while (true) { while (t &lt; n &amp;&amp; cnt &lt; all_ideas) { if (num_idea[a[t]] == 0) { cnt++; } num_idea[a[t]]++; ++t; } if (cnt &lt; all_ideas) { break; } ans = min(ans, t - s); num_idea[a[s]]--; if (num_idea[a[s]] == 0) { num_idea.
      <a href="http://liuxueyang.github.io/blog/2016/07/03/poj3320-jessicas-reading-problem/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/07/02/poj3061-subsequence/">Poj3061 Subsequence</a>
      </h1>
      <span class="post-date">Jul 2, 2016 &middot; 3 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/07/02/poj3061-subsequence/#disqus_thread">Comments</a>
      </span>
      
      Problem Subsequence
Solution 方法一：O(nlogn)
1. 计算前序和 2. 定起点，二分找不小于S的最小的连续区间和  方法二：O(n)
1. 定起点，线性找不小于S的最小的连续区间和，得到一个终点 2. 把起点向右移动一个单位，把终点在原来的基础上递增，线性找不小于S的最小的连 续区间和。如此反复。  Code 方法一：
C++ #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int N, S; vector&lt;int&gt; a, presum; void solve() { cin &gt;&gt; N &gt;&gt; S; presum.clear(); a.clear(); a.reserve(N); presum.reserve(N + 1); for (int i = 0; i &lt; N; ++i) { int tmp; cin &gt;&gt; tmp; a.push_back(tmp); } // presum[i] means sum of [0, i) elements // j &gt; i, presum[j] - presum[i] means sum of [i, j) elements presum.
      <a href="http://liuxueyang.github.io/blog/2016/07/02/poj3061-subsequence/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/07/01/educational-codeforces-round-10.-d.-nested-segments-c---perl-and-common-lisp-implementation-segment-tree/">Educational Codeforces Round 10. D. Nested Segments: c&#43;&#43;, perl and common lisp implementation, Segment Tree</a>
      </h1>
      <span class="post-date">Jul 1, 2016 &middot; 4 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/07/01/educational-codeforces-round-10.-d.-nested-segments-c---perl-and-common-lisp-implementation-segment-tree/#disqus_thread">Comments</a>
      </span>
      
      Problem Link
Fenwick Tree，它的本质就是把一个序列的和划分成一个个子序列的和。比如一个序列的长 度是10，那么10的二进制是1010，也就是2^1 + 2^3，所以结果就是树里面2和8两个节点的 和。在树里面，节点（n）表示数列里从1到n的元素的和，那么：
 (1) = (1) (2) = (2) (3) = (1) + (2) (4) = (4) (5) = (1) + (4) (6) = (2) + (4)   按照右端点排序，然后把它离散化； 按照左端点倒序排列，从大到小循环，计算右端点在Fenwick Tree里面的presum（也就 是之前插入的比当前右端点小的数量），这个presum就是当前的segment包含的segment 的个数； 把当前右端点插入Fewnwick Tree；  题目要求计算每个端点包含的segment的数量，因为后面要用到排序和离散化，所以可以在 结构体或者类中增加一个域表示它原来在数组中的初始位置。每计算一个presum就可以根据 这个域放到结果数组里面的对应位置。
C++ #include &lt;bits/stdc++.h&gt; using namespace std; struct segment { int x, y, position; }; const int N = 2e5 + 1; int n, fenwick[N]; long long ans[N]; segment S[N]; int cmpx_r(segment a, segment b) { return a.
      <a href="http://liuxueyang.github.io/blog/2016/07/01/educational-codeforces-round-10.-d.-nested-segments-c---perl-and-common-lisp-implementation-segment-tree/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/06/30/binary-search-tree-perl-and-common-lisp-implementation/">Binary Search Tree: Perl and Common Lisp implementation</a>
      </h1>
      <span class="post-date">Jun 30, 2016 &middot; 3 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/06/30/binary-search-tree-perl-and-common-lisp-implementation/#disqus_thread">Comments</a>
      </span>
      
      Perl #!perl use strict; use warnings; use utf8; use 5.014; # insert given value into the proper position. If no tree provided, # use implicit pass by reference aspect of @_ to fill one. sub insert { my($tree, $value) = @_; unless ($tree) { $tree = {}; $tree-&gt;{VALUE} = $value; $tree-&gt;{LEFT} = undef; $tree-&gt;{RIGHT} = undef; $_[0] = $tree; # $_[0] is reference param return; } if ($tree-&gt;{VALUE} &gt; $value) { insert($tree-&gt;{LEFT}, $value) } elsif ($tree-&gt;{VALUE} &lt; $value) { insert($tree-&gt;{RIGHT}, $value) } else { warn &quot;duplicate insert of $value\n&quot; } } sub in_order { my($tree) = @_; return unless $tree; in_order($tree-&gt;{LEFT}); print $tree-&gt;{VALUE}, &quot; &quot;; in_order($tree-&gt;{RIGHT}); } sub pre_order { my($tree) = @_; return unless $tree; print $tree-&gt;{VALUE}, &quot; &quot;; pre_order($tree-&gt;{LEFT}); pre_order($tree-&gt;{RIGHT}); } sub post_order { my($tree) = @_; return unless $tree; post_order($tree-&gt;{LEFT}); post_order($tree-&gt;{RIGHT}); print $tree-&gt;{VALUE}, &quot; &quot;; } sub search { my($tree, $value) = @_; return unless $tree; return $tree if ($tree-&gt;{VALUE} == $value); search ($tree-&gt;{ ($value &lt; $tree-&gt;{VALUE}) ?
      <a href="http://liuxueyang.github.io/blog/2016/06/30/binary-search-tree-perl-and-common-lisp-implementation/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/06/27/lowest-common-ancestor-in-binary-tree-perl-c-and-common-lisp-implementation/">Lowest common ancestor in binary tree: perl, c and common lisp implementation</a>
      </h1>
      <span class="post-date">Jun 27, 2016 &middot; 3 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/06/27/lowest-common-ancestor-in-binary-tree-perl-c-and-common-lisp-implementation/#disqus_thread">Comments</a>
      </span>
      
      Find lowest common ancestor in binary tree. We assume the values in the tree are unique and the two values are always in the tree.
Time complexity O(n), Space complexity O(n)
C: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // Find lowest common ancestor in binary tree. We assume the // values in the tree are unique and the two values are always in // the tree. // Time complexity O(n) // Space complexity O(n) typedef struct Node { int key; struct Node *left, *right; } Node; Node* createNode(int key) { Node * tmp = (Node*)malloc(sizeof(Node)); tmp-&gt;key = key; tmp-&gt;left = tmp-&gt;right = NULL; return tmp; } Node* findLCA(Node* root, int n1, int n2) { if (root == NULL) { return NULL; } if (n1 == root-&gt;key || n2 == root-&gt;key) { return root; } Node* left = findLCA(root-&gt;left, n1, n2); Node* right = findLCA(root-&gt;right, n1, n2); if (left &amp;&amp; right) { return root; } return left ?
      <a href="http://liuxueyang.github.io/blog/2016/06/27/lowest-common-ancestor-in-binary-tree-perl-c-and-common-lisp-implementation/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/06/27/fenwick-tree/">Fenwick Tree</a>
      </h1>
      <span class="post-date">Jun 27, 2016 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/06/27/fenwick-tree/#disqus_thread">Comments</a>
      </span>
      
      Fenwick Tree的原理是，把一个前缀和划分成多个子序列的和，子序列的个数是当前前缀和元素个数的数字二进制表示中的1的个数。
Perl实现：
#!/usr/bin/env perl -n #=============================================================================== # FILE: fenwick_tree.pl # AUTHOR: Sabastian (liuxueyang.github.io), liuxueyang457@gmail.com # ORGANIZATION: Hunan University # CREATED: 2016/06/26 23时27分06秒 #=============================================================================== use strict; use warnings; use utf8; use 5.014; chomp; my @fenwick; my @array = split; unshift @array, 0; unshift @fenwick, 0; sub lowbit { $_[0] &amp; -$_[0]; } sub build_fenwick_tree { for (1..$#array) { for my $j ($_-lowbit($_)+1..$_) { $fenwick[$_] += $array[$j] } } } sub modify_fenwick_tree { # two arguments # 1.
      <a href="http://liuxueyang.github.io/blog/2016/06/27/fenwick-tree/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/06/17/%E6%8E%A8%E8%8D%90rime%E5%B0%8F%E9%B9%A4%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95/">推荐Rime小鹤双拼输入法</a>
      </h1>
      <span class="post-date">Jun 17, 2016 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/06/17/%E6%8E%A8%E8%8D%90rime%E5%B0%8F%E9%B9%A4%E5%8F%8C%E6%8B%BC%E8%BE%93%E5%85%A5%E6%B3%95/#disqus_thread">Comments</a>
      </span>
      
      之前一直没有时间配置我的OS X上的Rime输入法。所以我最近认真配置了一下。首先，推荐 一篇博客： 安装及配置 Mac 上的 Rime 输入法——鼠鬚管 (Squirrel) 这是一篇好博客。然而复制配置文件的时候，还是不能直接复制到编辑器里面，一定要注意 格式！因为这篇博客，我发现了小鹤双拼输入法，然后随便找了一篇关于小鹤双拼的文章： 做少数派中的少数派：双拼输入快速入门 看了一下里面的键位映射图，大概理解了一下，就马上开始用了。也没怎么刻意记忆，不知 道哪个键就看一下那个图，和朋友聊了几句，就可以打字了，虽然很慢，但是可以接受。前 天晚上开始接触，昨天上午就可以愉快地打字了。到现在大概用了一天半的时间，我就可以 用双拼愉快地写这篇博客了。
愚笨如我也能够这么快地接受这个输入法，所以它的学习成本还真的是挺低的。然而打字效 率比原来的全拼却好很多。每个汉字拼音分成声母和韵母，每个声母和韵母只需要一次按键， 不得不说，很适合用汉语拼音打汉字。哈哈，用词根输入英语可能就没这么方便了？:joy: :joy:
另外，我也可以同步Rime的用户资料了。然后再同步到Gitlab的私人仓库里面，完美！另外， 那篇博客也介绍了如何配置小鹤双拼・语句流输入法，这样就可以中英混输并且还带emoji 了！简直Perfect流畅。
时间好快，麦子熟了。
      
      
    </div>
    
    
    
    <ul class="pagination">
        
        <li>
            <a href="/" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
        </li>
        
        <li
        >
        <a href="/page/4/" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
        </li>
        
        <li
        ><a href="/">1</a></li>
        
        <li
        ><a href="/page/2/">2</a></li>
        
        <li
        ><a href="/page/3/">3</a></li>
        
        <li
        ><a href="/page/4/">4</a></li>
        
        <li
        class="active"><a href="/page/5/">5</a></li>
        
        <li
        ><a href="/page/6/">6</a></li>
        
        <li
        ><a href="/page/7/">7</a></li>
        
        <li
        ><a href="/page/8/">8</a></li>
        
        <li
        ><a href="/page/9/">9</a></li>
        
        <li
        ><a href="/page/10/">10</a></li>
        
        <li
        ><a href="/page/11/">11</a></li>
        
        <li
        ><a href="/page/12/">12</a></li>
        
        <li
        ><a href="/page/13/">13</a></li>
        
        <li
        ><a href="/page/14/">14</a></li>
        
        <li
        ><a href="/page/15/">15</a></li>
        
        <li
        ><a href="/page/16/">16</a></li>
        
        <li
        ><a href="/page/17/">17</a></li>
        
        <li
        ><a href="/page/18/">18</a></li>
        
        <li
        ><a href="/page/19/">19</a></li>
        
        <li
        ><a href="/page/20/">20</a></li>
        
        <li
        ><a href="/page/21/">21</a></li>
        
        <li
        ><a href="/page/22/">22</a></li>
        
        <li
        ><a href="/page/23/">23</a></li>
        
        <li
        ><a href="/page/24/">24</a></li>
        
        <li
        ><a href="/page/25/">25</a></li>
        
        <li
        ><a href="/page/26/">26</a></li>
        
        <li
        ><a href="/page/27/">27</a></li>
        
        <li
        ><a href="/page/28/">28</a></li>
        
        <li
        ><a href="/page/29/">29</a></li>
        
        <li
        ><a href="/page/30/">30</a></li>
        
        <li
        ><a href="/page/31/">31</a></li>
        
        <li
        ><a href="/page/32/">32</a></li>
        
        <li
        ><a href="/page/33/">33</a></li>
        
        <li
        ><a href="/page/34/">34</a></li>
        
        <li
        ><a href="/page/35/">35</a></li>
        
        <li
        ><a href="/page/36/">36</a></li>
        
        <li
        ><a href="/page/37/">37</a></li>
        
        <li
        ><a href="/page/38/">38</a></li>
        
        <li
        ><a href="/page/39/">39</a></li>
        
        <li
        ><a href="/page/40/">40</a></li>
        
        <li
        ><a href="/page/41/">41</a></li>
        
        <li
        ><a href="/page/42/">42</a></li>
        
        <li
        ><a href="/page/43/">43</a></li>
        
        <li
        ><a href="/page/44/">44</a></li>
        
        <li
        ><a href="/page/45/">45</a></li>
        
        <li
        ><a href="/page/46/">46</a></li>
        
        <li
        ><a href="/page/47/">47</a></li>
        
        <li
        >
        <a href="/page/6/" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
        </li>
        
        <li>
            <a href="/page/47/" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
        </li>
        
    </ul>
    
  </div>
</div>


<script type="text/javascript">
var disqus_shortname = "abeliu";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>

<script src="http://liuxueyang.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

