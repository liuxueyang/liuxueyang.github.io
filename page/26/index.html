<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.20.1" />
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>黑历史 &middot; liuxueyang</title>

  
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/highlight/sunburst.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://liuxueyang.github.io/touch-icon-144-precomposed.png">
  <link href="http://liuxueyang.github.io/favicon.png" rel="icon">

  
  
  
  <link href="http://liuxueyang.github.io/index.xml" rel="alternate" type="application/rss+xml" title="黑历史 &middot; liuxueyang" />

  <meta name="description" content="This is my Notes">
  <meta name="keywords" content="Notes,Diary">
  
</head>
<body class="theme-base-08">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
        <img src="https://www.gravatar.com/avatar/2e3a2be066049f38f7a3f80eff0a5400?s=200"
             alt="gravatar" title="liuxueyang">
      
      <h1>liuxueyang</h1>
      <p class="lead">THE LAST ONE.</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="http://liuxueyang.github.io/">Blog</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="http://github.com/liuxueyang"><i class="fa fa-github-square fa-3x"></i></a>
      
      
      
      
      
      
      
      
      </li>
    </ul>

    

    <p>Copyright &copy; 2017 <a href="http://liuxueyang.github.io/license/">License</a><br/>
       Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>
  </div>
</div>


<div class="content container">
  <div class="posts">
    
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/23/poj2299-ultra-quicksort-%E7%BA%BF%E6%AE%B5%E6%A0%91/">poj2299 Ultra-QuickSort ——线段树</a>
      </h1>
      <span class="post-date">May 23, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/23/poj2299-ultra-quicksort-%E7%BA%BF%E6%AE%B5%E6%A0%91/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://poj.org/problem?id=2299 题目大意： 给n个任意的数字，把他们排序，求最少的交换次数。 题目思路： 开始没想法。后来zjl一说才知道。原来就是求逆序数！每一个数字前面有多少比它小的，这个数字就至少要交换多少次。所以，只需要求这列数字的逆序数就可以！好神奇 还有一个，就是每个数字的范围比较大，开始我还在想开数组貌似放不下，后来zjl说离散化……好吧，果然，我肿么没想到o(╯□╰)o感觉挺自然的想法啊…… 剩下的就是原来做过的题目了……甚至比原来做过的还简单 最后一个问题就是，最后的结果应该是long long 的，稍微算一下就知道，最大值(2*10^11)超过了4个字节的整型范围(4 * 10^9)，long long 范围是(1*10^19)，所以输出要按照long long 输出……这个问题以后一定要注意，判断一下数字的范围！别傻乎乎地就用int…… //#define LOCAL #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;deque&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 500000+10; typedef struct node { int val, index; bool operator &lt; (const node &amp; other) const { return val &lt; other.
      <a href="http://liuxueyang.github.io/blog/2013/05/23/poj2299-ultra-quicksort-%E7%BA%BF%E6%AE%B5%E6%A0%91/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/22/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-7.1.1-%E9%99%A4%E6%B3%95/">入门经典 7.1.1 除法</a>
      </h1>
      <span class="post-date">May 22, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/22/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-7.1.1-%E9%99%A4%E6%B3%95/#disqus_thread">Comments</a>
      </span>
      
      开始没思路，但是仔细思考一下，发现可以枚举，然后找一下上界和下界，可以知道范围并不大。我的枚举量是将近50000的样子，书上说枚举量可以降低到10000……没懂，再想一下
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;map&gt; using namespace std; map&lt;int, bool&gt; mymap; void solve(int i) { while (i) { mymap[i%10] = true; i /= 10; } } void init() { int n, i, j; while (~scanf(&quot;%d&quot;, &amp;n)) { for (i = 1200; i &lt; 50000; ++i) { if ((i*n)/10000 == 0 || (i*n)/10000 &gt;= 10) continue; mymap.clear(); solve(i); solve(i * n); if (i/10000 == 0) mymap[0] = true; for (j = 0; j &lt; 10; ++j) { if (!
      <a href="http://liuxueyang.github.io/blog/2013/05/22/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-7.1.1-%E9%99%A4%E6%B3%95/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/21/uva11078-open-credit-system/">uva11078 Open Credit System</a>
      </h1>
      <span class="post-date">May 21, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/21/uva11078-open-credit-system/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2019 题目大意： 给一个长度为n的序列，求Ai - Aj (i &lt; j)的最大值。序列的长度最大是10^5 题目思路： 动态维护某一个数字之前的最大值，不断更新之。同时不断更新结果ans，更新的方法是ans和当前数字之前的最大值与这个数字作差，取其中的最大值。时间复杂度O(N),空间复杂度O(1)
#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; using namespace std; void solve() { int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { int n; scanf(&quot;%d&quot;, &amp;n); int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); int i, Max = max(a,b), ans = a - b; for (i = 0; i &lt; n - 2; ++i) { scanf(&quot;%d&quot;, &amp;b); ans = max(ans, Max - b); Max = max(Max, b); } printf(&quot;%d\n&quot;, ans); } } int main(void) { //freopen(&quot;11078.
      <a href="http://liuxueyang.github.io/blog/2013/05/21/uva11078-open-credit-system/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/21/uva11462-age-sort-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/">uva11462 Age Sort ——计数排序</a>
      </h1>
      <span class="post-date">May 21, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/21/uva11462-age-sort-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2457 题目大意： 给很多个范围在１到１００之内的数字，数量最多有2*10^6个，排序输出。 题目思路： 数组很大，超内存。不能快排。所以采用计数排序
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; using namespace std; int a[120]; void solve() { int n, tmp, i, j; while (~scanf(&quot;%d&quot;, &amp;n)) { if (!n) break; memset(a, 0, sizeof(a)); for (i = 0; i &lt; n; ++i) { scanf(&quot;%d&quot;, &amp;tmp); a[tmp]++; } bool mrk = true; for (i = 1; i &lt;= 100; ++i) { for (j = 0; j &lt; a[i]; ++j) { if (!
      <a href="http://liuxueyang.github.io/blog/2013/05/21/uva11462-age-sort-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/21/usaco-friday-the-thirteenth-%E6%B0%B4%E9%A2%98/">USACO Friday the Thirteenth ——水题</a>
      </h1>
      <span class="post-date">May 21, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/21/usaco-friday-the-thirteenth-%E6%B0%B4%E9%A2%98/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://cerberus.delos.com:790/usacoprob2?a=EYxUgMg3whp&amp;S=friday 题目大意： 意思比较简单。求1900年到1900+N年的每个月的13号落在了星期几。输出13号落在一个星期的每一天的次数。 题目思路： 方法一： 有个蔡勒公式： 这个公式可以根据某天的日期，算出这一天是星期几，套用一下就行了。 公式中的符號含義如下： ——选自维基百科 /* ID: zypz457 LANG: C++ TASK: friday */ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; using namespace std; int n; int cnt[7]; int cal(int y, int m, int d) { int month = m, c; if (month == 1) { month = 13; y--; } else if (month == 2) { month = 14; y--; } else {month = m;} m = month; c = y/100; y = y%100; int ans = (y + y/4 + floor(c/4) -2*c + floor(26*(m+1)/10) + d - 1); ans = (ans%7 + 7) % 7; return ans; } void solve() { scanf(&quot;%d&quot;, &amp;n); memset(cnt, 0, sizeof(cnt)); int y, j, i, month, ans; for (i = 0; i &lt; n; ++i) { y = i + 1900; for (j = 1; j &lt;= 12; ++j) { ans = cal(y, j, 13); cnt[ans]++; } } printf(&quot;%d &quot;, cnt[6]); for (i = 0; i &lt; 5; ++i) printf(&quot;%d &quot;, cnt[i]); printf(&quot;%d\n&quot;, cnt[5]); } int main(void) { freopen(&quot;friday.
      <a href="http://liuxueyang.github.io/blog/2013/05/21/usaco-friday-the-thirteenth-%E6%B0%B4%E9%A2%98/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/21/usaco-greedy-gift-givers-%E6%B0%B4%E9%A2%98/">USACO Greedy Gift Givers ——水题</a>
      </h1>
      <span class="post-date">May 21, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/21/usaco-greedy-gift-givers-%E6%B0%B4%E9%A2%98/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://cerberus.delos.com:790/usacoprob2?S=gift1&amp;a=nR34fDHld4J 题目大意：http://blog.sina.com.cn/s/blog_63d0cab00100h1rx.html 赶脚这货考的是英语……
/* ID: zypz457 LANG: C++ TASK: gift1 */ #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;map&gt; using namespace std; int n; map&lt;string, int&gt; mymap; int wei[15][2]; string name[20]; void init() { int i; freopen(&quot;gift1.in&quot;, &quot;r&quot;, stdin); freopen(&quot;gift1.out&quot;, &quot;w&quot;, stdout); memset(wei, 0, sizeof(wei)); scanf(&quot;%d&quot;, &amp;n); for (i = 0; i &lt; n; ++i) { cin &gt;&gt; name[i]; mymap[name[i]] = i; } string str, str1; while (cin &gt;&gt; str) { int cnt, id, recid, i; id = mymap[str]; scanf(&quot;%d%d&quot;, &amp;wei[id][0], &amp;cnt); for (i = 0; i &lt; cnt;++i) { cin &gt;&gt; str1; recid = mymap[str1]; int tmp = wei[id][0] / cnt; wei[id][0] = tmp * cnt; wei[recid][1] += tmp; } } } void solve() { int i; for (i = 0; i &lt; n; ++i) { cout &lt;&lt; name[i] &lt;&lt; ' ' &lt;&lt; -wei[i][0]+wei[i][1]&lt;&lt;'\n'; } } int main(void) { init(); solve(); return 0; }  题目意思难理解，英语要好。 直接搜的翻译，开始真没看懂题意，当初感觉是有多难，看了翻译才发现……呵呵
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/21/usaco-your-ride-is-here-%E6%B0%B4%E9%A2%98/">USACO Your Ride Is Here ——水题</a>
      </h1>
      <span class="post-date">May 21, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/21/usaco-your-ride-is-here-%E6%B0%B4%E9%A2%98/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://cerberus.delos.com:790/usacoprob2?a=nR34fDHld4J&amp;S=ride 人家说USACO的题目适合入门……我还是先刷这个吧…… 这道题目主要是学了一下USACO里面的文件输入输出格式
/* ID: zypz457 TASK: ride LANG: C++ */ #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;fstream&gt; using namespace std; int main(void) { ifstream fin(&quot;ride.in&quot;); ofstream fout (&quot;ride.out&quot;); char a[10], b[10]; while (fin &gt;&gt; a &gt;&gt; b) { int sum1, sum2, i, len1, len2; len1 = strlen(a); len2 = strlen(b); sum1 = sum2 = 1; for (i = 0; i &lt; len1; ++i) { sum1 = (sum1*(a[i]-'A'+1))%47; } for (i = 0; i &lt; len2; ++i) { sum2 = (sum2*(b[i]-'A'+1))%47; } /* if (sum1 == sum2) fprintf(fout, &quot;GO\n&quot;); else fprintf(fout, &quot;STAY\n&quot;); * */ if(sum1 == sum2) fout &lt;&lt; &quot;GO\n&quot;; else fout &lt;&lt; &quot;STAY\n&quot;; } return 0; }  不用每次交题目都复制了倒是……但是格式要求挺严格的……还要有注释。。。 好吧，读文件神马的不用那么麻烦……按照原来的习惯写就行。 /* ID: zypz457 TASK: ride LANG: C++ */ #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; using namespace std; int main(void) { freopen(&quot;ride.
      <a href="http://liuxueyang.github.io/blog/2013/05/21/usaco-your-ride-is-here-%E6%B0%B4%E9%A2%98/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/20/nyoj16-%E7%9F%A9%E5%BD%A2%E5%B5%8C%E5%A5%97-dp%E5%85%A5%E9%97%A8%E9%A2%98/">NYOJ16 矩形嵌套 ——DP入门题</a>
      </h1>
      <span class="post-date">May 20, 2013 &middot; 4 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/20/nyoj16-%E7%9F%A9%E5%BD%A2%E5%B5%8C%E5%A5%97-dp%E5%85%A5%E9%97%A8%E9%A2%98/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.nyist.net/JudgeOnline/problem.php?pid=16 题目大意： 中文题…… 题目思路： 方法一： 先按照长和宽进行二级排序，然后转化成最长上升子序列求解。时间复杂度O(N^2)，数据范围1000.
#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cstring&gt; using namespace std; const int MAX = 1000+10; typedef struct node { int x, y; bool operator &lt; (const node &amp;other) const { if (x != other.x) { return x &lt; other.x; } else return y &lt; other.y; } }node; node ma[MAX]; int n, maxlen[MAX]; void init() { int i, a, b; scanf(&quot;%d&quot;, &amp;n); for (i = 0; i &lt; n; ++i) { scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if (a &gt; b) swap(a,b); ma[i].
      <a href="http://liuxueyang.github.io/blog/2013/05/20/nyoj16-%E7%9F%A9%E5%BD%A2%E5%B5%8C%E5%A5%97-dp%E5%85%A5%E9%97%A8%E9%A2%98/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/20/poj1163-the-triangle-dp%E5%85%A5%E9%97%A8%E9%A2%98/">poj1163 The Triangle ——DP入门题</a>
      </h1>
      <span class="post-date">May 20, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/20/poj1163-the-triangle-dp%E5%85%A5%E9%97%A8%E9%A2%98/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://poj.org/problem?id=1163 题目思路： 从三角形的底部开始考虑
#include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; const int MAX = 100; int a[MAX][MAX], dp[MAX][MAX]; int main(void) { //freopen(&quot;1163.in&quot;, &quot;r&quot;, stdin); int n,i,j; scanf(&quot;%d&quot;,&amp;n); for (i = 0; i &lt; n; ++i) { for (j = 0; j &lt; i+1; ++j) { scanf(&quot;%d&quot;, &amp;a[i][j]); } } memset(dp, 0, sizeof(dp)); for (i = 0; i &lt; n; ++i) dp[n-1][i] = a[n-1][i]; for (i = n - 2; i &gt;= 0; --i) { for (j = 0; j &lt; n - 1; ++j) { dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + a[i][j]; } } printf(&quot;%d\n&quot;, dp[0][0]); return 0; }  还是从最简单的开始做起吧 另外一种写法： #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; using namespace std; const int MAX = 100; int a[MAX][MAX], dp[MAX][MAX], n; int f(int i, int j) { if (dp[i][j] &gt;= 0) return dp[i][j]; else { if (i == n-1) dp[i][j] = a[i][j]; else dp[i][j] = a[i][j] + max(dp[i+1][j], dp[i+1][j+1]); return dp[i][j]; } } int main(void) { int i,j; scanf(&quot;%d&quot;,&amp;n); for (i = 0; i &lt; n; ++i) { for (j = 0; j &lt; i+1; ++j) { scanf(&quot;%d&quot;, &amp;a[i][j]); } } memset(dp, -1, sizeof(dp)); for (i = 0; i &lt; n; ++i) dp[n-1][i] = a[n-1][i]; for (i = n-1; i &gt;= 0; --i) for (j = 0; j &lt; i+1; ++j) f(i, j); printf(&quot;%d\n&quot;, dp[0][0]); return 0; }   这就是所谓的记忆化搜索 
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/19/csu1290-random-integers-dp%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/">csu1290 Random Integers ——DP入门题&amp;&amp;比赛残留题</a>
      </h1>
      <span class="post-date">May 19, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/19/csu1290-random-integers-dp%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://122.207.68.93/OnlineJudge/problem.php?id=1290 题目大意： 从K个不同的数字里面有放回地随机选N次，求选到的不同的数字的种类的期望。 题目思路： 这题不能用概率公式推导。因为有很多项的阶乘，应该会超double范围。应该用DP做。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; using namespace std; const int MAX=1000+10; double dp[MAX][MAX]; int main(void) { int i, j, k, t; double N, K; scanf(&quot;%d&quot;, &amp;t); while (t--) { scanf(&quot;%lf%lf&quot;, &amp;K, &amp;N); double sum = 0.0; for (i = 0; i &lt;= N; ++i) for (j = 0; j &lt;= K; ++j) dp[i][j] = 0.0; dp[0][0] = 1.0; for (i = 1; i &lt;= N; ++i){ for (j = 1; j &lt;= K; ++j){ dp[i][j]=dp[i-1][j-1]*(K-j+1)/K + dp[i-1][j]*(j/K); //sum += (j*dp[i][j]); } } for (i = 1; i &lt;= K; ++i) { sum += (i * dp[(int)N][i]); } printf(&quot;%.
      <a href="http://liuxueyang.github.io/blog/2013/05/19/csu1290-random-integers-dp%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/">Read On &rarr;</a>
      
    </div>
    
    
    
    <ul class="pagination">
        
        <li>
            <a href="/" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
        </li>
        
        <li
        >
        <a href="/page/25/" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
        </li>
        
        <li
        ><a href="/">1</a></li>
        
        <li
        ><a href="/page/2/">2</a></li>
        
        <li
        ><a href="/page/3/">3</a></li>
        
        <li
        ><a href="/page/4/">4</a></li>
        
        <li
        ><a href="/page/5/">5</a></li>
        
        <li
        ><a href="/page/6/">6</a></li>
        
        <li
        ><a href="/page/7/">7</a></li>
        
        <li
        ><a href="/page/8/">8</a></li>
        
        <li
        ><a href="/page/9/">9</a></li>
        
        <li
        ><a href="/page/10/">10</a></li>
        
        <li
        ><a href="/page/11/">11</a></li>
        
        <li
        ><a href="/page/12/">12</a></li>
        
        <li
        ><a href="/page/13/">13</a></li>
        
        <li
        ><a href="/page/14/">14</a></li>
        
        <li
        ><a href="/page/15/">15</a></li>
        
        <li
        ><a href="/page/16/">16</a></li>
        
        <li
        ><a href="/page/17/">17</a></li>
        
        <li
        ><a href="/page/18/">18</a></li>
        
        <li
        ><a href="/page/19/">19</a></li>
        
        <li
        ><a href="/page/20/">20</a></li>
        
        <li
        ><a href="/page/21/">21</a></li>
        
        <li
        ><a href="/page/22/">22</a></li>
        
        <li
        ><a href="/page/23/">23</a></li>
        
        <li
        ><a href="/page/24/">24</a></li>
        
        <li
        ><a href="/page/25/">25</a></li>
        
        <li
        class="active"><a href="/page/26/">26</a></li>
        
        <li
        ><a href="/page/27/">27</a></li>
        
        <li
        ><a href="/page/28/">28</a></li>
        
        <li
        ><a href="/page/29/">29</a></li>
        
        <li
        ><a href="/page/30/">30</a></li>
        
        <li
        ><a href="/page/31/">31</a></li>
        
        <li
        ><a href="/page/32/">32</a></li>
        
        <li
        ><a href="/page/33/">33</a></li>
        
        <li
        ><a href="/page/34/">34</a></li>
        
        <li
        ><a href="/page/35/">35</a></li>
        
        <li
        ><a href="/page/36/">36</a></li>
        
        <li
        ><a href="/page/37/">37</a></li>
        
        <li
        ><a href="/page/38/">38</a></li>
        
        <li
        ><a href="/page/39/">39</a></li>
        
        <li
        ><a href="/page/40/">40</a></li>
        
        <li
        ><a href="/page/41/">41</a></li>
        
        <li
        ><a href="/page/42/">42</a></li>
        
        <li
        ><a href="/page/43/">43</a></li>
        
        <li
        ><a href="/page/44/">44</a></li>
        
        <li
        ><a href="/page/45/">45</a></li>
        
        <li
        ><a href="/page/46/">46</a></li>
        
        <li
        >
        <a href="/page/27/" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
        </li>
        
        <li>
            <a href="/page/46/" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
        </li>
        
    </ul>
    
  </div>
</div>


<script type="text/javascript">
var disqus_shortname = "abeliu";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>

<script src="http://liuxueyang.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

