<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.20.1" />
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>黑历史 &middot; liuxueyang</title>

  
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/highlight/sunburst.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://liuxueyang.github.io/touch-icon-144-precomposed.png">
  <link href="http://liuxueyang.github.io/favicon.png" rel="icon">

  
  
  
  <link href="http://liuxueyang.github.io/index.xml" rel="alternate" type="application/rss+xml" title="黑历史 &middot; liuxueyang" />

  <meta name="description" content="This is my Notes">
  <meta name="keywords" content="Notes,Diary">
  
</head>
<body class="theme-base-08">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
      <h1>liuxueyang</h1>
      <p class="lead">THE LAST ONE.</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="http://liuxueyang.github.io/">Blog</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="http://github.com/liuxueyang"><i class="fa fa-github-square fa-3x"></i></a>
      
      
      
      
      
      
      
      
      </li>
    </ul>

    

    <p>Copyright &copy; 2017 <a href="http://liuxueyang.github.io/license/">License</a><br/>
       Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>
  </div>
</div>


<div class="content container">
  <div class="posts">
    
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/11/2013%E5%B9%B45%E6%9C%8811%E6%97%A5-%E6%99%B4/">2013年5月11日 晴</a>
      </h1>
      <span class="post-date">May 11, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/11/2013%E5%B9%B45%E6%9C%8811%E6%97%A5-%E6%99%B4/#disqus_thread">Comments</a>
      </span>
      
      10日 晴 晚上去跑步了，起跑的时候竟然有一种狂喜的感觉，停跑半个月了，今天第一次跑，兴奋中……哈哈，开始感觉节奏还保持地不错，天气也不错，凉快，这么好的天气憋在宿舍里面绝对是对生命的一种浪费啊！快到终点的时候，直接冲刺了大约500米的样子，虽然完全打乱了节奏，但还是很爽的感觉，^_^然后后来完全没有节奏了，，也没关系，边走边跑着回来了~ 11日 晴 又是一个大晴天，前几天一直下雨，甚至有暴雨，这两天终于晴了。一天就刷了一下水题，没什么收获，概率论也木有复习……图书馆人超多，刚进去就出来了，，回机房做题，一整天效率太低了有木有！晚上实在没有心情去跑步了，加上今晚湘江边有烟花，一想到放完烟花后的烟雾，还是算了。。明天再跑吧o(╯□╰)o
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/11/2013%E5%B9%B45%E6%9C%8811%E6%97%A5zoj%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98-zoj5000-density-of-power-network--zoj5002-friends/">2013年5月11日zoj比赛残留题 zoj5000 Density of Power Network &amp;&amp; zoj5002 Friends</a>
      </h1>
      <span class="post-date">May 11, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/11/2013%E5%B9%B45%E6%9C%8811%E6%97%A5zoj%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98-zoj5000-density-of-power-network--zoj5002-friends/#disqus_thread">Comments</a>
      </span>
      
      两道水题。直接暴力。数据范围都不大，还没有过，等哪天zoj把题目挂出来了再交。 Density of Power Network 题目链接：http://acm.zju.edu.cn/onlinejudge/showContestProblem.do?problemId=5000
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int edge[502][502], a[502], b[502]; int main(void){ #ifndef ONLINE_JUDGE freopen(&quot;zoj5000.
      <a href="http://liuxueyang.github.io/blog/2013/05/11/2013%E5%B9%B45%E6%9C%8811%E6%97%A5zoj%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98-zoj5000-density-of-power-network--zoj5002-friends/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/11/2013%E5%B9%B45%E6%9C%8811%E6%97%A5-zoj%E6%AF%94%E8%B5%9B%E4%B8%89%E9%81%93%E6%B0%B4%E9%A2%98zoj4998-break-standard-weight--zoj5004-hard-to-play--zoj5006-java-beans/">2013年5月11日 zoj比赛三道水题：zoj4998 Break Standard Weight &amp;&amp; zoj5004 Hard to Play &amp;&amp; zoj5006 Java Beans</a>
      </h1>
      <span class="post-date">May 11, 2013 &middot; 5 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/11/2013%E5%B9%B45%E6%9C%8811%E6%97%A5-zoj%E6%AF%94%E8%B5%9B%E4%B8%89%E9%81%93%E6%B0%B4%E9%A2%98zoj4998-break-standard-weight--zoj5004-hard-to-play--zoj5006-java-beans/#disqus_thread">Comments</a>
      </span>
      
      都是水题，特别水的内种，题目意思、思路神马滴就不说了…… Break Standard Weight 题目链接：http://acm.zju.edu.cn/onlinejudge/showContestProblem.do?problemId=4998 范围只有100，并且只有3个数字，直接枚举，代码好挫……o(╯□╰)o 只有一个需要注意的地方，就是绝对值为0的时候要考虑到！因为如果绝对值为0，那么根本就称不出什么重量来。。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; map&lt;int, bool&gt;mymap; int main(void){ #ifndef ONLINE_JUDGE freopen(&quot;zoj4998.
      <a href="http://liuxueyang.github.io/blog/2013/05/11/2013%E5%B9%B45%E6%9C%8811%E6%97%A5-zoj%E6%AF%94%E8%B5%9B%E4%B8%89%E9%81%93%E6%B0%B4%E9%A2%98zoj4998-break-standard-weight--zoj5004-hard-to-play--zoj5006-java-beans/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/11/dijkstra%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_1/">Dijkstra算法示例程序_1</a>
      </h1>
      <span class="post-date">May 11, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/11/dijkstra%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_1/#disqus_thread">Comments</a>
      </span>
      
      好几天不写程序的结果就是以前的东西都忘得差不多了……o(╯□╰)o
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 20; int S[MAX], dist[MAX], path[MAX], edge[MAX][MAX]; int n; void Dijkstra(int v0) { int i, j, k; for (i = 0; i &lt;n ; ++i) { dist[i] = edge[v0][i]; S[i] = 0; if (i !
      <a href="http://liuxueyang.github.io/blog/2013/05/11/dijkstra%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_1/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/10/hdu2577-how-to-type-dp%E5%85%A5%E9%97%A8%E9%A2%98/">hdu2577 How to Type ——DP入门题</a>
      </h1>
      <span class="post-date">May 10, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/10/hdu2577-how-to-type-dp%E5%85%A5%E9%97%A8%E9%A2%98/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2577 题目大意： 一个人打字，有小写字母，有大写字母，并且要求打完字以后要把CapsLock键关掉。求最少的按键次数。 题目思路： dp[i][0]表示打到第 i 个字母的时候，CapsLock键是关着的；　dp[i][1]表示打到第 i 个字母的时候，CapsLock键是开着的； 然后就是判断下一个字母是大写字母还是小写字母，如果是小写字母，dp[i+1][0] = min(dp[i][0] + 1, dp[i][1] + 2); 表示，要求下一个状态CapsLock关着，那么前一个状态如果是关着的，直接打字母就可以了，所以只需要加1，如果是开着的，就要先把CapsLock关掉，然后再打字母，所以需要加2. 其他的情况类似。参考的是这个人的代码：http://www.cnblogs.com/mengxm-lincf/archive/2011/06/07/2074489.html #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int dp[110][2]; char ch[110]; int main(void){ #ifndef ONLINE_JUDGE freopen(&quot;hdu2577.
      <a href="http://liuxueyang.github.io/blog/2013/05/10/hdu2577-how-to-type-dp%E5%85%A5%E9%97%A8%E9%A2%98/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/07/zoj3702-gibonacci-number-%E6%89%BE%E8%A7%84%E5%BE%8B/">zoj3702 Gibonacci number ——找规律</a>
      </h1>
      <span class="post-date">May 7, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/07/zoj3702-gibonacci-number-%E6%89%BE%E8%A7%84%E5%BE%8B/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3702 题目大意： 给一个数列，第一项是1，给第 i 项，这个数列满足斐波那契数列的那种性质。问是不是存在，如果存在输出第 j 项，否则输出 -1 题目思路： 找规律，这个数列每一项和原来的斐波那契数列的差值是原来的斐波那契数列的倍数。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; using namespace std; #define LL long long int LL f[30], g[30]; int main(void){ int i , j , k; f[0] = f[1] = 1; for (i = 2; i &lt; 23; ++i) { f[i] = f[i-2] + f[i-1]; } LL I, J, GI; int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { cin &gt;&gt; I &gt;&gt; GI &gt;&gt; J; LL d = GI - f[I]; if (d &lt; 0 || d % f[I-1] !
      <a href="http://liuxueyang.github.io/blog/2013/05/07/zoj3702-gibonacci-number-%E6%89%BE%E8%A7%84%E5%BE%8B/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/07/zoj3696--aliens-organ-%E6%A6%82%E7%8E%87%E9%A2%98/">zoj3696  Alien&#39;s Organ ——概率题</a>
      </h1>
      <span class="post-date">May 7, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/07/zoj3696--aliens-organ-%E6%A6%82%E7%8E%87%E9%A2%98/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3696 题目大意： 就是一个东西，随机产生器官，一天产生的数量的期望是x,求一天内产生个数小于等于N的概率 题目思路： 泊松分布。概率论得好好学。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;math.h&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; double la; double cal(double k) { double l = 1; for (int i = 1; i &lt;= k; ++i) { l = l * i; } double re = pow(la, k) / l * exp(-la); return re; } int main(void){ #ifndef ONLINE_JUDGE freopen(&quot;a.
      <a href="http://liuxueyang.github.io/blog/2013/05/07/zoj3696--aliens-organ-%E6%A6%82%E7%8E%87%E9%A2%98/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/06/poj1122zoj1053-fdny-to-the-rescue-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/">poj1122&amp;&amp;zoj1053 FDNY to the Rescue! ——最短路入门题_Dijkstra算法</a>
      </h1>
      <span class="post-date">May 6, 2013 &middot; 4 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/06/poj1122zoj1053-fdny-to-the-rescue-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://poj.org/problem?id=1122　http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=53 题目大意： 给定一个有向图，一个终点S，求多个点到这个点S的最短距离和对应的路径，把最短路排序后输出。 题目思路： 点的范围是20.可以一个一个用Dijkstra。。唯一的新意就是有多个点还需要按照路径长度排序，同时还要输出对应的路径，考的就是代码能力。用结构体存就可以。注意是有向图，开始就以为是无向图，怎么算最短路都不对。。赶脚这题不难，没什么思维难度，但是做OJ上这题的人却比较少，可能有一个原因，题目比较长，然后读完题目之后觉得没什么意思就不做了。。很简单的一个东西搞这么长的题目，也许就是考的读题吧。。貌似如果不是看的书上的翻译，我也没耐心读题。。。唉，读题确实是关键的一关。 然后这道题目，Poj上是单case，比较好过，然后数据也貌似比较弱，因为是单case，所以有一个输入的细节就特别好处理。开始Poj一下就过了，还沾沾自喜，结果把单case换成多case的时候，在zoj上交就Segmentation Fault……原来我最初处理输入个数不确定的数字的时候用了 while(~scanf())这种方法，很显然，这货只适用于单case。然后就想，该怎么处理这种输入数字个数不确定的输入呢？看了网上的一个思路，http://blog.csdn.net/yzldw333/article/details/7858172 哈哈，原来这么简单，就是以前做过的么，按照字符串处理就行了，，，好吧，，原来自己就是怕麻烦，这种方法想都没想。。然后就改了，，还是Segmentation Fault……继续调试，查错。。忍不住看了一下别人的代码，http://www.cnblogs.com/372465774y/archive/2012/11/19/2777552.html 一个注释提示了我，“这题给的字符真的是：t &lsquo; &rsquo;”好吧……我还真没注意到，虽然读题的时候注意到了，但是写代码的时候就想当然地只考虑空格，，像以前那样……思维定式啊。。然后就过了。。 Segmentation Fault的原因是访问了非法内存，在新的OJ上如果用的是Linux的话，归在Runtime Error一类里面。多谢zsl！ Poj代码：
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 20; int edge[MAX][MAX], n, dist[MAX], path[MAX], end; bool S[MAX]; typedef struct Fire { int street[MAX], len, start, E; bool operator &lt; (const Fire &amp;other) const { return len &lt; other.
      <a href="http://liuxueyang.github.io/blog/2013/05/06/poj1122zoj1053-fdny-to-the-rescue-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/05/zoj2750-idiomatic-phrases-game-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/">zoj2750 Idiomatic Phrases Game ——最短路入门题_Dijkstra算法</a>
      </h1>
      <span class="post-date">May 5, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/05/zoj2750-idiomatic-phrases-game-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1750 题目大意： 成语接龙游戏。给定n个单词，每个单词前面先给一个权值，表示由这个单词找到下一个单词所需要花费的时间。问从第一个单词至少要花多少时间才能找到最后一个单词。如果不能找到，输出-1 题目思路： 如果一个单词的最后一个字和另一个成语的第一个字一样的话。那么就可以连一个有向边。就是求一个最短路。注意：题目中说成语至少三个字，别想当然地以为成语就是4个字的……开始没注意到，后来才改的。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MINN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 1000+10; int dist[MAX], S[MAX], n, wei[MAX], edge[MAX][MAX]; char start[MAX][10], end[MAX][10], ch[50]; void Dijkstra(int u0) { int i, j; for (i = 1; i &lt;= n; ++i) { S[i] = 0; dist[i] = edge[u0][i]; } S[u0] = 1; dist[u0] = 0; int u; for (i = 1; i &lt; n; ++i) { int Min = MAXN; u = 1; for (j = 1; j &lt;= n; ++j) { if (S[j] == 0 &amp;&amp; dist[j] &lt; Min) { Min = dist[j]; u = j; } } S[u] = 1; for (j = 1; j &lt;= n; ++j) { if (S[j] == 0 &amp;&amp; edge[u][j] !
      <a href="http://liuxueyang.github.io/blog/2013/05/05/zoj2750-idiomatic-phrases-game-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/05/poj1135zoj1298-domino-effect-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/">poj1135&amp;&amp;zoj1298 Domino Effect ——最短路入门题_Dijkstra算法</a>
      </h1>
      <span class="post-date">May 5, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/05/poj1135zoj1298-domino-effect-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://poj.org/problem?id=1135　http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=298 题目大意： 有n个多米诺骨牌，有m条边，推倒第1张牌，以这个点为端点边上的的牌同时倒，问最后倒下的那张牌是哪张，并且求出时间。如果正好是端点上的牌，输出端点序号，否则需要输出这个点在哪两个端点之间。 题目思路： 假设骨牌倒下的速度是1.这样就可以用距离表征时间了。 如果最后倒下的牌正好是端点处的。那么就很好理解了，就是求所有点到这个点的最短路的最大值。设为Max1 如果最后倒下的是某两个端点之间的牌。那么就要认真想想了。比如是A点和B点之间的。可以先分别求出到A点的时间，和到B点的时间。然后再加上A和B之间的距离。所得的和就是从起点1到达最后终点的时间的两倍！为什么捏？可以这么思考：两个人，速度都是1，从起点开始，以同样的速度行走，然后在同一时刻到达同一点，那么他们所花的时间的和就是从起点到终点的距离的两倍嘛。不管他们分别到达A点和B点的先后顺序，总之，他们最后的效果都是相遇了！对于每一条边，都求出对应的时间。得到最大值，设为Max2 如果Max2 &gt; Max1 说明什么捏？说明了：两个人仅仅到达某些端点，并不能相遇有木有！还需要再走一段路程，在某两个端点之间的某处相遇！并且，这两个端点就是当Max2最大的时候的两个端点。 如果两者相等或者Max1 &gt; Max2 说明什么捏？其实貌似不能大于……因为，Max1就是起点到达所有点的最短距离的最大值嘛，而Max2是每条边上时间的最大值，然后可以发现，除了第一种情况，每条边上时间的最大值其实就是到达这条边的其中一个端点的时间的最大值……所以呢，Max1不能大于Max2.出去第一种情况狂，只能等于。 然后这道题目还有一个需要注意的地方，就是，当只有一张骨牌的时候，输出0.0……这种情况，，好吧，真不知道比赛的时候我怎么能想得出来…… #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MINN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 500+10; int dist[MAX], S[MAX], edge[MAX][MAX], n, m; void dijkstra(int v0) { int i, j; for (i = 1; i &lt;= n; ++i) { S[i] = 0; dist[i] = edge[v0][i]; } S[v0] = 1; for (i = 1; i &lt; n; ++i) { int Min = MAXN, u; for (j = 1; j &lt;= n; ++j) { if (S[j] == 0 &amp;&amp; Min &gt; dist[j]) { Min = dist[j]; u = j; } } S[u] = 1; for (j = 1; j &lt;= n; ++j) { if (S[j] == 0 &amp;&amp; edge[u][j] !
      <a href="http://liuxueyang.github.io/blog/2013/05/05/poj1135zoj1298-domino-effect-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/">Read On &rarr;</a>
      
    </div>
    
    
    
    <ul class="pagination">
        
        <li>
            <a href="/" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
        </li>
        
        <li
        >
        <a href="/page/27/" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
        </li>
        
        <li
        ><a href="/">1</a></li>
        
        <li
        ><a href="/page/2/">2</a></li>
        
        <li
        ><a href="/page/3/">3</a></li>
        
        <li
        ><a href="/page/4/">4</a></li>
        
        <li
        ><a href="/page/5/">5</a></li>
        
        <li
        ><a href="/page/6/">6</a></li>
        
        <li
        ><a href="/page/7/">7</a></li>
        
        <li
        ><a href="/page/8/">8</a></li>
        
        <li
        ><a href="/page/9/">9</a></li>
        
        <li
        ><a href="/page/10/">10</a></li>
        
        <li
        ><a href="/page/11/">11</a></li>
        
        <li
        ><a href="/page/12/">12</a></li>
        
        <li
        ><a href="/page/13/">13</a></li>
        
        <li
        ><a href="/page/14/">14</a></li>
        
        <li
        ><a href="/page/15/">15</a></li>
        
        <li
        ><a href="/page/16/">16</a></li>
        
        <li
        ><a href="/page/17/">17</a></li>
        
        <li
        ><a href="/page/18/">18</a></li>
        
        <li
        ><a href="/page/19/">19</a></li>
        
        <li
        ><a href="/page/20/">20</a></li>
        
        <li
        ><a href="/page/21/">21</a></li>
        
        <li
        ><a href="/page/22/">22</a></li>
        
        <li
        ><a href="/page/23/">23</a></li>
        
        <li
        ><a href="/page/24/">24</a></li>
        
        <li
        ><a href="/page/25/">25</a></li>
        
        <li
        ><a href="/page/26/">26</a></li>
        
        <li
        ><a href="/page/27/">27</a></li>
        
        <li
        class="active"><a href="/page/28/">28</a></li>
        
        <li
        ><a href="/page/29/">29</a></li>
        
        <li
        ><a href="/page/30/">30</a></li>
        
        <li
        ><a href="/page/31/">31</a></li>
        
        <li
        ><a href="/page/32/">32</a></li>
        
        <li
        ><a href="/page/33/">33</a></li>
        
        <li
        ><a href="/page/34/">34</a></li>
        
        <li
        ><a href="/page/35/">35</a></li>
        
        <li
        ><a href="/page/36/">36</a></li>
        
        <li
        ><a href="/page/37/">37</a></li>
        
        <li
        ><a href="/page/38/">38</a></li>
        
        <li
        ><a href="/page/39/">39</a></li>
        
        <li
        ><a href="/page/40/">40</a></li>
        
        <li
        ><a href="/page/41/">41</a></li>
        
        <li
        ><a href="/page/42/">42</a></li>
        
        <li
        ><a href="/page/43/">43</a></li>
        
        <li
        ><a href="/page/44/">44</a></li>
        
        <li
        ><a href="/page/45/">45</a></li>
        
        <li
        ><a href="/page/46/">46</a></li>
        
        <li
        >
        <a href="/page/29/" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
        </li>
        
        <li>
            <a href="/page/46/" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
        </li>
        
    </ul>
    
  </div>
</div>


<script type="text/javascript">
var disqus_shortname = "abeliu";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>

<script src="http://liuxueyang.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

