<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.20.1" />
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>黑历史 &middot; liuxueyang</title>

  
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/highlight/sunburst.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://liuxueyang.github.io/touch-icon-144-precomposed.png">
  <link href="http://liuxueyang.github.io/favicon.png" rel="icon">

  
  
  
  <link href="http://liuxueyang.github.io/index.xml" rel="alternate" type="application/rss+xml" title="黑历史 &middot; liuxueyang" />

  <meta name="description" content="This is my Notes">
  <meta name="keywords" content="Notes,Diary">
  
</head>
<body class="theme-base-08">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
        <img src="https://www.gravatar.com/avatar/8c0cbc14aa80dd620f186fcb50bbcab1?s=200"
             alt="gravatar" title="liuxueyang">
      
      <h1>liuxueyang</h1>
      <p class="lead">THE LAST ONE.</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="http://liuxueyang.github.io/">Blog</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="http://github.com/liuxueyang"><i class="fa fa-github-square fa-3x"></i></a>
      
      
      
      
      
      
      
      
      </li>
    </ul>

    

    <p>Copyright &copy; 2017 <a href="http://liuxueyang.github.io/license/">License</a><br/>
       Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>
  </div>
</div>


<div class="content container">
  <div class="posts">
    
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/04/dijkstra%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/">Dijkstra算法示例程序</a>
      </h1>
      <span class="post-date">May 4, 2013 &middot; 4 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/04/dijkstra%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/#disqus_thread">Comments</a>
      </span>
      
      输入：一个有向图，顶点个数 n ,然后是每条边的起点，终点，权值。顶点序号从0开始，-1 -1 -1表示结束。 输出：顶点0到其他各顶点的最短路径长度，并输出对应的最短路径。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 20; int S[MAX], dist[MAX], path[MAX], edge[MAX][MAX]; int n; void Dijkstra(int v0) { int i, j, k; for (i = 0; i &lt; n; ++i) { dist[i] = edge[v0][i]; S[i] = 0; if (i !
      <a href="http://liuxueyang.github.io/blog/2013/05/04/dijkstra%E7%AE%97%E6%B3%95%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/04/poj1679-the-unique-mst-%E5%88%A4%E6%96%AD%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80_kruscal%E7%AE%97%E6%B3%95/">poj1679 The Unique MST ——判断最小生成树是否唯一_kruscal算法</a>
      </h1>
      <span class="post-date">May 4, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/04/poj1679-the-unique-mst-%E5%88%A4%E6%96%AD%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80_kruscal%E7%AE%97%E6%B3%95/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://poj.org/problem?id=1679 题目大意： 判断一个连通的无向图的最小生成树是不是唯一的，如果唯一，输出最小生成树的权值，否者输出“Not Unique!” 题目思路： 这题目看的书上的，其实，最开始我的想法是，在求最小生成树的过程中，如果扩展到某一个点的时候，有多种选择，也就是说，有多个权值相同的边可以选择，那么就break掉，说明最小生成树不唯一。其实这是有问题的，因为，很可能在这权值相同的边当中，只能选择其中一条，如果选择其它的就得不到最小生成树，这就是一个反例。所以原来的做法是错误的。 书上的做法是，首先，预处理，看每个边是不是有别的边的权值和它一样的，有的话就标记一下，用结构体里面的equal表示，然后用kruscal算法求一遍最小生成树，并且把这棵最小生成树里面的边都标记一下，用结构体里面的used表示，然后，对于那种有其他边和它权值相同的那种边，同时这条边在第一次求的最小生成树里面，我们就把它删除，做法就是用结构体里面的del标记，然后再次求一遍最小生成树，不用del被标记的边，这样如果求出来的最小生成树的权值和原来的一样，说明最小生成树不唯一，break; 然后就OK了，唉，其实这是很自然的一个想法~
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 100+10; typedef struct Edge { int u, v, w, equal, used, del; bool operator &lt; (const Edge &amp;other) const { return w &lt; other.
      <a href="http://liuxueyang.github.io/blog/2013/05/04/poj1679-the-unique-mst-%E5%88%A4%E6%96%AD%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80_kruscal%E7%AE%97%E6%B3%95/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/04/poj2048zoj1751-highways-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/">poj2048&amp;&amp;zoj1751 Highways ——最小生成树入门题_Prim算法</a>
      </h1>
      <span class="post-date">May 4, 2013 &middot; 4 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/04/poj2048zoj1751-highways-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://poj.org/problem?id=1751 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1048 题目大意： 给定n个点的坐标。还有m对已经相连的点的编号。求连接这n个点的总权值最小的一棵生成树，输出还需要连接的点的编号。 题目思路： 这道题目和以前做过的poj2421是一样的。这里采用了那篇博客里面的第一种方法。幸运的是，在poj上1A了。但是在zoj上，因为输入输出格式有一些不一样，卡了一下，到最后我也没明白“If no new highways need to be built (all towns are already connected), then the output should be created but it should be empty.” 这句话的含义，看书上的翻译是，如果不需要再建了，输出一个空行。可是，在poj上，输出空行与否都是可以过的。在zoj上，输出空行就WA了，就是因为这个错误…… poj代码：
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 759; double edge[MAX][MAX]; double lowcost[MAX];int nearvex[MAX]; int n, m; typedef struct Point { int x, y; }Point; Point point[MAX]; void prim(int u0) { int i, j, k, v;double sum = 0; for (i = 1; i &lt;= n; ++i) { lowcost[i] = edge[i][u0]; nearvex[i] = u0; } lowcost[u0] = 0; nearvex[u0] = -1; for (i = 1; i &lt; n; ++i) { double min = 1.
      <a href="http://liuxueyang.github.io/blog/2013/05/04/poj2048zoj1751-highways-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/03/poj2349-arctic-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/">poj2349 Arctic Network ——最小生成树入门题_Prim算法</a>
      </h1>
      <span class="post-date">May 3, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/03/poj2349-arctic-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://poj.org/problem?id=2349 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=914 题目大意： 有一些炮台，如果这个炮台有卫星接收器，那么任意两个有卫星接收器的炮台可以通信，不受距离限制；否者，两个炮台之间只能通过对讲机通信，这是受距离限制的。要买一种对讲机，用在需要的炮台上，要求所有炮台两两之间可以直接或者间接通信，问要买通信距离至少为多少的对讲机可以满足要求。输入：S卫星接收器的数量，P炮台的数量，然后是P行，每行代表一个炮台的坐标。输出要求的对讲机的通信距离D。 题目思路： 题目意思比较难懂。关键是satellite channel的安放方法，注意，它是放在炮台上的，只要这个炮台上有这货，它就可以和任何也有这货的炮台通信。明白这一点，然后就简单了。有S个卫星接收器，那么就可以减少S-1个距离开销。要让D尽可能小，就让这S-1个距离开销最大，所以，想法就是，求这些点的最小生成树，然后把所选的边排序，第S大的边的权值就是所求。 开始题意没搞懂。关键是“Any two outposts with a satellite channel can communicate via the satellite, regardless of their location.”这句话没有理解明白，也就是说，任何两个有卫星接收器的炮台都可通信！然后自己就把问题复杂化了……写的代码就很复杂了。。后来改了一下，就过了。。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 500+10; int n, s, p; double edge[MAX][MAX]; double lowcost[MAX]; int nearvex[MAX]; typedef struct Point { double x, y; }Point; typedef struct Vex { int i, j; double len; bool operator &lt; (const Vex &amp; other) const { // 不能写反了 return len &gt; other.
      <a href="http://liuxueyang.github.io/blog/2013/05/03/poj2349-arctic-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/03/poj1789-truck-history-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/">poj1789 Truck History ——最小生成树入门题_Prim算法</a>
      </h1>
      <span class="post-date">May 3, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/03/poj1789-truck-history-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://poj.org/problem?id=1789 题目大意： 输入一个数字n，然后输入n个长度为7的字符串，从任意一个字符串开始派生，直到派生出所有的字符串，两个字符串的距离规定为他们对应位置不相等的字母的个数，求出一种派生方案，使得派生方案的优劣值最大，并输出这个优劣值。优劣值的定义是：1/Σ(to,td)d(to,td) 表示对所有派生对的距离求和，再取倒数。 题目了思路： 要让优劣值最大，只需要距离之和最小，把7个字符串看成7个点，每两个点有一个距离，目的就是求权值最小的生成树，其实就是最小生成树。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 2000+10; char a[MAX][MAX]; int edge[MAX][MAX]; int n, lowcost[MAX]; void prim(int u0) { int sum = 0, i, j, k; for (i = 1; i &lt;= n; ++i) lowcost[i] = edge[u0][i]; lowcost[u0] = -1; for (i = 1; i &lt; n; ++i) { int v = -1, min = MAXN; for (j = 1; j &lt;= n; ++j) { if (lowcost[j] !
      <a href="http://liuxueyang.github.io/blog/2013/05/03/poj1789-truck-history-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/03/zoj1586-qs-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/">zoj1586 QS Network ——最小生成树入门题_Prim算法</a>
      </h1>
      <span class="post-date">May 3, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/03/zoj1586-qs-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=586 题目大意： 题目意思比较难懂。看书上的翻译竟然没有看懂，还是打开OJ，看英文的原题。看了两遍的样子，终于差不多懂了。 QS是一种生物，要完成通信，需要设备，每个QS需要的设备的价格不同，并且，这种设备只能在两个QS之间用一次，也就是说，如果一个QS需要和3个QS通信的话，它就必须得买3个设备，同时，对方三个也必须买对应的适合自己的设备。同时，每两个QS之间是有距离的，要完成通信还需要网线，给出每两个QS之间的网线的价值。求一棵生成树，使得所需要的费用最少。数据范围：所有数据都在1000以内。 题目思路： 根据这种设备的特性，每个设备只能和另外一个QS通信，所以呢，建图的时候，每条边的权值就是网线的费用，加上这条边的两个端点的QS所需设备的费用的和。这样，就转化成了常规的最小生成树的问题。因为只需要求出最小费用，所以，可以不必记录prim过程中要选的边的顶点编号，也就是说，可以省略nearvex数组，用lowcost数组就可以实现。如果lowcost[i]的值是-1，则代表已经选择了这个点，否则，lowcost[i]依然表示集合T1内的顶点 i 距离集合T内个顶点权值最小的边的权值。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 1000+10; int edge[MAX][MAX], lowcost[MAX]; int t, n, pri[MAX]; void prim(int u0) { int sum = 0, i, j, v; for (i = 1; i &lt;= n; ++i) lowcost[i] = edge[u0][i]; lowcost[u0] = -1; for (i = 1; i &lt; n; ++i) { int min = MAXN; v = -1; for (j = 1; j &lt;= n; ++j) { if (min &gt; lowcost[j] &amp;&amp; lowcost[j] !
      <a href="http://liuxueyang.github.io/blog/2013/05/03/zoj1586-qs-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/03/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_prim%E7%AE%97%E6%B3%95/">最小生成树示例程序_Prim算法</a>
      </h1>
      <span class="post-date">May 3, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/03/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_prim%E7%AE%97%E6%B3%95/#disqus_thread">Comments</a>
      </span>
      
      输入：顶点个数n和边数m，然后是m条边的数据。u v w 分别代表两个顶点和权值。顶点从1开始记起。 输出：一次选择的各条边和最小生成树的权。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 100; int n, m, lowcost[MAX], nearvex[MAX], edge[MAX][MAX]; void prim(int u0) { int i, j, sum = 0; for (i = 1; i &lt;= n; ++i) { lowcost[i] = edge[u0][i]; nearvex[i] = u0; } nearvex[u0] = -1; for (i = 1; i &lt; n; ++i) { int min = MAXN, v = -1; for (j = 1; j &lt;= n; ++j) { if (nearvex[j] !
      <a href="http://liuxueyang.github.io/blog/2013/05/03/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_prim%E7%AE%97%E6%B3%95/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/02/poj2421-constructing-roads-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/">poj2421 Constructing Roads ——最小生成树入门题_Kruscal算法</a>
      </h1>
      <span class="post-date">May 2, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/02/poj2421-constructing-roads-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://poj.org/problem?id=2421 题目大意： 给定一个矩阵，第 i 行第 j 列表示点 i 和点 j　的距离是ｓ［ｉ］［ｊ］。然后输入Ｑ，下面Ｑ行，每行两个数字ａ，ｂ表示点ａ和点ｂ已经有路相连。求需要至少再修多长的路，可以构成一棵生成树。输出需要在修的路的总长度。 题目思路： 转化为最小生成树求解。有两种思路： １）把已经相连的两个点的权值设置为０，这样，就可以直接求最小生成树了。因为kruscal的过程中，一定会选择到已经相连的这些点，因为它们的权值是0嘛，同时，即使把它们的权值加上，也不会影响结果。这个方法我好不容易想出来了，可是还有一个问题，就是：输入a b 后，如何定位到相应的边，并把这个边的权值设置为0？开始的时候，是暴力找，超时了，然后自己想各种方法，还求出来个公式，用a,b,N,表示出边的编号。最后还是超时了。。看网上别人恰好有人也是这么个思路，但是他是怎么定位边，并把边的权值设置为0的，没仔细看，不知道为什么人家就用这种方法过了…… 2）第二种思路，如果a b 已经相连，很简单，只要它俩的根节点不同，就把它两个合并不就可以了么，这样，kruscal的过程中，就不会再加入这些已经存在的边的权值了。剩下的就是纯的kruscal问题。这个方法很好！看的别人的想法。然后自己写了一下，RE了一次，原因是，合并a b 的时候，没有判断他们的根节点是否不同。。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; typedef struct Edge { int u, v, w; bool operator &lt; (const Edge &amp;o) const { return w &lt; o.
      <a href="http://liuxueyang.github.io/blog/2013/05/02/poj2421-constructing-roads-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/01/hoj12616-median-tree-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/">hoj12616 Median Tree ——最小生成树入门题&amp;&amp;比赛残留题_Kruscal算法</a>
      </h1>
      <span class="post-date">May 1, 2013 &middot; 3 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/01/hoj12616-median-tree-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hnu.cn/online/?action=problem&amp;type=show&amp;id=12616 题目大意： 给n个点,m条边，求一棵生成树，使得这个生成树的边的权值的中位数最小。输出这个中位数。 题目思路： 和poj1861&amp;&amp;zoj1542的思路是一样的。可以证明要求的树就是最小生成树。然后就是中位数的概念：长度为N的数列的中位数，就是(N+1)/2位置的数字。百度百科里面貌似不是严格的中位数的概念。 开始写了一遍按照那种不严格的中位数的定义写的。过了。kruscal的过程中，只需要计算到(n-1+1)/2-1的那一条边即可退出。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int n, m; const int em = 10000+10, vm = 1000+10; typedef struct Edge { int u, v, w; bool operator &lt; (const Edge &amp;other) const { return w &lt; other.
      <a href="http://liuxueyang.github.io/blog/2013/05/01/hoj12616-median-tree-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/01/poj1861zoj1542-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/">poj1861&amp;&amp;zoj1542 Network ——最小生成树入门题_Kruscal算法</a>
      </h1>
      <span class="post-date">May 1, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/01/poj1861zoj1542-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://poj.org/problem?id=1861 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=542 题目大意： 给n个点，m条边。求一棵生成树，并且满足任意两点之间的距离的最大值最小。输出这个最大值，然后输出树的边的数量，最后输出树的每条边。 题目思路： 其实就是求最小生成树。关键就是证明，对于一个图的最小生成树来说，它的最大边满足在所有的生成树的最大边里最小。这是可以理解的。简单思考一下：假设最小生成树不满足这个条件。那么就是说，存在另一棵生成树，它的最大边的值比最小生成树还小，但是它的权值之和可能比最小生成树大，但是这表明，构造最小生成树的时候，存在一步，选择边的时候，没有选择权值最小的，这是不可能的。所以矛盾。所以假设不成立。所以，问题就转化成了常规的求最小生成树的问题了。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 1000+10; const int MAX1 = 15000+10; typedef struct Edge { int u, v, w; bool operator &lt; (const Edge &amp;other) const { return w &lt; other.
      <a href="http://liuxueyang.github.io/blog/2013/05/01/poj1861zoj1542-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/">Read On &rarr;</a>
      
    </div>
    
    
    
    <ul class="pagination">
        
        <li>
            <a href="/" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
        </li>
        
        <li
        >
        <a href="/page/28/" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
        </li>
        
        <li
        ><a href="/">1</a></li>
        
        <li
        ><a href="/page/2/">2</a></li>
        
        <li
        ><a href="/page/3/">3</a></li>
        
        <li
        ><a href="/page/4/">4</a></li>
        
        <li
        ><a href="/page/5/">5</a></li>
        
        <li
        ><a href="/page/6/">6</a></li>
        
        <li
        ><a href="/page/7/">7</a></li>
        
        <li
        ><a href="/page/8/">8</a></li>
        
        <li
        ><a href="/page/9/">9</a></li>
        
        <li
        ><a href="/page/10/">10</a></li>
        
        <li
        ><a href="/page/11/">11</a></li>
        
        <li
        ><a href="/page/12/">12</a></li>
        
        <li
        ><a href="/page/13/">13</a></li>
        
        <li
        ><a href="/page/14/">14</a></li>
        
        <li
        ><a href="/page/15/">15</a></li>
        
        <li
        ><a href="/page/16/">16</a></li>
        
        <li
        ><a href="/page/17/">17</a></li>
        
        <li
        ><a href="/page/18/">18</a></li>
        
        <li
        ><a href="/page/19/">19</a></li>
        
        <li
        ><a href="/page/20/">20</a></li>
        
        <li
        ><a href="/page/21/">21</a></li>
        
        <li
        ><a href="/page/22/">22</a></li>
        
        <li
        ><a href="/page/23/">23</a></li>
        
        <li
        ><a href="/page/24/">24</a></li>
        
        <li
        ><a href="/page/25/">25</a></li>
        
        <li
        ><a href="/page/26/">26</a></li>
        
        <li
        ><a href="/page/27/">27</a></li>
        
        <li
        ><a href="/page/28/">28</a></li>
        
        <li
        class="active"><a href="/page/29/">29</a></li>
        
        <li
        ><a href="/page/30/">30</a></li>
        
        <li
        ><a href="/page/31/">31</a></li>
        
        <li
        ><a href="/page/32/">32</a></li>
        
        <li
        ><a href="/page/33/">33</a></li>
        
        <li
        ><a href="/page/34/">34</a></li>
        
        <li
        ><a href="/page/35/">35</a></li>
        
        <li
        ><a href="/page/36/">36</a></li>
        
        <li
        ><a href="/page/37/">37</a></li>
        
        <li
        ><a href="/page/38/">38</a></li>
        
        <li
        ><a href="/page/39/">39</a></li>
        
        <li
        ><a href="/page/40/">40</a></li>
        
        <li
        ><a href="/page/41/">41</a></li>
        
        <li
        ><a href="/page/42/">42</a></li>
        
        <li
        ><a href="/page/43/">43</a></li>
        
        <li
        ><a href="/page/44/">44</a></li>
        
        <li
        ><a href="/page/45/">45</a></li>
        
        <li
        ><a href="/page/46/">46</a></li>
        
        <li
        >
        <a href="/page/30/" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
        </li>
        
        <li>
            <a href="/page/46/" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
        </li>
        
    </ul>
    
  </div>
</div>


<script type="text/javascript">
var disqus_shortname = "abeliu";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>

<script src="http://liuxueyang.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

