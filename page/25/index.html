<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.20.1" />
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>黑历史 &middot; liuxueyang</title>

  
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/highlight/sunburst.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://liuxueyang.github.io/touch-icon-144-precomposed.png">
  <link href="http://liuxueyang.github.io/favicon.png" rel="icon">

  
  
  
  <link href="http://liuxueyang.github.io/index.xml" rel="alternate" type="application/rss+xml" title="黑历史 &middot; liuxueyang" />

  <meta name="description" content="This is my Notes">
  <meta name="keywords" content="Notes,Diary">
  
</head>
<body class="theme-base-08">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
        <img src="https://www.gravatar.com/avatar/2e3a2be066049f38f7a3f80eff0a5400?s=200"
             alt="gravatar" title="liuxueyang">
      
      <h1>liuxueyang</h1>
      <p class="lead">THE LAST ONE.</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="http://liuxueyang.github.io/">Blog</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="http://github.com/liuxueyang"><i class="fa fa-github-square fa-3x"></i></a>
      
      
      
      
      
      
      
      
      </li>
    </ul>

    

    <p>Copyright &copy; 2017 <a href="http://liuxueyang.github.io/license/">License</a><br/>
       Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>
  </div>
</div>


<div class="content container">
  <div class="posts">
    
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/06/15/%E7%82%B9%E5%A4%B41010-%E5%8F%AA%E5%8C%85%E5%90%AB%E5%9B%A0%E5%AD%902-3-5%E7%9A%84%E6%95%B0/">点头1010 只包含因子2 3 5的数</a>
      </h1>
      <span class="post-date">Jun 15, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/06/15/%E7%82%B9%E5%A4%B41010-%E5%8F%AA%E5%8C%85%E5%90%AB%E5%9B%A0%E5%AD%902-3-5%E7%9A%84%E6%95%B0/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://www.51nod.com/onlineJudge/questionCode.html#!problemId=1010 题目思路： 想想怎么打表吧，还有，只需要存下满足要求的数字，要求的数字可以表示为：(2^x*3^y*5^z)，然后可以发现：2^60&gt;10^18，所以，枚举的上限是60*60*60，大约是216000，实际上，只有1万多。枚举的方法就是以前做过的题目了：http://poj.org/problem?id=1338 然后就是二分查找，边界比较纠结。
#include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cstdlib&gt; #define LL long long #define MAXN 216000+10 #define min(a,b) ((a)&lt;(b)?(a):(b)) LL a[MAXN]; int main(void) { int i, j, k, p; i = j = k = 0; a[0] = 1; for (p = 1; p &lt;= 12690; ++p) { a[p] = min(a[i]*2, min(a[j]*3, a[k]*5)); if (a[p] == a[i] * 2) ++i; if (a[p] == a[j] * 3) ++j; if (a[p] == a[k] * 5) ++k; } int T; scanf(&quot;%d&quot;,&amp;T); while (T--) { LL n; scanf(&quot;%I64d&quot;, &amp;n); int low = 1, high = 12690, mid, last; LL goal; goal = n; while (low &lt; high) { mid = low + (high - low) / 2; if (a[mid] &lt; goal) low = mid + 1; else if (a[mid] &gt; goal) high = mid - 1; else {last = mid; break;} } if (high == low) { last = high; } else if (low &gt; high) last = low; if (goal == 1) last = 1; if (a[last] &lt; goal) last++; printf(&quot;%I64d\n&quot;, a[last]); } return 0; }  输入输出原来要用%I64d，这个WA了两次……A了之后竟然是第一名，呵呵，可能大家都没有手写二分，都用的STL吧。
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/06/08/%E5%87%86%E5%A4%87%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95-%E5%8D%9A%E5%AE%A2%E4%B8%8D%E6%9B%B4%E4%BA%86/">准备期末考试 博客不更了</a>
      </h1>
      <span class="post-date">Jun 8, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/06/08/%E5%87%86%E5%A4%87%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95-%E5%8D%9A%E5%AE%A2%E4%B8%8D%E6%9B%B4%E4%BA%86/#disqus_thread">Comments</a>
      </span>
      
      今天高考结束了……大家都考得挺好的吧，祝福他们。 高考结束后，马上又将会有这么一群孩子，迫不及待的扔下书包，去聚餐，通宵上网，旅行，KTV，闲逛，狂欢……认为自己终于解放了……殊不知，你们离开的，就是天堂。 认真准备期末考试，虽然还是有的时候忍不住会写代码，囧。昨天CF做得真的挫了。这就是一周不写程序的后果，呵呵。坚决不写程序了，准备考试！实在无聊看看python，haskell什么的……
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/06/08/codeforces-round-#187-div.-2-b.-sereja-and-array/">Codeforces Round #187 (Div. 2) B. Sereja and Array</a>
      </h1>
      <span class="post-date">Jun 8, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/06/08/codeforces-round-#187-div.-2-b.-sereja-and-array/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://codeforces.com/contest/315/problem/B 开始以为线段树，汗……原来是道水题
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;vector&gt; #include &lt;stack&gt; #include &lt;map&gt; #include &lt;queue&gt; using namespace std; typedef struct Po { int d, a; }Po; Po p[100000+10]; int main(void) { #ifndef ONLINE_JUDGE freopen(&quot;187b.in&quot;, &quot;r&quot;, stdin); #endif int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;p[i].a); p[i].d = 0; } int D = 0, t, s; for (int i = 0; i &lt; m; ++i) { scanf(&quot;%d&quot;, &amp;t); if (t == 1) { int st, en; scanf(&quot;%d%d&quot;, &amp;st, &amp;en); p[st].
      <a href="http://liuxueyang.github.io/blog/2013/06/08/codeforces-round-#187-div.-2-b.-sereja-and-array/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/06/08/codeforces-round-#187-div.-2-a.-sereja-and-bottles/">Codeforces Round #187 (Div. 2) A. Sereja and Bottles</a>
      </h1>
      <span class="post-date">Jun 8, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/06/08/codeforces-round-#187-div.-2-a.-sereja-and-bottles/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://codeforces.com/contest/315/problem/A 这到题目比赛的时候过了，赛后WA了……虽然很简单，但是还是没想太清楚
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; using namespace std; #define MAX 103 int a[MAX], b[MAX]; int main(void) { int n; #ifndef ONLINE_JUDGE freopen(&quot;187a.in&quot;, &quot;r&quot;, stdin); #endif while (~scanf(&quot;%d&quot;, &amp;n)) { for (int i = 0; i &lt; n; ++i) scanf(&quot;%d%d&quot;, a+i, b+i); int cnt = 0; for (int i = 0; i &lt; n; ++i) { bool flag = false; for (int j = 0; j &lt; n; ++j) { if (i!
      <a href="http://liuxueyang.github.io/blog/2013/06/08/codeforces-round-#187-div.-2-a.-sereja-and-bottles/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/06/03/nyoj5-binary-string-matching-kmp/">NYOJ5 Binary String Matching ——KMP</a>
      </h1>
      <span class="post-date">Jun 3, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/06/03/nyoj5-binary-string-matching-kmp/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.nyist.net/JudgeOnline/problem.php?pid=5 题目思路： 典型的KMP，关键就是修改一下，找到了模式串p之后，继续从大的串s里面模式串开始的位置的下一个位置开始找下一个。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; using namespace std; char p[1000], s[1000]; int next[1000]; void getnext() { int i = 0, j = -1, len = strlen(p); next[0] = -1; while (i &lt; len - 1) { if (j == -1 || p[j] == p[i]) { j++; i++; next[i] = j; } else j = next[j]; } } int kmp() { int i = -1, j = -1, lenp = strlen(p), lens = strlen(s); getnext(); int num = 0; while (i &lt; lens) { if (j == -1 || s[i] == p[j]) {++i; ++j;} else j = next[j]; if (j == lenp) {i-=j; j = -1; num++;} } return num; } int main(void) { int n; while (~scanf(&quot;%d&quot;, &amp;n)) while (n--){ scanf(&quot;%s%s&quot;, p, s); printf(&quot;%d\n&quot;, kmp()); } return 0; }  复习了一下KMP，很有意思~ 看到了一个STL的方法，碉堡了…… #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; string s, p; int main(void) { int n; while (~scanf(&quot;%d&quot;, &amp;n)) { while (n--) { cin &gt;&gt; p &gt;&gt; s; int num = 0; unsigned ans = 0; ans = s.
      <a href="http://liuxueyang.github.io/blog/2013/06/03/nyoj5-binary-string-matching-kmp/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/06/03/kmp%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/">KMP示例程序</a>
      </h1>
      <span class="post-date">Jun 3, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/06/03/kmp%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/#disqus_thread">Comments</a>
      </span>
      
      输入： 数字N，然后是N组数据，每一组数据第一行是模式串p，第二行是一个大的字符创s，如果在s里面出现了p，那么输出p第一次出现的位置，否则输出No #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; using namespace std; char p[1000], s[1000]; int next[1000]; void getnext() { int i = 0, j = -1, len = strlen(p); next[0] = -1; while (i &lt; len - 1) { if (j == -1 || p[j] == p[i]) { j++; i++; next[i] = j; } else j = next[j]; } } int kmp() { int i = -1, j = -1, lenp = strlen(p), lens = strlen(s); getnext(); while (j !
      <a href="http://liuxueyang.github.io/blog/2013/06/03/kmp%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/06/01/hdu1420-prepared-for-new-acmer-%E5%BF%AB%E9%80%9F%E5%B9%82/">hdu1420 Prepared for New Acmer ——快速幂</a>
      </h1>
      <span class="post-date">Jun 1, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/06/01/hdu1420-prepared-for-new-acmer-%E5%BF%AB%E9%80%9F%E5%B9%82/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1420 题目大意： 中文题。 题目思路： 赤裸裸的快速幂。呵呵
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;cstdlib&gt; using namespace std; #define LL long long LL m; LL Po(LL a, LL b) { LL ans = 1; while (b) { if (b&amp;1) { ans = (ans * a) % m; b--; } b /= 2; a = a * a % m; } return ans; } int main(void) { LL n, a, b; #ifndef ONLINE_JUDGE freopen(&quot;1420.
      <a href="http://liuxueyang.github.io/blog/2013/06/01/hdu1420-prepared-for-new-acmer-%E5%BF%AB%E9%80%9F%E5%B9%82/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/06/01/hdu1257-%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F-dp%E4%B9%88/">hdu1257 最少拦截系统 ——DP么？</a>
      </h1>
      <span class="post-date">Jun 1, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/06/01/hdu1257-%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F-dp%E4%B9%88/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1257 题目大意： 中文的…… 题目思路： 人家说是DP，求最长不升子序列的个数。好吧……我不是那么做的。 我的思路是，从前往后扫一遍，访问过的标记为true，记录一下个数就ＯＫ了。
#include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; int b[1000]; bool a[1000]; int main(void) { int n; #ifndef ONLINE_JUDGE freopen(&quot;1257.in&quot;, &quot;r&quot;, stdin); #endif while (~scanf(&quot;%d&quot;, &amp;n)) { int i, j, cnt = 0; for (i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, b+i); memset(a, false, sizeof(a)); for (i = 0; i &lt; n; ++i) { while (a[i]) ++i; if (i == n) break; if (!
      <a href="http://liuxueyang.github.io/blog/2013/06/01/hdu1257-%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F-dp%E4%B9%88/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/31/codeforces-round-#185-div.-2-b.-archer/">Codeforces Round #185 (Div. 2) B. Archer</a>
      </h1>
      <span class="post-date">May 31, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/31/codeforces-round-#185-div.-2-b.-archer/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://codeforces.com/problemset/problem/312/B 题目大意： 很简短，不解释了。 题目思路： 开始怎么也读不懂题意，以为求期望呢，想不开……后来问了别人才知道，原来就是求概率，也没说多少个回合，所以就是求极限…… 所以，这货就是一道很简洁的概率题，推个公式就好了。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; using namespace std; int main(void) { int a, b, c, d; double p1, p2, ans; scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d); p1 = 1.0*a/b; p2 = 1.0*c/d; ans = p1/(1-(1-p1)*(1-p2)); printf(&quot;%.12f\n&quot;, ans); return 0; }   开始为什么怎么也读不懂捏？果然是理解能力差么？ 这题几天前做的，忘了总结一下了。
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/31/codeforces-round-#186-div.-2-c.-ilya-and-matrix/">Codeforces Round #186 (Div. 2) C. Ilya and Matrix</a>
      </h1>
      <span class="post-date">May 31, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/31/codeforces-round-#186-div.-2-c.-ilya-and-matrix/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://codeforces.com/problemset/problem/313/C 题目大意： 还是看原题吧，意思不难懂。 题目思路： 开始一直没有想法，后来听一然酱讲了才好不容易搞懂，赶脚好神奇。 构造的思路应该算贪心，先把前4大的数字排列到最先划分的4个方格里面，然后再依次把后面比较大的数字依次填充到这四个方格里空着的小格子里面，直到所有的格子填满为止，为什么这个思路是正确的呢？还是模拟一下4*4的格子就差不多理解了吧。 但是关键是怎么算出递归得到的结果？一然酱的思路很巧妙，先把数字逆序排列，再把前序和算出来，目的是方便后面的求和，然后从递归的最底层开始考虑。最底层肯定是所有的数字都包括，也就是前N个数字的和，再往上走，就是前N/4个数字的和，直到N&lt;1为止。碉堡了…… #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; using namespace std; #define LL long long int const int MAX = 1000000*2+10; LL a[MAX], ans, n; bool cmp2(LL a, LL b) { return a &gt; b; } int main(void) { while (~scanf(&quot;%I64d&quot;, &amp;n)) { int i; for (i = 0; i &lt; n; ++i) scanf(&quot;%I64d&quot;, a+i); sort(a, a+n, cmp2); for (i = 1; i &lt; n; ++i) a[i] += a[i-1]; ans = 0; while (n &gt;= 1) { ans += a[n-1]; n = n &gt;&gt; 2; } printf(&quot;%I64d\n&quot;, ans); } return 0 ; }   然后就是注意一下类型用LL…… 这回跟一然酱去网吧做CF，感触颇深，看人家神牛怎么做比赛的，给跪……谢谢一然酱~ 
      
      
    </div>
    
    
    
    <ul class="pagination">
        
        <li>
            <a href="/" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
        </li>
        
        <li
        >
        <a href="/page/24/" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
        </li>
        
        <li
        ><a href="/">1</a></li>
        
        <li
        ><a href="/page/2/">2</a></li>
        
        <li
        ><a href="/page/3/">3</a></li>
        
        <li
        ><a href="/page/4/">4</a></li>
        
        <li
        ><a href="/page/5/">5</a></li>
        
        <li
        ><a href="/page/6/">6</a></li>
        
        <li
        ><a href="/page/7/">7</a></li>
        
        <li
        ><a href="/page/8/">8</a></li>
        
        <li
        ><a href="/page/9/">9</a></li>
        
        <li
        ><a href="/page/10/">10</a></li>
        
        <li
        ><a href="/page/11/">11</a></li>
        
        <li
        ><a href="/page/12/">12</a></li>
        
        <li
        ><a href="/page/13/">13</a></li>
        
        <li
        ><a href="/page/14/">14</a></li>
        
        <li
        ><a href="/page/15/">15</a></li>
        
        <li
        ><a href="/page/16/">16</a></li>
        
        <li
        ><a href="/page/17/">17</a></li>
        
        <li
        ><a href="/page/18/">18</a></li>
        
        <li
        ><a href="/page/19/">19</a></li>
        
        <li
        ><a href="/page/20/">20</a></li>
        
        <li
        ><a href="/page/21/">21</a></li>
        
        <li
        ><a href="/page/22/">22</a></li>
        
        <li
        ><a href="/page/23/">23</a></li>
        
        <li
        ><a href="/page/24/">24</a></li>
        
        <li
        class="active"><a href="/page/25/">25</a></li>
        
        <li
        ><a href="/page/26/">26</a></li>
        
        <li
        ><a href="/page/27/">27</a></li>
        
        <li
        ><a href="/page/28/">28</a></li>
        
        <li
        ><a href="/page/29/">29</a></li>
        
        <li
        ><a href="/page/30/">30</a></li>
        
        <li
        ><a href="/page/31/">31</a></li>
        
        <li
        ><a href="/page/32/">32</a></li>
        
        <li
        ><a href="/page/33/">33</a></li>
        
        <li
        ><a href="/page/34/">34</a></li>
        
        <li
        ><a href="/page/35/">35</a></li>
        
        <li
        ><a href="/page/36/">36</a></li>
        
        <li
        ><a href="/page/37/">37</a></li>
        
        <li
        ><a href="/page/38/">38</a></li>
        
        <li
        ><a href="/page/39/">39</a></li>
        
        <li
        ><a href="/page/40/">40</a></li>
        
        <li
        ><a href="/page/41/">41</a></li>
        
        <li
        ><a href="/page/42/">42</a></li>
        
        <li
        ><a href="/page/43/">43</a></li>
        
        <li
        ><a href="/page/44/">44</a></li>
        
        <li
        ><a href="/page/45/">45</a></li>
        
        <li
        ><a href="/page/46/">46</a></li>
        
        <li
        ><a href="/page/47/">47</a></li>
        
        <li
        ><a href="/page/48/">48</a></li>
        
        <li
        >
        <a href="/page/26/" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
        </li>
        
        <li>
            <a href="/page/48/" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
        </li>
        
    </ul>
    
  </div>
</div>


<script type="text/javascript">
var disqus_shortname = "abeliu";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>

<script src="http://liuxueyang.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

