<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.20.1" />
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>黑历史 &middot; liuxueyang</title>

  
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/highlight/sunburst.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://liuxueyang.github.io/touch-icon-144-precomposed.png">
  <link href="http://liuxueyang.github.io/favicon.png" rel="icon">

  
  
  
  <link href="http://liuxueyang.github.io/index.xml" rel="alternate" type="application/rss+xml" title="黑历史 &middot; liuxueyang" />

  <meta name="description" content="This is my Notes">
  <meta name="keywords" content="Notes,Diary">
  
</head>
<body class="theme-base-08">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
        <img src="https://www.gravatar.com/avatar/2e3a2be066049f38f7a3f80eff0a5400?s=200"
             alt="gravatar" title="liuxueyang">
      
      <h1>liuxueyang</h1>
      <p class="lead">THE LAST ONE.</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="http://liuxueyang.github.io/">Blog</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="http://github.com/liuxueyang"><i class="fa fa-github-square fa-3x"></i></a>
      
      
      
      
      
      
      
      
      </li>
    </ul>

    

    <p>Copyright &copy; 2017 <a href="http://liuxueyang.github.io/license/">License</a><br/>
       Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>
  </div>
</div>


<div class="content container">
  <div class="posts">
    
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/26/agri-net-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">Agri-Net ——最小生成树</a>
      </h1>
      <span class="post-date">May 26, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/26/agri-net-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hust.edu.cn/vjudge/contest/view.action?cid=24534#problem/A 题目大意： 给定无向图，邻接矩阵。求最小生成树权值。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; #define MAXN 110 #define MAXM 5009 typedef struct edge { int u, v, w; bool operator &lt; (const edge &amp;other) const { return w &lt; other.w; } }edge; edge edges[MAXM]; int parent[MAXN]; int n, m, i, j; void init() { for (i = 1; i &lt;= n; ++i) parent[i] = -1; } int find(int x) { int s; for (s = x; parent[s] &gt;= 0; s = parent[s]) ; while (s !
      <a href="http://liuxueyang.github.io/blog/2013/05/26/agri-net-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/25/hdu1176-%E5%85%8D%E8%B4%B9%E9%A6%85%E9%A5%BC-dp/">hdu1176 免费馅饼 ——DP</a>
      </h1>
      <span class="post-date">May 25, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/25/hdu1176-%E5%85%8D%E8%B4%B9%E9%A6%85%E9%A5%BC-dp/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1176 题目大意： 中文题…… 题目思路： 类似于 Triangle 。d[i][j] 表示 i 时间在 j 位置的所得到的价值。然后就像 Triangle 一样从下往上递推。最终求在0秒的时候，在5位置上的值。 ＷＡ了两次，当初求的是0秒的时候，所有位置上的最大值，，这显然是不对的。因为起始位置是5啊。
#include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; const int MAX = 100000+10; int a[MAX][11], d[MAX][11]; void init() { int m, i, j, x, t, tMax = -1; while (~scanf(&quot;%d&quot;, &amp;m) &amp;&amp; m) { memset(a, 0, sizeof(a)); memset(d, 0, sizeof(d)); for (i = 0; i &lt; m; ++i) { scanf(&quot;%d%d&quot;, &amp;x, &amp;t); if (tMax &lt; t) tMax = t; a[t][x]++; } for (i = 0; i &lt;= 10; ++i) d[tMax][i] = a[tMax][i]; for (i = tMax-1; i&gt;= 0; --i) { for (j = 0; j &lt;= 10; ++j) { if (j == 0) { d[i][j] = max(d[i+1][j], d[i+1][j+1]) + a[i][j]; continue; } else if (j == 10) { d[i][j] = max(d[i+1][j], d[i+1][j-1]) + a[i][j]; continue; } d[i][j]=max(d[i+1][j], max(d[i+1][j+1], d[i+1][j-1]))+a[i][j]; } } printf(&quot;%d\n&quot;, d[0][5]); } } int main(void) { init(); return 0; }  很多题目都是相通的
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/25/poj1018-communication-system-%E8%B4%AA%E5%BF%83-%E6%9E%9A%E4%B8%BE/">poj1018 Communication System ——贪心&#43;枚举</a>
      </h1>
      <span class="post-date">May 25, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/25/poj1018-communication-system-%E8%B4%AA%E5%BF%83-%E6%9E%9A%E4%B8%BE/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://poj.org/problem?id=1018 题目大意： 有n种设备，每种设备有mi个选择，每种设备选择一个，每个设备都有一个带宽值和价钱，要求每种设备选择一个，最终选择的n个设备里面，带宽B是这n个设备里面所有带宽的最小值吗，价钱P为这n个设备价钱的和，求B/P的最大值。 题目思路： 这题开始没读懂题意，后来搜的题意之后才明白。然后没有思路……看了人家的思路，貌似懂了……然后就开始写，写跪了……开始的方法是，求出所有这n种设备里面每种设备的带宽的最小值，依次枚举这些最小值就可以了。总是WA…… 昨天纠结一晚上，今天早上又想了一下，发现原来的想法是有问题的，应该一直枚举到所有n中设备里面每种带宽的最大值的最小值。第一：保证这n种设备每一种都可以选上。第二：虽然枚举的B值比原来大了，所得到的的价钱不小于我原来的做法所得到的的价钱，但是，重点来了：B也增大了啊！有木有！所以，这就是我当初没有想到的！ #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; #define MAXN 0x7fffffff #define MINN -MAXN const int MAX = 100+10; typedef struct node { int p, b, cnt; bool operator &lt; (const node &amp; other ) const { if (p != other.p) return p &lt; other.p; else return b &lt; other.b; } }node; typedef struct sys { node de[MAX]; int Min, Max, cnt; bool operator &lt; (const sys &amp;other) const { return Min &lt; other.
      <a href="http://liuxueyang.github.io/blog/2013/05/25/poj1018-communication-system-%E8%B4%AA%E5%BF%83-%E6%9E%9A%E4%B8%BE/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/24/%E8%AE%BE%E7%BD%AEzsh%E4%B8%BA%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4shell/">设置zsh为系统默认shell</a>
      </h1>
      <span class="post-date">May 24, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/24/%E8%AE%BE%E7%BD%AEzsh%E4%B8%BA%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4shell/#disqus_thread">Comments</a>
      </span>
      
      whereis zsh 就会显示zsh的路径，一般是 /bin/zsh 然后输入 chsh -s /bin/zsh 会提示输入密码，然后重新登录就好了～ 同样，如果设置其它的shell，也是类似的做法。
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/24/hdu2069-coin-change-dp/">hdu2069 Coin Change ——DP</a>
      </h1>
      <span class="post-date">May 24, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/24/hdu2069-coin-change-dp/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2069 题目大意： 给一个数字，用1, 5, 10， 25, 50 这五种硬币，最多用100枚，有多少种组合方式。 题目思路： 这道题和之前的题目不同，有了硬币个数的限制，所以需要加上一维表示硬币的个数就可以了。d[i][j]表示价值为 i 的最多用 j 枚硬币有多少中组合方式。很多人用母函数做，感觉DP做简单多了…… 参考博客：http://www.cnblogs.com/qiufeihai/archive/2012/09/11/2680840.html
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; using namespace std; const int MAX = 250+10; int d[MAX][MAX], n, a[5] = {1, 5, 10, 25, 50}; void solve() { while (~scanf(&quot;%d&quot;, &amp;n)) { int i, j, k; memset(d, 0, sizeof(d)); d[0][0] = 1; for (k = 0; k &lt; 5; ++k) { for (j = 1; j &lt;= 100; ++j) { for (i = a[k]; i &lt;= n; ++i) { d[i][j] += d[i-a[k]][j-1]; } } } int sum(0); for (i = 0; i &lt;= n; ++i) { sum += d[n][i]; } printf(&quot;%d\n&quot;, sum); } } int main(void) { solve(); return 0; }  　还有要注意一点，初始化要d[0][0] = 1 因为题目中说：Note that we count that there is one way of making change for zero cent.
      <a href="http://liuxueyang.github.io/blog/2013/05/24/hdu2069-coin-change-dp/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/23/2013%E5%B9%B45%E6%9C%8823%E6%97%A5-%E6%99%B4/">2013年5月23日 晴</a>
      </h1>
      <span class="post-date">May 23, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/23/2013%E5%B9%B45%E6%9C%8823%E6%97%A5-%E6%99%B4/#disqus_thread">Comments</a>
      </span>
      
      最近长沙的天气啊，不是下雨就是下雨……无语O__O&rdquo;… 今天晚上终于去跑步了，穿上跑鞋，还有差不多半年没有穿过的棒球队队服，去跑步吧~ 开始感觉不错，节奏还不错，跑得略快，到一半的时候，感觉有点吃不消啊，还好后来放慢速度，把节奏调整好了，继续跑着，又是一个月明风清的晚上，湘江边对面的灯光很美，就那么不快不慢地跑着，多好，人生一大幸事啊。夏天来了，汗水，激情，奋斗，梦想，青春，就是这样的吧，加油 最后还是跑完全程5K了。虽然也许永远也达不到高中的时候48分钟跑完10K的那种状态了，但是跑步也不全是为了速度或者成绩，高兴就行了，实力是在不知不觉中增长的。 说好了晚上回宿舍就补作业不写程序的，结果……不知不觉写了一晚上的程序，，然后就跑步去了，，回来就十点半了……又写了会儿程序，，就到现在了……果然还是没写作业啊……要交作业了还没有预习完有木有……果然是要通宵补作业了么…… 学习时间可以少，但是效率一定要高！ 身边总有些人在无私地帮助我，鼓励我，谢谢你们~
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1398-square-coins-dp/">hdu1398 Square Coins ——DP</a>
      </h1>
      <span class="post-date">May 23, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1398-square-coins-dp/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1398 题目大意： 给一个数字，不大于300，求有多少种用完全平方数表示这个数字的方法 题目思路： 方法跟hdu1283一样一样的……只需要把那道题目的代码稍微改一下就可以过了 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &lt;= floor(sqrt(n)); ++i) { for (j = i*i; j &lt;= n; ++j) { d[j] += d[j-i*i]; } } printf(&quot;%lld\n&quot;, d[n]); } } int main(void) { solve(); return 0; }   因为题目的范围很小嘛，只有300。 
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1284-%E9%92%B1%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-dp/">hdu1284 钱币兑换问题 ——DP</a>
      </h1>
      <span class="post-date">May 23, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1284-%E9%92%B1%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-dp/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1284 题目大意： 中文题…… 题目思路： 只有3个硬币，范围是32768，可以一个一个枚举硬币，如果只放价值为1的硬币，从d[1]递推到d[n]；如果再加上价值为2的硬币，那么就从d[2]递推到d[n]；在加上价值为3的硬币，就从d[3]递推到d[n].递推公式是d[j] = d[j] + d[j-i]； d[j]表示j有几种只用1，2, 3这三个数字的拆分方法，i 就是硬币的价值。 #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&quot;%d&quot;, &amp;n)) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &lt;= 3; ++i) { for (j = i; j &lt;= n; ++j) { d[j] += d[j-i]; } } printf(&quot;%lld\n&quot;, d[n]); } } int main(void) { solve(); return 0; }   参考博客：http://www.
      <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1284-%E9%92%B1%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-dp/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1028-ignatius-and-the-princess-iii-dp/">hdu1028 Ignatius and the Princess III ——DP</a>
      </h1>
      <span class="post-date">May 23, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1028-ignatius-and-the-princess-iii-dp/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1028 题目大意：　整数拆分，给一个整数n,求它有多少种拆分方法。 题目思路： 做法一： d[i][j]表示把整数 i 拆成最多 j 个数字所具有的方法数。那么 if (i &gt;ｊ)　d[i][j] = d[i-j][j] + d[i][j-1]; 意思就是如果i&gt;j，那么有两种方式：一种是先把i里面分理处j个1，然后再把i-j拆成最多i-j个数字；另一种是把i拆分成最多j-1个数字。 if (i &lt; j) d[i][j] = d[i][i]; 意思就是如果i&lt;j，那么这种情况和把数字i最多拆成i个数字的是一样的。 if (i == j) d[i][j] = d[i][j-1] + 1; 意思就是如果i==j，那么可以把数字i拆分成j-1个数字，也可以把数字i拆分成i个1（这个就是那个1的意义） #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; using namespace std; #define LL long long int d[140][140], n; void init() { while (~scanf(&quot;%d&quot;, &amp;n)) { int i, j; memset(d, 0, sizeof(d)); for (i = 0; i &lt;= n; ++i) d[i][1] = d[1][i] = 1; for (i = 2; i &lt;= n; ++i) { for (j = 1; j &lt;= n; ++j) { if (i &gt; j) d[i][j] = d[i-j][j] + d[i][j-1]; else if (i == j) d[i][j] = 1 + d[i][j-1]; else d[i][j] = d[i][i]; } } cout &lt;&lt; d[n][n] &lt;&lt; endl; } } int main(void) { init(); return 0 ; }   剩下的就是考虑一下边界，比如当 i 或者 j 等于1的时候，显然都是只有一种拆分情况。 做法二： 借用hdu1284这道题的方法，也可以做这道题目，因为n的范围是120嘛,两个算法的复杂度都是O(n^2)的，当然可以了。只需要把hdu1284的代码里面把3改成n，这题就过了…… #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&quot;%d&quot;, &amp;n)) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &lt;= n; ++i) { for (j = i; j &lt;= n; ++j) { d[j] += d[j-i]; } } printf(&quot;%lld\n&quot;, d[n]); } } int main(void) { solve(); return 0; }   优化到了一维数组，这个方法碉堡了…… 参考博客：http://www.
      <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1028-ignatius-and-the-princess-iii-dp/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1394-minimum-inversion-number-%E7%BA%BF%E6%AE%B5%E6%A0%91/">hdu1394 Minimum Inversion Number ——线段树</a>
      </h1>
      <span class="post-date">May 23, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1394-minimum-inversion-number-%E7%BA%BF%E6%AE%B5%E6%A0%91/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1394 题目大意： 给定一个0到ｎ-1的数字组成的序列，它的逆序数，然后把第一个数字放到末尾，得到一个新的序列，再求逆序数，再把新序列的第一个数字放到末尾，一直这样做，求所有这些序列的逆序数的最小值。 题目思路： 可以先求出起初的序列的逆序数。然后根据逆序数的定义，把一个数字从开头移动到末尾，逆序数的改变量是什么？求出这个改变量，然后剩下的所有序列的逆序数就都求出来了。 这样考虑：一个数字 ｂ[i] 在开头，比它大的数字有 ｂ[i] 个，也就是说和这个数字组成了 ｂ[i] 个逆序，把它放到最后，这个数字可以组成 n-1-ｂ[i] 个逆序，所以逆序数的增量是 n - 1 - ｂ[i] - ｂ[i] ，这样就可以根据原来的序列的逆序数求出剩下的所有序列的逆序数了～
#include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const int MAX = 5000+10; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 int a[MAX&lt;&lt;2], b[MAX], n; void pushup(int rt) { a[rt] = a[rt&lt;&lt;1] + a[rt&lt;&lt;1|1]; } void build(int l, int r, int rt) { if (l == r) {a[rt] = 0; return;} int m = (l + r) &gt;&gt; 1; build(lson); build(rson); pushup(rt); } void update(int p, int l, int r, int rt) { if (l == r) {a[rt]++; return;} int m = (l + r) &gt;&gt; 1; if (p &lt;= m) update(p, lson); else update(p, rson); pushup(rt); } int query(int L, int R,int l, int r, int rt) { if (L &lt;= l &amp;&amp; R &gt;= r) {return a[rt];} int m = (l + r) &gt;&gt; 1, ret = 0; if (L &lt;= m) ret += query(L, R, lson); if (R &gt; m) ret += query(L, R, rson); return ret; } void init() { while (~scanf(&quot;%d&quot;, &amp;n)) { int i, sum = 0, ans; build(0, n - 1, 1); for (i = 0; i &lt; n; ++i) { scanf(&quot;%d&quot;, b+i); sum += query(b[i]+1, n-1, 0, n-1, 1); update(b[i], 0, n-1, 1); } ans = sum; for (i = 0; i &lt; n; ++i) { sum += (n-1-2*b[i]); if (sum &lt; ans) ans = sum; } printf(&quot;%d\n&quot;, ans); } } int main(void) { init(); return 0; }  这题是线段树的单点更新
      
      
    </div>
    
    
    
    <ul class="pagination">
        
        <li>
            <a href="/" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
        </li>
        
        <li
        >
        <a href="/page/24/" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
        </li>
        
        <li
        ><a href="/">1</a></li>
        
        <li
        ><a href="/page/2/">2</a></li>
        
        <li
        ><a href="/page/3/">3</a></li>
        
        <li
        ><a href="/page/4/">4</a></li>
        
        <li
        ><a href="/page/5/">5</a></li>
        
        <li
        ><a href="/page/6/">6</a></li>
        
        <li
        ><a href="/page/7/">7</a></li>
        
        <li
        ><a href="/page/8/">8</a></li>
        
        <li
        ><a href="/page/9/">9</a></li>
        
        <li
        ><a href="/page/10/">10</a></li>
        
        <li
        ><a href="/page/11/">11</a></li>
        
        <li
        ><a href="/page/12/">12</a></li>
        
        <li
        ><a href="/page/13/">13</a></li>
        
        <li
        ><a href="/page/14/">14</a></li>
        
        <li
        ><a href="/page/15/">15</a></li>
        
        <li
        ><a href="/page/16/">16</a></li>
        
        <li
        ><a href="/page/17/">17</a></li>
        
        <li
        ><a href="/page/18/">18</a></li>
        
        <li
        ><a href="/page/19/">19</a></li>
        
        <li
        ><a href="/page/20/">20</a></li>
        
        <li
        ><a href="/page/21/">21</a></li>
        
        <li
        ><a href="/page/22/">22</a></li>
        
        <li
        ><a href="/page/23/">23</a></li>
        
        <li
        ><a href="/page/24/">24</a></li>
        
        <li
        class="active"><a href="/page/25/">25</a></li>
        
        <li
        ><a href="/page/26/">26</a></li>
        
        <li
        ><a href="/page/27/">27</a></li>
        
        <li
        ><a href="/page/28/">28</a></li>
        
        <li
        ><a href="/page/29/">29</a></li>
        
        <li
        ><a href="/page/30/">30</a></li>
        
        <li
        ><a href="/page/31/">31</a></li>
        
        <li
        ><a href="/page/32/">32</a></li>
        
        <li
        ><a href="/page/33/">33</a></li>
        
        <li
        ><a href="/page/34/">34</a></li>
        
        <li
        ><a href="/page/35/">35</a></li>
        
        <li
        ><a href="/page/36/">36</a></li>
        
        <li
        ><a href="/page/37/">37</a></li>
        
        <li
        ><a href="/page/38/">38</a></li>
        
        <li
        ><a href="/page/39/">39</a></li>
        
        <li
        ><a href="/page/40/">40</a></li>
        
        <li
        ><a href="/page/41/">41</a></li>
        
        <li
        ><a href="/page/42/">42</a></li>
        
        <li
        ><a href="/page/43/">43</a></li>
        
        <li
        ><a href="/page/44/">44</a></li>
        
        <li
        ><a href="/page/45/">45</a></li>
        
        <li
        ><a href="/page/46/">46</a></li>
        
        <li
        >
        <a href="/page/26/" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
        </li>
        
        <li>
            <a href="/page/46/" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
        </li>
        
    </ul>
    
  </div>
</div>


<script type="text/javascript">
var disqus_shortname = "abeliu";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>

<script src="http://liuxueyang.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

