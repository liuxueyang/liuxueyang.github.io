<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.20.1" />
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>黑历史 &middot; liuxueyang</title>

  
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/highlight/sunburst.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://liuxueyang.github.io/touch-icon-144-precomposed.png">
  <link href="http://liuxueyang.github.io/favicon.png" rel="icon">

  
  
  
  <link href="http://liuxueyang.github.io/index.xml" rel="alternate" type="application/rss+xml" title="黑历史 &middot; liuxueyang" />

  <meta name="description" content="This is my Notes">
  <meta name="keywords" content="Notes,Diary">
  
</head>
<body class="theme-base-08">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
      <h1>liuxueyang</h1>
      <p class="lead">THE LAST ONE.</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="http://liuxueyang.github.io/">Blog</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="http://github.com/liuxueyang"><i class="fa fa-github-square fa-3x"></i></a>
      
      
      
      
      
      
      
      
      </li>
    </ul>

    

    <p>Copyright &copy; 2017 <a href="http://liuxueyang.github.io/license/">License</a><br/>
       Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>
  </div>
</div>


<div class="content container">
  <div class="posts">
    
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/06/03/nyoj5-binary-string-matching-kmp/">NYOJ5 Binary String Matching ——KMP</a>
      </h1>
      <span class="post-date">Jun 3, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/06/03/nyoj5-binary-string-matching-kmp/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.nyist.net/JudgeOnline/problem.php?pid=5 题目思路： 典型的KMP，关键就是修改一下，找到了模式串p之后，继续从大的串s里面模式串开始的位置的下一个位置开始找下一个。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; using namespace std; char p[1000], s[1000]; int next[1000]; void getnext() { int i = 0, j = -1, len = strlen(p); next[0] = -1; while (i &lt; len - 1) { if (j == -1 || p[j] == p[i]) { j++; i++; next[i] = j; } else j = next[j]; } } int kmp() { int i = -1, j = -1, lenp = strlen(p), lens = strlen(s); getnext(); int num = 0; while (i &lt; lens) { if (j == -1 || s[i] == p[j]) {++i; ++j;} else j = next[j]; if (j == lenp) {i-=j; j = -1; num++;} } return num; } int main(void) { int n; while (~scanf(&quot;%d&quot;, &amp;n)) while (n--){ scanf(&quot;%s%s&quot;, p, s); printf(&quot;%d\n&quot;, kmp()); } return 0; }  复习了一下KMP，很有意思~ 看到了一个STL的方法，碉堡了…… #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; using namespace std; string s, p; int main(void) { int n; while (~scanf(&quot;%d&quot;, &amp;n)) { while (n--) { cin &gt;&gt; p &gt;&gt; s; int num = 0; unsigned ans = 0; ans = s.
      <a href="http://liuxueyang.github.io/blog/2013/06/03/nyoj5-binary-string-matching-kmp/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/06/03/kmp%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/">KMP示例程序</a>
      </h1>
      <span class="post-date">Jun 3, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/06/03/kmp%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/#disqus_thread">Comments</a>
      </span>
      
      输入： 数字N，然后是N组数据，每一组数据第一行是模式串p，第二行是一个大的字符创s，如果在s里面出现了p，那么输出p第一次出现的位置，否则输出No #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; using namespace std; char p[1000], s[1000]; int next[1000]; void getnext() { int i = 0, j = -1, len = strlen(p); next[0] = -1; while (i &lt; len - 1) { if (j == -1 || p[j] == p[i]) { j++; i++; next[i] = j; } else j = next[j]; } } int kmp() { int i = -1, j = -1, lenp = strlen(p), lens = strlen(s); getnext(); while (j !
      <a href="http://liuxueyang.github.io/blog/2013/06/03/kmp%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/06/01/hdu1420-prepared-for-new-acmer-%E5%BF%AB%E9%80%9F%E5%B9%82/">hdu1420 Prepared for New Acmer ——快速幂</a>
      </h1>
      <span class="post-date">Jun 1, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/06/01/hdu1420-prepared-for-new-acmer-%E5%BF%AB%E9%80%9F%E5%B9%82/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1420 题目大意： 中文题。 题目思路： 赤裸裸的快速幂。呵呵
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;cstdlib&gt; using namespace std; #define LL long long LL m; LL Po(LL a, LL b) { LL ans = 1; while (b) { if (b&amp;1) { ans = (ans * a) % m; b--; } b /= 2; a = a * a % m; } return ans; } int main(void) { LL n, a, b; #ifndef ONLINE_JUDGE freopen(&quot;1420.
      <a href="http://liuxueyang.github.io/blog/2013/06/01/hdu1420-prepared-for-new-acmer-%E5%BF%AB%E9%80%9F%E5%B9%82/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/06/01/hdu1257-%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F-dp%E4%B9%88/">hdu1257 最少拦截系统 ——DP么？</a>
      </h1>
      <span class="post-date">Jun 1, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/06/01/hdu1257-%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F-dp%E4%B9%88/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1257 题目大意： 中文的…… 题目思路： 人家说是DP，求最长不升子序列的个数。好吧……我不是那么做的。 我的思路是，从前往后扫一遍，访问过的标记为true，记录一下个数就ＯＫ了。
#include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; int b[1000]; bool a[1000]; int main(void) { int n; #ifndef ONLINE_JUDGE freopen(&quot;1257.in&quot;, &quot;r&quot;, stdin); #endif while (~scanf(&quot;%d&quot;, &amp;n)) { int i, j, cnt = 0; for (i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, b+i); memset(a, false, sizeof(a)); for (i = 0; i &lt; n; ++i) { while (a[i]) ++i; if (i == n) break; if (!
      <a href="http://liuxueyang.github.io/blog/2013/06/01/hdu1257-%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F-dp%E4%B9%88/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/31/codeforces-round-#185-div.-2-b.-archer/">Codeforces Round #185 (Div. 2) B. Archer</a>
      </h1>
      <span class="post-date">May 31, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/31/codeforces-round-#185-div.-2-b.-archer/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://codeforces.com/problemset/problem/312/B 题目大意： 很简短，不解释了。 题目思路： 开始怎么也读不懂题意，以为求期望呢，想不开……后来问了别人才知道，原来就是求概率，也没说多少个回合，所以就是求极限…… 所以，这货就是一道很简洁的概率题，推个公式就好了。 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; using namespace std; int main(void) { int a, b, c, d; double p1, p2, ans; scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d); p1 = 1.0*a/b; p2 = 1.0*c/d; ans = p1/(1-(1-p1)*(1-p2)); printf(&quot;%.12f\n&quot;, ans); return 0; }   开始为什么怎么也读不懂捏？果然是理解能力差么？ 这题几天前做的，忘了总结一下了。
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/31/codeforces-round-#186-div.-2-c.-ilya-and-matrix/">Codeforces Round #186 (Div. 2) C. Ilya and Matrix</a>
      </h1>
      <span class="post-date">May 31, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/31/codeforces-round-#186-div.-2-c.-ilya-and-matrix/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://codeforces.com/problemset/problem/313/C 题目大意： 还是看原题吧，意思不难懂。 题目思路： 开始一直没有想法，后来听一然酱讲了才好不容易搞懂，赶脚好神奇。 构造的思路应该算贪心，先把前4大的数字排列到最先划分的4个方格里面，然后再依次把后面比较大的数字依次填充到这四个方格里空着的小格子里面，直到所有的格子填满为止，为什么这个思路是正确的呢？还是模拟一下4*4的格子就差不多理解了吧。 但是关键是怎么算出递归得到的结果？一然酱的思路很巧妙，先把数字逆序排列，再把前序和算出来，目的是方便后面的求和，然后从递归的最底层开始考虑。最底层肯定是所有的数字都包括，也就是前N个数字的和，再往上走，就是前N/4个数字的和，直到N&lt;1为止。碉堡了…… #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; using namespace std; #define LL long long int const int MAX = 1000000*2+10; LL a[MAX], ans, n; bool cmp2(LL a, LL b) { return a &gt; b; } int main(void) { while (~scanf(&quot;%I64d&quot;, &amp;n)) { int i; for (i = 0; i &lt; n; ++i) scanf(&quot;%I64d&quot;, a+i); sort(a, a+n, cmp2); for (i = 1; i &lt; n; ++i) a[i] += a[i-1]; ans = 0; while (n &gt;= 1) { ans += a[n-1]; n = n &gt;&gt; 2; } printf(&quot;%I64d\n&quot;, ans); } return 0 ; }   然后就是注意一下类型用LL…… 这回跟一然酱去网吧做CF，感触颇深，看人家神牛怎么做比赛的，给跪……谢谢一然酱~ 
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/30/codeforces-round-#185-div.-1-a.-the-closest-pair/">Codeforces Round #185 (Div. 1) A. The Closest Pair</a>
      </h1>
      <span class="post-date">May 30, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/30/codeforces-round-#185-div.-1-a.-the-closest-pair/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://codeforces.com/problemset/problem/311/A 题目大意： 题目很短，不解释了。^_^ 题目思路： 开始感觉很难，没思路。看了解题报告，发现原来是道水题嘛。程序里面有个break语句，要让循环次数达到最大，并且循环次数容易计算，只需要让这个break;永远不会执行就可以了。也就是说，可以让p[j].x - p[i].x &gt;= d 永远不成立，只需要让p[j].x - p[i].x总等于0就可以了！因为题目让生成任意一组符合条件的数据嘛，所以，可以让产生的所有的点的横坐标都是一样的就可以了。
#include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; #define LL long long int main(void) { #ifndef ONLINE_JUDGE //freopen(&quot;185_c.in1&quot;, &quot;r&quot;, stdin); #endif LL n, k; scanf(&quot;%I64d%I64d&quot;, &amp;n, &amp;k); if (n*(n-1)/2 &lt;= k){ printf(&quot;no solution\n&quot;); } else { for (int i = 0; i &lt; n; ++i) { printf(&quot;1 %d\n&quot;, i); } } return 0; }  很简单的思路，当初为什么没有想到？
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/26/the-unique-mst-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7/">The Unique MST ——最小生成树的唯一性</a>
      </h1>
      <span class="post-date">May 26, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/26/the-unique-mst-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hust.edu.cn/vjudge/contest/view.action?cid=24534#problem/C 题目大意： 判断最小生成树是否唯一。 题目思路： 对于如果有一条边A在最小生成树里面，并且存在和这条边权值一样的另外一条边B，那么再次求最小生成树的时候，把A去掉，看看求出的最小生成树是不是和原来的最小生成树权值一样。如果一样，就是不唯一，否则就刚才去掉的加进来，然后再找下一条这样的边。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; #define MAXN 110 #define MAXM 5009 typedef struct edge { int u, v, w, used, del, equal; bool operator &lt; (const edge &amp;other) const { return w &lt; other.w; } }edge; edge edges[MAXM]; int parent[MAXN]; bool first; int n, m, i, j; void init() { for (i = 1; i &lt;= n; ++i) parent[i] = -1; } int find(int x) { int s; for (s = x; parent[s] &gt;= 0; s = parent[s]) ; while (s !
      <a href="http://liuxueyang.github.io/blog/2013/05/26/the-unique-mst-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/26/constructing-roads-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">Constructing Roads ——最小生成树</a>
      </h1>
      <span class="post-date">May 26, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/26/constructing-roads-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hust.edu.cn/vjudge/contest/view.action?cid=24534#problem/B 题目大意： 给邻接矩阵，和已经建立好的几条边。求最小生成树权值。 题目思路： 方法就是把已将建立好的边的权值赋值为0即可。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; #define MAXN 110 #define MAXM 5009 typedef struct edge { int u, v, w; bool operator &lt; (const edge &amp;other) const { return w &lt; other.w; } }edge; edge edges[MAXM]; int parent[MAXN]; int n, m, i, j; void init() { for (i = 1; i &lt;= n; ++i) parent[i] = -1; } int find(int x) { int s; for (s = x; parent[s] &gt;= 0; s = parent[s]) ; while (s !
      <a href="http://liuxueyang.github.io/blog/2013/05/26/constructing-roads-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/26/agri-net-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">Agri-Net ——最小生成树</a>
      </h1>
      <span class="post-date">May 26, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/26/agri-net-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hust.edu.cn/vjudge/contest/view.action?cid=24534#problem/A 题目大意： 给定无向图，邻接矩阵。求最小生成树权值。
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; using namespace std; #define MAXN 110 #define MAXM 5009 typedef struct edge { int u, v, w; bool operator &lt; (const edge &amp;other) const { return w &lt; other.w; } }edge; edge edges[MAXM]; int parent[MAXN]; int n, m, i, j; void init() { for (i = 1; i &lt;= n; ++i) parent[i] = -1; } int find(int x) { int s; for (s = x; parent[s] &gt;= 0; s = parent[s]) ; while (s !
      <a href="http://liuxueyang.github.io/blog/2013/05/26/agri-net-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">Read On &rarr;</a>
      
    </div>
    
    
    
    <ul class="pagination">
        
        <li>
            <a href="/" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
        </li>
        
        <li
        >
        <a href="/page/23/" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
        </li>
        
        <li
        ><a href="/">1</a></li>
        
        <li
        ><a href="/page/2/">2</a></li>
        
        <li
        ><a href="/page/3/">3</a></li>
        
        <li
        ><a href="/page/4/">4</a></li>
        
        <li
        ><a href="/page/5/">5</a></li>
        
        <li
        ><a href="/page/6/">6</a></li>
        
        <li
        ><a href="/page/7/">7</a></li>
        
        <li
        ><a href="/page/8/">8</a></li>
        
        <li
        ><a href="/page/9/">9</a></li>
        
        <li
        ><a href="/page/10/">10</a></li>
        
        <li
        ><a href="/page/11/">11</a></li>
        
        <li
        ><a href="/page/12/">12</a></li>
        
        <li
        ><a href="/page/13/">13</a></li>
        
        <li
        ><a href="/page/14/">14</a></li>
        
        <li
        ><a href="/page/15/">15</a></li>
        
        <li
        ><a href="/page/16/">16</a></li>
        
        <li
        ><a href="/page/17/">17</a></li>
        
        <li
        ><a href="/page/18/">18</a></li>
        
        <li
        ><a href="/page/19/">19</a></li>
        
        <li
        ><a href="/page/20/">20</a></li>
        
        <li
        ><a href="/page/21/">21</a></li>
        
        <li
        ><a href="/page/22/">22</a></li>
        
        <li
        ><a href="/page/23/">23</a></li>
        
        <li
        class="active"><a href="/page/24/">24</a></li>
        
        <li
        ><a href="/page/25/">25</a></li>
        
        <li
        ><a href="/page/26/">26</a></li>
        
        <li
        ><a href="/page/27/">27</a></li>
        
        <li
        ><a href="/page/28/">28</a></li>
        
        <li
        ><a href="/page/29/">29</a></li>
        
        <li
        ><a href="/page/30/">30</a></li>
        
        <li
        ><a href="/page/31/">31</a></li>
        
        <li
        ><a href="/page/32/">32</a></li>
        
        <li
        ><a href="/page/33/">33</a></li>
        
        <li
        ><a href="/page/34/">34</a></li>
        
        <li
        ><a href="/page/35/">35</a></li>
        
        <li
        ><a href="/page/36/">36</a></li>
        
        <li
        ><a href="/page/37/">37</a></li>
        
        <li
        ><a href="/page/38/">38</a></li>
        
        <li
        ><a href="/page/39/">39</a></li>
        
        <li
        ><a href="/page/40/">40</a></li>
        
        <li
        ><a href="/page/41/">41</a></li>
        
        <li
        ><a href="/page/42/">42</a></li>
        
        <li
        ><a href="/page/43/">43</a></li>
        
        <li
        ><a href="/page/44/">44</a></li>
        
        <li
        ><a href="/page/45/">45</a></li>
        
        <li
        ><a href="/page/46/">46</a></li>
        
        <li
        >
        <a href="/page/25/" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
        </li>
        
        <li>
            <a href="/page/46/" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
        </li>
        
    </ul>
    
  </div>
</div>


<script type="text/javascript">
var disqus_shortname = "abeliu";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>

<script src="http://liuxueyang.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

