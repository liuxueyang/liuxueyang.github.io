<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.20.1" />
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>黑历史 &middot; liuxueyang</title>

  
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/highlight/sunburst.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://liuxueyang.github.io/touch-icon-144-precomposed.png">
  <link href="http://liuxueyang.github.io/favicon.png" rel="icon">

  
  
  
  <link href="http://liuxueyang.github.io/index.xml" rel="alternate" type="application/rss+xml" title="黑历史 &middot; liuxueyang" />

  <meta name="description" content="This is my Notes">
  <meta name="keywords" content="Notes,Diary">
  
</head>
<body class="theme-base-08">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
        <img src="https://www.gravatar.com/avatar/2e3a2be066049f38f7a3f80eff0a5400?s=200"
             alt="gravatar" title="liuxueyang">
      
      <h1>liuxueyang</h1>
      <p class="lead">THE LAST ONE.</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="http://liuxueyang.github.io/">Blog</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="http://github.com/liuxueyang"><i class="fa fa-github-square fa-3x"></i></a>
      
      
      
      
      
      
      
      
      </li>
    </ul>

    

    <p>Copyright &copy; 2017 <a href="http://liuxueyang.github.io/license/">License</a><br/>
       Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>
  </div>
</div>


<div class="content container">
  <div class="posts">
    
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1284-%E9%92%B1%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-dp/">hdu1284 钱币兑换问题 ——DP</a>
      </h1>
      <span class="post-date">May 23, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1284-%E9%92%B1%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-dp/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1284 题目大意： 中文题…… 题目思路： 只有3个硬币，范围是32768，可以一个一个枚举硬币，如果只放价值为1的硬币，从d[1]递推到d[n]；如果再加上价值为2的硬币，那么就从d[2]递推到d[n]；在加上价值为3的硬币，就从d[3]递推到d[n].递推公式是d[j] = d[j] + d[j-i]； d[j]表示j有几种只用1，2, 3这三个数字的拆分方法，i 就是硬币的价值。 #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&quot;%d&quot;, &amp;n)) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &lt;= 3; ++i) { for (j = i; j &lt;= n; ++j) { d[j] += d[j-i]; } } printf(&quot;%lld\n&quot;, d[n]); } } int main(void) { solve(); return 0; }   参考博客：http://www.
      <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1284-%E9%92%B1%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-dp/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1028-ignatius-and-the-princess-iii-dp/">hdu1028 Ignatius and the Princess III ——DP</a>
      </h1>
      <span class="post-date">May 23, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1028-ignatius-and-the-princess-iii-dp/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1028 题目大意：　整数拆分，给一个整数n,求它有多少种拆分方法。 题目思路： 做法一： d[i][j]表示把整数 i 拆成最多 j 个数字所具有的方法数。那么 if (i &gt;ｊ)　d[i][j] = d[i-j][j] + d[i][j-1]; 意思就是如果i&gt;j，那么有两种方式：一种是先把i里面分理处j个1，然后再把i-j拆成最多i-j个数字；另一种是把i拆分成最多j-1个数字。 if (i &lt; j) d[i][j] = d[i][i]; 意思就是如果i&lt;j，那么这种情况和把数字i最多拆成i个数字的是一样的。 if (i == j) d[i][j] = d[i][j-1] + 1; 意思就是如果i==j，那么可以把数字i拆分成j-1个数字，也可以把数字i拆分成i个1（这个就是那个1的意义） #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; using namespace std; #define LL long long int d[140][140], n; void init() { while (~scanf(&quot;%d&quot;, &amp;n)) { int i, j; memset(d, 0, sizeof(d)); for (i = 0; i &lt;= n; ++i) d[i][1] = d[1][i] = 1; for (i = 2; i &lt;= n; ++i) { for (j = 1; j &lt;= n; ++j) { if (i &gt; j) d[i][j] = d[i-j][j] + d[i][j-1]; else if (i == j) d[i][j] = 1 + d[i][j-1]; else d[i][j] = d[i][i]; } } cout &lt;&lt; d[n][n] &lt;&lt; endl; } } int main(void) { init(); return 0 ; }   剩下的就是考虑一下边界，比如当 i 或者 j 等于1的时候，显然都是只有一种拆分情况。 做法二： 借用hdu1284这道题的方法，也可以做这道题目，因为n的范围是120嘛,两个算法的复杂度都是O(n^2)的，当然可以了。只需要把hdu1284的代码里面把3改成n，这题就过了…… #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&quot;%d&quot;, &amp;n)) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &lt;= n; ++i) { for (j = i; j &lt;= n; ++j) { d[j] += d[j-i]; } } printf(&quot;%lld\n&quot;, d[n]); } } int main(void) { solve(); return 0; }   优化到了一维数组，这个方法碉堡了…… 参考博客：http://www.
      <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1028-ignatius-and-the-princess-iii-dp/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1394-minimum-inversion-number-%E7%BA%BF%E6%AE%B5%E6%A0%91/">hdu1394 Minimum Inversion Number ——线段树</a>
      </h1>
      <span class="post-date">May 23, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/23/hdu1394-minimum-inversion-number-%E7%BA%BF%E6%AE%B5%E6%A0%91/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1394 题目大意： 给定一个0到ｎ-1的数字组成的序列，它的逆序数，然后把第一个数字放到末尾，得到一个新的序列，再求逆序数，再把新序列的第一个数字放到末尾，一直这样做，求所有这些序列的逆序数的最小值。 题目思路： 可以先求出起初的序列的逆序数。然后根据逆序数的定义，把一个数字从开头移动到末尾，逆序数的改变量是什么？求出这个改变量，然后剩下的所有序列的逆序数就都求出来了。 这样考虑：一个数字 ｂ[i] 在开头，比它大的数字有 ｂ[i] 个，也就是说和这个数字组成了 ｂ[i] 个逆序，把它放到最后，这个数字可以组成 n-1-ｂ[i] 个逆序，所以逆序数的增量是 n - 1 - ｂ[i] - ｂ[i] ，这样就可以根据原来的序列的逆序数求出剩下的所有序列的逆序数了～
#include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; using namespace std; const int MAX = 5000+10; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 int a[MAX&lt;&lt;2], b[MAX], n; void pushup(int rt) { a[rt] = a[rt&lt;&lt;1] + a[rt&lt;&lt;1|1]; } void build(int l, int r, int rt) { if (l == r) {a[rt] = 0; return;} int m = (l + r) &gt;&gt; 1; build(lson); build(rson); pushup(rt); } void update(int p, int l, int r, int rt) { if (l == r) {a[rt]++; return;} int m = (l + r) &gt;&gt; 1; if (p &lt;= m) update(p, lson); else update(p, rson); pushup(rt); } int query(int L, int R,int l, int r, int rt) { if (L &lt;= l &amp;&amp; R &gt;= r) {return a[rt];} int m = (l + r) &gt;&gt; 1, ret = 0; if (L &lt;= m) ret += query(L, R, lson); if (R &gt; m) ret += query(L, R, rson); return ret; } void init() { while (~scanf(&quot;%d&quot;, &amp;n)) { int i, sum = 0, ans; build(0, n - 1, 1); for (i = 0; i &lt; n; ++i) { scanf(&quot;%d&quot;, b+i); sum += query(b[i]+1, n-1, 0, n-1, 1); update(b[i], 0, n-1, 1); } ans = sum; for (i = 0; i &lt; n; ++i) { sum += (n-1-2*b[i]); if (sum &lt; ans) ans = sum; } printf(&quot;%d\n&quot;, ans); } } int main(void) { init(); return 0; }  这题是线段树的单点更新
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/23/poj2299-ultra-quicksort-%E7%BA%BF%E6%AE%B5%E6%A0%91/">poj2299 Ultra-QuickSort ——线段树</a>
      </h1>
      <span class="post-date">May 23, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/23/poj2299-ultra-quicksort-%E7%BA%BF%E6%AE%B5%E6%A0%91/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://poj.org/problem?id=2299 题目大意： 给n个任意的数字，把他们排序，求最少的交换次数。 题目思路： 开始没想法。后来zjl一说才知道。原来就是求逆序数！每一个数字前面有多少比它小的，这个数字就至少要交换多少次。所以，只需要求这列数字的逆序数就可以！好神奇 还有一个，就是每个数字的范围比较大，开始我还在想开数组貌似放不下，后来zjl说离散化……好吧，果然，我肿么没想到o(╯□╰)o感觉挺自然的想法啊…… 剩下的就是原来做过的题目了……甚至比原来做过的还简单 最后一个问题就是，最后的结果应该是long long 的，稍微算一下就知道，最大值(2*10^11)超过了4个字节的整型范围(4 * 10^9)，long long 范围是(1*10^19)，所以输出要按照long long 输出……这个问题以后一定要注意，判断一下数字的范围！别傻乎乎地就用int…… //#define LOCAL #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cctype&gt; #include &lt;stack&gt; #include &lt;queue&gt; #include &lt;deque&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;cmath&gt; #include &lt;algorithm&gt; #define lson l, m, rt&lt;&lt;1 #define rson m+1, r, rt&lt;&lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 500000+10; typedef struct node { int val, index; bool operator &lt; (const node &amp; other) const { return val &lt; other.
      <a href="http://liuxueyang.github.io/blog/2013/05/23/poj2299-ultra-quicksort-%E7%BA%BF%E6%AE%B5%E6%A0%91/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/22/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-7.1.1-%E9%99%A4%E6%B3%95/">入门经典 7.1.1 除法</a>
      </h1>
      <span class="post-date">May 22, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/22/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-7.1.1-%E9%99%A4%E6%B3%95/#disqus_thread">Comments</a>
      </span>
      
      开始没思路，但是仔细思考一下，发现可以枚举，然后找一下上界和下界，可以知道范围并不大。我的枚举量是将近50000的样子，书上说枚举量可以降低到10000……没懂，再想一下
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;map&gt; using namespace std; map&lt;int, bool&gt; mymap; void solve(int i) { while (i) { mymap[i%10] = true; i /= 10; } } void init() { int n, i, j; while (~scanf(&quot;%d&quot;, &amp;n)) { for (i = 1200; i &lt; 50000; ++i) { if ((i*n)/10000 == 0 || (i*n)/10000 &gt;= 10) continue; mymap.clear(); solve(i); solve(i * n); if (i/10000 == 0) mymap[0] = true; for (j = 0; j &lt; 10; ++j) { if (!
      <a href="http://liuxueyang.github.io/blog/2013/05/22/%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8-7.1.1-%E9%99%A4%E6%B3%95/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/21/uva11078-open-credit-system/">uva11078 Open Credit System</a>
      </h1>
      <span class="post-date">May 21, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/21/uva11078-open-credit-system/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2019 题目大意： 给一个长度为n的序列，求Ai - Aj (i &lt; j)的最大值。序列的长度最大是10^5 题目思路： 动态维护某一个数字之前的最大值，不断更新之。同时不断更新结果ans，更新的方法是ans和当前数字之前的最大值与这个数字作差，取其中的最大值。时间复杂度O(N),空间复杂度O(1)
#include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; using namespace std; void solve() { int t; scanf(&quot;%d&quot;, &amp;t); while (t--) { int n; scanf(&quot;%d&quot;, &amp;n); int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); int i, Max = max(a,b), ans = a - b; for (i = 0; i &lt; n - 2; ++i) { scanf(&quot;%d&quot;, &amp;b); ans = max(ans, Max - b); Max = max(Max, b); } printf(&quot;%d\n&quot;, ans); } } int main(void) { //freopen(&quot;11078.
      <a href="http://liuxueyang.github.io/blog/2013/05/21/uva11078-open-credit-system/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/21/uva11462-age-sort-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/">uva11462 Age Sort ——计数排序</a>
      </h1>
      <span class="post-date">May 21, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/21/uva11462-age-sort-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2457 题目大意： 给很多个范围在１到１００之内的数字，数量最多有2*10^6个，排序输出。 题目思路： 数组很大，超内存。不能快排。所以采用计数排序
#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; using namespace std; int a[120]; void solve() { int n, tmp, i, j; while (~scanf(&quot;%d&quot;, &amp;n)) { if (!n) break; memset(a, 0, sizeof(a)); for (i = 0; i &lt; n; ++i) { scanf(&quot;%d&quot;, &amp;tmp); a[tmp]++; } bool mrk = true; for (i = 1; i &lt;= 100; ++i) { for (j = 0; j &lt; a[i]; ++j) { if (!
      <a href="http://liuxueyang.github.io/blog/2013/05/21/uva11462-age-sort-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/21/usaco-friday-the-thirteenth-%E6%B0%B4%E9%A2%98/">USACO Friday the Thirteenth ——水题</a>
      </h1>
      <span class="post-date">May 21, 2013 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/21/usaco-friday-the-thirteenth-%E6%B0%B4%E9%A2%98/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://cerberus.delos.com:790/usacoprob2?a=EYxUgMg3whp&amp;S=friday 题目大意： 意思比较简单。求1900年到1900+N年的每个月的13号落在了星期几。输出13号落在一个星期的每一天的次数。 题目思路： 方法一： 有个蔡勒公式： 这个公式可以根据某天的日期，算出这一天是星期几，套用一下就行了。 公式中的符號含義如下： ——选自维基百科 /* ID: zypz457 LANG: C++ TASK: friday */ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cmath&gt; using namespace std; int n; int cnt[7]; int cal(int y, int m, int d) { int month = m, c; if (month == 1) { month = 13; y--; } else if (month == 2) { month = 14; y--; } else {month = m;} m = month; c = y/100; y = y%100; int ans = (y + y/4 + floor(c/4) -2*c + floor(26*(m+1)/10) + d - 1); ans = (ans%7 + 7) % 7; return ans; } void solve() { scanf(&quot;%d&quot;, &amp;n); memset(cnt, 0, sizeof(cnt)); int y, j, i, month, ans; for (i = 0; i &lt; n; ++i) { y = i + 1900; for (j = 1; j &lt;= 12; ++j) { ans = cal(y, j, 13); cnt[ans]++; } } printf(&quot;%d &quot;, cnt[6]); for (i = 0; i &lt; 5; ++i) printf(&quot;%d &quot;, cnt[i]); printf(&quot;%d\n&quot;, cnt[5]); } int main(void) { freopen(&quot;friday.
      <a href="http://liuxueyang.github.io/blog/2013/05/21/usaco-friday-the-thirteenth-%E6%B0%B4%E9%A2%98/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/21/usaco-greedy-gift-givers-%E6%B0%B4%E9%A2%98/">USACO Greedy Gift Givers ——水题</a>
      </h1>
      <span class="post-date">May 21, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/21/usaco-greedy-gift-givers-%E6%B0%B4%E9%A2%98/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://cerberus.delos.com:790/usacoprob2?S=gift1&amp;a=nR34fDHld4J 题目大意：http://blog.sina.com.cn/s/blog_63d0cab00100h1rx.html 赶脚这货考的是英语……
/* ID: zypz457 LANG: C++ TASK: gift1 */ #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;map&gt; using namespace std; int n; map&lt;string, int&gt; mymap; int wei[15][2]; string name[20]; void init() { int i; freopen(&quot;gift1.in&quot;, &quot;r&quot;, stdin); freopen(&quot;gift1.out&quot;, &quot;w&quot;, stdout); memset(wei, 0, sizeof(wei)); scanf(&quot;%d&quot;, &amp;n); for (i = 0; i &lt; n; ++i) { cin &gt;&gt; name[i]; mymap[name[i]] = i; } string str, str1; while (cin &gt;&gt; str) { int cnt, id, recid, i; id = mymap[str]; scanf(&quot;%d%d&quot;, &amp;wei[id][0], &amp;cnt); for (i = 0; i &lt; cnt;++i) { cin &gt;&gt; str1; recid = mymap[str1]; int tmp = wei[id][0] / cnt; wei[id][0] = tmp * cnt; wei[recid][1] += tmp; } } } void solve() { int i; for (i = 0; i &lt; n; ++i) { cout &lt;&lt; name[i] &lt;&lt; ' ' &lt;&lt; -wei[i][0]+wei[i][1]&lt;&lt;'\n'; } } int main(void) { init(); solve(); return 0; }  题目意思难理解，英语要好。 直接搜的翻译，开始真没看懂题意，当初感觉是有多难，看了翻译才发现……呵呵
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2013/05/21/usaco-your-ride-is-here-%E6%B0%B4%E9%A2%98/">USACO Your Ride Is Here ——水题</a>
      </h1>
      <span class="post-date">May 21, 2013 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2013/05/21/usaco-your-ride-is-here-%E6%B0%B4%E9%A2%98/#disqus_thread">Comments</a>
      </span>
      
      题目链接：http://cerberus.delos.com:790/usacoprob2?a=nR34fDHld4J&amp;S=ride 人家说USACO的题目适合入门……我还是先刷这个吧…… 这道题目主要是学了一下USACO里面的文件输入输出格式
/* ID: zypz457 TASK: ride LANG: C++ */ #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; #include &lt;fstream&gt; using namespace std; int main(void) { ifstream fin(&quot;ride.in&quot;); ofstream fout (&quot;ride.out&quot;); char a[10], b[10]; while (fin &gt;&gt; a &gt;&gt; b) { int sum1, sum2, i, len1, len2; len1 = strlen(a); len2 = strlen(b); sum1 = sum2 = 1; for (i = 0; i &lt; len1; ++i) { sum1 = (sum1*(a[i]-'A'+1))%47; } for (i = 0; i &lt; len2; ++i) { sum2 = (sum2*(b[i]-'A'+1))%47; } /* if (sum1 == sum2) fprintf(fout, &quot;GO\n&quot;); else fprintf(fout, &quot;STAY\n&quot;); * */ if(sum1 == sum2) fout &lt;&lt; &quot;GO\n&quot;; else fout &lt;&lt; &quot;STAY\n&quot;; } return 0; }  不用每次交题目都复制了倒是……但是格式要求挺严格的……还要有注释。。。 好吧，读文件神马的不用那么麻烦……按照原来的习惯写就行。 /* ID: zypz457 TASK: ride LANG: C++ */ #include &lt;cstdio&gt; #include &lt;cstdlib&gt; #include &lt;cstring&gt; using namespace std; int main(void) { freopen(&quot;ride.
      <a href="http://liuxueyang.github.io/blog/2013/05/21/usaco-your-ride-is-here-%E6%B0%B4%E9%A2%98/">Read On &rarr;</a>
      
    </div>
    
    
    
    <ul class="pagination">
        
        <li>
            <a href="/" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
        </li>
        
        <li
        >
        <a href="/page/26/" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
        </li>
        
        <li
        ><a href="/">1</a></li>
        
        <li
        ><a href="/page/2/">2</a></li>
        
        <li
        ><a href="/page/3/">3</a></li>
        
        <li
        ><a href="/page/4/">4</a></li>
        
        <li
        ><a href="/page/5/">5</a></li>
        
        <li
        ><a href="/page/6/">6</a></li>
        
        <li
        ><a href="/page/7/">7</a></li>
        
        <li
        ><a href="/page/8/">8</a></li>
        
        <li
        ><a href="/page/9/">9</a></li>
        
        <li
        ><a href="/page/10/">10</a></li>
        
        <li
        ><a href="/page/11/">11</a></li>
        
        <li
        ><a href="/page/12/">12</a></li>
        
        <li
        ><a href="/page/13/">13</a></li>
        
        <li
        ><a href="/page/14/">14</a></li>
        
        <li
        ><a href="/page/15/">15</a></li>
        
        <li
        ><a href="/page/16/">16</a></li>
        
        <li
        ><a href="/page/17/">17</a></li>
        
        <li
        ><a href="/page/18/">18</a></li>
        
        <li
        ><a href="/page/19/">19</a></li>
        
        <li
        ><a href="/page/20/">20</a></li>
        
        <li
        ><a href="/page/21/">21</a></li>
        
        <li
        ><a href="/page/22/">22</a></li>
        
        <li
        ><a href="/page/23/">23</a></li>
        
        <li
        ><a href="/page/24/">24</a></li>
        
        <li
        ><a href="/page/25/">25</a></li>
        
        <li
        ><a href="/page/26/">26</a></li>
        
        <li
        class="active"><a href="/page/27/">27</a></li>
        
        <li
        ><a href="/page/28/">28</a></li>
        
        <li
        ><a href="/page/29/">29</a></li>
        
        <li
        ><a href="/page/30/">30</a></li>
        
        <li
        ><a href="/page/31/">31</a></li>
        
        <li
        ><a href="/page/32/">32</a></li>
        
        <li
        ><a href="/page/33/">33</a></li>
        
        <li
        ><a href="/page/34/">34</a></li>
        
        <li
        ><a href="/page/35/">35</a></li>
        
        <li
        ><a href="/page/36/">36</a></li>
        
        <li
        ><a href="/page/37/">37</a></li>
        
        <li
        ><a href="/page/38/">38</a></li>
        
        <li
        ><a href="/page/39/">39</a></li>
        
        <li
        ><a href="/page/40/">40</a></li>
        
        <li
        ><a href="/page/41/">41</a></li>
        
        <li
        ><a href="/page/42/">42</a></li>
        
        <li
        ><a href="/page/43/">43</a></li>
        
        <li
        ><a href="/page/44/">44</a></li>
        
        <li
        ><a href="/page/45/">45</a></li>
        
        <li
        ><a href="/page/46/">46</a></li>
        
        <li
        ><a href="/page/47/">47</a></li>
        
        <li
        ><a href="/page/48/">48</a></li>
        
        <li
        >
        <a href="/page/28/" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
        </li>
        
        <li>
            <a href="/page/48/" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
        </li>
        
    </ul>
    
  </div>
</div>


<script type="text/javascript">
var disqus_shortname = "abeliu";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>

<script src="http://liuxueyang.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

