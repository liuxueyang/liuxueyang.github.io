<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.20.1" />
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>黑历史 &middot; liuxueyang</title>

  
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="http://liuxueyang.github.io/css/highlight/sunburst.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://liuxueyang.github.io/touch-icon-144-precomposed.png">
  <link href="http://liuxueyang.github.io/favicon.png" rel="icon">

  
  
  
  <link href="http://liuxueyang.github.io/index.xml" rel="alternate" type="application/rss+xml" title="黑历史 &middot; liuxueyang" />

  <meta name="description" content="This is my Notes">
  <meta name="keywords" content="Notes,Diary">
  
</head>
<body class="theme-base-08">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
        <img src="https://www.gravatar.com/avatar/2e3a2be066049f38f7a3f80eff0a5400?s=200"
             alt="gravatar" title="liuxueyang">
      
      <h1>liuxueyang</h1>
      <p class="lead">THE LAST ONE.</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="http://liuxueyang.github.io/">Blog</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="http://github.com/liuxueyang"><i class="fa fa-github-square fa-3x"></i></a>
      
      
      
      
      
      
      
      
      </li>
    </ul>

    

    <p>Copyright &copy; 2017 <a href="http://liuxueyang.github.io/license/">License</a><br/>
       Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>
  </div>
</div>


<div class="content container">
  <div class="posts">
    
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/07/25/spoj-segment-tree-gss1---can-you-answer-these-queries-i/">spoj, segment tree: GSS1 - Can you answer these queries I</a>
      </h1>
      <span class="post-date">Jul 25, 2016 &middot; 3 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/07/25/spoj-segment-tree-gss1---can-you-answer-these-queries-i/#disqus_thread">Comments</a>
      </span>
      
      Problem Link
max sum of a sequence can be from one of the three:
1. left half of the sequence 2. right half of the sequence 3. left half + right half  segment tree range query
#include &lt;iostream&gt; using namespace std; struct SegmentTreeNode { int pre, suf, sub, total; void assignLeaf(int value) { pre = suf = sub = total = value; } void merge(SegmentTreeNode &amp;left, SegmentTreeNode &amp;right) { pre = max(left.
      <a href="http://liuxueyang.github.io/blog/2016/07/25/spoj-segment-tree-gss1---can-you-answer-these-queries-i/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/07/25/spoj-segment-tree-brckts---brackets/">spoj, segment tree: BRCKTS - Brackets</a>
      </h1>
      <span class="post-date">Jul 25, 2016 &middot; 3 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/07/25/spoj-segment-tree-brckts---brackets/#disqus_thread">Comments</a>
      </span>
      
      Problem Link
开始没有读懂题目，合法括号的意思其实就是常识情况下的括号合法：整个序列的左括号数目和右括号的数目相同，但是也不能出现这样的：)))(((，所以还要保证在任意一点，左括号的数目大于等于右括号的数目。
这就需要，在序列里面任意一点，左边的不匹配的左括号的数目一定等于右边的不匹配右括号的数目。
平常的线段树的点更新和区间查询
#include &lt;iostream&gt; using namespace std; struct SegmentTreeNode { int unmatchedLeft, unmatchedRight; void assignLeaf(char value) { if (value == '(') { unmatchedLeft = 1; unmatchedRight = 0; } else { unmatchedLeft = 0; unmatchedRight = 1; } } void merge(SegmentTreeNode &amp;left, SegmentTreeNode &amp;right) { int L_unl = left.unmatchedLeft, L_unr = left.unmatchedRight, R_unl = right.unmatchedLeft, R_unr = right.unmatchedRight; int matched = min(L_unl, R_unr); unmatchedLeft = L_unl + R_unl - matched; unmatchedRight = L_unr + R_unr - matched; return; } bool getValue() { return unmatchedRight == 0 &amp;&amp; unmatchedLeft == 0; } }; template &lt;class T, class V&gt; class SegmentTree { SegmentTreeNode *nodes; int N; public: SegmentTree(T arr[], int N) { this-&gt;N = N; nodes = new SegmentTreeNode[getSegmentTreeSize(N)]; buildTree(arr, 1, 0, N - 1); } ~SegmentTree() { delete[] nodes; } V getValue(int lo, int hi) { SegmentTreeNode result = getValue(1, 0, N - 1, lo, hi); return result.
      <a href="http://liuxueyang.github.io/blog/2016/07/25/spoj-segment-tree-brckts---brackets/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/07/25/spoj-segment-tree-akvqld03---how-to-handle-the-fans/">spoj, segment tree: AKVQLD03 - How to Handle the Fans</a>
      </h1>
      <span class="post-date">Jul 25, 2016 &middot; 2 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/07/25/spoj-segment-tree-akvqld03---how-to-handle-the-fans/#disqus_thread">Comments</a>
      </span>
      
      Problem Link
平常的线段树点更新和区间查询
#include &lt;iostream&gt; #include &lt;string.h&gt; using namespace std; struct SegmentTreeNode { // fields on the node long long sum; void assignLeaf(int value) { sum = value; } void merge(SegmentTreeNode &amp;left, SegmentTreeNode &amp;right) { sum = left.sum + right.sum; } long long getValue() { return sum; } }; template &lt;class T, class V&gt; class SegmentTree { SegmentTreeNode *nodes; int N; public: SegmentTree(T arr[], int N) { this-&gt;N = N; nodes = new SegmentTreeNode[getSegmentTreeSize(N)]; buildTree(arr, 1, 0, N - 1); } ~SegmentTree() { delete[] nodes; } V getValue(int lo, int hi) { SegmentTreeNode result = getValue(1, 0, N - 1, lo, hi); return result.
      <a href="http://liuxueyang.github.io/blog/2016/07/25/spoj-segment-tree-akvqld03---how-to-handle-the-fans/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/07/25/segment-tree-lazy-propagation-codechef-flipping-coins/">segment tree, lazy propagation, codechef: Flipping Coins</a>
      </h1>
      <span class="post-date">Jul 25, 2016 &middot; 3 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/07/25/segment-tree-lazy-propagation-codechef-flipping-coins/#disqus_thread">Comments</a>
      </span>
      
      Problem Link
平常的线段树区间更新、区间查询加上懒惰更新
// 2016/07/24 22:01:19 PM // Sabastian #include &lt;iostream&gt; #include &lt;math.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; using namespace std; typedef long long ll; typedef struct TreeNode { int start, end; ll total; bool lazy; TreeNode() : total(0), lazy(false) {} void merge(TreeNode &amp; left, TreeNode &amp; right) { total = (left.lazy ? left.end - left.start + 1 - left.total : left.total) + (right.lazy ? right.end - right.start + 1 - right.
      <a href="http://liuxueyang.github.io/blog/2016/07/25/segment-tree-lazy-propagation-codechef-flipping-coins/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/07/11/iterm2-%E6%9F%A5%E7%9C%8B%E5%9B%BE%E7%89%87/">iTerm2 查看图片</a>
      </h1>
      <span class="post-date">Jul 11, 2016 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/07/11/iterm2-%E6%9F%A5%E7%9C%8B%E5%9B%BE%E7%89%87/#disqus_thread">Comments</a>
      </span>
      
      首先是，OS X El Capitan的几个截图技巧：
 ⌘ + ⇪ + 3 ：全屏截图，并且把截图保存在桌面。 ⌘ + ⇪ + 4 ：区域截图，可以自由拖动大小，松开触摸板自动保存截图到桌面。 ⌘ + ⇪ + 4 ，然后，单击空格键，可以选定窗口截图。（这么好用的快捷键我很长时间都不知道……） ⌘ + ⇪ + 4，然后用触摸板选定一个矩形区域，然后，按住空格键，再拖动鼠标，就可以发现，矩形区域跟随鼠标移动，但是大小不变。 ⌘ + ⇪ + 4，选定一个矩形区域，然后，按住 ⇪ 键，然后鼠标如果在左右方向移动，那么你可以发现矩形区域高度被锁定；如果在按住 ⇪ 键的同时，鼠标在上下方向移动，那么左右方向被锁定。 ⌘ + ⇪ + 4，选定一个矩形区域，按住 ⇪ 和 ⌥ 键，再拖动鼠标，可以发现，矩形区域在锁定一个方向的基础上，在水平或者数值方向上呈对称性变化。  在终端里面的时候，有时需要查看一下图片到底是不是想要的那一张，然而并不想在打开finder看，所以，这个功能就比较有用了，如图：
更多用法，看这里
      
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/07/03/poj3320-jessicas-reading-problem/">POJ3320 Jessica&#39;s Reading Problem</a>
      </h1>
      <span class="post-date">Jul 3, 2016 &middot; 1 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/07/03/poj3320-jessicas-reading-problem/#disqus_thread">Comments</a>
      </span>
      
      Problem Jessica&rsquo;s Reading Problem
Solution 方法和Subsequence一样，只是增加一个计数的步骤。
Code C++ #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;set&gt; using namespace std; const int MAX_N = 100 * 10000 + 1; int a[MAX_N], n; set&lt;int&gt; idea; map&lt;int, int&gt; num_idea; void solve() { idea.clear(); num_idea.clear(); for (int i = 0; i &lt; n; ++i) { idea.insert(a[i]); } int all_ideas = (int)idea.size(); int s = 0, t = 0, cnt = 0, ans = n + 1; while (true) { while (t &lt; n &amp;&amp; cnt &lt; all_ideas) { if (num_idea[a[t]] == 0) { cnt++; } num_idea[a[t]]++; ++t; } if (cnt &lt; all_ideas) { break; } ans = min(ans, t - s); num_idea[a[s]]--; if (num_idea[a[s]] == 0) { num_idea.
      <a href="http://liuxueyang.github.io/blog/2016/07/03/poj3320-jessicas-reading-problem/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/07/02/poj3061-subsequence/">Poj3061 Subsequence</a>
      </h1>
      <span class="post-date">Jul 2, 2016 &middot; 3 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/07/02/poj3061-subsequence/#disqus_thread">Comments</a>
      </span>
      
      Problem Subsequence
Solution 方法一：O(nlogn)
1. 计算前序和 2. 定起点，二分找不小于S的最小的连续区间和  方法二：O(n)
1. 定起点，线性找不小于S的最小的连续区间和，得到一个终点 2. 把起点向右移动一个单位，把终点在原来的基础上递增，线性找不小于S的最小的连 续区间和。如此反复。  Code 方法一：
C++ #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; int N, S; vector&lt;int&gt; a, presum; void solve() { cin &gt;&gt; N &gt;&gt; S; presum.clear(); a.clear(); a.reserve(N); presum.reserve(N + 1); for (int i = 0; i &lt; N; ++i) { int tmp; cin &gt;&gt; tmp; a.push_back(tmp); } // presum[i] means sum of [0, i) elements // j &gt; i, presum[j] - presum[i] means sum of [i, j) elements presum.
      <a href="http://liuxueyang.github.io/blog/2016/07/02/poj3061-subsequence/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/07/01/educational-codeforces-round-10.-d.-nested-segments-c---perl-and-common-lisp-implementation-segment-tree/">Educational Codeforces Round 10. D. Nested Segments: c&#43;&#43;, perl and common lisp implementation, Segment Tree</a>
      </h1>
      <span class="post-date">Jul 1, 2016 &middot; 4 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/07/01/educational-codeforces-round-10.-d.-nested-segments-c---perl-and-common-lisp-implementation-segment-tree/#disqus_thread">Comments</a>
      </span>
      
      Problem Link
Fenwick Tree，它的本质就是把一个序列的和划分成一个个子序列的和。比如一个序列的长 度是10，那么10的二进制是1010，也就是2^1 + 2^3，所以结果就是树里面2和8两个节点的 和。在树里面，节点（n）表示数列里从1到n的元素的和，那么：
 (1) = (1) (2) = (2) (3) = (1) + (2) (4) = (4) (5) = (1) + (4) (6) = (2) + (4)   按照右端点排序，然后把它离散化； 按照左端点倒序排列，从大到小循环，计算右端点在Fenwick Tree里面的presum（也就 是之前插入的比当前右端点小的数量），这个presum就是当前的segment包含的segment 的个数； 把当前右端点插入Fewnwick Tree；  题目要求计算每个端点包含的segment的数量，因为后面要用到排序和离散化，所以可以在 结构体或者类中增加一个域表示它原来在数组中的初始位置。每计算一个presum就可以根据 这个域放到结果数组里面的对应位置。
C++ #include &lt;bits/stdc++.h&gt; using namespace std; struct segment { int x, y, position; }; const int N = 2e5 + 1; int n, fenwick[N]; long long ans[N]; segment S[N]; int cmpx_r(segment a, segment b) { return a.
      <a href="http://liuxueyang.github.io/blog/2016/07/01/educational-codeforces-round-10.-d.-nested-segments-c---perl-and-common-lisp-implementation-segment-tree/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/06/30/binary-search-tree-perl-and-common-lisp-implementation/">Binary Search Tree: Perl and Common Lisp implementation</a>
      </h1>
      <span class="post-date">Jun 30, 2016 &middot; 3 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/06/30/binary-search-tree-perl-and-common-lisp-implementation/#disqus_thread">Comments</a>
      </span>
      
      Perl #!perl use strict; use warnings; use utf8; use 5.014; # insert given value into the proper position. If no tree provided, # use implicit pass by reference aspect of @_ to fill one. sub insert { my($tree, $value) = @_; unless ($tree) { $tree = {}; $tree-&gt;{VALUE} = $value; $tree-&gt;{LEFT} = undef; $tree-&gt;{RIGHT} = undef; $_[0] = $tree; # $_[0] is reference param return; } if ($tree-&gt;{VALUE} &gt; $value) { insert($tree-&gt;{LEFT}, $value) } elsif ($tree-&gt;{VALUE} &lt; $value) { insert($tree-&gt;{RIGHT}, $value) } else { warn &quot;duplicate insert of $value\n&quot; } } sub in_order { my($tree) = @_; return unless $tree; in_order($tree-&gt;{LEFT}); print $tree-&gt;{VALUE}, &quot; &quot;; in_order($tree-&gt;{RIGHT}); } sub pre_order { my($tree) = @_; return unless $tree; print $tree-&gt;{VALUE}, &quot; &quot;; pre_order($tree-&gt;{LEFT}); pre_order($tree-&gt;{RIGHT}); } sub post_order { my($tree) = @_; return unless $tree; post_order($tree-&gt;{LEFT}); post_order($tree-&gt;{RIGHT}); print $tree-&gt;{VALUE}, &quot; &quot;; } sub search { my($tree, $value) = @_; return unless $tree; return $tree if ($tree-&gt;{VALUE} == $value); search ($tree-&gt;{ ($value &lt; $tree-&gt;{VALUE}) ?
      <a href="http://liuxueyang.github.io/blog/2016/06/30/binary-search-tree-perl-and-common-lisp-implementation/">Read On &rarr;</a>
      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="http://liuxueyang.github.io/blog/2016/06/27/lowest-common-ancestor-in-binary-tree-perl-c-and-common-lisp-implementation/">Lowest common ancestor in binary tree: perl, c and common lisp implementation</a>
      </h1>
      <span class="post-date">Jun 27, 2016 &middot; 3 minute read &middot; <a href="http://liuxueyang.github.io/blog/2016/06/27/lowest-common-ancestor-in-binary-tree-perl-c-and-common-lisp-implementation/#disqus_thread">Comments</a>
      </span>
      
      Find lowest common ancestor in binary tree. We assume the values in the tree are unique and the two values are always in the tree.
Time complexity O(n), Space complexity O(n)
C: #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // Find lowest common ancestor in binary tree. We assume the // values in the tree are unique and the two values are always in // the tree. // Time complexity O(n) // Space complexity O(n) typedef struct Node { int key; struct Node *left, *right; } Node; Node* createNode(int key) { Node * tmp = (Node*)malloc(sizeof(Node)); tmp-&gt;key = key; tmp-&gt;left = tmp-&gt;right = NULL; return tmp; } Node* findLCA(Node* root, int n1, int n2) { if (root == NULL) { return NULL; } if (n1 == root-&gt;key || n2 == root-&gt;key) { return root; } Node* left = findLCA(root-&gt;left, n1, n2); Node* right = findLCA(root-&gt;right, n1, n2); if (left &amp;&amp; right) { return root; } return left ?
      <a href="http://liuxueyang.github.io/blog/2016/06/27/lowest-common-ancestor-in-binary-tree-perl-c-and-common-lisp-implementation/">Read On &rarr;</a>
      
    </div>
    
    
    
    <ul class="pagination">
        
        <li>
            <a href="/" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
        </li>
        
        <li
        >
        <a href="/page/5/" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
        </li>
        
        <li
        ><a href="/">1</a></li>
        
        <li
        ><a href="/page/2/">2</a></li>
        
        <li
        ><a href="/page/3/">3</a></li>
        
        <li
        ><a href="/page/4/">4</a></li>
        
        <li
        ><a href="/page/5/">5</a></li>
        
        <li
        class="active"><a href="/page/6/">6</a></li>
        
        <li
        ><a href="/page/7/">7</a></li>
        
        <li
        ><a href="/page/8/">8</a></li>
        
        <li
        ><a href="/page/9/">9</a></li>
        
        <li
        ><a href="/page/10/">10</a></li>
        
        <li
        ><a href="/page/11/">11</a></li>
        
        <li
        ><a href="/page/12/">12</a></li>
        
        <li
        ><a href="/page/13/">13</a></li>
        
        <li
        ><a href="/page/14/">14</a></li>
        
        <li
        ><a href="/page/15/">15</a></li>
        
        <li
        ><a href="/page/16/">16</a></li>
        
        <li
        ><a href="/page/17/">17</a></li>
        
        <li
        ><a href="/page/18/">18</a></li>
        
        <li
        ><a href="/page/19/">19</a></li>
        
        <li
        ><a href="/page/20/">20</a></li>
        
        <li
        ><a href="/page/21/">21</a></li>
        
        <li
        ><a href="/page/22/">22</a></li>
        
        <li
        ><a href="/page/23/">23</a></li>
        
        <li
        ><a href="/page/24/">24</a></li>
        
        <li
        ><a href="/page/25/">25</a></li>
        
        <li
        ><a href="/page/26/">26</a></li>
        
        <li
        ><a href="/page/27/">27</a></li>
        
        <li
        ><a href="/page/28/">28</a></li>
        
        <li
        ><a href="/page/29/">29</a></li>
        
        <li
        ><a href="/page/30/">30</a></li>
        
        <li
        ><a href="/page/31/">31</a></li>
        
        <li
        ><a href="/page/32/">32</a></li>
        
        <li
        ><a href="/page/33/">33</a></li>
        
        <li
        ><a href="/page/34/">34</a></li>
        
        <li
        ><a href="/page/35/">35</a></li>
        
        <li
        ><a href="/page/36/">36</a></li>
        
        <li
        ><a href="/page/37/">37</a></li>
        
        <li
        ><a href="/page/38/">38</a></li>
        
        <li
        ><a href="/page/39/">39</a></li>
        
        <li
        ><a href="/page/40/">40</a></li>
        
        <li
        ><a href="/page/41/">41</a></li>
        
        <li
        ><a href="/page/42/">42</a></li>
        
        <li
        ><a href="/page/43/">43</a></li>
        
        <li
        ><a href="/page/44/">44</a></li>
        
        <li
        ><a href="/page/45/">45</a></li>
        
        <li
        ><a href="/page/46/">46</a></li>
        
        <li
        ><a href="/page/47/">47</a></li>
        
        <li
        ><a href="/page/48/">48</a></li>
        
        <li
        >
        <a href="/page/7/" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
        </li>
        
        <li>
            <a href="/page/48/" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
        </li>
        
    </ul>
    
  </div>
</div>


<script type="text/javascript">
var disqus_shortname = "abeliu";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>

<script src="http://liuxueyang.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

