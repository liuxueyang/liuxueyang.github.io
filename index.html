<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="黑历史">
<meta property="og:url" content="liuxueyang.github.io/index.html">
<meta property="og:site_name" content="黑历史">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黑历史">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="liuxueyang.github.io/"/>





  <title> 黑历史 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">黑历史</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="liuxueyang.github.io/2017/04/12/Haskell-笔记7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liuxueyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/drawing.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑历史">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/12/Haskell-笔记7/" itemprop="url">
                  Haskell 笔记7
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T11:16:43+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这是一些阅读<a href="http://learnyouahaskell.com" target="_blank" rel="external">Learn You a Haskell for Great Good!</a>的时候的笔记，之前用Latex写的，放在Dropbox里面，现在想把它们整理一下，放在博客里。这是<a href="http://learnyouahaskell.com/modules" target="_blank" rel="external">第七章 Modules</a>的笔记。</p>
<h2 id="Loading-modules"><a href="#Loading-modules" class="headerlink" title="Loading modules"></a>Loading modules</h2><p>之前用TeXmacs虽然挺方便，但还是感觉有点不舒服。所以还是换回来吧。</p>
<p>在默认的Prelude模块里面，已经默认引入了一些Data.List中的函数。另外，引入Data.List模块的时候不需要使用带限定符的方法，因为Prelude里面的函数除了默认引入的Data.List的部分函数以外，不会和Data.List里面的其它函数命名冲突。然而，如果再引用其它模块的时候就不一定了。一般情况下只需要用一般的引入模块的方法就够了：import Data.List</p>
<h2 id="Data-List"><a href="#Data-List" class="headerlink" title="Data.List"></a>Data.List</h2><p>group这个函数，它接收一个列表，把列表中相邻并且相等的元素合成一个子列表，对于相等但是不相邻的元素，它会分别合成独立的子列表，也就是说，它并不会排序。比如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; group [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">[[<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">5</span>],[<span class="number">6</span>]]</div></pre></td></tr></table></figure>
<p>如果想要一个列表中的某个元素的个数，可以这样做：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; map (\ xs@(x : xs') -&gt; (x, length xs)) $ group . sort $ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">[(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">6</span>),(<span class="number">3</span>,<span class="number">1</span>),(<span class="number">4</span>,<span class="number">1</span>),(<span class="number">5</span>,<span class="number">1</span>),(<span class="number">6</span>,<span class="number">1</span>)]</div></pre></td></tr></table></figure>
<p>这里我用到了function composition(.)、function application($)、lambda表达式、lambda表达式中的模式匹配、用@符号来捕获整个模式（注意它的用法，用@符号来把整个模式和部分模式分隔开）。</p>
<p>init函数的意思是得到列表的前<code>n - 1</code>个元素，inits的意思是依次得到列表的前<code>0, 1, 2 ... n</code>个元素组成一个嵌套列表。</p>
<p>tail函数的意思是去掉列表的前<code>1</code>个元素，tails的意思是依次去掉列表的前<code>0, 1, 2 ... n</code>个元素组成的一个嵌套列表。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">λ&gt; init [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line">λ&gt; tail [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</div><div class="line">λ&gt; inits [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">[[],[<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</div><div class="line">λ&gt; tails [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">[[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">6</span>],[]]</div></pre></td></tr></table></figure>
<p>好像这两个比较容易弄混。可以这样记：tails就代表一个列表的尾部，从最大的尾巴（整个列表）到最小的尾巴（空列表）组成的一个列表。<br>而inits就代表头部，从最小的头部（空列表）到最大的头部（整个列表）组成的一个列表。可以这样用：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="title">search</span> :: (<span class="type">Eq</span> a) =&gt; [a] -&gt; [a] -&gt; <span class="type">Bool</span></div><div class="line"><span class="title">search</span> smallList bigList = foldl (\ accu xs -&gt;</div><div class="line">                                    <span class="keyword">if</span> take (length smallList) xs == smallList</div><div class="line">                                    <span class="keyword">then</span> <span class="type">True</span></div><div class="line">                                    <span class="keyword">else</span> accu) <span class="type">False</span></div><div class="line">                           $ tails bigList</div></pre></td></tr></table></figure>
<p>这个函数用来在一个嵌套列表里面找一个子列表：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; search [<span class="number">3.</span><span class="number">.5</span>] [<span class="number">1.</span><span class="number">.7</span>]</div><div class="line"><span class="type">True</span></div><div class="line">λ&gt; search [<span class="number">3</span>, <span class="number">5</span>] [<span class="number">1.</span><span class="number">.7</span>]</div><div class="line"><span class="type">False</span></div></pre></td></tr></table></figure>
<p>最常见的应用就是在一个字符串里面找一个字符串吧，因为一个字符串也是一个列表。其实这个函数已经有库函数来实现同样的功能：isInfixOf，它接收两个列表，如果第一个列表是第二个列表的子列表那么返回真：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; isInfixOf [<span class="number">3</span>, <span class="number">5</span>] [<span class="number">1.</span><span class="number">.7</span>]</div><div class="line"><span class="type">False</span></div><div class="line">λ&gt; isInfixOf [<span class="number">3.</span><span class="number">.5</span>] [<span class="number">1.</span><span class="number">.7</span>]</div><div class="line"><span class="type">True</span></div></pre></td></tr></table></figure>
<p>类似的函数有isPrefixOf，它检查一个列表是不是另外一个列表的前缀。isSuffixOf，它检查一个列表是不是另外一个列表的后缀。</p>
<p>elem函数检查一个元素是不是存在于另外一个列表中。notElem相反。</p>
<p>partition这个函数接收一个predicate和一个列表，返回一个tuple，第一个元素是满足predicate的元素的列表，第二个元素是不满足predicate的元素的列表：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; partition (&gt; <span class="number">3</span>) [<span class="number">1.</span><span class="number">.7</span>]</div><div class="line">([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div></pre></td></tr></table></figure>
<p>这个函数和span函数是有区别的，span函数会在predicate第一次不被满足的地方把列表分割成两个列表，但是partition会遍历整个列表，把满足predicate和不满足predicate的元素分别放到一个列表里面。</p>
<p>find函数接收一个predicate和一个列表，如果列表中有一个元素满足predicate，那么立即返回用Maybe包裹起来的这个值。这个Maybe啊，其实相当于SML里面的option。它可以是<code>Nothing</code>，也可以是<code>Just n</code>。一个Maybe的类型由它所代表的类型决定，比如<code>Just 6</code>的类型就是Maybe Int。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">λ&gt; find (&gt; <span class="number">9</span>) [<span class="number">1.</span><span class="number">.7</span>]</div><div class="line"><span class="type">Nothing</span></div><div class="line">λ&gt; find (&gt; <span class="number">5</span>) [<span class="number">1.</span><span class="number">.7</span>]</div><div class="line"><span class="type">Just</span> <span class="number">6</span></div><div class="line">λ&gt; :t (find (&gt; <span class="number">9</span>) [<span class="number">1.</span><span class="number">.7</span>])</div><div class="line">(find (&gt; <span class="number">9</span>) [<span class="number">1.</span><span class="number">.7</span>]) :: (<span class="type">Enum</span> a, <span class="type">Num</span> a, <span class="type">Ord</span> a) =&gt; <span class="type">Maybe</span> a</div></pre></td></tr></table></figure>
<p>由于head函数对于空列表会抛出异常，所以这个时候find函数就是一个比较好的选择，如果有满足predicate的那么就返回一个<code>Just x</code>，如果没有那么返回一个Nothing。对于Maybe类型，后面会学到。</p>
<p>elemIndex函数和elem同样的功能，但是它会返回一个Maybe，如果要找的元素存在，那么返回<code>Just i</code>，如果不存在那么返回<code>Nothing</code>。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; elemIndex <span class="number">3</span> [<span class="number">1.</span><span class="number">.7</span>]</div><div class="line"><span class="type">Just</span> <span class="number">2</span></div><div class="line">λ&gt; elemIndex <span class="number">10</span> [<span class="number">1.</span><span class="number">.7</span>]</div><div class="line"><span class="type">Nothing</span></div></pre></td></tr></table></figure>
<p>elemIndices这个函数接收一个元素和一个列表，返回一个列表，列表中的元素代表要找的元素在列表中的所有的下标。它会遍历整个列表并返回所有出现的位置。因为它返回的是一个列表，所以不需要使用Maybe，因为可以使用空列表来代表不存在，它代替了<code>Nothing</code>的功能。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; ' ' `elemIndices` <span class="string">"Music Flavor by"</span></div><div class="line">[<span class="number">5</span>,<span class="number">12</span>]</div><div class="line">λ&gt; '<span class="type">K'</span> `elemIndices` <span class="string">"Music Flavor by"</span></div><div class="line">[]</div></pre></td></tr></table></figure>
<p>findIndex和elemIndex函数类似，但是它接收一个predicate和一个列表，返回第一个使得predicate为真的下标的Maybe。findIndices和elemIndices类似，但是它接收一个predicate和一个列表，返回一个使得predicate为真的下标的列表，或者空列表。</p>
<p>和zip、zipWith函数类似，也有zip{3..7}，zipWith{3..7}函数。比如zip4函数接收四个列表，把它们对应位置的元素打包成一个tuple。zipWith4函数接收一个函数和一个列表，把每个列表对应的元素作为函数的参数然后作为结果列表的一个元素。比如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; zip4 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>] [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</div><div class="line">[(<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">12</span>),(<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">13</span>),(<span class="number">3</span>,<span class="number">6</span>,<span class="number">11</span>,<span class="number">14</span>)]</div><div class="line">λ&gt; zipWith4 (\ x y z m -&gt; x + y + z + m) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>] [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</div><div class="line">[<span class="number">26</span>,<span class="number">30</span>,<span class="number">34</span>]</div></pre></td></tr></table></figure>
<p>注意：如果参数列表中的各个列表长度不一样的话，那么结果列表的长度和参数列表中的最短的一致。</p>
<p>lines函数接收一个字符串，根据字符串的换行符把字符串分割成一个一个字符串放到一个子列表里面：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; lines <span class="string">"Hello\nTOUCH\nSummer"</span></div><div class="line">[<span class="string">"Hello"</span>,<span class="string">"TOUCH"</span>,<span class="string">"Summer"</span>]</div></pre></td></tr></table></figure>
<p>unlines函数则相反，它接收一个字符串列表，把各个字符串用换行符连接成一个大字符串。需要注意的是，结果字符串后面会有一个换行符。不管原来列表的最后一个元素结尾是不是有换行符：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; unlines [<span class="string">"hello"</span>, <span class="string">"TOUCH"</span>, <span class="string">"Summer"</span>]</div><div class="line"><span class="string">"hello\nTOUCH\nSummer\n"</span></div><div class="line">λ&gt; unlines [<span class="string">"hello"</span>, <span class="string">"TOUCH"</span>, <span class="string">"Summer\n"</span>]</div><div class="line"><span class="string">"hello\nTOUCH\nSummer\n\n"</span></div></pre></td></tr></table></figure>
<p>words函数把一个字符串按照空格和换行符分割成多个单词，连续的空格被当作一个空格，然后把这些单词放在结果列表里面。unwords函数接收一个单词列表，把他们用空格连接起来成为一个字符串。注意，结果字符串的结尾没有追加换行符。</p>
<p>nub函数接收一个列表，返回一个所有元素都唯一的一个列表。也就是它把参数中的重复元素都去掉。</p>
<p>delete函数接收一个元素与一个和这个元素相同类型的列表，它会删除列表中参数元素第一次出现的位置：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; delete <span class="number">3</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>]</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>]</div></pre></td></tr></table></figure>
<p><code>\\</code> 函数接收两个列表，相当于集合的差，它会从第一个列表中移除所有在第二个列表中出现在元素：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; [<span class="number">1.</span><span class="number">.7</span>] \\ [<span class="number">3.</span><span class="number">.5</span>]</div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>]</div></pre></td></tr></table></figure>
<p>union接收两个列表，它类似于集合的并操作。遍历第二个列表，如果第二个列表中的某个元素不存在于第一个列表中，那么追加到结果列表，否则抛弃。</p>
<p>intersect接收两个列表，它类似于集合的交操作。</p>
<p>insert函数的行为类似于C++里面的lower_bound函数，它接收一个参数和一个列表，并且把参数插入到列表中。它会找到第一个不小于参数的位置插入。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">λ&gt; insert <span class="number">4</span> [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>]</div><div class="line">λ&gt; insert <span class="number">4</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>]</div><div class="line">λ&gt; insert <span class="number">4</span> [<span class="number">3</span>, <span class="number">1</span>]</div><div class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]</div></pre></td></tr></table></figure>
<p>在第二个例子里，4插入到了原来的列表中的3和4之间。如果列表中所有元素都小于参数，那么把参数插入到列表末尾。</p>
<p>看下面这几个函数的类型：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">λ&gt; :t length</div><div class="line"><span class="title">length</span> :: <span class="type">Foldable</span> t =&gt; t a -&gt; <span class="type">Int</span></div><div class="line">λ&gt; :t take</div><div class="line"><span class="title">take</span> :: <span class="type">Int</span> -&gt; [a] -&gt; [a]</div><div class="line">λ&gt; :t drop</div><div class="line"><span class="title">drop</span> :: <span class="type">Int</span> -&gt; [a] -&gt; [a]</div><div class="line">λ&gt; :t splitAt</div><div class="line"><span class="title">splitAt</span> :: <span class="type">Int</span> -&gt; [a] -&gt; ([a], [a])</div><div class="line">λ&gt; :t (!!)</div><div class="line">(!!) :: [a] -&gt; <span class="type">Int</span> -&gt; a</div><div class="line">λ&gt; :t replicate</div><div class="line"><span class="title">replicate</span> :: <span class="type">Int</span> -&gt; a -&gt; [a]</div></pre></td></tr></table></figure>
<p>我们发现这些函数里面都含有Int，其实这些函数本可以更一般，把Int替换成属于Num的成员类型变量。由于历史原因，修改这些函数可能会让现有的很多程序出问题。所以在Data.List里面实现了这些函数的替代品：genericLength，genericTake，genericDrop，genericSplitAt，genericIndex，genericReplicate。这些函数中把Int替换成了Num，所以更具一般性，也更好用。</p>
<p>nub， delete， union， intersect，group这些函数都有其它版本，分别是：nubBy，deleteBy，unionBy，intersectBy，groupBy，不同之处在于，原来的函数使用(==)函数来测试相等性，By版本的函数可以接收一个函数用来测试相等性。比如把一个列表中的正数和负数分别分组：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; groupBy (\ x y -&gt; (x &gt; <span class="number">0</span>) == (y &gt; <span class="number">0</span>))  [<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</div><div class="line">[[<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]]</div></pre></td></tr></table></figure>
<p>也可以使用Data.Function模块中的on函数，on函数的定义类似于这样：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">on'</span> :: (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c</div><div class="line"><span class="title">on'</span> f g = \ x y -&gt; f (g x) (g y)</div></pre></td></tr></table></figure>
<p>所以上面的程序也可以写成：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; groupBy ((==) `on` (&gt; <span class="number">0</span>)) [<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</div><div class="line">[[<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]]</div></pre></td></tr></table></figure>
<p>sort，insert，maximum，minimum这几个函数也有对应的By版本：sortBy，insertBy，maximumBy，minimumBy。他们都接收一个函数和一个列表，函数参数接收两个元素作为参数，返回值是一个Ordering实例。比如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; sortBy (compare `on` length) [[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]]</div><div class="line">[[<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]]</div></pre></td></tr></table></figure>
<p>所以有两类By系列的函数：</p>
<ol>
<li>接收一个函数来测试相等性，一般用(==) <code>on</code> something</li>
<li>接收一个函数来测试顺序，一般用compare <code>on</code> something</li>
</ol>
<h2 id="Data-Char"><a href="#Data-Char" class="headerlink" title="Data.Char"></a>Data.Char</h2><p>这个模块里面的函数是针对字符的。</p>
<ul>
<li>isControl 检查一个字符是不是控制字符。</li>
<li>isSpace 检查一个字符是不是空白符：包括空格、制表符、换行符等。</li>
<li>isLower 检查一个字符是否是小写字母。</li>
<li>isUpper 检查一个符是否是大写字母。</li>
<li>isAlpha 检查一个字符是否是字母。</li>
<li>isAlphaNum 检查一个字符是否是字母或者数字。</li>
<li>isPrint 检查一个字符是否是可打印的。比如控制符是不可打印的。</li>
<li>isDigit 检查一个字符是否是数字。</li>
<li>isOctDigit 检查一个字符是否是八进制数字。</li>
<li>isHexDigit 检查一个数字是否是十六进制数字。</li>
<li>isLetter 检查一个字符是否是字母。和isAlpha函数一样。</li>
<li>isMark 检查一个字符是否是Unicode标识字符。它们用来组成一些类似于á之类的字符吧好像。法语里面有，西语里面也有。</li>
<li>isNumber 检查一个字符是不是numeric，不知道它和isDigit有什么区别。</li>
<li>isPunctuation 检查一个字符是否是标点符号。</li>
<li>isSymbol 检查一个字符是否是数学或者货币符号。</li>
<li>isSeparator 检查一个字符是否是Unicode空格或者分隔符。</li>
<li>isAscii 检查一个字符是否是Unicode字符集的前128个字符。</li>
<li>isLatin1 检查一个字符是否是Unicode字符集的前256个字符。</li>
<li>isAsciiUpper 检查一个字符是否是ASCII并且大写。</li>
<li>isAsciiLower 检查一个字符是否是ASCII并且小写。</li>
</ul>
<p>比如检查一个字符串是否只包含数字和字母，可以用all函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; all isAlphaNum <span class="string">"abel457"</span></div><div class="line"><span class="type">True</span></div><div class="line">λ&gt; all isAlphaNum <span class="string">"abel-457"</span></div><div class="line"><span class="type">False</span></div></pre></td></tr></table></figure>
<p>Kewl这个单词啊，和cool的意思差不多吧。</p>
<p>实现words函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="title">words'</span> :: <span class="type">String</span> -&gt; [<span class="type">String</span>]</div><div class="line"><span class="title">words'</span> xs = filter (not . any isSpace) $</div><div class="line">  groupBy ((==) `on` isSpace) xs</div><div class="line">λ&gt; words' <span class="string">"Hey gus its me"</span></div><div class="line">[<span class="string">"Hey"</span>,<span class="string">"gus"</span>,<span class="string">"its"</span>,<span class="string">"me"</span>]</div><div class="line">λ&gt; words' <span class="string">"Hey gus its   me"</span></div><div class="line">[<span class="string">"Hey"</span>,<span class="string">"gus"</span>,<span class="string">"its"</span>,<span class="string">"me"</span>]</div></pre></td></tr></table></figure>
<p>这个函数在filter的predicate里面用到了复合函数，有点意思。</p>
<p>Ordering类型的值为LT，EQ，GT。它们是enumeration的。他们描述了两个值比较的所有的结果。同样地，GeneralCategory类型也是enumeration，它描述了任意一个字符所在的类别，一共有31种类别。比如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">λ&gt; generalCategory 'a'</div><div class="line"><span class="type">LowercaseLetter</span></div><div class="line">λ&gt; generalCategory ' '</div><div class="line"><span class="type">Space</span></div><div class="line">λ&gt; generalCategory '\n'</div><div class="line"><span class="type">Control</span></div></pre></td></tr></table></figure>
<p>GeneralCategory类型是Eq的成员，所以是可以比较的：generalCategory c == Space</p>
<ul>
<li>toUpper 把一个字符转化成大写。</li>
<li>toLower 把一个字符转化成小写。</li>
<li>toTitle 把一个字符转化成title-case，一般情况下就是大写。</li>
<li>digitToInt 把一个字符转化成数字，字符必须在’0’..’9’，’a’..’f’，’A’..’F’的范围内。</li>
<li>intToDigit 和digitToInt相反，把一个数字转化成字符，数字范围必须在0..15的范围内，转化成的字符是小写的。</li>
<li>ord 得到一个字符的ASCII码。</li>
<li>chr 从ASCII得到对应的字符。</li>
</ul>
<p>把一个字符串转化成另外一个字符串：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="title">encode</span> :: <span class="type">Int</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span></div><div class="line"><span class="title">encode</span> shift xs =</div><div class="line">  <span class="keyword">let</span> nums = map ord xs</div><div class="line">      nums_ = map (+ shift) nums</div><div class="line">  <span class="keyword">in</span></div><div class="line">    map chr nums_</div></pre></td></tr></table></figure>
<p>也可以用复合函数的方法：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">encode'</span> :: <span class="type">Int</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span></div><div class="line"><span class="title">encode'</span> shift = map (chr . (+ shift) . ord)</div></pre></td></tr></table></figure>
<p>把字符串还原：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">decode</span> :: <span class="type">Int</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span></div><div class="line"><span class="title">decode</span> shift = encode (negate shift)</div></pre></td></tr></table></figure>
<h2 id="Data-Map"><a href="#Data-Map" class="headerlink" title="Data.Map"></a>Data.Map</h2><p>一般使用一个pair列表来表示：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">phoneBook</span> = [(<span class="string">"abel"</span>, <span class="string">"123"</span>)</div><div class="line">            ,(<span class="string">"shin-chan"</span>, <span class="string">"789"</span>)</div><div class="line">            ,(<span class="string">"Zh"</span>, <span class="string">"456"</span>)]</div></pre></td></tr></table></figure>
<p>在一个map里面根据key找到对应的value：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">findKey</span> :: (<span class="type">Eq</span> a) =&gt; a -&gt; [(a, b)] -&gt; b</div><div class="line"><span class="title">findKey</span> x = snd . head . filter (\ (k, v) -&gt; k == x)</div></pre></td></tr></table></figure>
<p>这个函数当key在map里面不存在的时候会异常。因为把[]传递给了head函数。可以用Maybe来代替：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">findKey'</span> :: (<span class="type">Eq</span> a) =&gt; a -&gt; [(a, b)] -&gt; <span class="type">Maybe</span> b</div><div class="line"><span class="title">findKey'</span> k [] = <span class="type">Nothing</span></div><div class="line"><span class="title">findKey'</span> k ((kk, vv) : xs) = <span class="keyword">if</span> kk == k <span class="keyword">then</span> <span class="type">Just</span> vv</div><div class="line">                      <span class="keyword">else</span> findKey' k xs</div></pre></td></tr></table></figure>
<p>很标准的模式匹配的写法。也可以用fold来实现：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="title">findKey's</span> :: (<span class="type">Eq</span> a) =&gt; a -&gt; [(a, b)] -&gt; <span class="type">Maybe</span> b</div><div class="line"><span class="title">findKey's</span> k = foldl (\ accu (kk, vv) -&gt;</div><div class="line">                        <span class="keyword">if</span> kk == k <span class="keyword">then</span> <span class="type">Just</span> vv</div><div class="line">                        <span class="keyword">else</span> accu) <span class="type">Nothing</span></div></pre></td></tr></table></figure>
<p>这里使用的是左折叠，也可以使用右折叠。</p>
<p>在Data.Map里面，map使用树来表示的，而不是用列表。因此速度会快很多。Data.Map导出的函数可能会和Prelude模块里面的函数冲突，因此需要用带有限定符的方式来导入：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.Map <span class="keyword">as</span> Map</div></pre></td></tr></table></figure>
<ul>
<li>fromList 这个函数接收一个关联列表，返回一个map。如果关联列表中有重复的key，那么会忽略。这个函数的类型是：</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; :t <span class="type">Map</span>.fromList</div><div class="line"><span class="type">Map</span>.fromList :: <span class="type">Ord</span> k =&gt; [(k, a)] -&gt; <span class="type">Map</span>.<span class="type">Map</span> k a</div></pre></td></tr></table></figure>
<p>要注意的是，map里面的key必须是Ord的实例，map根据Ord来决定key在树中的位置。另外这个函数的返回值是Data.Map k a，其中key和value的类型也包括在里面。</p>
<ul>
<li>empty 没有参数，返回一个空的map。</li>
<li>insert 接收一个key，一个value，一个map，把key-value插入到map中并返回。可以用这个函数来实现fromList：</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">fromList'</span> :: (<span class="type">Ord</span> k) =&gt; [(k, a)] -&gt; <span class="type">Map</span>.<span class="type">Map</span> k a</div><div class="line"><span class="title">fromList'</span> = foldl (\ accu (k, v) -&gt;</div><div class="line">                     <span class="type">Map</span>.insert k v accu) <span class="type">Map</span>.empty</div></pre></td></tr></table></figure>
<p>这里用的是左折叠，如果用右折叠也是可以的。</p>
<ul>
<li>null 检查一个map是否为空。</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; <span class="type">Map</span>.empty</div><div class="line"><span class="title">fromList</span> []</div><div class="line">λ&gt; <span class="type">Map</span>.null <span class="type">Map</span>.empty</div><div class="line"><span class="type">True</span></div></pre></td></tr></table></figure>
<ul>
<li>size 返回map的大小，也就是key-value对的个数</li>
<li>singleton 接收一个key和一个value，返回一个只含有这个key-value对的map：</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; <span class="type">Map</span>.singleton <span class="string">"Hel"</span> <span class="number">101</span></div><div class="line"><span class="title">fromList</span> [(<span class="string">"Hel"</span>,<span class="number">101</span>)]</div><div class="line">λ&gt; <span class="type">Map</span>.insert <span class="string">"Hola"</span> <span class="number">102</span> $ <span class="type">Map</span>.singleton <span class="string">"Hel"</span> <span class="number">101</span></div><div class="line"><span class="title">fromList</span> [(<span class="string">"Hel"</span>,<span class="number">101</span>),(<span class="string">"Hola"</span>,<span class="number">102</span>)]</div></pre></td></tr></table></figure>
<ul>
<li>lookup 接收一个键和一个map，返回一个Maybe。如果键存在，那么返回Just value，否则返回Nothing：</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; <span class="type">Map</span>.lookup <span class="string">"Hel"</span> $ <span class="type">Map</span>.insert <span class="string">"Hola"</span> <span class="number">102</span> $ <span class="type">Map</span>.singleton <span class="string">"Hel"</span> <span class="number">101</span></div><div class="line"><span class="type">Just</span> <span class="number">101</span></div><div class="line">λ&gt; <span class="type">Map</span>.lookup <span class="string">"Hello"</span> $ <span class="type">Map</span>.insert <span class="string">"Hola"</span> <span class="number">102</span> $ <span class="type">Map</span>.singleton <span class="string">"Hel"</span> <span class="number">101</span></div><div class="line"><span class="type">Nothing</span></div></pre></td></tr></table></figure>
<p>注意，$是右结合的。</p>
<ul>
<li>member 和lookup类似，只不过它只返回一个Bool，表示提供的键在map中是否存在。</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; <span class="type">Map</span>.member <span class="string">"Hello"</span> $ <span class="type">Map</span>.insert <span class="string">"Hola"</span> <span class="number">102</span> $ <span class="type">Map</span>.singleton <span class="string">"Hel"</span> <span class="number">101</span></div><div class="line"><span class="type">False</span></div><div class="line">λ&gt; <span class="type">Map</span>.member <span class="string">"Hel"</span> $ <span class="type">Map</span>.insert <span class="string">"Hola"</span> <span class="number">102</span> $ <span class="type">Map</span>.singleton <span class="string">"Hel"</span> <span class="number">101</span></div><div class="line"><span class="type">True</span></div></pre></td></tr></table></figure>
<ul>
<li>map 功能和Data.List.map类似，接收一个函数和一个map作为参数，把map里面的每个value传递给函数，其返回值作为新的value。</li>
<li>filter 功能和Data.List.filter类似，接收一个predicate函数和一个map作为参数，返回一个新的map。这个map里面的所有的value都使得predicate函数返回真。</li>
<li>toList 和fromList相反，接收一个map，然后返回一个list：</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; <span class="type">Map</span>.toList . <span class="type">Map</span>.filter isUpper $ <span class="type">Map</span>.fromList [(<span class="number">1</span>, '<span class="type">A'</span>), (<span class="number">3</span>, 'b'), (<span class="number">5</span>, '<span class="type">C'</span>)]</div><div class="line">[(<span class="number">1</span>,'<span class="type">A'</span>),(<span class="number">5</span>,'<span class="type">C'</span>)]</div></pre></td></tr></table></figure>
<p>复合函数和function application($)真是好用。</p>
<ul>
<li>keys 和Perl一样，返回一个map的键的列表。</li>
<li>elems 它竟然不叫做values。。elems是什么鬼。。它返回map的值的列表：</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; <span class="type">Map</span>.keys . <span class="type">Map</span>.filter isUpper $ <span class="type">Map</span>.fromList [(<span class="number">1</span>, '<span class="type">A'</span>), (<span class="number">3</span>, 'b'), (<span class="number">5</span>, '<span class="type">C'</span>)]</div><div class="line">[<span class="number">1</span>,<span class="number">5</span>]</div><div class="line">λ&gt; <span class="type">Map</span>.elems . <span class="type">Map</span>.filter isUpper $ <span class="type">Map</span>.fromList [(<span class="number">1</span>, '<span class="type">A'</span>), (<span class="number">3</span>, 'b'), (<span class="number">5</span>, '<span class="type">C'</span>)]</div><div class="line"><span class="string">"AC"</span></div></pre></td></tr></table></figure>
<ul>
<li>fromListWith 它和fromList的不同点是：对于list中的相同的key，它会用一个函数来处理对应的value，而不是忽略。注意，它的第一个参数是一个函数，它只处理value的值，所以这个函数的参数是两个value：</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; <span class="type">Map</span>.fromListWith (\ x y -&gt; x ++ <span class="string">", "</span> ++ y) [(<span class="string">"abel-abel"</span>, <span class="string">"123"</span>), (<span class="string">"bern"</span>, <span class="string">"456"</span>), (<span class="string">"abel-abel"</span>, <span class="string">"789"</span>), (<span class="string">"repl"</span>, <span class="string">"101"</span>)]</div><div class="line"><span class="title">fromList</span> [(<span class="string">"abel-abel"</span>,<span class="string">"789, 123"</span>),(<span class="string">"bern"</span>,<span class="string">"456"</span>),(<span class="string">"repl"</span>,<span class="string">"101"</span>)]</div></pre></td></tr></table></figure>
<p>我们也可以先把关链表里面的value全部变成list，然后把(++)传递给fromListWith函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; <span class="type">Map</span>.fromListWith (++) $ map (\ (x, y) -&gt; (x, [y])) [(<span class="string">"abel-abel"</span>, <span class="string">"123"</span>), (<span class="string">"bern"</span>, <span class="string">"456"</span>), (<span class="string">"abel-abel"</span>, <span class="string">"789"</span>), (<span class="string">"repl"</span>, <span class="string">"101"</span>)]</div><div class="line"><span class="title">fromList</span> [(<span class="string">"abel-abel"</span>,[<span class="string">"789"</span>,<span class="string">"123"</span>]),(<span class="string">"bern"</span>,[<span class="string">"456"</span>]),(<span class="string">"repl"</span>,[<span class="string">"101"</span>])]</div></pre></td></tr></table></figure>
<p>另外一种使用场景是：比如在列表里面一个key有多个value，我们想选择其中最大的value作为map中的value，所以：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; <span class="type">Map</span>.fromListWith max [(<span class="string">"1"</span>, <span class="number">2</span>), (<span class="string">"1"</span>, <span class="number">3</span>), (<span class="string">"2"</span>, <span class="number">10</span>)]</div><div class="line"><span class="title">fromList</span> [(<span class="string">"1"</span>,<span class="number">3</span>),(<span class="string">"2"</span>,<span class="number">10</span>)]</div></pre></td></tr></table></figure>
<p>或者把所有相同key对应的value加起来：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; <span class="type">Map</span>.fromListWith (+) [(<span class="string">"1"</span>, <span class="number">2</span>), (<span class="string">"1"</span>, <span class="number">3</span>), (<span class="string">"2"</span>, <span class="number">10</span>)]</div><div class="line"><span class="title">fromList</span> [(<span class="string">"1"</span>,<span class="number">5</span>),(<span class="string">"2"</span>,<span class="number">10</span>)]</div></pre></td></tr></table></figure>
<ul>
<li>insertWith 和insert类似，它接收一个额外的函数，当要插入的key在map中已经存在的时候，用这个函数来更新map中对应的value的值：</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; <span class="type">Map</span>.insertWith (+) <span class="number">3</span> <span class="number">10</span> $ <span class="type">Map</span>.fromList [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">4</span>)]</div><div class="line"><span class="title">fromList</span> [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">14</span>)]</div></pre></td></tr></table></figure>
<h2 id="Data-Set"><a href="#Data-Set" class="headerlink" title="Data.Set"></a>Data.Set</h2><ul>
<li>fromList 接收一个列表，返回一个set：</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">λ&gt; <span class="keyword">let</span> s1 = <span class="type">Set</span>.fromList <span class="string">"Hello, I am abel. Buenas nochas!"</span></div><div class="line">λ&gt; <span class="keyword">let</span> s2 = <span class="type">Set</span>.fromList <span class="string">"Mucho gusto! Soy Slackware!"</span></div><div class="line">λ&gt; s1</div><div class="line"><span class="title">fromList</span> <span class="string">" !,.BHIabcehlmnosu"</span></div></pre></td></tr></table></figure>
<ul>
<li>intersection 返回两个set的交集：</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; <span class="type">Set</span>.intersection s1 s2</div><div class="line"><span class="title">fromList</span> <span class="string">" !acehlosu"</span></div></pre></td></tr></table></figure>
<ul>
<li>difference 返回第一个set和第二个set的差集：</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; <span class="type">Set</span>.difference s1 s2</div><div class="line"><span class="title">fromList</span> <span class="string">",.BHIbmn"</span></div></pre></td></tr></table></figure>
<ul>
<li>union 返回两个set的并集：</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">λ&gt; <span class="type">Set</span>.union s1 s2</div><div class="line"><span class="title">fromList</span> <span class="string">" !,.BHIMSabceghklmnorstuwy"</span></div></pre></td></tr></table></figure>
<p><code>null, size, member, empty, singleton, insert, delete</code> 这些函数和Map里面的类似。</p>
<h2 id="Making-our-own-modules"><a href="#Making-our-own-modules" class="headerlink" title="Making our own modules"></a>Making our own modules</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="liuxueyang.github.io/2017/04/12/Haskell-笔记1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liuxueyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/drawing.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑历史">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/12/Haskell-笔记1/" itemprop="url">
                  Haskell 笔记1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T10:35:34+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这是一些阅读<a href="http://learnyouahaskell.com" target="_blank" rel="external">Learn You a Haskell for Great Good!</a>的时候的笔记，之前用Latex写的，放在Dropbox里面，现在想把它们整理一下，放在博客里。这是<a href="http://learnyouahaskell.com/starting-out" target="_blank" rel="external">第二章 Starting Out</a>的笔记。</p>
<h3 id="Baby’s-first-functions"><a href="#Baby’s-first-functions" class="headerlink" title="Baby’s first functions"></a>Baby’s first functions</h3><p>2017/03/15 10:32:18</p>
<p>function call的优先级最高。</p>
<p>定义函数这样：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">doubleMe</span> x = x * <span class="number">2</span></div></pre></td></tr></table></figure>
<p>和SML基本一样。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">doubleUs</span> x y = doubleMe x + doubleMe y</div><div class="line"><span class="title">doubleUs1</span>(x, y) = doubleMe x + doubleMe y</div></pre></td></tr></table></figure>
<p>这两个的区别？</p>
<p>第一个是curried function，第二个函数接收一个参数，这个参数是一个含有两个元素的tuple，也叫做pair。</p>
<p>函数调用格式：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">doubleUs</span> <span class="number">3</span> <span class="number">4</span></div><div class="line"><span class="title">doubleUs1</span>(<span class="number">3</span>, <span class="number">4</span>)</div></pre></td></tr></table></figure>
<p><code>if else</code>格式：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">if</span> x &gt; <span class="number">50</span> <span class="keyword">then</span> x <span class="keyword">else</span> x * <span class="number">3</span></div></pre></td></tr></table></figure>
<p>和SML基本一样。同样，else部分不能省略。因为这是一个「表达式」，表达式必须有一个值，所以，不管条件是否满足，一定要有一部分被求值，并且当作这个表达式的值。并且，这两部分的表达式的返回值的类型必须一样。</p>
<p>不能在ghci里面像在文件里面那样定义函数。有几种解决方法：<a href="http://stackoverflow.com/questions/2846050/how-to-define-a-function-in-ghci-across-multiple-lines#19798581" target="_blank" rel="external">defun function in ghci</a></p>
<p><code>&#39;</code>符号在函数和变量名字里面是合法的。比如<code>doubleMe&#39;</code>是一个合法的函数名字</p>
<p>函数名字不能以大写字母开头。没有参数的函数名字其实就是一个「绑定」，不可修改，类似于常量吧？</p>
<h3 id="An-intro-to-lists"><a href="#An-intro-to-lists" class="headerlink" title="An intro to lists"></a>An intro to lists</h3><p>string也是一种list</p>
<p>一个单词：「homogenous」，同质的。list是一种「同质」的数据结构，也就是说，列表可以只含有很多个int，也可以只含有很多个string，但是不能同时含有int和string。这一点也和SML基本一样。</p>
<p>在程序里面写<code>a = 1</code>和在ghci里面<code>let a = 1</code>等价。</p>
<p>string其实一种语法糖：<code>&quot;he&quot;</code>等价于<code>[&#39;h&#39;, &#39;e&#39;]</code></p>
<p>合并列表运算符：<code>++</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">let</span> xs = [<span class="number">1</span>, <span class="number">2</span>]</div><div class="line"><span class="title">let</span> ys = [<span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="title">xs</span> ++ ys</div></pre></td></tr></table></figure>
<p>结果是一个新建的列表，注意：内部实现会把左边的列表遍历一遍。所以：类似于这样的操作<code>[1, 2, 3] ++ [4]</code>的效率可能非常低。</p>
<p><code>:</code>运算符类似于lisp中的<code>cons</code>，<code>3 : [1, 3]</code>类似于<code>(cons 3 &#39;(1 3))</code></p>
<p>所以：[1, 2, 3]就等价于：<code>1 : 2 : 3 : []</code>，类似于：<code>(cons 1 (cons 2 (cons 3 null)))</code></p>
<p>取得下标为１的元素：<code>[1, 2, 3] !! 1</code>，下标从０开始计数</p>
<p>列表里面的子列表（和子列表的子列表等）所含元素必须一致。</p>
<p>如果列表中的元素可以比较大小，那么列表也可以比较大小。按照字典序比较。（这里的字典序并不是我以前认为的字符串的字典序。。。比如：[10000] &gt; [99]是True）</p>
<p>取得列表头元素：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">head</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>类似于lisp中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(car &apos;(1 2 3))</div></pre></td></tr></table></figure>
<p>同样地，</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">tail</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] == [<span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>类似于：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(cdr '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))</div></pre></td></tr></table></figure>
<p>取得最后一个元素：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">last</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] == <span class="number">3</span></div></pre></td></tr></table></figure>
<p>取得除最后一个元素之外的元素：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">init</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] == [<span class="number">1</span>, <span class="number">2</span>]</div></pre></td></tr></table></figure>
<p>从空列表中取头元素会抛异常：（lisp里面的car并不会）</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">head</span> []</div></pre></td></tr></table></figure>
<p>取得列表长度：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">length</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>类似于lisp中：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(length '(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))</div></pre></td></tr></table></figure>
<p>检查一个列表是否为空：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">null</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="title">null</span> []</div></pre></td></tr></table></figure>
<p>类似于lisp中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(null &apos;(1 2 3))</div><div class="line">(null nil) (null &apos;())</div></pre></td></tr></table></figure>
<p>把一个列表倒序：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">reverse</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>从一个列表中取得开头的k个元素，返回取得的元素列表：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">take</span> k [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>当<code>k == 0</code>时，返回<code>[]</code><br>当<code>k &gt; length xs</code>时，返回<code>xs</code></p>
<p>去掉列表开头的k个元素，返回剩余元素的列表：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="title">drop</span> <span class="number">2</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] == [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="title">drop</span> <span class="number">0</span> [<span class="number">1</span>, <span class="number">2</span>] == [<span class="number">1</span>, <span class="number">2</span>]</div><div class="line"><span class="title">drop</span> <span class="number">10000</span> [<span class="number">1</span>, <span class="number">2</span>] == []</div></pre></td></tr></table></figure>
<p>取得最大、最小元素：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">maximum</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] == <span class="number">3</span></div><div class="line"><span class="title">minimum</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] == <span class="number">1</span></div></pre></td></tr></table></figure>
<p>求列表所有元素的和、积：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">sum</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] = <span class="number">6</span></div><div class="line"><span class="title">product</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] = <span class="number">24</span></div></pre></td></tr></table></figure>
<p>判断一个元素是否在列表里面：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">4</span> `elem` [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] == <span class="type">True</span></div><div class="line"><span class="title">elem</span> <span class="number">4</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] == <span class="type">True</span></div></pre></td></tr></table></figure>
<h3 id="Texas-ranges"><a href="#Texas-ranges" class="headerlink" title="Texas ranges"></a>Texas ranges</h3><p><code>ranges:[1..20]</code>和<code>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]</code>等价</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">['a'..'z'] == <span class="string">"abcdefghijklmnopqrstuvwxyz"</span></div><div class="line">[<span class="number">2</span>, <span class="number">4.</span><span class="number">.20</span>] == [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</div><div class="line">[<span class="number">3</span>, <span class="number">6.</span><span class="number">.20</span>] == [<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">18</span>]</div></pre></td></tr></table></figure>
<p>注意：<code>[20..1]</code>并不合法，必须这样写：<code>[20, 19..1]</code></p>
<p>当浮点数字出现的时候，<code>[0.3, 0.6..1]</code>得到：<code>[0.3,0.6,0.8999999999999999]</code>，因为浮点数不精确。</p>
<p>如果去掉上限，会构造出一个无限列表：<code>[13, 26..]</code>，这里haskell会「懒惰求值」，仅仅当列表中的元素被用到的时候才会生成。可以这样用：<code>take 24 [13, 26..]</code>、<code>take 3 [10..]</code></p>
<p>生成循环列表：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">cycle</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">take</span> <span class="number">10</span> (cycle [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) == [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</div></pre></td></tr></table></figure>
<p>生成某个元素的无限列表：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">repeat</span> <span class="number">5</span></div></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">take</span> <span class="number">10</span> (repeat <span class="number">5</span>) == [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</div></pre></td></tr></table></figure>
<h3 id="I’m-a-list-comprehension"><a href="#I’m-a-list-comprehension" class="headerlink" title="I’m a list comprehension"></a>I’m a list comprehension</h3><p>列表解析：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[x * <span class="number">2</span> | x &lt;- [<span class="number">1.</span><span class="number">.5</span>]] == [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</div><div class="line">[x * <span class="number">3</span> | x &lt;- [<span class="number">1.</span><span class="number">.5</span>], x * <span class="number">3</span> &gt; <span class="number">10</span>] == [<span class="number">12</span>, <span class="number">15</span>]</div></pre></td></tr></table></figure>
<p>可以在binding后面追加几个predicate，用逗号分割。比如：一个函数，接受一个整数列表，把所有小于１０的奇数替换成”BOOM!”，所有大于等于１０的奇数替换成”BANG!”，所有的偶数舍弃：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">boomBangs</span> xs = [<span class="keyword">if</span> x &lt; <span class="number">10</span> <span class="keyword">then</span> <span class="string">"BOOM!"</span> <span class="keyword">else</span> <span class="string">"BANG!"</span> | x &lt;- xs, odd x]</div></pre></td></tr></table></figure>
<p>当binding有多个的时候，效果相当于其它语言里面的嵌套的<br>for循环：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[x * y | x &lt;- [<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>], y &lt;- [<span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>]] ==</div><div class="line">[<span class="number">16</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]</div></pre></td></tr></table></figure>
<p>利用列表解析重新定义length函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">length'</span> xs = sum [<span class="number">1</span> | _ &lt;- xs]</div></pre></td></tr></table></figure>
<p>这里<code>_</code>起到一个占位符的作用。</p>
<h3 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h3><p>果然有tuple这个类型。它和list的区别是：一个tuple的类型和它包含的元素的个数和元素类型都有关系，比如包含一个int元素的tuple和包含两个int元素的tuple类型不一样。</p>
<p>一个list的类型仅仅和它包含的元素有关系，一个int list可以包含任意多个元素，它们的类型都属于int list。</p>
<p>另外，tuple不是homogenous的，也就是，一个tuple里面可以包含int，同时也可以包含string等等。</p>
<p>比如[(1, 2), (3, 4), (5, 6)]是合法的，然而[(1, 2), (3, 4, 5), (5, 6)]是非法的，因为包含三个元素的tuple和包含两个元素的tuple类型不一样，同时list是homogenous的。</p>
<p>所以，不存在这样一个函数：它接受一个任意的tuple，然后追加一个元素到tuple里。必须这样：针对不同长度的tuple添加不同的函数。</p>
<p>长度为２的tuple也叫做pair，tuple的长度不能小于２。相同类型（长度相同，元素类型相同）的tuple可以相互比较。不同长度的list可以相互比较。</p>
<p>取得一个pair的第一、二个元素：（注意是pair，并不是tuple）</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">fst</span> (<span class="number">8</span>, <span class="number">11</span>) == <span class="number">8</span></div><div class="line"><span class="title">snd</span> (<span class="number">1</span>, <span class="number">2</span>) == <span class="number">2</span></div></pre></td></tr></table></figure>
<p>zip函数，接受两个列表作为参数，把对应位置的两个元素组成一个pair，返回一个pair list</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="title">zip</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] == [(<span class="number">1</span>,<span class="number">4</span>),(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">3</span>,<span class="number">6</span>)]</div></pre></td></tr></table></figure>
<p>如果这两个列表长度不同，那么最后的结果列表和较短的列表长度一致。因为懒惰求值，zip的一个参数可以是无限列表。</p>
<p>例子：求三边长小于10并且周长为24的所有的三角形。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">triangles</span> = [(a, b, c) | c &lt;- [<span class="number">1.</span><span class="number">.10</span>], b &lt;- [<span class="number">1.</span>.c], a &lt;- [<span class="number">1.</span>.b],</div><div class="line">             a + b + c == <span class="number">24</span>, a ^ <span class="number">2</span> + b ^ <span class="number">2</span> == c ^ <span class="number">2</span>]</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="liuxueyang.github.io/2017/04/10/重新整理博客/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liuxueyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/drawing.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑历史">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/10/重新整理博客/" itemprop="url">
                  重新整理博客
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-10T21:11:11+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这么长时间过去了，好像很久不管这个博客了，差不多10个月过去了。是时候<br>把这些零散的东西整理一下了。争取把之前在别的地方写的东西都整理到这里<br>来。这样以后查看会方便很多吧！</p>
<p>主要是2014年的「博客园」上面的东西。找了一下现有的工具<a href="https://npm.taobao.org/package/hexo-migrator-cnblogs" target="_blank" rel="external">hexo-migrator-cnblogs</a>发现早已经不维护了，现在也不能用了。所以写了一个简单的脚本来爬取我的博客：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 2017/04/11 00:45:15 AM</span></div><div class="line"><span class="comment"># Author: liuxueyang</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> os.path</div><div class="line"></div><div class="line">url = <span class="string">'http://www.cnblogs.com/liuxueyang/default.html?page='</span></div><div class="line">page_nums = range(<span class="number">1</span>, <span class="number">11</span>)</div><div class="line">cnt = <span class="number">0</span></div><div class="line">already_urls = []</div><div class="line"></div><div class="line"><span class="keyword">if</span> os.path.exists(<span class="string">'already.txt'</span>):</div><div class="line">    <span class="keyword">with</span> open(<span class="string">'already.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> already_f:</div><div class="line">        already_urls = already_urls + already_f.readlines()</div><div class="line"></div><div class="line"><span class="keyword">for</span> page_num <span class="keyword">in</span> page_nums:</div><div class="line">    url1 = url + str(page_num)</div><div class="line">    r = requests.get(url1)</div><div class="line">    soup = BeautifulSoup(r.content, <span class="string">'html5lib'</span>)</div><div class="line"></div><div class="line">    titles = soup.find_all(<span class="string">'a'</span>, class_=<span class="string">'posttitle'</span>)</div><div class="line">    <span class="keyword">for</span> title <span class="keyword">in</span> titles:</div><div class="line">        <span class="keyword">print</span> <span class="string">'=='</span> * <span class="number">20</span>, <span class="string">'\n\n'</span></div><div class="line">        cnt += <span class="number">1</span></div><div class="line">        blog_url = title.get(<span class="string">'href'</span>)</div><div class="line">        blog_name = title.string</div><div class="line">        blog_r = requests.get(blog_url)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> blog_url + <span class="string">'\n'</span> <span class="keyword">in</span> already_urls:</div><div class="line">            <span class="keyword">print</span> cnt, blog_name</div><div class="line">            <span class="keyword">continue</span></div><div class="line"></div><div class="line">        blog_soup = BeautifulSoup(blog_r.content, <span class="string">'html5lib'</span>)</div><div class="line">        blog_body = blog_soup.find(id=<span class="string">'cnblogs_post_body'</span>)</div><div class="line">        blog_date = blog_soup.find(id=<span class="string">'post-date'</span>).text</div><div class="line"></div><div class="line">        <span class="keyword">print</span> cnt, blog_url</div><div class="line">        tags = <span class="string">'tags: \n'</span></div><div class="line"></div><div class="line">        body = [</div><div class="line">            <span class="string">'---\n'</span>, <span class="string">'title: "%s"\n'</span> % blog_name, <span class="string">'date: %s\n'</span> % blog_date,</div><div class="line">            tags, <span class="string">'---\n\n'</span></div><div class="line">        ]</div><div class="line"></div><div class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> blog_body.children:</div><div class="line">            <span class="keyword">if</span> child.name == <span class="string">'p'</span>:</div><div class="line">                body.append(child.text + <span class="string">'\n'</span>)</div><div class="line">            <span class="keyword">elif</span> child.name == <span class="string">'div'</span> <span class="keyword">and</span> child.has_attr(<span class="string">'class'</span>) <span class="keyword">and</span> child.get(</div><div class="line">                    <span class="string">'class'</span>)[<span class="number">0</span>] == <span class="string">'cnblogs_code'</span>:</div><div class="line">                lines = child.text.split(<span class="string">'\n'</span>)</div><div class="line">                body.append(<span class="string">'\n```cpp\n'</span>)</div><div class="line">                <span class="keyword">for</span> line <span class="keyword">in</span> lines:</div><div class="line">                    line = re.sub(<span class="string">r'^ *'</span>, <span class="string">''</span>, line)</div><div class="line">                    line = re.sub(<span class="string">r'^\d* '</span>, <span class="string">''</span>, line)</div><div class="line">                    body.append(line + <span class="string">'\n'</span>)</div><div class="line">                body.append(<span class="string">'```\n\n'</span>)</div><div class="line"></div><div class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> body:</div><div class="line">            <span class="keyword">print</span> line,</div><div class="line">        file_name = re.sub(<span class="string">r' |/'</span>, <span class="string">'-'</span>, blog_name) + <span class="string">'.md'</span></div><div class="line">        <span class="keyword">print</span> file_name</div><div class="line"></div><div class="line">        action = raw_input()</div><div class="line"></div><div class="line">        <span class="keyword">if</span> action == <span class="string">'S'</span>:</div><div class="line">            process_later_file = <span class="string">'later.txt'</span></div><div class="line">            f = open(process_later_file, <span class="string">'a'</span>)</div><div class="line">            f.write(blog_url + <span class="string">'\n'</span>)</div><div class="line">            <span class="keyword">print</span> <span class="string">'-'</span> * <span class="number">30</span></div><div class="line">            <span class="keyword">print</span> <span class="string">'process by hand later!'</span></div><div class="line">            <span class="keyword">print</span> <span class="string">'-'</span> * <span class="number">30</span></div><div class="line">            f.close()</div><div class="line">            <span class="keyword">continue</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> action:</div><div class="line">            action = action.split(<span class="string">','</span>)</div><div class="line">            tags = <span class="string">'tags: ['</span> + <span class="string">', '</span>.join(action) + <span class="string">']'</span> + <span class="string">'\n'</span></div><div class="line">            body[<span class="number">3</span>] = tags</div><div class="line"></div><div class="line">        ff = open(file_name, <span class="string">'w'</span>)</div><div class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> body:</div><div class="line">            ff.write(b.encode(<span class="string">'utf-8'</span>))</div><div class="line">        ff.close()</div><div class="line"></div><div class="line">        <span class="keyword">with</span> open(<span class="string">'already.txt'</span>, <span class="string">'a'</span>) <span class="keyword">as</span> already_f:</div><div class="line">            already_f.write(blog_url + <span class="string">'\n'</span>)</div></pre></td></tr></table></figure>
<p>没有加处理图片的功能。因为以前的博客用的图片并不多，手动处理。它会抓取博客正文和嵌入的代码，处理嵌入代码的时候花了比较多的时间，比如如果从xml中获取到嵌入的代码，然后去掉行号之类的。这个程序抓取到一篇博客就显示出博客正文和代码块来，等待用户输入，如果正常，之间按回车处理下一篇，如果原来的博客有图片或者抓取的内容不完整，按下<code>S</code>会把当前博客的地址保存到一个<code>later.txt</code>这个文本文件里，随后手动处理。已经处理好的博客地址放到<code>already.txt</code>文件里，这样避免了重复处理。结果还可以。</p>
<p>总共有455篇日志了。可能是我的电脑太老的原因，hexo生成的时候竟然用了好几分钟。所以之后想试一试Hakyll了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="liuxueyang.github.io/2017/03/16/整理Bilibili安卓客户端缓存的视频/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liuxueyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/drawing.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑历史">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/16/整理Bilibili安卓客户端缓存的视频/" itemprop="url">
                  整理Bilibili安卓客户端缓存的视频
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-16T22:30:48+08:00">
                2017-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>昨天晚上无意中看到了B站竟然有TOUCH。。完全没想到。所以我决定这次要把这部动画片全部下载下来，B站的视频质量看起来还不错。所以最简单的方法就是用安卓客户端缓存，然后在电脑上处理了。</p>
<p>其实之前我做过这件事情。当初是为了整理「暖暖日记」这部番，因为它每集仅仅有5分钟左右。每个视频只有一个文件，所以只需要找到所有视频然后读json文件找到视频名称，重命名就好了。</p>
<p>不过这次好像有点不同：每集一般有25分钟，缓存的是高清的。奇怪的是：即使是同一集，最开始我缓存的时候某一集是仅仅有一个mp4文件，然后我又实验了一次，发现它就变成了多个flv文件。。真是迷。。</p>
<p>处理也不难，如果是单个mp4文件直接重命名就好了。如果是多个flv文件，那么就需要先合并，然后再命名。</p>
<p>然后看了一下之前写的Perl程序，竟然，看不太懂了。。。T_T，然而还好，最后还是搞定了：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/perl</span></div><div class="line"></div><div class="line"><span class="comment"># Date  : 2017/03/16 19:14:35</span></div><div class="line"><span class="comment"># Finish: 2017/03/16 22:04:07</span></div><div class="line"></div><div class="line"><span class="comment"># <span class="doctag">NOTE:</span> There MUST NOT be any non-ascii character in the path!!!!!!!!!!</span></div><div class="line"></div><div class="line"><span class="keyword">use</span> strict;</div><div class="line"><span class="keyword">use</span> warnings;</div><div class="line"><span class="keyword">use</span> <span class="number">5.014</span>;</div><div class="line"><span class="keyword">use</span> Cwd;</div><div class="line"><span class="keyword">use</span> JSON <span class="string">qw()</span>;</div><div class="line"><span class="keyword">use</span> <span class="keyword">open</span> <span class="string">':std'</span>, <span class="string">':encoding(UTF-8)'</span>;</div><div class="line"><span class="keyword">use</span> File::Copy;</div><div class="line"></div><div class="line"><span class="keyword">my</span> $cur_dir = <span class="string">'/home/repl/Videos/Bilibili/Fanju/TOUCH/s_2425'</span>;</div><div class="line"><span class="keyword">opendir</span>(DIR, $cur_dir) <span class="keyword">or</span> dir $!;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (<span class="keyword">my</span> $file = <span class="keyword">readdir</span>(DIR)) &#123;</div><div class="line">    <span class="keyword">next</span> <span class="keyword">if</span> ($file =~ <span class="regexp">/^\./</span>);</div><div class="line">    </div><div class="line">    <span class="comment"># get index_title</span></div><div class="line">    <span class="keyword">my</span> $json_file = $cur_dir . <span class="string">"/$file"</span> . <span class="string">'/entry.json'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">my</span> $json_text = <span class="keyword">do</span> &#123;</div><div class="line">	<span class="keyword">open</span>(<span class="keyword">my</span> $json_fh, <span class="string">"&lt;:encoding(UTF-8)"</span>, $json_file)</div><div class="line">	    <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"Can not open $json_file\"$!\n\""</span>);</div><div class="line">	<span class="keyword">local</span> $/;</div><div class="line">	&lt;$json_fh&gt;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">my</span> $json = JSON-&gt;new;</div><div class="line">    <span class="keyword">my</span> $data = $json-&gt;decode($json_text);</div><div class="line">    <span class="keyword">my</span> $index = $data-&gt;&#123;<span class="string">'ep'</span>&#125;&#123;<span class="string">'index_title'</span>&#125;;</div><div class="line"></div><div class="line">    <span class="comment"># directories like 58116</span></div><div class="line">    <span class="keyword">my</span> $subdir = <span class="string">"$cur_dir/$file"</span>;</div><div class="line">    <span class="keyword">opendir</span>(SUBDIR, $subdir) <span class="keyword">or</span> dir $!;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">my</span> $subfile = <span class="keyword">readdir</span>(SUBDIR)) &#123;</div><div class="line">	<span class="keyword">next</span> <span class="keyword">if</span> ($subfile =~ <span class="regexp">/^\./</span>);</div><div class="line">	<span class="keyword">if</span> (-d <span class="string">"$subdir/$subfile"</span>) &#123;</div><div class="line">	    <span class="keyword">if</span> ($subfile =~ <span class="regexp">/hdmp4/</span>) &#123;</div><div class="line">		<span class="comment"># only rename</span></div><div class="line">		<span class="keyword">opendir</span>(DSTDIR, <span class="string">"$subdir/$subfile"</span>);</div><div class="line">		<span class="keyword">while</span> (<span class="keyword">my</span> $dstfile = <span class="keyword">readdir</span>(DSTDIR)) &#123;</div><div class="line">		    <span class="keyword">next</span> <span class="keyword">if</span> ($dstfile =~ <span class="regexp">/^\./</span>);</div><div class="line">		    <span class="keyword">if</span> ($dstfile =~ <span class="regexp">/mp4$/</span>) &#123;</div><div class="line">			$index =~ <span class="regexp">s/ /_/g</span>;</div><div class="line">			<span class="keyword">rename</span>(<span class="string">"$subdir/$subfile/$dstfile"</span>, <span class="string">"$index.mp4"</span>) <span class="keyword">or</span> <span class="keyword">die</span></div><div class="line">			    <span class="string">"failed to copy file"</span> . $index;</div><div class="line">		    &#125;</div><div class="line">		&#125;</div><div class="line">		closedir(DSTDIR);</div><div class="line">	    &#125;</div><div class="line">	    <span class="keyword">if</span> ($subfile =~ <span class="regexp">/flv/</span>) &#123;</div><div class="line">		<span class="comment"># concat flv files</span></div><div class="line">		<span class="keyword">opendir</span>(DSTDIR, <span class="string">"$subdir/$subfile"</span>);</div><div class="line">		<span class="keyword">my</span> @flv = ();</div><div class="line">		<span class="keyword">while</span> (<span class="keyword">my</span> $dstfile = <span class="keyword">readdir</span>(DSTDIR)) &#123;</div><div class="line">		    <span class="keyword">next</span> <span class="keyword">if</span> ($dstfile =~ <span class="regexp">/^\./</span>);</div><div class="line">		    <span class="keyword">if</span> ($dstfile =~ <span class="regexp">/flv$/</span>) &#123;</div><div class="line">			<span class="keyword">push</span> @flv, $dstfile;</div><div class="line">		    &#125;</div><div class="line">		&#125;</div><div class="line">		@flv = <span class="keyword">sort</span> &#123; $a cmp $b &#125; @flv;</div><div class="line">		@flv = <span class="keyword">map</span> &#123; <span class="string">"file './$_'"</span> &#125; @flv;</div><div class="line">		<span class="keyword">my</span> $mylist = <span class="string">"$subdir/$subfile/mylist.txt"</span>;</div><div class="line">		<span class="keyword">open</span> (<span class="keyword">my</span> $fh, <span class="string">"&gt;"</span>, $mylist)</div><div class="line">		    <span class="keyword">or</span> dir $!;</div><div class="line">		<span class="keyword">for</span> (@flv) &#123; <span class="keyword">print</span> $fh <span class="string">"$_\n"</span>; &#125;</div><div class="line">		<span class="keyword">close</span>($fh);</div><div class="line">		<span class="keyword">say</span> <span class="string">"$subdir/$subfile"</span>;</div><div class="line">		<span class="comment"># output file is: output.flv. Chinese filename will crash. T_T</span></div><div class="line">		<span class="keyword">system</span>(<span class="string">"cd $subdir/$subfile &amp;&amp; ffmpeg -f concat -safe 0 -i mylist.txt -c copy output.flv"</span>);</div><div class="line">		<span class="comment"># rename the filename of the output.flv to Chinese filename.</span></div><div class="line">		$index =~ <span class="regexp">s/ /_/g</span>;</div><div class="line">		<span class="keyword">rename</span>(<span class="string">"$subdir/$subfile/output.flv"</span>, <span class="string">"$index.flv"</span>) <span class="keyword">or</span> <span class="keyword">die</span></div><div class="line">		    <span class="string">"failed to copy file"</span> . $index;</div><div class="line">		closedir(DSTDIR);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">close</span>(SUBDIR);</div><div class="line">&#125;</div><div class="line"></div><div class="line">closedir(DIR);</div><div class="line"><span class="keyword">exit</span> <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>遇到几个陷阱：ffmpeg命令的输出文件不能是中文文件名，这个调试很久。然后文件路径最好不要有中文，否则出现一些奇怪的问题，不知道怎么解决，都改成英文名就好了。</p>
<p>哦，还有一件事情：以前试过很多种从Android传数据到Linux的方法，最后还是发现，<code>adb pull</code>最好用，速度最快。比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb pull /storage/emulated/0/Android/data/tv.danmaku.bili/download/s_2425</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="liuxueyang.github.io/2017/03/06/复习C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liuxueyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/drawing.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑历史">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/06/复习C/" itemprop="url">
                  复习C++
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-06T23:24:07+08:00">
                2017-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天复习了一下C++。很久很久不碰这门语言，早上看到一段代码竟然感觉十分陌生。<code>this</code>，<code>const pointer</code>，引用之类的，有点忘了。其实也不是忘，就是感觉很陌生。比如<code>this</code>别的语言里面也有，只是不是指针，比较容易混淆。所以就大概查了一下<code>C++ Primer</code>，然后做了几道题目。放在这里。</p>
<h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><p>给CMyString类写一个方法，使它能够支持赋值<code>=</code>操作。CMyString类已经给出。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line"></div><div class="line">// implement a operator `=` on class CMyString</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class CMyString &#123;</div><div class="line">public:</div><div class="line">  CMyString(char * pData = NULL);</div><div class="line">  CMyString(const CMyString &amp; str);</div><div class="line">  CMyString &amp; operator =(const CMyString &amp;);</div><div class="line">  void print();</div><div class="line">  ~CMyString(void);</div><div class="line"></div><div class="line">private:</div><div class="line">  char * m_pData;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">CMyString &amp; CMyString::operator =(const CMyString &amp; str)</div><div class="line">&#123;</div><div class="line">  // if (this == &amp;str) return *this;</div><div class="line">  // delete [] m_pData;</div><div class="line">  // m_pData = NULL;</div><div class="line">  // m_pData = new char[strlen(str.m_pData) + 1];</div><div class="line">  // strcpy(m_pData, str.m_pData);</div><div class="line">  // return *this;</div><div class="line"></div><div class="line">  if (this != &amp;str) &#123;</div><div class="line">    CMyString strTemp(str);</div><div class="line"></div><div class="line">    char * pTemp = strTemp.m_pData; // I wrote str.m_pData before. Stupid!</div><div class="line">    strTemp.m_pData = m_pData;</div><div class="line">    m_pData = pTemp;</div><div class="line">  &#125;</div><div class="line">  return *this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">CMyString::CMyString(char * pData)</div><div class="line">&#123;</div><div class="line">  m_pData = NULL;</div><div class="line">  m_pData = new char[strlen(pData) + 1];</div><div class="line">  strcpy(m_pData, pData);</div><div class="line">&#125;</div><div class="line"></div><div class="line">CMyString::CMyString(const CMyString &amp; str)</div><div class="line">&#123;</div><div class="line">  cout &lt;&lt; "copying " &lt;&lt; str.m_pData &lt;&lt; "\n";</div><div class="line">  m_pData = NULL;</div><div class="line">  m_pData = new char[strlen(str.m_pData) + 1];</div><div class="line">  strcpy(m_pData, str.m_pData);</div><div class="line">  cout &lt;&lt; "end of copying: " &lt;&lt; m_pData &lt;&lt; "\n";</div><div class="line">  if (m_pData != str.m_pData) cout &lt;&lt; "not equal" &lt;&lt; "\n";</div><div class="line">&#125;</div><div class="line"></div><div class="line">CMyString::~CMyString()</div><div class="line">&#123;</div><div class="line">  cout &lt;&lt; "delete: " &lt;&lt; m_pData &lt;&lt; "\n";</div><div class="line">  delete [] m_pData;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void CMyString::print()</div><div class="line">&#123;</div><div class="line">  cout &lt;&lt; m_pData &lt;&lt; "\n";</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">  CMyString str((char*)"Rabbit"), str4((char*)"Hola!"), str1((char*)"Slackware");</div><div class="line">  str4 = str;</div><div class="line"></div><div class="line">  str.print();</div><div class="line">  str4.print();</div><div class="line"></div><div class="line">  str = str4 = str1;</div><div class="line">  str1.print();</div><div class="line"></div><div class="line">  cout &lt;&lt; "end of program" &lt;&lt; "\n";</div><div class="line"></div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><p>给一个二维数组，这个二维数组从左到右、从上到下依次按照从小到大的顺序排列。给一个数字，在这个数组里面找这个数字，如果找到，返回true。否则返回false</p>
<h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当然你可以把整个二维数组扫描一遍。然而有更好的方法：起点从右上角或者左下角开始，如果num比当前位置的数字小，说明num不在这一列，<code>j--</code>，这样就可以找到num所在的列。如果num比当前数字大，说明num不在这一行，<code>i++</code>，这样就可以确定num所在的行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// 2017/03/06 16:22:14</div><div class="line"></div><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">// find a number in a sorted two-dimension array.</div><div class="line">// the array is from left to right, top to bottom sorted.</div><div class="line">bool findNumber(int *a, int row, int col, int num)</div><div class="line">&#123;</div><div class="line">  if (NULL == a) return false;</div><div class="line"></div><div class="line">  int j = col - 1, i = 0;</div><div class="line">  if (col &gt; 0 &amp;&amp; row &gt; 0) &#123;</div><div class="line">    // find the max column</div><div class="line">    while (j &gt;= 0 &amp;&amp; a[i * col + j] &gt; num) &#123;</div><div class="line">      j--;</div><div class="line">    &#125;</div><div class="line">    if (j &lt; 0) &#123;</div><div class="line">      return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // find the max row</div><div class="line">    while (i &lt; row &amp;&amp; a[i * col + j] &lt; num) &#123;</div><div class="line">      i++;</div><div class="line">    &#125;</div><div class="line">    if (i == row) &#123;</div><div class="line">      return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return a[i * col + j] == num;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">  int a[4][4] = &#123;</div><div class="line">    &#123;1, 2, 8, 9&#125;,</div><div class="line">    &#123;2, 4, 9, 12&#125;,</div><div class="line">    &#123;4, 7, 10, 13&#125;,</div><div class="line">    &#123;6, 8, 11, 15&#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  cout &lt;&lt; findNumber(&amp;a[0][0], 4, 4, 7) &lt;&lt; &quot;\n&quot;; // found</div><div class="line">  cout &lt;&lt; findNumber(&amp;a[0][0], 4, 4, 1) &lt;&lt; &quot;\n&quot;; // found</div><div class="line">  cout &lt;&lt; findNumber(&amp;a[0][0], 4, 4, 15) &lt;&lt; &quot;\n&quot;; // found</div><div class="line"></div><div class="line">  cout &lt;&lt; findNumber(&amp;a[0][0], 4, 4, 3) &lt;&lt; &quot;\n&quot;; // no</div><div class="line">  cout &lt;&lt; findNumber(&amp;a[0][0], 4, 4, 16) &lt;&lt; &quot;\n&quot;;</div><div class="line">  cout &lt;&lt; findNumber(&amp;a[0][0], 4, 4, -1) &lt;&lt; &quot;\n&quot;;</div><div class="line"></div><div class="line">  cout &lt;&lt; findNumber(NULL, 4, 4, 7) &lt;&lt; &quot;\n&quot;; // no</div><div class="line"></div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><p>给定一个字符串，把字符串里面的所有空格替换成<code>%20</code>。题目要求对字符串进行本地修改，保证字符串指向的连续内存有足够的空间。</p>
<h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><p>当然可以从前往后找空格，找到一个就把后面内容向后移动，然后把空格替换成<code>%20</code>。然而有更好的方法。从后往前替换。首先扫描一遍字符串，找到有<code>cnt</code>个空格。说明替换后的字符串长度是<code>len + cnt * 2</code>。所以从后往前一个一个替换就好了。需要注意的一个细节是：倒数第一个空格之后的内容需要向后移动<code>cnt * 2</code>个单位长度，倒数第二个空格之后的内容需要往后移动<code>(cnt - 1) * 2</code>个单位长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">// 2017/03/06 16:23:21</div><div class="line"></div><div class="line">#include &lt;bits/stdc++.h&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">// replace all of the white spaces in a string to `%20`</div><div class="line">// O(n)</div><div class="line">void replaceSpace(char str[], int length)</div><div class="line">&#123;</div><div class="line">  // IMPORTANT!!!</div><div class="line">  if (NULL == str || length &lt;= 0) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // count the number of white spaces</div><div class="line">  int cnt = 0;</div><div class="line">  int strLen = 0;</div><div class="line">  for (int i = 0; str[i] != &apos;\0&apos;; i++) &#123;</div><div class="line">    if (str[i] == &apos; &apos;) &#123;</div><div class="line">      cnt++;</div><div class="line">    &#125;</div><div class="line">    strLen++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (length &lt;= strLen + cnt * 2) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // replace from the tail of the string</div><div class="line">  int pos = strLen;</div><div class="line">  while (cnt &gt; 0 &amp;&amp; pos &gt;= 0) &#123;</div><div class="line">    while (pos &gt;= 0 &amp;&amp; &apos; &apos; != str[pos]) &#123;</div><div class="line">      str[pos + cnt * 2] = str[pos];</div><div class="line">      pos--;</div><div class="line">    &#125;</div><div class="line">    if (pos &gt;= 0 &amp;&amp; &apos; &apos; == str[pos]) &#123;</div><div class="line">      str[pos + (cnt - 1) * 2] = &apos;%&apos;;</div><div class="line">      str[pos + (cnt - 1) * 2 + 1] = &apos;2&apos;;</div><div class="line">      str[pos + (cnt - 1) * 2 + 2] = &apos;0&apos;;</div><div class="line">    &#125;</div><div class="line">    cnt--;</div><div class="line">    pos--;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">  char str[100] = &quot;we are happy.&quot;; // simple case</div><div class="line">  replaceSpace(str, 100);</div><div class="line">  cout &lt;&lt; str &lt;&lt; &quot;\n&quot;;</div><div class="line"></div><div class="line">  char str1[100] = &quot;we are happy. &quot;; // one tail space</div><div class="line">  replaceSpace(str1, 100);</div><div class="line">  cout &lt;&lt; str1 &lt;&lt; &quot;\n&quot;;</div><div class="line"></div><div class="line">  char str2[100] = &quot; we are happy. &quot;; // head and tail space</div><div class="line">  replaceSpace(str2, 100);</div><div class="line">  cout &lt;&lt; str2 &lt;&lt; &quot;\n&quot;;</div><div class="line"></div><div class="line">  char str3[100] = &quot;  we are happy. &quot;; // two head spaces</div><div class="line">  replaceSpace(str3, 100);</div><div class="line">  cout &lt;&lt; str3 &lt;&lt; &quot;\n&quot;;</div><div class="line"></div><div class="line">  char str4[100] = &quot;we are happy.  &quot;; // two tail spaces</div><div class="line">  replaceSpace(str4, 100);</div><div class="line">  cout &lt;&lt; str4 &lt;&lt; &quot;\n&quot;;</div><div class="line"></div><div class="line">  char str5[100] = &quot;wearehappy.&quot;; // no space</div><div class="line">  replaceSpace(str5, 100);</div><div class="line">  cout &lt;&lt; str5 &lt;&lt; &quot;\n&quot;;</div><div class="line"></div><div class="line">  char str6[100] = &quot;   &quot;; // only some spaces</div><div class="line">  replaceSpace(str6, 100);</div><div class="line">  cout &lt;&lt; str6 &lt;&lt; &quot;\n&quot;;</div><div class="line"></div><div class="line">  char str7[100] = &quot; &quot;; // only one space</div><div class="line">  replaceSpace(str7, 100);</div><div class="line">  cout &lt;&lt; str7 &lt;&lt; &quot;\n&quot;;</div><div class="line"></div><div class="line">  char str8[100] = &quot;&quot;; // empty string</div><div class="line">  replaceSpace(str8, 100);</div><div class="line">  cout &lt;&lt; str8 &lt;&lt; &quot;\n&quot;;</div><div class="line"></div><div class="line">  char *str9 = NULL; // NULL pointer</div><div class="line">  replaceSpace(str9, 100);</div><div class="line">  cout &lt;&lt; str9 &lt;&lt; &quot;\n&quot;;</div><div class="line"></div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h3><p>给一个单向链表，要求倒序打印出链表的内容。</p>
<h4 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h4><p>比较简单。可以递归打印，也可以把每个节点的值放到栈里面。最好打印栈里面的内容。需要注意的是，第二个方法比较好。原因是递归容易造成Stackoverflow，当链表非常长的时候。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 2017/03/06 19:31:00</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// print all of the nodes in the list in reverse order</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> ListNode</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> m_nKey;</div><div class="line">  ListNode *m_pNext;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// add a node to the tail</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddToTail</span><span class="params">(ListNode **pHead, <span class="keyword">int</span> value)</span></span></div><div class="line">&#123;</div><div class="line">  ListNode *pNew = <span class="keyword">new</span> ListNode();</div><div class="line">  pNew-&gt;m_nKey = value;</div><div class="line">  pNew-&gt;m_pNext = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == *pHead) &#123;</div><div class="line">    *pHead = pNew;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    ListNode *next = *pHead;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">NULL</span> != next-&gt;m_pNext) &#123;</div><div class="line">      next = next-&gt;m_pNext;</div><div class="line">    &#125;</div><div class="line">    next-&gt;m_pNext = pNew;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// print list nodes in reverse order</span></div><div class="line"><span class="comment">// <span class="doctag">NOTE:</span> very long list will cause stack overflow!</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintReverse</span><span class="params">(ListNode *pHead)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == pHead) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  <span class="comment">// print cdr, then print the current node</span></div><div class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> != pHead-&gt;m_pNext) &#123;</div><div class="line">    PrintReverse(pHead-&gt;m_pNext);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; pHead-&gt;m_nKey &lt;&lt; <span class="string">" "</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintReverse_Iterate</span><span class="params">(ListNode *pHead)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == pHead) <span class="keyword">return</span>;</div><div class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; values;</div><div class="line">  <span class="keyword">while</span> (<span class="literal">NULL</span> != pHead) &#123;</div><div class="line">    values.push(pHead-&gt;m_nKey);</div><div class="line">    pHead = pHead-&gt;m_pNext;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (!values.empty()) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; values.top() &lt;&lt; <span class="string">" "</span>;</div><div class="line">    values.pop();</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">  ListNode *head = <span class="literal">NULL</span>;</div><div class="line">  AddToTail(&amp;head, <span class="number">3</span>);</div><div class="line">  AddToTail(&amp;head, <span class="number">1</span>);</div><div class="line">  AddToTail(&amp;head, <span class="number">10</span>);</div><div class="line">  AddToTail(&amp;head, <span class="number">9</span>);</div><div class="line">  AddToTail(&amp;head, <span class="number">-1</span>);</div><div class="line"></div><div class="line">  PrintReverse(head);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</div><div class="line"></div><div class="line">  PrintReverse_Iterate(head);</div><div class="line"></div><div class="line">  ListNode *head1 = <span class="literal">NULL</span>;</div><div class="line">  AddToTail(&amp;head1, <span class="number">10000</span>);</div><div class="line">  PrintReverse_Iterate(head1);</div><div class="line">  PrintReverse(head1);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</div><div class="line"></div><div class="line">  PrintReverse_Iterate(<span class="literal">NULL</span>);</div><div class="line">  PrintReverse(<span class="literal">NULL</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h3><p>给定一个二叉树的前序遍历序列和中序遍历序列，构造出这个二叉树。</p>
<h4 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h4><p>这题早就见过，不过还是第一次写。其实也挺简单，就是首先在<code>preorder</code>里面找到根，然后在<code>inorder</code>序列里找到这个根的位置。那么在<code>inorder</code>里的根之前的都是左子树，右边的都是右子树。这样我们就有了左右子树的<code>inorder</code>序列。我们也在<code>inorder</code>里面得到了左子树的长度，那么在<code>preorder</code>里面根后面截取相同的长度，就是左子树的<code>preorder</code>序列，剩下的就是右子树的<code>preorder</code>序列。这样，我们就根据当前树的<code>preorder</code>序列和<code>inorder</code>序列得到了左右子树的<code>preorder</code>和<code>inorder</code>序列。所以这是一个递归的做法。</p>
<p>另外，实现的时候，不要傻傻的复制<code>preorder</code>和<code>inorder</code>这两个数组（我一开始就这么想的T_T）。可以用指针，传对应位置的指针当作子数组就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 2016/03/06 20:10:41</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct</span> BinaryTreeNode</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> m_nValue;</div><div class="line">  BinaryTreeNode *m_pLeft;</div><div class="line">  BinaryTreeNode *m_pRight;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function">BinaryTreeNode * <span class="title">ConstructCore</span><span class="params">(<span class="keyword">int</span> * startPreorder, <span class="keyword">int</span> * endPreorder,</span></span></div><div class="line">                               <span class="keyword">int</span> * startInorder, <span class="keyword">int</span> * endInorder)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (startPreorder &gt; endPreorder ||</div><div class="line">      startInorder &gt; endInorder) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> rootValue = startPreorder[<span class="number">0</span>];</div><div class="line">  <span class="keyword">int</span> leftNodesLen = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> *current = startInorder;</div><div class="line"></div><div class="line">  BinaryTreeNode * root = <span class="keyword">new</span> BinaryTreeNode();</div><div class="line">  root-&gt;m_nValue = rootValue;</div><div class="line">  root-&gt;m_pLeft = root-&gt;m_pRight = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">  <span class="comment">// only one element in the array</span></div><div class="line">  <span class="keyword">if</span> (startPreorder == endPreorder) &#123;</div><div class="line">    <span class="keyword">if</span> (startInorder == endInorder &amp;&amp;</div><div class="line">        *startPreorder == *startInorder) &#123;</div><div class="line">      <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">throw</span> exception();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(current != endInorder &amp;&amp; *current != rootValue) &#123;</div><div class="line">    current++;</div><div class="line">    leftNodesLen++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// didn't find root value in the inorder array</span></div><div class="line">  <span class="keyword">if</span> (current == endInorder &amp;&amp;</div><div class="line">      *current != rootValue) &#123;</div><div class="line">    <span class="keyword">throw</span> exception();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// left child</span></div><div class="line">  root-&gt;m_pLeft = ConstructCore(startPreorder + <span class="number">1</span>, startPreorder + leftNodesLen,</div><div class="line">                                startInorder, startInorder + leftNodesLen - <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="comment">// right child</span></div><div class="line">  root-&gt;m_pRight = ConstructCore(startPreorder + leftNodesLen + <span class="number">1</span>, endPreorder,</div><div class="line">                                 startInorder + leftNodesLen + <span class="number">1</span>, endInorder);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> root;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// construct a binary tree using preorder and inorder</span></div><div class="line"><span class="function">BinaryTreeNode * <span class="title">Construct</span><span class="params">(<span class="keyword">int</span> * preorder, <span class="keyword">int</span> * inorder, <span class="keyword">int</span> len)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == preorder || <span class="literal">NULL</span> == inorder || <span class="number">0</span> &gt;= len) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> ConstructCore(preorder, preorder + len - <span class="number">1</span>,</div><div class="line">                       inorder, inorder + len - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderPrintTree</span><span class="params">(BinaryTreeNode * root)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == root) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; root-&gt;m_nValue &lt;&lt; <span class="string">" "</span>;</div><div class="line">  PreorderPrintTree(root-&gt;m_pLeft);</div><div class="line">  PreorderPrintTree(root-&gt;m_pRight);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> preorder[<span class="number">8</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span> &#125;;</div><div class="line">  <span class="keyword">int</span> inorder[<span class="number">8</span>] = &#123; <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span> &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> T = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; T++ &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">  BinaryTreeNode *root = Construct(preorder, inorder, <span class="number">8</span>);</div><div class="line">  PreorderPrintTree(root);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</div><div class="line"></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; T++ &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">  <span class="keyword">int</span> preorder1[<span class="number">7</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;; <span class="comment">// complete binary tree</span></div><div class="line">  <span class="keyword">int</span> inorder1[<span class="number">7</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</div><div class="line">  BinaryTreeNode *root1 = Construct(preorder1, inorder1, <span class="number">7</span>);</div><div class="line">  PreorderPrintTree(root1);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</div><div class="line"></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; T++ &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">  <span class="keyword">int</span> preorder2[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>&#125;; <span class="comment">// incomplete binary tree</span></div><div class="line">  <span class="keyword">int</span> inorder2[<span class="number">5</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</div><div class="line">  BinaryTreeNode *root2 = Construct(preorder2, inorder2, <span class="number">5</span>);</div><div class="line">  PreorderPrintTree(root2);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// only have left children</span></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; T++ &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">  <span class="keyword">int</span> preorder3[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</div><div class="line">  <span class="keyword">int</span> inorder3[<span class="number">3</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</div><div class="line">  BinaryTreeNode *root3 = Construct(preorder3, inorder3, <span class="number">3</span>);</div><div class="line">  PreorderPrintTree(root3);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// only have right children</span></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; T++ &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">  <span class="keyword">int</span> preorder4[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</div><div class="line">  <span class="keyword">int</span> inorder4[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</div><div class="line">  BinaryTreeNode *root4 = Construct(preorder4, inorder4, <span class="number">3</span>);</div><div class="line">  PreorderPrintTree(root4);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// only root node</span></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; T++ &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">  <span class="keyword">int</span> preorder5[<span class="number">1</span>] = &#123;<span class="number">1</span>&#125;;</div><div class="line">  <span class="keyword">int</span> inorder5[<span class="number">1</span>] = &#123;<span class="number">1</span>&#125;;</div><div class="line">  BinaryTreeNode *root5 = Construct(preorder5, inorder5, <span class="number">1</span>);</div><div class="line">  PreorderPrintTree(root5);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// empty tree</span></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; T++ &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">  <span class="keyword">int</span> preorder6[<span class="number">0</span>] = &#123;&#125;;</div><div class="line">  <span class="keyword">int</span> inorder6[<span class="number">0</span>] = &#123;&#125;;</div><div class="line">  BinaryTreeNode *root6 = Construct(preorder6, inorder6, <span class="number">0</span>);</div><div class="line">  PreorderPrintTree(root6);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</div><div class="line"></div><div class="line">  <span class="comment">// invalid input</span></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; T++ &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">  <span class="keyword">int</span> preorder7[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</div><div class="line">  <span class="keyword">int</span> inorder7[<span class="number">3</span>] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</div><div class="line">  BinaryTreeNode *root7 = Construct(preorder7, inorder7, <span class="number">3</span>);</div><div class="line">  PreorderPrintTree(root7);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>做了几道题目，大概又熟悉一些了吧。指针操作什么的。捡起来也挺容易。不过，有时间还是要研究一下C++的高级语法。</p>
<p>不太懂，同样的语法为什么短程序块就有代码高亮，长一点的就没有。不管了。就这样吧。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="liuxueyang.github.io/2017/03/06/const-member-function-in-cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liuxueyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/drawing.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑历史">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/06/const-member-function-in-cpp/" itemprop="url">
                  const member function in cpp
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-06T11:25:18+08:00">
                2017-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>默认情况下，<code>this</code>是一个const pointer to the nonconst version of the class type。比如有一个类<code>A</code>，那么在类里面，<code>this</code>的类型是<code>A * const</code>。因为不能把一个const对象的地址赋值给一个指向nonconst对象的指针，因此不能把this绑定到一个const对象上。这就导致，不能在const对象上调用一个nonconst member function。</p>
<p>解决方法就是，把<code>this</code>声明为<code>const</code>。可是<code>this</code>是隐性的变量，所以C++的解决方法就是在参数列表后面指定<code>const</code>。这样的函数就是const member function。它的语义是：<code>this</code>是一个const pointer to a const object of the class type。这样，const对象和nonconst对象都可以调用这个函数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="liuxueyang.github.io/2017/03/06/const-pointer-and-pointer-to-const-in-Cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liuxueyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/drawing.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑历史">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/06/const-pointer-and-pointer-to-const-in-Cpp/" itemprop="url">
                  const pointer and pointer to const in Cpp
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-06T10:03:28+08:00">
                2017-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>中文翻译好像有常量指针和指针常量这两种说法。然而翻译过来让我更加费解。还是英文更加直白。</p>
<h2 id="pointer-to-const"><a href="#pointer-to-const" class="headerlink" title="pointer to const"></a>pointer to const</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">30</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> * bptr = &amp;b;</div></pre></td></tr></table></figure>
<p><code>bptr</code>是一个指针，它指向的是一个类型为<code>const int</code>的对象。可以对<code>bptr</code>本身的内容（保存的地址）进行修改，但是不能对它指向的对象进行修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">31</span>;</div><div class="line">bptr = &amp;c;</div></pre></td></tr></table></figure>
<p>这样，<code>bptr</code>就指向了另外一个const对象。</p>
<p>有个例外：可以让pointer to const指向一个nonconst对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> d = <span class="number">32</span>;</div><div class="line">bptr = &amp;d;</div></pre></td></tr></table></figure>
<p>需要注意的是，即使<code>d</code>变量是nonconst，仍然不能通过<code>bptr</code>这个指针对<code>b</code>进行修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// *bptr = 33; // error!</span></div></pre></td></tr></table></figure>
<p>总之，</p>
<blockquote>
<p>我可以指向const对象，也可以指向nonconst对象，你也可以修改我。但是，你不能修改我指向的<em>对象</em>。<br>— pointer to const</p>
</blockquote>
<h2 id="const-pointer"><a href="#const-pointer" class="headerlink" title="const pointer"></a>const pointer</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</div><div class="line"><span class="keyword">int</span> * <span class="keyword">const</span> aptr = &amp;a;</div></pre></td></tr></table></figure>
<p><code>aptr</code>是一个常量，同时是一个指针。不能对<code>aptr</code>里面保存的地址进行修改。但是可以对<code>aptr</code>所指向的对象进行修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*aptr = <span class="number">4</span>;</div></pre></td></tr></table></figure>
<h2 id="const-reference"><a href="#const-reference" class="headerlink" title="const reference"></a>const reference</h2><p>一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">42</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = i;</div></pre></td></tr></table></figure>
<p>例外：const reference 可以引用一个nonconst对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> j = <span class="number">10</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;rj = &amp;j;</div></pre></td></tr></table></figure>
<p>这样做唯一的作用就是，不能够通过<code>rj</code>这个引用来改变<code>j</code>变量的值。这里和<code>pointer to const</code>是一样的。</p>
<p>但是不能让一个nonconst reference引用一个const对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const int k = 30;</div><div class="line">// int &amp;rk = &amp;k; // error!</div></pre></td></tr></table></figure>
<p>总之指向const的指针或者引用可以指向（引用）nonconst对象。但是指向nonconst的指针或者引用不可以指向（const）对象。</p>
<hr>
<p>这个问题以前就遇到过也弄明白了，然而过了很长时间又忘了。所以记在这里。</p>
<p>一段完整的测试程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 2017/03/06 08:57:48</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">const: const.cpp</div><div class="line">	g++ -Wall -std=gnu++11 const.cpp -o const</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// Pointers and const</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">// we may store the address of a const object ONLY in a pointer to const</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</div><div class="line">  <span class="comment">// double *ptr = &amp;pi;            // error!</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;</div><div class="line">  <span class="comment">// *cptr = 10;                   // error: cannot assign to *cptr</span></div><div class="line"></div><div class="line">  <span class="comment">// But there are two exceptions to the rule that the type of a pointer</span></div><div class="line">  <span class="comment">// and the object to which it points must match:</span></div><div class="line">  <span class="comment">// 1) we can use a pointer to const to point to a nonconst object:</span></div><div class="line">  <span class="keyword">double</span> a = <span class="number">2.17</span>;</div><div class="line">  cptr = &amp;a;                    <span class="comment">// we can not change a through cptr</span></div><div class="line">  <span class="comment">// pointer to const: I think I point to a const though I am not sure. T_T</span></div><div class="line">  <span class="comment">// Maybe it is nonconst. But I won't (cannot) change its value. ^_^ Besides,</span></div><div class="line">  <span class="comment">// You can change myself, but you can not change the OBJECT I point to.</span></div><div class="line"></div><div class="line">  <span class="keyword">int</span> b = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> *<span class="keyword">const</span> bptr = &amp;b;         <span class="comment">// bptr will ALWAYS point to b</span></div><div class="line">  <span class="comment">// but you can change the object it points if that is not a const object:</span></div><div class="line">  *bptr = <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">double</span> * <span class="keyword">const</span> ppi = &amp;pi; <span class="comment">// ppi is a const pointer to const object</span></div><div class="line"></div><div class="line">  <span class="comment">// //////////////////////////////</span></div><div class="line">  <span class="comment">// References</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> c = <span class="number">8</span>;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> &amp; cc = c;</div><div class="line">  <span class="comment">// int &amp; c1 = c;                 // error! we cannot assign directly to c,</span></div><div class="line">  <span class="comment">// we also should not be able to use a reference to change c.</span></div><div class="line"></div><div class="line">  <span class="comment">// But there is an exception: a reference to const may refer to an object</span></div><div class="line">  <span class="comment">// that is not const</span></div><div class="line">  <span class="keyword">int</span> i = <span class="number">42</span>;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;</div><div class="line">  <span class="keyword">int</span> &amp;r2 = i;</div><div class="line">  r2 = <span class="number">43</span>;</div><div class="line">  <span class="comment">// r1 = 44;                      // error: can not change i through r1</span></div><div class="line"></div><div class="line">  <span class="comment">// c++ programmers tend to abbreviate `reference to const` as `const reference`. There are non const references. A reference is not an object, so we cannot make a reference itself const. Because there is no way to make a reference refer to a different object, in some sense all references are const.</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="liuxueyang.github.io/2017/03/06/Learn-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liuxueyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/drawing.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑历史">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/06/Learn-C/" itemprop="url">
                  Learn C++
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-06T09:56:32+08:00">
                2017-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我已经很久没有碰过C++这门语言了。重新看到C++程序的时候竟然有些陌生，很多语法都模糊了。所以我打算复习一下。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="liuxueyang.github.io/2017/02/17/学习org-mode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liuxueyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/drawing.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑历史">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/17/学习org-mode/" itemprop="url">
                  学习org-mode
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-17T14:09:39+08:00">
                2017-02-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天我花了非常多的时间来学习org-mode，以前主要用它来记录每天的工作和学习日志，仅仅记录学习时间，几乎只用到了Clock in, Clock out之类的功能。这两天我发现我非常有必要对学过的东西做一个总结或者笔记，供以后查看，不然每次捡起很久之前看的东西还是有点困难。比如前几周学的PL课程，分三部分，学完第一部分觉得还可以，第二部分就比较难了，有些比较新的概念虽然没有完全理解，但是照葫芦画瓢做作业还是可以的。然后到了第三部分，也能够顺利把作业完成。然而到了最后的考试的时候考到第二部分的知识和概念，我竟然几乎完全记不起来了！说实话我还是挺惊讶的。所以我决定以后要经常作笔记，没有完全理解的概念和原理应该经常回顾，反复消化。所以我决定认真学习一下org-mode，用它来管理我的笔记。</p>
<p>本来我把笔记放在了 Dropbox 里面同步，后来想了想，我可能还是会拷贝一份在这里。以后查阅可能会方便很多。随后我会陆续把关于org-mode的笔记贴到下面。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="liuxueyang.github.io/2017/02/16/解决Kconsole下Emacs-org-mode快捷键不能使用的问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liuxueyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/drawing.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="黑历史">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/16/解决Kconsole下Emacs-org-mode快捷键不能使用的问题/" itemprop="url">
                  解决Konsole下Emacs org-mode快捷键不能使用的问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-16T20:11:10+08:00">
                2017-02-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果想在终端里面使用Emacs的话，org-mode的有些快捷键可能会失效，比如<code>M-LEFT</code>，这个问题在这里有一个解决方案：<a href="http://stackoverflow.com/questions/5556678/m-ret-and-m-up-down-not-working-in-emacs-org-mode-in-console-terminal#6808124" target="_blank" rel="external">Stack Overflow</a>。然而我还是觉得挺麻烦的。</p>
<p>今天瞎玩的时候，一个非常偶然的机会，发现这个问题在KDE 4里面的原生的Konsole里面可以非常容易地被解决，只需要在Profile的设置里面的Keyboard标签里面的<code>Key Bindings</code>设置成<code>Default (Xfree 4)</code>，如图：</p>
<p><img src="http://wstaw.org/m/2017/02/16/plasma-desktopQm1469.png" alt="Konsole"></p>
<p>然后在<code>org-mode</code>里面就可以使用类似于<code>M-LEFT</code>之类的快捷键了。虽然GUI版本的Emacs可能会比较好看，不过还是终端下用Emacs更方便一点。另外，说到终端，以前经常用Terminator，不过在KDE 4里面其实原生的Konsole体验更好。顺便说一句：Slackware是我用过的最好用的发行版。KDE 4非常好用，当作主力机使用了两个多月了，没有出现过问题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/46/">46</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/drawing.png"
               alt="liuxueyang" />
          <p class="site-author-name" itemprop="name">liuxueyang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">457</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">55</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liuxueyang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
