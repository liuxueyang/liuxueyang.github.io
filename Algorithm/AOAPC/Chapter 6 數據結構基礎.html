<!DOCTYPE html>
<html lang="zh-TW">
<head>
<!-- 2019-02-09 Sat 20:26 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Chapter 6 數據結構基礎</title>
<meta name="generator" content="Org mode">
<meta name="author" content="liuxueyang">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
 <link rel='stylesheet' title='Standard' href='/views/css/worg.css' type='text/css' />
 <link rel='alternate stylesheet' title='Zenburn' href='/views/css/worg-zenburn.css' type='text/css' />
 <link rel='alternate stylesheet' title='Classic' href='/views/css/worg-classic.css' type='text/css' />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src='https://www.googletagmanager.com/gtag/js?id=UA-123066567-1'></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-123066567-1');
</script>

<link rel='apple-touch-icon' sizes='57x57' href='./images/favicon/apple-icon-57x57.png'>
<link rel='apple-touch-icon' sizes='60x60' href='./images/favicon/apple-icon-60x60.png'>
<link rel='apple-touch-icon' sizes='72x72' href='./images/favicon/apple-icon-72x72.png'>
<link rel='apple-touch-icon' sizes='76x76' href='./images/favicon/apple-icon-76x76.png'>
<link rel='apple-touch-icon' sizes='114x114' href='./images/favicon/apple-icon-114x114.png'>
<link rel='apple-touch-icon' sizes='120x120' href='./images/favicon/apple-icon-120x120.png'>
<link rel='apple-touch-icon' sizes='144x144' href='./images/favicon/apple-icon-144x144.png'>
<link rel='apple-touch-icon' sizes='152x152' href='./images/favicon/apple-icon-152x152.png'>
<link rel='apple-touch-icon' sizes='180x180' href='./images/favicon/apple-icon-180x180.png'>
<link rel='icon' type='image/png' sizes='192x192'  href='./images/favicon/android-icon-192x192.png'>
<link rel='icon' type='image/png' sizes='32x32' href='./images/favicon/favicon-32x32.png'>
<link rel='icon' type='image/png' sizes='96x96' href='./images/favicon/favicon-96x96.png'>
<link rel='icon' type='image/png' sizes='16x16' href='./images/favicon/favicon-16x16.png'>
<link rel='manifest' href='./images/favicon/manifest.json'>
<meta name='msapplication-TileColor' content='#ffffff'>
<meta name='msapplication-TileImage' content='/ms-icon-144x144.png'>
<meta name='theme-color' content='#ffffff'>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="javascript:history.back()"> 返回 </a>
 |
 <a accesskey="H" href="/"> 主頁 </a>
</div><div id="content">
<header>
<h1 class="title">Chapter 6 數據結構基礎</h1>
</header><nav id="table-of-contents">
<h2>&#30446;&#37636;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org32e2438">1. <span class="done DONE">DONE</span> 棧和隊列</a>
<ul>
<li><a href="#org87968a9">1.1. 鐵軌</a></li>
</ul>
</li>
<li><a href="#org4a2f825">2. <span class="done DONE">DONE</span> 鏈表</a>
<ul>
<li><a href="#org72e7968">2.1. 對比測試</a></li>
</ul>
</li>
<li><a href="#org44f3852">3. <span class="done DONE">DONE</span> 二叉樹</a>
<ul>
<li><a href="#orgbc33db3">3.1. <span class="done DONE">DONE</span> 小球下落</a></li>
<li><a href="#orgf25e8a7">3.2. <span class="done DONE">DONE</span> 層次遍歷</a></li>
<li><a href="#orge6c1673">3.3. <span class="done DONE">DONE</span> 二叉樹重建</a></li>
</ul>
</li>
<li><a href="#org6c20c84">4. 圖</a>
<ul>
<li><a href="#orgcf8049b">4.1. <span class="done DONE">DONE</span> 黑白圖像</a></li>
<li><a href="#orga5889f3">4.2. <span class="done DONE">DONE</span> 走迷宮</a></li>
<li><a href="#orga6090f7">4.3. <span class="done DONE">DONE</span> 拓撲排序</a></li>
</ul>
</li>
</ul>
</div>
</nav>

<div id="outline-container-org32e2438" class="outline-2">
<h2 id="org32e2438"><span class="section-number-2">1</span> <span class="done DONE">DONE</span> 棧和隊列</h2>
<div class="outline-text-2" id="text-1">
</div>

<div id="outline-container-org87968a9" class="outline-3">
<h3 id="org87968a9"><span class="section-number-3">1.1</span> 鐵軌</h3>
<div class="outline-text-3" id="text-1-1">
<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">MAXN</span> = 1000 + 10;
<span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-variable-name">a</span>[MAXN];

<span class="org-type">int</span> <span class="org-function-name">main</span>( <span class="org-type">void</span> ) {

<span class="org-preprocessor">#ifdef</span> DEBUG
  freopen(<span class="org-string">"6-1-2.in"</span>, <span class="org-string">"r"</span>, stdin);
<span class="org-preprocessor">#endif</span>

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#37941;&#36556;</span>
  <span class="org-keyword">while</span> (cin &gt;&gt; n) {
    <span class="org-type">int</span> <span class="org-variable-name">stk</span>[MAXN], <span class="org-variable-name">top</span> = 0;
    <span class="org-type">int</span> <span class="org-variable-name">A</span> = 1, <span class="org-variable-name">B</span> = 1;
    REP_1(i, n) cin &gt;&gt; a[i]; <span class="org-type">int</span> <span class="org-variable-name">ok</span> = 1;
    <span class="org-keyword">while</span> (B &lt;= n) {
      <span class="org-keyword">while</span> (A == a[B]) ++B, ++A;
      <span class="org-keyword">while</span> (A &lt; a[B]) stk[++top] = A++;
      <span class="org-keyword">while</span> (top &amp;&amp; stk[top] == a[B]) --top, ++B;
      PR3(A, B, a[B]);
      PR2(top, stk[top]);
      <span class="org-keyword">if</span> (B &gt;= n) <span class="org-keyword">break</span>;
      <span class="org-keyword">if</span> (A &gt; a[B]) {ok = 0; <span class="org-keyword">break</span>;}
    }
    PRLN(ok ? <span class="org-string">"Yes"</span> : <span class="org-string">"No"</span>);
  }

  <span class="org-keyword">return</span> 0;
}

</pre>
</div>

<p>
<a href="code/6-1-2.cpp"><code>6-1-2.cpp</code></a>
</p>
</div>
</div>
</div>


<div id="outline-container-org4a2f825" class="outline-2">
<h2 id="org4a2f825"><span class="section-number-2">2</span> <span class="done DONE">DONE</span> 鏈表</h2>
<div class="outline-text-2" id="text-2">
</div>

<div id="outline-container-org72e7968" class="outline-3">
<h3 id="org72e7968"><span class="section-number-3">2.1</span> 對比測試</h3>
<div class="outline-text-3" id="text-2-1">
<p>
生成隨機數據：
</p>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-type">double</span> <span class="org-function-name">random_</span>() {
  <span class="org-comment-delimiter">// </span><span class="org-comment">generate random number in [0, 1]</span>
  <span class="org-keyword">return</span> <span class="org-type">double</span>(rand()) / RAND_MAX;
}

<span class="org-type">int</span> <span class="org-function-name">random</span>(<span class="org-type">int</span> <span class="org-variable-name">m</span>) {
  <span class="org-comment-delimiter">// </span><span class="org-comment">generate random int between [0, m - 1]</span>
  <span class="org-keyword">return</span> <span class="org-type">int</span>(random_() * (m - 1) + 0.5);
}

<span class="org-type">int</span> <span class="org-function-name">main</span>( <span class="org-type">void</span> ) {

<span class="org-preprocessor">#ifdef</span> DEBUG
  freopen(<span class="org-string">"6-2-3.in"</span>, <span class="org-string">"r"</span>, stdin);
<span class="org-preprocessor">#endif</span>

  srand(time(<span class="org-constant">NULL</span>));

  REP(i, 5) PR1(random(10));

  <span class="org-keyword">return</span> 0;
}

</pre>
</div>

<p>
<a href="code/6-2-3.cpp"><code>6-2-3.cpp</code></a>
</p>

<p>
一般來說， 只在函數開頭調用一次 <code>srand</code> 函數就好。如果需要每次運行生成不同的隨機數，把 time(NULL) 返回的結果作爲參數傳遞給 <code>srand</code> 函數就好。
</p>
</div>
</div>
</div>


<div id="outline-container-org44f3852" class="outline-2">
<h2 id="org44f3852"><span class="section-number-2">3</span> <span class="done DONE">DONE</span> 二叉樹</h2>
<div class="outline-text-2" id="text-3">
</div>

<div id="outline-container-orgbc33db3" class="outline-3">
<h3 id="orgbc33db3"><span class="section-number-3">3.1</span> <span class="done DONE">DONE</span> 小球下落</h3>
<div class="outline-text-3" id="text-3-1">
<p>
根據小球個數的奇偶性，得到下降 D - 1 層的落點。比如對於根節點，第奇數個小球落在左子樹，偶數個小球落在右子樹；對於根節點的左子節點，同樣是第奇數個小球落在左子節點的左子樹，因此只需要知道有多少個小球經過左子樹就好。直到下降 D - 1 層，就可以得到一個小球最終的落點。
</p>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-type">int</span> <span class="org-function-name">main</span>( <span class="org-type">void</span> ) {

<span class="org-preprocessor">#ifdef</span> DEBUG
  freopen(<span class="org-string">"6-3-1.in"</span>, <span class="org-string">"r"</span>, stdin);
<span class="org-preprocessor">#endif</span>

  <span class="org-type">int</span> <span class="org-variable-name">D</span>, <span class="org-variable-name">I</span>;
  <span class="org-keyword">while</span> (cin &gt;&gt; D &gt;&gt; I) {
    <span class="org-type">int</span> <span class="org-variable-name">p</span> = 1;
    REP(i, D - 1) {
      p = p * 2 + (I % 2 == 0);
      ++I; I/=2;
    }
    PRLN(p);
  }

  <span class="org-keyword">return</span> 0;
}


</pre>
</div>

<p>
<a href="code/6-3-1.cpp"><code>6-3-1.cpp</code></a>
</p>
</div>
</div>


<div id="outline-container-orgf25e8a7" class="outline-3">
<h3 id="orgf25e8a7"><span class="section-number-3">3.2</span> <span class="done DONE">DONE</span> 層次遍歷</h3>
<div class="outline-text-3" id="text-3-2">
<p>
在編寫題目的時候，儘量避免指針和動態內存，但仍然需要具體問題具體分析。比如，用指針比用「數組+下標」的方式略快，因此，可以用「結構體+指針」的方式處理動態數據結構，但是在申請節點的時候，仍然用「動態化靜態」的思想，即：在程序開始申請足夠大的結構體數組，避免程序動態分配的時間花費。
</p>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-keyword">struct</span> <span class="org-type">Node</span> {
  <span class="org-type">int</span> <span class="org-variable-name">value</span>;
  <span class="org-type">bool</span> <span class="org-variable-name">assigned</span>;
  <span class="org-type">Node</span> *<span class="org-variable-name">left</span>;
  <span class="org-type">Node</span> *<span class="org-variable-name">right</span>;
};
<span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">root</span> = 1;
<span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">MAXN</span> = 300;
<span class="org-type">Node</span> <span class="org-variable-name">node</span>[MAXN];
<span class="org-type">int</span> <span class="org-variable-name">cnt</span> = 0;

<span class="org-type">Node</span> *<span class="org-function-name">new_node</span>() {
  <span class="org-type">Node</span> *<span class="org-variable-name">n</span> = &amp;node[++cnt];
  n-&gt;assigned = <span class="org-constant">false</span>; n-&gt;left = n-&gt;right = <span class="org-constant">nullptr</span>;
  <span class="org-keyword">return</span> n;
}

<span class="org-type">void</span> <span class="org-function-name">reset_tree</span>() {
  cnt = 0;
  new_node();
}

<span class="org-type">bool</span> <span class="org-function-name">add_node</span>(<span class="org-type">int</span> <span class="org-variable-name">value</span>, <span class="org-type">string</span> <span class="org-variable-name">move</span>) {
  <span class="org-type">Node</span> *<span class="org-variable-name">cur</span> = &amp;node[root];
  <span class="org-keyword">for</span> (<span class="org-keyword">auto</span> <span class="org-variable-name">x</span> : move) {
    <span class="org-keyword">if</span> (x == <span class="org-string">'L'</span>) {
      <span class="org-keyword">if</span> (<span class="org-constant">nullptr</span> == cur-&gt;left) {
        <span class="org-type">Node</span> *<span class="org-variable-name">p</span> = new_node();
        cur-&gt;left = p;
      }
      cur = cur-&gt;left;
    }
    <span class="org-keyword">else</span> {
      <span class="org-keyword">if</span> (<span class="org-constant">nullptr</span> == cur-&gt;right) cur-&gt;right = new_node();
      cur = cur-&gt;right;
    }
  }
  <span class="org-keyword">if</span> (cur-&gt;assigned) <span class="org-keyword">return</span> <span class="org-constant">false</span>; <span class="org-comment-delimiter">// </span><span class="org-comment">invalid input</span>
  cur-&gt;value = value; cur-&gt;assigned = <span class="org-constant">true</span>;
  <span class="org-keyword">return</span> <span class="org-constant">true</span>;
}

<span class="org-type">int</span> <span class="org-variable-name">ans</span>[MAXN];
<span class="org-type">int</span> <span class="org-variable-name">n</span> = 0;

<span class="org-type">bool</span> <span class="org-function-name">bfs</span>() {
  n = 0;
  <span class="org-type">Node</span> *<span class="org-variable-name">que</span>[MAXN];
  <span class="org-type">int</span> <span class="org-variable-name">front</span> = 0, <span class="org-variable-name">rear</span> = 1;
  que[front] = &amp;node[root];
  <span class="org-type">Node</span> *<span class="org-variable-name">cur</span>;
  <span class="org-keyword">while</span> (front &lt; rear) {
    cur = que[front++];
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>cur-&gt;assigned) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    ans[n++] = cur-&gt;value;
    <span class="org-keyword">if</span> (<span class="org-constant">nullptr</span> != cur-&gt;left) que[rear++] = cur-&gt;left;
    <span class="org-keyword">if</span> (<span class="org-constant">nullptr</span> != cur-&gt;right) que[rear++] = cur-&gt;right;
  }

  <span class="org-keyword">return</span> <span class="org-constant">true</span>;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>( <span class="org-type">void</span> ) {

<span class="org-preprocessor">#ifdef</span> DEBUG
  freopen(<span class="org-string">"6-3-2.in"</span>, <span class="org-string">"r"</span>, stdin);
<span class="org-preprocessor">#endif</span>

  <span class="org-type">string</span> <span class="org-variable-name">line</span>;
  <span class="org-keyword">while</span> (getline(cin, line)) {
    <span class="org-type">stringstream</span> <span class="org-variable-name">ss</span>(line);
    <span class="org-type">string</span> <span class="org-variable-name">s</span>; <span class="org-type">bool</span> <span class="org-variable-name">ok</span> = <span class="org-constant">true</span>;
    reset_tree();
    <span class="org-keyword">while</span> (ss &gt;&gt; s &amp;&amp; s != <span class="org-string">"()"</span>) {
      <span class="org-type">stringstream</span> <span class="org-variable-name">ss1</span>(s); <span class="org-type">int</span> <span class="org-variable-name">v</span>; ss1.ignore(); ss1 &gt;&gt; v; ss1.ignore();
      <span class="org-type">string</span> <span class="org-variable-name">move</span>; ss1 &gt;&gt; move; move = move.substr(0, move.size() - 1);
      ok = ok &amp;&amp; add_node(v, move);
    }
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>ok) { PRLN(-1); <span class="org-keyword">continue</span>; }
    ok = bfs();
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>ok) { PRLN(-1); <span class="org-keyword">continue</span>; }
    REP(i, n) PRC(ans[i]); NL;
  }

  <span class="org-keyword">return</span> 0;
}


</pre>
</div>

<p>
<a href="code/6-3-2.cpp"><code>6-3-2.cpp</code></a>
</p>

<p>
寫這道題的時候，初始化根節點的時候，沒有正確初始化 cnt，所以新建節點的過程中，出現了循環指針的錯誤，調試了很久。可見，使用全局變量的時候，還是要細心一點。
</p>
</div>
</div>

<div id="outline-container-orge6c1673" class="outline-3">
<h3 id="orge6c1673"><span class="section-number-3">3.3</span> <span class="done DONE">DONE</span> 二叉樹重建</h3>
<div class="outline-text-3" id="text-3-3">
<p>
根據二叉樹的先序遍歷和中序遍歷，輸出它的後序遍歷序列。
</p>

<p>
先序遍歷的第一個字符就是根，因此只需要在中序遍歷中找到根，之前的就是左子樹，之後的就是右子樹。可以得到左子樹的長度，因此就可以在先序遍歷中截取相同長度，得到左子樹的先序遍歷，也能得到右子樹的先序遍歷。可以發現，這是一個遞歸過程。在過程中直接輸出根節點就好。
</p>

<p>
當然，也可以先把整棵樹構造出來，然後再後序遍歷。構造樹的時候，需要把當前遇到的節點壓棧，然後向左右子樹走的時候，標記一下，當前進入的是左子樹還是右子樹。新建節點的時候，看一下當前是左子樹還是右子樹，把當前節點掛載到根節點的左邊或者右邊就好，根節點可以在棧頂得到。
</p>

<p>
兩種方法我都寫了一遍：
</p>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-comment-delimiter">/**</span>
<span class="org-comment">   &#20351;&#29992;&#25351;&#37341;&#25351;&#21521;&#21205;&#24907;&#25976;&#25818;&#32080;&#27083;&#30340;&#20803;&#32032;&#30340;&#26178;&#20505;&#65292;&#19968;&#23450;&#35201;&#23567;&#24515;&#65292;&#22240;&#29234;&#21487;&#33021;&#21205;&#24907;&#25976;&#25818;</span>
<span class="org-comment">   &#32080;&#27083;&#26371;&#37325;&#26032;&#20998;&#37197;&#20839;&#23384;&#65292;&#36896;&#25104;&#21407;&#20358;&#30340;&#25351;&#37341;&#22833;&#25928;&#12290;</span>
<span class="org-comment"> */</span>

<span class="org-keyword">struct</span> <span class="org-type">Node</span> {
  <span class="org-type">char</span> <span class="org-variable-name">value</span>;
  <span class="org-type">int</span> <span class="org-variable-name">left</span>;
  <span class="org-type">int</span> <span class="org-variable-name">right</span>;
};

<span class="org-type">vector</span>&lt;<span class="org-type">Node</span>&gt; <span class="org-variable-name">node</span>;
<span class="org-type">stack</span>&lt;<span class="org-type">int</span>&gt; <span class="org-variable-name">st_node</span>;

<span class="org-type">void</span> <span class="org-function-name">reset_tree</span>() {
  <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>node.empty()) node.pop_back();
  <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>st_node.empty()) st_node.pop();
}

<span class="org-type">void</span> <span class="org-function-name">new_node</span>(<span class="org-type">char</span> <span class="org-variable-name">v</span>, <span class="org-type">bool</span> <span class="org-variable-name">left</span>) {
  <span class="org-type">Node</span> <span class="org-variable-name">t</span>; t.value = v; t.left = t.right = -1; node.push_back(t);
  <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>st_node.empty()) {
    <span class="org-type">int</span> <span class="org-variable-name">p</span> = st_node.top();
    <span class="org-keyword">if</span> (left) node[p].left = node.size() - 1;
    <span class="org-keyword">else</span> node[p].right = node.size() - 1;
  }
  st_node.push(node.size() - 1);
}

<span class="org-type">void</span> <span class="org-function-name">print_postorder</span>(<span class="org-keyword">const</span> <span class="org-type">string</span>&amp; <span class="org-variable-name">preorder</span>, <span class="org-keyword">const</span> <span class="org-type">string</span>&amp; <span class="org-variable-name">inorder</span>) {
  <span class="org-keyword">if</span> (preorder.empty() || inorder.empty()) <span class="org-keyword">return</span>;
  <span class="org-type">size_t</span> <span class="org-variable-name">p</span> = inorder.find(preorder[0]);
  assert(p != <span class="org-constant">string</span>::npos);
  print_postorder(preorder.substr(1, p), inorder.substr(0, p));
  print_postorder(preorder.substr(p + 1), inorder.substr(p + 1));
  cout &lt;&lt; preorder[0];
}

<span class="org-type">void</span> <span class="org-function-name">build_tree</span>(<span class="org-keyword">const</span> <span class="org-type">string</span>&amp; <span class="org-variable-name">preorder</span>, <span class="org-keyword">const</span> <span class="org-type">string</span>&amp; <span class="org-variable-name">inorder</span>, <span class="org-type">bool</span> <span class="org-variable-name">left</span>) {
  <span class="org-keyword">if</span> (preorder.empty() || inorder.empty()) <span class="org-keyword">return</span>;
  <span class="org-type">size_t</span> <span class="org-variable-name">p</span> = inorder.find(preorder[0]);
  assert(p != <span class="org-constant">string</span>::npos);
  new_node(preorder[0], left);
  build_tree(preorder.substr(1, p), inorder.substr(0, p), <span class="org-constant">true</span>);
  build_tree(preorder.substr(p + 1), inorder.substr(p + 1), <span class="org-constant">false</span>);
  st_node.pop();
}

<span class="org-type">void</span> <span class="org-function-name">post_traversal</span>(<span class="org-type">int</span> <span class="org-variable-name">root</span>) {
  <span class="org-keyword">if</span> (-1 == root) <span class="org-keyword">return</span>;
  post_traversal(node[root].left); post_traversal(node[root].right); cout &lt;&lt; node[root].value;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>( <span class="org-type">void</span> ) {

<span class="org-preprocessor">#ifdef</span> DEBUG
  freopen(<span class="org-string">"6-3-3.in"</span>, <span class="org-string">"r"</span>, stdin);
<span class="org-preprocessor">#endif</span>

  <span class="org-type">string</span> <span class="org-variable-name">preorder</span>, <span class="org-variable-name">inorder</span>;
  <span class="org-keyword">while</span> (cin &gt;&gt; preorder &gt;&gt; inorder) {
    reset_tree();
    print_postorder(preorder, inorder); NL;
    build_tree(preorder, inorder, <span class="org-constant">false</span>);
    post_traversal(0);
    NL;
  }

  <span class="org-keyword">return</span> 0;
}

</pre>
</div>

<p>
<a href="code/6-3-3.cpp"><code>6-3-3.cpp</code></a>
</p>

<p>
在建樹的過程中，原先我想用 vector 配合結構體指針來實現樹結構，後來遇到了奇怪的錯誤，才發現是因爲我把指針指向了 vector 元素，vector 在自動重新分配內存的時候，其實原來的指針已經失效了，所以我之前保存在樹節點的指針是無效的。所以，以後使用指針指向動態數據結構的時候，一定要小心。對這個問題我的解決方法是避免指針操作，使用下標來指向子節點。
</p>
</div>
</div>
</div>


<div id="outline-container-org6c20c84" class="outline-2">
<h2 id="org6c20c84"><span class="section-number-2">4</span> 圖</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgcf8049b" class="outline-3">
<h3 id="orgcf8049b"><span class="section-number-3">4.1</span> <span class="done DONE">DONE</span> 黑白圖像</h3>
<div class="outline-text-3" id="text-4-1">
<p>
簡單的 DFS 題目，判斷邊界的時候用到了一個小技巧：一開始把二維數組開大一點，然後在讀入數據的時候，把矩陣往左下方移動一個單位，矩陣邊緣都是 0，這樣就可以避免搜索過程中判斷數組是否越界了。因爲永遠不會從 0
的單位開始 DFS。
</p>

<p>
另外，遞歸 DFS 有棧溢出的危險，可以修改成用顯式棧的方式實現。兩種方法我都實現了一遍：
</p>

<div class="org-src-container">
<pre class="src src-cpp"><span class="org-type">int</span> <span class="org-variable-name">direction</span>[8][2] = { {-1, 0}, {1, 0}, {0, -1}, {0, 1},
                        {-1, -1}, {-1, 1}, {1, -1}, {1, 1} };

<span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">MAXN</span> = 300;
<span class="org-type">int</span> <span class="org-variable-name">mat</span>[MAXN][MAXN];
<span class="org-type">bool</span> <span class="org-variable-name">vis</span>[MAXN][MAXN];

<span class="org-type">void</span> <span class="org-function-name">dfs</span>(<span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span>) {
  <span class="org-keyword">if</span> (vis[x][y] || <span class="org-negation-char">!</span>mat[x][y]) <span class="org-keyword">return</span>;
  vis[x][y] = <span class="org-constant">true</span>;
  REP(i, 8) dfs(x + direction[i][0],
                y + direction[i][1]);
}

<span class="org-keyword">using</span> <span class="org-type">pp</span> = <span class="org-type">pair</span>&lt;<span class="org-type">int</span>,<span class="org-type">int</span>&gt;;
<span class="org-type">stack</span>&lt;<span class="org-type">pp</span>&gt; <span class="org-variable-name">st</span>;

<span class="org-type">void</span> <span class="org-function-name">dfs_stack</span>(<span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span>) {
  st.push(make_pair(x, y));
  <span class="org-keyword">while</span> (<span class="org-negation-char">!</span>st.empty()) {
    <span class="org-type">pp</span> <span class="org-variable-name">t</span> = st.top(); <span class="org-type">int</span> <span class="org-variable-name">x</span> = t.first, <span class="org-variable-name">y</span> = t.second;
    <span class="org-keyword">if</span> (vis[x][y] || <span class="org-negation-char">!</span>mat[x][y]) { st.pop(); <span class="org-keyword">continue</span>; }
    vis[t.first][t.second] = <span class="org-constant">true</span>;
    REP(i, 8) st.push(make_pair(x + direction[i][0],
                                y + direction[i][1]));
  }
}

<span class="org-type">int</span> <span class="org-function-name">main</span>( <span class="org-type">void</span> ) {

<span class="org-preprocessor">#ifdef</span> DEBUG
  freopen(<span class="org-string">"6-4-1.in"</span>, <span class="org-string">"r"</span>, stdin);
<span class="org-preprocessor">#endif</span>

  <span class="org-type">int</span> <span class="org-variable-name">n</span>;
  <span class="org-keyword">while</span> (cin &gt;&gt; n) {
    <span class="org-type">string</span> <span class="org-variable-name">s</span>;
    memset(vis, <span class="org-constant">false</span>, <span class="org-keyword">sizeof</span> vis);
    memset(mat, 0, <span class="org-keyword">sizeof</span> mat);

    REP(i, n) {
      cin &gt;&gt; s;
      REP(j, n) mat[i + 1][j + 1] = s[j] - <span class="org-string">'0'</span>;
    }
    <span class="org-type">int</span> <span class="org-variable-name">cnt</span> {0};
    REP_1(i, n) {
      REP_1(j, n)
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>vis[i][j] &amp;&amp; mat[i][j]) {
          ++cnt; dfs_stack(i, j);
        }
    }
    PRLN(cnt);
  }

  <span class="org-keyword">return</span> 0;
}

</pre>
</div>

<p>
<a href="code/6-4-1.cpp"><code>6-4-1.cpp</code></a>
</p>
</div>
</div>


<div id="outline-container-orga5889f3" class="outline-3">
<h3 id="orga5889f3"><span class="section-number-3">4.2</span> <span class="done DONE">DONE</span> 走迷宮</h3>
<div class="outline-text-3" id="text-4-2">
<p>
BFS 求最短路。
</p>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-type">int</span> <span class="org-variable-name">direction</span>[8][2] = { {-1, 0}, {1, 0}, {0, -1}, {0, 1},
                        {-1, -1}, {-1, 1}, {1, -1}, {1, 1} };

<span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">MAXN</span> = 150;
<span class="org-type">int</span> <span class="org-variable-name">mat</span>[MAXN][MAXN], <span class="org-variable-name">parent</span>[MAXN][MAXN], <span class="org-variable-name">dir</span>[MAXN][MAXN], <span class="org-variable-name">dist</span>[MAXN][MAXN];
<span class="org-type">bool</span> <span class="org-variable-name">vis</span>[MAXN][MAXN];
<span class="org-type">int</span> <span class="org-variable-name">que</span>[MAXN * MAXN];
<span class="org-type">int</span> <span class="org-variable-name">n</span>, <span class="org-variable-name">m</span>;
<span class="org-type">char</span> <span class="org-variable-name">name</span>[5] = <span class="org-string">"UDLR"</span>;

<span class="org-type">void</span> <span class="org-function-name">bfs</span>( <span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span> ) {
  <span class="org-type">int</span> <span class="org-variable-name">front</span> = 0, <span class="org-variable-name">rear</span> = 0, <span class="org-variable-name">u</span> = x * m + y;
  que[rear++] = u; parent[x][y] = u; dist[x][y] = 0;

  <span class="org-keyword">while</span> (front &lt; rear) {
    <span class="org-type">int</span> <span class="org-variable-name">t</span> = que[front++], <span class="org-variable-name">tx</span> = t / m, <span class="org-variable-name">ty</span> = t % m;
    vis[tx][ty] = <span class="org-constant">true</span>;
    REP(i, 4) {
      <span class="org-type">int</span> <span class="org-variable-name">nx</span> = tx + direction[i][0], <span class="org-variable-name">ny</span> = ty + direction[i][1];

      <span class="org-keyword">if</span> (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m &amp;&amp;
          mat[nx][ny] &amp;&amp; <span class="org-negation-char">!</span>vis[nx][ny]) {

        que[rear++] = nx * m + ny; parent[nx][ny] = t; dir[nx][ny] = i;
        dist[nx][ny] = dist[tx][ty] + 1;
      }
    }
  }
}

<span class="org-type">int</span> <span class="org-variable-name">path_dir_index</span>[MAXN*MAXN];

<span class="org-type">void</span> <span class="org-function-name">print_path</span>(<span class="org-type">int</span> <span class="org-variable-name">x</span>, <span class="org-type">int</span> <span class="org-variable-name">y</span>) {
  <span class="org-type">int</span> <span class="org-variable-name">p</span>, <span class="org-variable-name">x1</span> = x, <span class="org-variable-name">y1</span> {y}, cnt = 0;

  <span class="org-keyword">while</span> (parent[x1][y1] != x1 * m + y1) {
    path_dir_index[cnt++] = dir[x1][y1];
    p = parent[x1][y1];
    x1 = p / m; y1 = p % m;
  }

  <span class="org-keyword">while</span> (cnt--) {
    cout &lt;&lt; name[path_dir_index[cnt]];
  } NL;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>(<span class="org-type">void</span>) {

  <span class="org-comment-delimiter">// </span><span class="org-comment">&#36208;&#36855;&#23470;</span>
<span class="org-preprocessor">#ifdef</span> DEBUG
  freopen(<span class="org-string">"6-4-2.in"</span>, <span class="org-string">"r"</span>, stdin);
<span class="org-preprocessor">#endif</span>

  <span class="org-keyword">while</span> (cin&gt;&gt;n&gt;&gt;m) {
    memset(vis, <span class="org-constant">false</span>, <span class="org-keyword">sizeof</span>(vis));
    memset(parent, -1, <span class="org-keyword">sizeof</span>(parent));
    REP(i, n) {
      REP(j, m) cin &gt;&gt; mat[i][j];
    }
    <span class="org-type">int</span> <span class="org-variable-name">startx</span>, <span class="org-variable-name">starty</span>, <span class="org-variable-name">endx</span>, <span class="org-variable-name">endy</span>;
    cin &gt;&gt; startx &gt;&gt; starty &gt;&gt; endx &gt;&gt; endy;
    bfs(startx, starty);
    print_path(endx, endy);
  }

  <span class="org-keyword">return</span> 0;
}

</pre>
</div>

<p>
<a href="code/6-4-2.cpp"><code>6-4-2.cpp</code></a>
</p>

<ul class="org-ul">
<li>寫程序的時候，一定要想清楚，思路清晰。實現的時候只需要按照想法認真實現就可以了。</li>
<li>寫這道題目的過程中出現了兩個筆誤，稍微調試了一下，還好很容易就調試出來了：
<ul class="org-ul">
<li>一個是輸入的時候下標寫錯了</li>
<li>另外一個是條件判斷的 <code>&amp;&amp;</code> 寫成了 <code>&amp;</code></li>
</ul></li>
<li>另外，數組範圍開多大一定要考慮清楚，不能想當然。</li>
<li>處理細節的時候不能夠心急，要每個方面都考慮周全，否則之後造成的錯誤更加難以彌補。</li>
</ul>
</div>
</div>


<div id="outline-container-orga6090f7" class="outline-3">
<h3 id="orga6090f7"><span class="section-number-3">4.3</span> <span class="done DONE">DONE</span> 拓撲排序</h3>
<div class="outline-text-3" id="text-4-3">
<p>
如果圖中存在有向環，則不存在拓撲排序，反之則存在。我們把不包含有向環的有向圖叫做有向無環圖「DAG」。
</p>

<p>
可以使用 DFS 來完成拓撲排序：在訪問完一個節點之後把它加入到當前拓撲序的首部。原因是回退的時候的節點一定是拓撲序前面的節點。
</p>

<div class="org-src-container">
<pre class="src src-cpp">
<span class="org-keyword">const</span> <span class="org-type">int</span> <span class="org-variable-name">MAXN</span> = 1000 + 1;
<span class="org-type">int</span> <span class="org-variable-name">G</span>[MAXN][MAXN];
<span class="org-type">int</span> <span class="org-variable-name">vis</span>[MAXN], <span class="org-variable-name">path</span>[MAXN];
<span class="org-type">int</span> <span class="org-variable-name">t</span>, <span class="org-variable-name">n</span>;

<span class="org-type">bool</span> <span class="org-function-name">dfs</span>(<span class="org-type">int</span> <span class="org-variable-name">u</span>) {
  vis[u] = -1;
  REP_1(v, n) {
    <span class="org-keyword">if</span> (G[u][v]) {
      <span class="org-keyword">if</span> (-1 == vis[v]) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
      <span class="org-keyword">else</span> {
        <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>vis[v]) {
          <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>dfs(v)) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
        }
      }
    }
  }
  vis[u] = 1;
  path[t--] = u;
  <span class="org-keyword">return</span> <span class="org-constant">true</span>;
}

<span class="org-type">bool</span> <span class="org-function-name">topsort</span>() {
  t = n;
  memset(vis, 0, <span class="org-keyword">sizeof</span>(vis));

  REP_1(u, n) {
    <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>vis[u]) {
      <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>dfs(u)) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    }
  }
  <span class="org-keyword">return</span> <span class="org-constant">true</span>;
}

<span class="org-type">int</span> <span class="org-function-name">main</span>( <span class="org-type">void</span> ) {

<span class="org-preprocessor">#ifdef</span> DEBUG
  freopen(<span class="org-string">"6-4-3.in"</span>, <span class="org-string">"r"</span>, stdin);
<span class="org-preprocessor">#endif</span>

  <span class="org-type">int</span> <span class="org-variable-name">m</span>;
  <span class="org-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) {
    <span class="org-type">int</span> <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span>;
    memset(G, 0, <span class="org-keyword">sizeof</span>(G));
    <span class="org-keyword">while</span> (m--) {
      cin &gt;&gt; a &gt;&gt; b; G[a][b] = 1;
    }

    <span class="org-keyword">if</span> (topsort()) {
      REP_1(i, n) PRC(path[i]);
      NL;
    }
    <span class="org-keyword">else</span> {
      PRLN(<span class="org-string">"not DAG"</span>);
    }
  }

  <span class="org-keyword">return</span> 0;
}

</pre>
</div>

<p>
<a href="code/6-4-3.cpp">6-4-3.cpp</a>
</p>

<p>
<a href="code/6-4-3.in">6-4-3.in</a>
</p>

<p>
程序中在 DFS 的過程中，使用了一個 <code>vis</code> 標記數組：
</p>

<ul class="org-ul">
<li>0 表示從來沒有被訪問過；</li>
<li>1 表示已經訪問過，並且還訪問過它的子孫；</li>
<li>-1 表示正在訪問它的子孫。</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<br/>
<br/>
<p class='author'>Author: liuxueyang (<a href="mailto:liuxueyang457@gmail.com">liuxueyang457@gmail.com</a>)</p>
<p class='date'>Date: 2018-09-17 Mon 00:00</p>
<p class='creator'>Emacs 26.1 (Org mode 9.1.9)</p>
<p class='validation'><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>

<script>
var idcomments_acct = 'ab93a85474f166ce7e6c4b85791a447d';
var idcomments_post_id;
var idcomments_post_url;
</script>

 <div id='comments'>
  <div class='intense_debate' id='intense_debate_btn'
       onclick='intense_debate()'>点击加载评论
  </div>
  <div id='intense_debate_thread'></div>
  <span id='IDCommentsPostTitle' style='display:none'></span>
 </div>

 <script>
     let disqus_loaded = false;
     function intense_debate() {
         if (!disqus_loaded) {
             disqus_loaded = true;
             (function () {
                 var d = document, s = d.createElement('script');
                 s.src = 'https://www.intensedebate.com/js/genericCommentWrapperV2.js';
                 d.body.appendChild(s);
             })();
         }
         document.getElementById('intense_debate_btn').style.display = 'none';
         return false;
     }
 </script>
</div>
</body>
</html>
