<!doctype html>

<html lang="zh-cn">

<head>
  <title>LXY Site</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="The HTML5 Herald" />
  <meta name="author" content="" />
  <meta name="generator" content="Hugo 0.32.2" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/7.0.0/normalize.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  <link rel="stylesheet" type="text/css" href="/css/styles.css" />
</head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="/">LXY Site</a>
            </h1>

      <ul id="social-media">
             
      </ul>
      
    </header>

    
<nav>
    <ul>
        
    </ul>
</nav>

    <main>




<article>

    <h1>poj2421 Constructing Roads ——最小生成树入门题_Kruscal算法</h1>

    
        <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2013-05-02T10:17:00Z">May 2, 2013</time>
        </li>
        
        

        
        <li>
            <em>
                
                    
                    <a href="/tags/poj/">#POJ</a>
                
                    , 
                    <a href="/tags/graph/">#Graph</a>
                
            </em>
        </li>
        

        <li>2 min read</li>
    </ul>
</aside>
    

    <p>题目链接：<a href="http://poj.org/problem?id=2421">http://poj.org/problem?id=2421</a>
题目大意：
　　给定一个矩阵，第 i 行第 j 列表示点 i 和点 j　的距离是ｓ［ｉ］［ｊ］。然后输入Ｑ，下面Ｑ行，每行两个数字ａ，ｂ表示点ａ和点ｂ已经有路相连。求需要至少再修多长的路，可以构成一棵生成树。输出需要在修的路的总长度。
题目思路：
　　转化为最小生成树求解。有两种思路：
　　１）把已经相连的两个点的权值设置为０，这样，就可以直接求最小生成树了。因为kruscal的过程中，一定会选择到已经相连的这些点，因为它们的权值是0嘛，同时，即使把它们的权值加上，也不会影响结果。这个方法我好不容易想出来了，可是还有一个问题，就是：输入a b 后，如何定位到相应的边，并把这个边的权值设置为0？开始的时候，是暴力找，超时了，然后自己想各种方法，还求出来个公式，用a,b,N,表示出边的编号。最后还是超时了。。看网上别人恰好有人也是这么个思路，但是他是怎么定位边，并把边的权值设置为0的，没仔细看，不知道为什么人家就用这种方法过了……
　　2）第二种思路，如果a b 已经相连，很简单，只要它俩的根节点不同，就把它两个合并不就可以了么，这样，kruscal的过程中，就不会再加入这些已经存在的边的权值了。剩下的就是纯的kruscal问题。这个方法很好！看的别人的想法。然后自己写了一下，RE了一次，原因是，合并a b 的时候，没有判断他们的根节点是否不同。。</p>

<pre><code class="language-cpp">
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cctype&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#define lson l, m, rt&lt;&lt;1
#define rson m+1, r, rt&lt;&lt;1|1
using namespace std;
typedef long long int LL;
const int MAXN =  0x3f3f3f3f;
const int  MIN =  -0x3f3f3f3f;
const double eps = 1e-9;
const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1},
  {1,1},{1,-1},{-1,-1}};
typedef struct Edge {
  int u, v, w;
  bool operator &lt; (const Edge &amp;o) const {
    return w &lt; o.w;
  }
}Edge;
const int Mam = 5000+10, Man = 100+10;
Edge edge[Mam];
int parent[Man];
int N, Q, a, b, S[Man][Man], sum, ecnt;
void init()
{
  for (int i = 1; i &lt;= N; ++i) parent[i] = -1;
}
int Find(int x)
{
  int s;
  for (s = x; parent[s] &gt;= 0; s = parent[s]) ;
  while (s != x) {
    int tmp = parent[x]; parent[x] = s; x = tmp;
  } return s;
}
void Union(int R1, int R2)
{
  int r1 = Find(R1), r2 = Find(R2), tmp = parent[r1] + parent[r2];
  if (parent[r1] &gt; parent[r2]) {
    parent[r1] = r2; parent[r2] = tmp;
  } else {
    parent[r2] = r1; parent[r1] = tmp;
  }
}
void kruscal()
{
  int i, j, u, v, w, cnt = 0;
  for (i = 1; i &lt; ecnt; ++i) {
    u = edge[i].u; v = edge[i].v; w = edge[i].w;
    if (Find(u) != Find(v)) {
        sum += w; Union(u, v); cnt++;
    }
    if (cnt &gt;= N - 1) break;
  }
  printf(&quot;%d\n&quot;, sum);
}
int main(void){
#ifndef ONLINE_JUDGE
  freopen(&quot;poj2421.in&quot;, &quot;r&quot;, stdin);
#endif
  int i, j, k, a, b;
  while (~scanf(&quot;%d&quot;, &amp;N)) {
    sum = 0; k = 1;
    for (i = 1; i &lt;= N; ++i) {
      for (j = 1; j &lt;= N; ++j) {
        scanf(&quot;%d&quot;, &amp;S[i][j]);
        if (i &lt; j) {
          edge[k].u = i; edge[k].v = j;
          edge[k].w = S[i][j]; k++;
        }
      }
    }
    ecnt = k;
    init();
    scanf(&quot;%d&quot;, &amp;Q);
    for (i = 0; i &lt; Q; ++i) {
      scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
      if (Find(a) != Find(b)) Union(a, b); //这里要判断一下根节点是不是相同，再合并！RE一次
    }
    sort(edge, edge + ecnt);
    kruscal();
  }

  return 0;
}

</code></pre>

<p>　　Code::Blocks超级难用赶脚……这两天老是用着用着就假死……然后强制关闭。。很不爽。。唉，还是回来乖乖地用gvim吧，自己学着写脚本，以后就不怕了。O(∩_∩)O哈哈~</p>


</article>


<section class="post-nav">
    <ul>
        
        <li>
            <a href="http://liuxueyang.github.io/posts/hoj12616-median-tree-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/"><i class="fa fa-chevron-circle-left"></i> hoj12616 Median Tree ——最小生成树入门题&amp;&amp;比赛残留题_Kruscal算法</a>
        </li>
        
        
        <li>
            <a href="http://liuxueyang.github.io/posts/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F_prim%E7%AE%97%E6%B3%95/">最小生成树示例程序_Prim算法 <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
    





</main>
    <footer>
        <h6> | 
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="http://liuxueyang.github.ioindex.xml">Subscribe</a></h6>
    </footer>
</div>
<script src="/js/scripts.js"></script>
</body>

</html>