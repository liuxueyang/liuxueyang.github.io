<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spoj on LXY Site</title>
    <link>http://liuxueyang.github.io/tags/spoj/</link>
    <description>Recent content in Spoj on LXY Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright &amp;copy; 2018 (LXY). All Rights Reserved.</copyright>
    <lastBuildDate>Sun, 14 Aug 2016 21:11:34 +0000</lastBuildDate>
    
	<atom:link href="http://liuxueyang.github.io/tags/spoj/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Spoj, math: CPCRC1C - Sum of Digits</title>
      <link>http://liuxueyang.github.io/posts/spoj-math-cpcrc1c-sum-of-digits/</link>
      <pubDate>Sun, 14 Aug 2016 21:11:34 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-math-cpcrc1c-sum-of-digits/</guid>
      <description>Primary Problem 题目大意：
给两个数字a和b，求从a到b所有数字的每一位的和。比如1到3就是：1+2+3=6, 10到12 就是：1+0 + 1+1 + 1+2=6，范围是10^9  为了表示方便，用[n]表示从1到n的所有数字的每一位的和。要求从a到b，只需要计算[b] - [a]就可以。</description>
    </item>
    
    <item>
      <title>Spoj: ANARC09A - Seinfeld</title>
      <link>http://liuxueyang.github.io/posts/spoj-anarc09a-seinfeld/</link>
      <pubDate>Sun, 14 Aug 2016 15:59:14 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-anarc09a-seinfeld/</guid>
      <description>题目意思：
一个字符串由`{`和`}`组成，长度最多位2000，求最少修改多少次可以使得这个字符串合法。  如果把合法的字符串都消去的话，那么最后留下不合法的括号，一定是这样的}*{*其中 *代表0个或者多个。题目规定字符串长度是偶数，所以不合法的括号的长度也一定是偶数， 假设它是len。
1. 如果只有左括号或者右括号，那么答案是`len/2`； 2. 如果左右括号都有，那么答案是左括号的个数/2 + 右括号的个数 / 2，如果左括号 或者右括号的个数是奇数，那么答案增加一。比如这个例子：`}}}{{{`  所以复杂度是O(n)。</description>
    </item>
    
    <item>
      <title>Spoj, dynamic-programming: ASSIGN - Assignments</title>
      <link>http://liuxueyang.github.io/posts/spoj-dynamic-programming-assign-assignments/</link>
      <pubDate>Sun, 14 Aug 2016 15:08:27 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-dynamic-programming-assign-assignments/</guid>
      <description>题目意思：
有n个学生和n个任务，每个学生有喜欢的任务，输入一个矩阵，第i行第j列表示第i个 学生喜欢第j个任务。把任务分配给所有学生，使得每个学生得到的任务都是他喜欢的。 输出有多少种分配方法。n的最大值是20。  用一个数字的一个位表示这个任务是否已经被分配，如果任务全部被分配，那么这个数字就 是(1&amp;lt;&amp;lt;n)-1。可以想到这样的递归方法：solve(i,mask) 表示对i..n这些人分配任务的 方法的数目，mask代表此时对1..i-1这些人已经分配了任务，也就是说mask的二进制表示里 面有i-1个1。对当前的人，如果他喜欢第j个任务，并且mask的第j位是0，那么就可以把这 个任务分配给他，继续考虑下一个人。</description>
    </item>
    
    <item>
      <title>Spoj, dynamic-programming: AIBOHP - Aibohphobia</title>
      <link>http://liuxueyang.github.io/posts/spoj-dynamic-programming-aibohp-aibohphobia/</link>
      <pubDate>Fri, 12 Aug 2016 21:36:32 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-dynamic-programming-aibohp-aibohphobia/</guid>
      <description>给一个字符串，求最少插入多少个字符，可以使得这个字符串是回文的。
可以这样想：我们假设它已经是回文的，那么把这个字符串逆序，如果它是回文的，那么对 应的每个字符应该相等。可以它不是回文的，那么就需要尽量少地加一些字符，加多少呢？ 那么需要知道当前的最长连续公共子序列的长度len，把不相等的那些字符串加进去就成为 了回文的。加进去的字符的最少个数 = 字符串长度 - 原先的字符串和它的逆序字符串的最 长连续公共子序列的长度。</description>
    </item>
    
    <item>
      <title>Spoj, dynamic-programming: BYTESM2 - Philosophers Stone</title>
      <link>http://liuxueyang.github.io/posts/spoj-dynamic-programming-bytesm2-philosophers-stone/</link>
      <pubDate>Fri, 12 Aug 2016 21:32:26 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-dynamic-programming-bytesm2-philosophers-stone/</guid>
      <description>在矩阵里面捡石头，求最大值。和常见的直角三角形那样的问题是一样的。
/* * ===================================================================================== * * Filename: main.cpp * * Description: http://www.</description>
    </item>
    
    <item>
      <title>Dynamic-programming: Spoj DIEHARD - DIE HARD</title>
      <link>http://liuxueyang.github.io/posts/dynamic-programming-spoj-diehard-die-hard/</link>
      <pubDate>Fri, 12 Aug 2016 21:14:23 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/dynamic-programming-spoj-diehard-die-hard/</guid>
      <description>题目很好理解：
有三个区域，你在每个区域里面只能停留一秒，每个区域会对你的两个指标h和a增加或者减少： 区域A：h += 3, a += 2 区域B：h -= 5, a -= 10 区域C：h -= 20, a+= 5 你在任意区域最多只能停留1秒，下一秒必须移动到其它两个区域中的一个，也就是说 你不能一直呆在一个区域。在任意时刻，如果你的两个指标其中的任意一个&amp;lt;=0，那么 游戏结束，输出你一共在游戏里面停留了多长时间。  如果不加什么思考，那么容易想到，直接递归就可以了，递归函数有三个参数：当前的h值， 当前的a值，当前的位置。为了不重复求解，用一个三位数组存储这一步的结果。</description>
    </item>
    
    <item>
      <title>spoj, segment tree: KGSS - Maximum Sum</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-kgss-maximum-sum/</link>
      <pubDate>Tue, 26 Jul 2016 08:58:52 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-kgss-maximum-sum/</guid>
      <description>Problem Link
每个节点保存三个值：区间的最大值，区间的第二大值，区间的最大的两个数的和
平常的区间的点更新和区间查询
// 2016/07/25 19:29:33 PM // Sabastian #include &amp;lt;iostream&amp;gt; #include &amp;lt;math.</description>
    </item>
    
    <item>
      <title>spoj, segment tree: HORRIBLE - Horrible Queries</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-horrible-horrible-queries/</link>
      <pubDate>Mon, 25 Jul 2016 23:25:39 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-horrible-horrible-queries/</guid>
      <description>Problem Link
平常的线段树区间更新和区间查询
// 2016/07/22 14:38:03 PM // Sabastian #include &amp;lt;iostream&amp;gt; #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>spoj, segment tree: GSS4 - Can you answer these queries IV</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-gss4-can-you-answer-these-queries-iv/</link>
      <pubDate>Mon, 25 Jul 2016 23:19:05 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-gss4-can-you-answer-these-queries-iv/</guid>
      <description>Problem Link
这道题目并没有用到懒惰更新，只是有一个优化：当一个区间的和等于区间长度的时候，那么他就没有必要更新了。
平常的线段树区间更新和区间查询
另外注意，题目中并没有说X和Y的大小关系。。
// 2016/07/22 19:58:12 PM // Sabastian #include &amp;lt;iostream&amp;gt; #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>spoj, segment tree: GSS3 - Can you answer these queries III</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-gss3-can-you-answer-these-queries-iii/</link>
      <pubDate>Mon, 25 Jul 2016 23:16:44 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-gss3-can-you-answer-these-queries-iii/</guid>
      <description>Problem Link
similar to GSS1 in addition to point update in segment tree.</description>
    </item>
    
    <item>
      <title>spoj, segment tree: GSS1 - Can you answer these queries I</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-gss1-can-you-answer-these-queries-i/</link>
      <pubDate>Mon, 25 Jul 2016 23:07:09 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-gss1-can-you-answer-these-queries-i/</guid>
      <description>Problem Link
max sum of a sequence can be from one of the three:</description>
    </item>
    
    <item>
      <title>spoj, segment tree: BRCKTS - Brackets</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-brckts-brackets/</link>
      <pubDate>Mon, 25 Jul 2016 22:56:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-brckts-brackets/</guid>
      <description>Problem Link
开始没有读懂题目，合法括号的意思其实就是常识情况下的括号合法：整个序列的左括号数目和右括号的数目相同，但是也不能出现这样的：)))(((，所以还要保证在任意一点，左括号的数目大于等于右括号的数目。
这就需要，在序列里面任意一点，左边的不匹配的左括号的数目一定等于右边的不匹配右括号的数目。
平常的线段树的点更新和区间查询
#include &amp;lt;iostream&amp;gt; using namespace std; struct SegmentTreeNode { int unmatchedLeft, unmatchedRight; void assignLeaf(char value) { if (value == &#39;(&#39;) { unmatchedLeft = 1; unmatchedRight = 0; } else { unmatchedLeft = 0; unmatchedRight = 1; } } void merge(SegmentTreeNode &amp;amp;left, SegmentTreeNode &amp;amp;right) { int L_unl = left.</description>
    </item>
    
    <item>
      <title>spoj, segment tree: AKVQLD03 - How to Handle the Fans</title>
      <link>http://liuxueyang.github.io/posts/spoj-segment-tree-akvqld03-how-to-handle-the-fans/</link>
      <pubDate>Mon, 25 Jul 2016 22:49:37 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/spoj-segment-tree-akvqld03-how-to-handle-the-fans/</guid>
      <description>Problem Link
平常的线段树点更新和区间查询
#include &amp;lt;iostream&amp;gt; #include &amp;lt;string.h&amp;gt; using namespace std; struct SegmentTreeNode { // fields on the node long long sum; void assignLeaf(int value) { sum = value; } void merge(SegmentTreeNode &amp;amp;left, SegmentTreeNode &amp;amp;right) { sum = left.</description>
    </item>
    
  </channel>
</rss>