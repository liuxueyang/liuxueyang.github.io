<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Poj on LXY Site</title>
    <link>http://liuxueyang.github.io/tags/poj/</link>
    <description>Recent content in Poj on LXY Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 03 Jul 2016 19:00:24 +0000</lastBuildDate>
    
	<atom:link href="http://liuxueyang.github.io/tags/poj/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>POJ3320 Jessica&#39;s Reading Problem</title>
      <link>http://liuxueyang.github.io/posts/poj3320-jessica-s-reading-problem/</link>
      <pubDate>Sun, 03 Jul 2016 19:00:24 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj3320-jessica-s-reading-problem/</guid>
      <description>Problem Jessica&amp;rsquo;s Reading Problem
Solution 方法和Subsequence一样，只是增加一个计数的步骤。
Code C++ #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; using namespace std; const int MAX_N = 100 * 10000 + 1; int a[MAX_N], n; set&amp;lt;int&amp;gt; idea; map&amp;lt;int, int&amp;gt; num_idea; void solve() { idea.clear(); num_idea.clear(); for (int i = 0; i &amp;lt; n; ++i) { idea.insert(a[i]); } int all_ideas = (int)idea.size(); int s = 0, t = 0, cnt = 0, ans = n + 1; while (true) { while (t &amp;lt; n &amp;amp;&amp;amp; cnt &amp;lt; all_ideas) { if (num_idea[a[t]] == 0) { cnt++; } num_idea[a[t]]++; ++t; } if (cnt &amp;lt; all_ideas) { break; } ans = min(ans, t - s); num_idea[a[s]]--; if (num_idea[a[s]] == 0) { num_idea.</description>
    </item>
    
    <item>
      <title>Poj3061 Subsequence</title>
      <link>http://liuxueyang.github.io/posts/poj3061-subsequence/</link>
      <pubDate>Sat, 02 Jul 2016 16:58:15 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj3061-subsequence/</guid>
      <description>Problem Subsequence
Solution 方法一：O(nlogn)
1. 计算前序和 2. 定起点，二分找不小于S的最小的连续区间和  方法二：O(n)
1. 定起点，线性找不小于S的最小的连续区间和，得到一个终点 2. 把起点向右移动一个单位，把终点在原来的基础上递增，线性找不小于S的最小的连 续区间和。如此反复。  Code 方法一：
C++ #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; int N, S; vector&amp;lt;int&amp;gt; a, presum; void solve() { cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; S; presum.clear(); a.clear(); a.reserve(N); presum.reserve(N + 1); for (int i = 0; i &amp;lt; N; ++i) { int tmp; cin &amp;gt;&amp;gt; tmp; a.push_back(tmp); } // presum[i] means sum of [0, i) elements // j &amp;gt; i, presum[j] - presum[i] means sum of [i, j) elements presum.</description>
    </item>
    
    <item>
      <title>poj1458 Common Subsequence ——最长公共子序列</title>
      <link>http://liuxueyang.github.io/posts/poj1458-common-subsequence-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sat, 17 Aug 2013 10:38:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1458-common-subsequence-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>link:http://poj.org/problem?id=1458 最基础的那种
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int sad[1111][1111];char apple[1111],pear[1111]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin ); #endif // ONLINE_JUDGE // while (gets(apple)!</description>
    </item>
    
    <item>
      <title>poj3181 Dollar Dayz ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/poj3181-dollar-dayz-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 18:14:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj3181-dollar-dayz-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://poj.org/problem?id=3181 本来很常规的一道完全背包，比较有意思的一点是，结果会超int，更有意思的解决方法是，不用高精度，用两个整型的拼接起来就行了。ORZ
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; typedef unsigned long long ULL; ULL dp[1111], dp1[1111]; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>poj3249 Test for Job  ——拓扑&#43;DP</title>
      <link>http://liuxueyang.github.io/posts/poj3249-test-for-job--%E6%8B%93%E6%89%91&#43;dp/</link>
      <pubDate>Thu, 15 Aug 2013 17:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj3249-test-for-job--%E6%8B%93%E6%89%91&#43;dp/</guid>
      <description>link:http://poj.org/problem?id=3249 在拓扑排序的过程中进行状态转移，dp[i]表示从起点到 i 这个点所得到的的最大值。比如从u点到v点，dp[v]=max(dp[v], dp[u]+a[v]) a[]数组是点的价值，最终的dp[]数组里面的最大值就是所求的。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; #define N 111111 using namespace std; int WO[N],NI[N],dp[N],TA[N]; vector&amp;lt;int&amp;gt; V[N]; queue&amp;lt;int&amp;gt; QU; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>poj1018 Communication System ——贪心&#43;枚举</title>
      <link>http://liuxueyang.github.io/posts/poj1018-communication-system-%E8%B4%AA%E5%BF%83&#43;%E6%9E%9A%E4%B8%BE/</link>
      <pubDate>Sat, 25 May 2013 06:16:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1018-communication-system-%E8%B4%AA%E5%BF%83&#43;%E6%9E%9A%E4%B8%BE/</guid>
      <description>题目链接：http://poj.org/problem?id=1018 题目大意： 有n种设备，每种设备有mi个选择，每种设备选择一个，每个设备都有一个带宽值和价钱，要求每种设备选择一个，最终选择的n个设备里面，带宽B是这n个设备里面所有带宽的最小值吗，价钱P为这n个设备价钱的和，求B/P的最大值。 题目思路： 这题开始没读懂题意，后来搜的题意之后才明白。然后没有思路……看了人家的思路，貌似懂了……然后就开始写，写跪了……开始的方法是，求出所有这n种设备里面每种设备的带宽的最小值，依次枚举这些最小值就可以了。总是WA…… 昨天纠结一晚上，今天早上又想了一下，发现原来的想法是有问题的，应该一直枚举到所有n中设备里面每种带宽的最大值的最小值。第一：保证这n种设备每一种都可以选上。第二：虽然枚举的B值比原来大了，所得到的的价钱不小于我原来的做法所得到的的价钱，但是，重点来了：B也增大了啊！有木有！所以，这就是我当初没有想到的！ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define MAXN 0x7fffffff #define MINN -MAXN const int MAX = 100+10; typedef struct node { int p, b, cnt; bool operator &amp;lt; (const node &amp;amp; other ) const { if (p != other.p) return p &amp;lt; other.p; else return b &amp;lt; other.b; } }node; typedef struct sys { node de[MAX]; int Min, Max, cnt; bool operator &amp;lt; (const sys &amp;amp;other) const { return Min &amp;lt; other.</description>
    </item>
    
    <item>
      <title>poj2299 Ultra-QuickSort ——线段树</title>
      <link>http://liuxueyang.github.io/posts/poj2299-ultra-quicksort-%E7%BA%BF%E6%AE%B5%E6%A0%91/</link>
      <pubDate>Thu, 23 May 2013 14:40:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2299-ultra-quicksort-%E7%BA%BF%E6%AE%B5%E6%A0%91/</guid>
      <description>题目链接：http://poj.org/problem?id=2299 题目大意： 给n个任意的数字，把他们排序，求最少的交换次数。 题目思路： 开始没想法。后来zjl一说才知道。原来就是求逆序数！每一个数字前面有多少比它小的，这个数字就至少要交换多少次。所以，只需要求这列数字的逆序数就可以！好神奇 还有一个，就是每个数字的范围比较大，开始我还在想开数组貌似放不下，后来zjl说离散化……好吧，果然，我肿么没想到o(╯□╰)o感觉挺自然的想法啊…… 剩下的就是原来做过的题目了……甚至比原来做过的还简单 最后一个问题就是，最后的结果应该是long long 的，稍微算一下就知道，最大值(2*10^11)超过了4个字节的整型范围(4 * 10^9)，long long 范围是(1*10^19)，所以输出要按照long long 输出……这个问题以后一定要注意，判断一下数字的范围！别傻乎乎地就用int…… //#define LOCAL #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 500000+10; typedef struct node { int val, index; bool operator &amp;lt; (const node &amp;amp; other) const { return val &amp;lt; other.</description>
    </item>
    
    <item>
      <title>poj1163 The Triangle ——DP入门题</title>
      <link>http://liuxueyang.github.io/posts/poj1163-the-triangle-dp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 20 May 2013 16:42:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1163-the-triangle-dp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1163 题目思路： 从三角形的底部开始考虑
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; const int MAX = 100; int a[MAX][MAX], dp[MAX][MAX]; int main(void) { //freopen(&amp;quot;1163.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); int n,i,j; scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); for (i = 0; i &amp;lt; n; ++i) { for (j = 0; j &amp;lt; i+1; ++j) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;a[i][j]); } } memset(dp, 0, sizeof(dp)); for (i = 0; i &amp;lt; n; ++i) dp[n-1][i] = a[n-1][i]; for (i = n - 2; i &amp;gt;= 0; --i) { for (j = 0; j &amp;lt; n - 1; ++j) { dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + a[i][j]; } } printf(&amp;quot;%d\n&amp;quot;, dp[0][0]); return 0; }  还是从最简单的开始做起吧 另外一种写法： #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; const int MAX = 100; int a[MAX][MAX], dp[MAX][MAX], n; int f(int i, int j) { if (dp[i][j] &amp;gt;= 0) return dp[i][j]; else { if (i == n-1) dp[i][j] = a[i][j]; else dp[i][j] = a[i][j] + max(dp[i+1][j], dp[i+1][j+1]); return dp[i][j]; } } int main(void) { int i,j; scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); for (i = 0; i &amp;lt; n; ++i) { for (j = 0; j &amp;lt; i+1; ++j) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;a[i][j]); } } memset(dp, -1, sizeof(dp)); for (i = 0; i &amp;lt; n; ++i) dp[n-1][i] = a[n-1][i]; for (i = n-1; i &amp;gt;= 0; --i) for (j = 0; j &amp;lt; i+1; ++j) f(i, j); printf(&amp;quot;%d\n&amp;quot;, dp[0][0]); return 0; }   这就是所谓的记忆化搜索 </description>
    </item>
    
    <item>
      <title>poj3070 Fibonacci ——矩阵快速幂</title>
      <link>http://liuxueyang.github.io/posts/poj3070-fibonacci-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Sun, 19 May 2013 01:38:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj3070-fibonacci-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>题目链接：http://poj.org/problem?id=3070 题目大意： 求第N项的Fibonacci数的后四位。 题目思路： 根据公式： 用矩阵快速幂就OK，模板题……但还是TLE了一次，原因是题目要求输入-1结束，我没看到……o(╯□╰)o
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cmath&amp;gt; using namespace std; const int MAX = 2; const int M = 10000; typedef struct { int m[MAX][MAX]; }Matrix; Matrix a, per; int n; void init() { int i , j; for (i = 0; i &amp;lt; n; ++i) { for (j = 0; j &amp;lt; n; ++j) { per.m[i][j] = (i == j); } } a.</description>
    </item>
    
    <item>
      <title>poj1272 棋盘问题 ——DFS入门题</title>
      <link>http://liuxueyang.github.io/posts/poj1272-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 13 May 2013 01:52:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1272-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1321 题目大意： 中文题，省了…… 题目思路： 感觉搜索题目还是要多做，很多东西都是开始看起来很复杂，其实根本就没有那么复杂，比如说这道，实际上就比较基础，可是，自己还是做不出来……o(╯□╰)o 这道题目需要注意的一点就是：先DFS一行，然后要注意，要考虑当前行不放，直接DFS下一行！这个情况赶脚还是比较不容易想到的，虽然做完之后感觉也挺自然啊，可是……当初为毛想不到。。。就是思维的问题吧……代码看的是这位仁兄的：http://fuliang.iteye.com/blog/398700ＴＨＸ……＾＿＾
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 10; char m[MAX][MAX];int cnt, n, k, sum; bool p[MAX]; bool judge(int i, int j) { if (p[j] == false &amp;amp;&amp;amp; m[i][j] == &#39;#&#39;) return true; else return false; } void dfs(int x) { if (sum == k) {cnt++; return;} if (x &amp;gt;= n) return; int i; for (i = 0; i &amp;lt; n; ++i) { if (judge(x, i)) { p[i] = true; sum++; dfs(x+1); p[i] = false; sum--; } } dfs(x + 1); } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;poj1321.</description>
    </item>
    
    <item>
      <title>poj1122&amp;&amp;zoj1053 FDNY to the Rescue! ——最短路入门题_Dijkstra算法</title>
      <link>http://liuxueyang.github.io/posts/poj1122zoj1053-fdny-to-the-rescue-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 06 May 2013 19:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1122zoj1053-fdny-to-the-rescue-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1122　http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=53 题目大意： 给定一个有向图，一个终点S，求多个点到这个点S的最短距离和对应的路径，把最短路排序后输出。 题目思路： 点的范围是20.可以一个一个用Dijkstra。。唯一的新意就是有多个点还需要按照路径长度排序，同时还要输出对应的路径，考的就是代码能力。用结构体存就可以。注意是有向图，开始就以为是无向图，怎么算最短路都不对。。赶脚这题不难，没什么思维难度，但是做OJ上这题的人却比较少，可能有一个原因，题目比较长，然后读完题目之后觉得没什么意思就不做了。。很简单的一个东西搞这么长的题目，也许就是考的读题吧。。貌似如果不是看的书上的翻译，我也没耐心读题。。。唉，读题确实是关键的一关。 然后这道题目，Poj上是单case，比较好过，然后数据也貌似比较弱，因为是单case，所以有一个输入的细节就特别好处理。开始Poj一下就过了，还沾沾自喜，结果把单case换成多case的时候，在zoj上交就Segmentation Fault……原来我最初处理输入个数不确定的数字的时候用了 while(~scanf())这种方法，很显然，这货只适用于单case。然后就想，该怎么处理这种输入数字个数不确定的输入呢？看了网上的一个思路，http://blog.csdn.net/yzldw333/article/details/7858172 哈哈，原来这么简单，就是以前做过的么，按照字符串处理就行了，，，好吧，，原来自己就是怕麻烦，这种方法想都没想。。然后就改了，，还是Segmentation Fault……继续调试，查错。。忍不住看了一下别人的代码，http://www.cnblogs.com/372465774y/archive/2012/11/19/2777552.html 一个注释提示了我，“这题给的字符真的是：t &amp;lsquo; &amp;rsquo;”好吧……我还真没注意到，虽然读题的时候注意到了，但是写代码的时候就想当然地只考虑空格，，像以前那样……思维定式啊。。然后就过了。。 Segmentation Fault的原因是访问了非法内存，在新的OJ上如果用的是Linux的话，归在Runtime Error一类里面。多谢zsl！ Poj代码：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 20; int edge[MAX][MAX], n, dist[MAX], path[MAX], end; bool S[MAX]; typedef struct Fire { int street[MAX], len, start, E; bool operator &amp;lt; (const Fire &amp;amp;other) const { return len &amp;lt; other.</description>
    </item>
    
    <item>
      <title>poj1135&amp;&amp;zoj1298 Domino Effect ——最短路入门题_Dijkstra算法</title>
      <link>http://liuxueyang.github.io/posts/poj1135zoj1298-domino-effect-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 05 May 2013 03:18:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1135zoj1298-domino-effect-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1135　http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=298 题目大意： 有n个多米诺骨牌，有m条边，推倒第1张牌，以这个点为端点边上的的牌同时倒，问最后倒下的那张牌是哪张，并且求出时间。如果正好是端点上的牌，输出端点序号，否则需要输出这个点在哪两个端点之间。 题目思路： 假设骨牌倒下的速度是1.这样就可以用距离表征时间了。 如果最后倒下的牌正好是端点处的。那么就很好理解了，就是求所有点到这个点的最短路的最大值。设为Max1 如果最后倒下的是某两个端点之间的牌。那么就要认真想想了。比如是A点和B点之间的。可以先分别求出到A点的时间，和到B点的时间。然后再加上A和B之间的距离。所得的和就是从起点1到达最后终点的时间的两倍！为什么捏？可以这么思考：两个人，速度都是1，从起点开始，以同样的速度行走，然后在同一时刻到达同一点，那么他们所花的时间的和就是从起点到终点的距离的两倍嘛。不管他们分别到达A点和B点的先后顺序，总之，他们最后的效果都是相遇了！对于每一条边，都求出对应的时间。得到最大值，设为Max2 如果Max2 &amp;gt; Max1 说明什么捏？说明了：两个人仅仅到达某些端点，并不能相遇有木有！还需要再走一段路程，在某两个端点之间的某处相遇！并且，这两个端点就是当Max2最大的时候的两个端点。 如果两者相等或者Max1 &amp;gt; Max2 说明什么捏？其实貌似不能大于……因为，Max1就是起点到达所有点的最短距离的最大值嘛，而Max2是每条边上时间的最大值，然后可以发现，除了第一种情况，每条边上时间的最大值其实就是到达这条边的其中一个端点的时间的最大值……所以呢，Max1不能大于Max2.出去第一种情况狂，只能等于。 然后这道题目还有一个需要注意的地方，就是，当只有一张骨牌的时候，输出0.0……这种情况，，好吧，真不知道比赛的时候我怎么能想得出来…… #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MINN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 500+10; int dist[MAX], S[MAX], edge[MAX][MAX], n, m; void dijkstra(int v0) { int i, j; for (i = 1; i &amp;lt;= n; ++i) { S[i] = 0; dist[i] = edge[v0][i]; } S[v0] = 1; for (i = 1; i &amp;lt; n; ++i) { int Min = MAXN, u; for (j = 1; j &amp;lt;= n; ++j) { if (S[j] == 0 &amp;amp;&amp;amp; Min &amp;gt; dist[j]) { Min = dist[j]; u = j; } } S[u] = 1; for (j = 1; j &amp;lt;= n; ++j) { if (S[j] == 0 &amp;amp;&amp;amp; edge[u][j] !</description>
    </item>
    
    <item>
      <title>poj1679 The Unique MST ——判断最小生成树是否唯一_kruscal算法</title>
      <link>http://liuxueyang.github.io/posts/poj1679-the-unique-mst-%E5%88%A4%E6%96%AD%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80_kruscal%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 04 May 2013 21:57:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1679-the-unique-mst-%E5%88%A4%E6%96%AD%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80_kruscal%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1679 题目大意： 判断一个连通的无向图的最小生成树是不是唯一的，如果唯一，输出最小生成树的权值，否者输出“Not Unique!” 题目思路： 这题目看的书上的，其实，最开始我的想法是，在求最小生成树的过程中，如果扩展到某一个点的时候，有多种选择，也就是说，有多个权值相同的边可以选择，那么就break掉，说明最小生成树不唯一。其实这是有问题的，因为，很可能在这权值相同的边当中，只能选择其中一条，如果选择其它的就得不到最小生成树，这就是一个反例。所以原来的做法是错误的。 书上的做法是，首先，预处理，看每个边是不是有别的边的权值和它一样的，有的话就标记一下，用结构体里面的equal表示，然后用kruscal算法求一遍最小生成树，并且把这棵最小生成树里面的边都标记一下，用结构体里面的used表示，然后，对于那种有其他边和它权值相同的那种边，同时这条边在第一次求的最小生成树里面，我们就把它删除，做法就是用结构体里面的del标记，然后再次求一遍最小生成树，不用del被标记的边，这样如果求出来的最小生成树的权值和原来的一样，说明最小生成树不唯一，break; 然后就OK了，唉，其实这是很自然的一个想法~
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 100+10; typedef struct Edge { int u, v, w, equal, used, del; bool operator &amp;lt; (const Edge &amp;amp;other) const { return w &amp;lt; other.</description>
    </item>
    
    <item>
      <title>poj2048&amp;&amp;zoj1751 Highways ——最小生成树入门题_Prim算法</title>
      <link>http://liuxueyang.github.io/posts/poj2048zoj1751-highways-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 04 May 2013 01:25:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2048zoj1751-highways-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1751 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1048 题目大意： 给定n个点的坐标。还有m对已经相连的点的编号。求连接这n个点的总权值最小的一棵生成树，输出还需要连接的点的编号。 题目思路： 这道题目和以前做过的poj2421是一样的。这里采用了那篇博客里面的第一种方法。幸运的是，在poj上1A了。但是在zoj上，因为输入输出格式有一些不一样，卡了一下，到最后我也没明白“If no new highways need to be built (all towns are already connected), then the output should be created but it should be empty.” 这句话的含义，看书上的翻译是，如果不需要再建了，输出一个空行。可是，在poj上，输出空行与否都是可以过的。在zoj上，输出空行就WA了，就是因为这个错误…… poj代码：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 759; double edge[MAX][MAX]; double lowcost[MAX];int nearvex[MAX]; int n, m; typedef struct Point { int x, y; }Point; Point point[MAX]; void prim(int u0) { int i, j, k, v;double sum = 0; for (i = 1; i &amp;lt;= n; ++i) { lowcost[i] = edge[i][u0]; nearvex[i] = u0; } lowcost[u0] = 0; nearvex[u0] = -1; for (i = 1; i &amp;lt; n; ++i) { double min = 1.</description>
    </item>
    
    <item>
      <title>poj2349 Arctic Network ——最小生成树入门题_Prim算法</title>
      <link>http://liuxueyang.github.io/posts/poj2349-arctic-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 03 May 2013 23:36:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2349-arctic-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=2349 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=914 题目大意： 有一些炮台，如果这个炮台有卫星接收器，那么任意两个有卫星接收器的炮台可以通信，不受距离限制；否者，两个炮台之间只能通过对讲机通信，这是受距离限制的。要买一种对讲机，用在需要的炮台上，要求所有炮台两两之间可以直接或者间接通信，问要买通信距离至少为多少的对讲机可以满足要求。输入：S卫星接收器的数量，P炮台的数量，然后是P行，每行代表一个炮台的坐标。输出要求的对讲机的通信距离D。 题目思路： 题目意思比较难懂。关键是satellite channel的安放方法，注意，它是放在炮台上的，只要这个炮台上有这货，它就可以和任何也有这货的炮台通信。明白这一点，然后就简单了。有S个卫星接收器，那么就可以减少S-1个距离开销。要让D尽可能小，就让这S-1个距离开销最大，所以，想法就是，求这些点的最小生成树，然后把所选的边排序，第S大的边的权值就是所求。 开始题意没搞懂。关键是“Any two outposts with a satellite channel can communicate via the satellite, regardless of their location.”这句话没有理解明白，也就是说，任何两个有卫星接收器的炮台都可通信！然后自己就把问题复杂化了……写的代码就很复杂了。。后来改了一下，就过了。。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 500+10; int n, s, p; double edge[MAX][MAX]; double lowcost[MAX]; int nearvex[MAX]; typedef struct Point { double x, y; }Point; typedef struct Vex { int i, j; double len; bool operator &amp;lt; (const Vex &amp;amp; other) const { // 不能写反了 return len &amp;gt; other.</description>
    </item>
    
    <item>
      <title>poj1789 Truck History ——最小生成树入门题_Prim算法</title>
      <link>http://liuxueyang.github.io/posts/poj1789-truck-history-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 03 May 2013 16:00:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1789-truck-history-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1789 题目大意： 输入一个数字n，然后输入n个长度为7的字符串，从任意一个字符串开始派生，直到派生出所有的字符串，两个字符串的距离规定为他们对应位置不相等的字母的个数，求出一种派生方案，使得派生方案的优劣值最大，并输出这个优劣值。优劣值的定义是：1/Σ(to,td)d(to,td) 表示对所有派生对的距离求和，再取倒数。 题目了思路： 要让优劣值最大，只需要距离之和最小，把7个字符串看成7个点，每两个点有一个距离，目的就是求权值最小的生成树，其实就是最小生成树。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 2000+10; char a[MAX][MAX]; int edge[MAX][MAX]; int n, lowcost[MAX]; void prim(int u0) { int sum = 0, i, j, k; for (i = 1; i &amp;lt;= n; ++i) lowcost[i] = edge[u0][i]; lowcost[u0] = -1; for (i = 1; i &amp;lt; n; ++i) { int v = -1, min = MAXN; for (j = 1; j &amp;lt;= n; ++j) { if (lowcost[j] !</description>
    </item>
    
    <item>
      <title>poj2421 Constructing Roads ——最小生成树入门题_Kruscal算法</title>
      <link>http://liuxueyang.github.io/posts/poj2421-constructing-roads-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 02 May 2013 10:17:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2421-constructing-roads-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=2421 题目大意： 给定一个矩阵，第 i 行第 j 列表示点 i 和点 j　的距离是ｓ［ｉ］［ｊ］。然后输入Ｑ，下面Ｑ行，每行两个数字ａ，ｂ表示点ａ和点ｂ已经有路相连。求需要至少再修多长的路，可以构成一棵生成树。输出需要在修的路的总长度。 题目思路： 转化为最小生成树求解。有两种思路： １）把已经相连的两个点的权值设置为０，这样，就可以直接求最小生成树了。因为kruscal的过程中，一定会选择到已经相连的这些点，因为它们的权值是0嘛，同时，即使把它们的权值加上，也不会影响结果。这个方法我好不容易想出来了，可是还有一个问题，就是：输入a b 后，如何定位到相应的边，并把这个边的权值设置为0？开始的时候，是暴力找，超时了，然后自己想各种方法，还求出来个公式，用a,b,N,表示出边的编号。最后还是超时了。。看网上别人恰好有人也是这么个思路，但是他是怎么定位边，并把边的权值设置为0的，没仔细看，不知道为什么人家就用这种方法过了…… 2）第二种思路，如果a b 已经相连，很简单，只要它俩的根节点不同，就把它两个合并不就可以了么，这样，kruscal的过程中，就不会再加入这些已经存在的边的权值了。剩下的就是纯的kruscal问题。这个方法很好！看的别人的想法。然后自己写了一下，RE了一次，原因是，合并a b 的时候，没有判断他们的根节点是否不同。。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; typedef struct Edge { int u, v, w; bool operator &amp;lt; (const Edge &amp;amp;o) const { return w &amp;lt; o.</description>
    </item>
    
    <item>
      <title>poj1861&amp;&amp;zoj1542 Network ——最小生成树入门题_Kruscal算法</title>
      <link>http://liuxueyang.github.io/posts/poj1861zoj1542-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 01 May 2013 20:52:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1861zoj1542-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://poj.org/problem?id=1861 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=542 题目大意： 给n个点，m条边。求一棵生成树，并且满足任意两点之间的距离的最大值最小。输出这个最大值，然后输出树的边的数量，最后输出树的每条边。 题目思路： 其实就是求最小生成树。关键就是证明，对于一个图的最小生成树来说，它的最大边满足在所有的生成树的最大边里最小。这是可以理解的。简单思考一下：假设最小生成树不满足这个条件。那么就是说，存在另一棵生成树，它的最大边的值比最小生成树还小，但是它的权值之和可能比最小生成树大，但是这表明，构造最小生成树的时候，存在一步，选择边的时候，没有选择权值最小的，这是不可能的。所以矛盾。所以假设不成立。所以，问题就转化成了常规的求最小生成树的问题了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 1000+10; const int MAX1 = 15000+10; typedef struct Edge { int u, v, w; bool operator &amp;lt; (const Edge &amp;amp;other) const { return w &amp;lt; other.</description>
    </item>
    
    <item>
      <title>poj1094&amp;&amp;zoj1060 Sorting It All Out ——拓扑排序入门题</title>
      <link>http://liuxueyang.github.io/posts/poj1094zoj1060-sorting-it-all-out-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Wed, 01 May 2013 01:23:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1094zoj1060-sorting-it-all-out-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1094 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=60 题目大意： 输入两个整数，n, m 分别表示以下的字母在字母表前 n 个字母范围内，有 m 行，每行描述一个大小关系，只有小于号。如果从开始到某一个关系式可以确定最终的序列，就输出确定的序列。如果得到矛盾，就输出到此经历的几个关系式。如果最终都没有确定，就输出序列不能确定的信息。 题目思路： 边读入，边建图，每读入一条表达式，就拓扑排序判断是不是可以确定最后的序列了。如果可以得到最后包含全部n个字母的序列，后面的表达式只需要输入，但是不需要处理了。如果过程中到达一个表达式的时候，找到了一个环，就说明肯定不能确定最后的序列了。也不需要处理后面的表达式了。如果一直都没有确定，就一直处理。 这题大体上的思路是这样，但是还是有一些细节没有处理好。最严重的就是：如何在中间的过程中去判断环。不能单纯地比较弹栈的顶点个数和 n 的大小，因为可能读入的顶点个数还没有到达 ｎ的时候，就已经出现环了，这样，以后的输入就不用处理了。如何处理呢？我的方法就是，当前剩下的点当中，是不是还存在度数大于０的点，用ｂｕｇ标记，因为这个ｂｕｇ调试了好久。。如果存在的话，就说明返回－１，表示存在环。为什么会出现这个ｂｕｇ呢？因为这个涉及到到第几条表达式出现矛盾的问题。 主要还是思维不严谨，虽然后来测试数据过了，但还是不知道哪里错了，后来自己出了几组数据才发现那个ｂｕｇ。这题做了好久，有的人一下就过了，可是我却卡了两天……教训就是：遇到ｂｕｇ了不能慌，分析一下是不是自己当初的想法错了，还是哪个细节没有处理好。即使有一个细节处理不好，程序最后都会崩溃。还有就是，可能自己的处理方法不好，导致最后的ｂｕｇ超多，代码也超级繁琐……一开始就应该想清楚，有没有更好的处理办法，尤其是一些细节问题。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; bool edge[27][27]; int n, m, rela; string s, out; map&amp;lt;int,bool&amp;gt; mymap; int Count[27], mystack[27], Count1[27]; int topsort(int ki) { out.</description>
    </item>
    
    <item>
      <title>poj2585&amp;&amp;zoj2193 Window Pains ——拓扑排序入门题</title>
      <link>http://liuxueyang.github.io/posts/poj2585zoj2193-window-pains-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Tue, 30 Apr 2013 19:15:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2585zoj2193-window-pains-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=2585 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2193 题目大意： 有9个窗口，每个窗口占4个格子，并且每个窗口的位置是固定的。如果重叠的话，在前面的窗口会覆盖另一种窗口，这9个窗口在4*4的矩阵里面，给出一种矩阵的格局。问这中格局是不是合法的。 题目思路： 还是看的书上的。刚开始一点也没有思路。方法就是：16个格子，每个格子可能会存在哪几种窗口，这是可以枚举出来的。针对输入的矩阵，那么可以判断，每一个格子会覆盖哪几种窗口，如果这种窗口在16个格子里面出现过，那么就可以判断当前这个格子一定覆盖了它，那么就可以用一条有向边连接当前窗口和被覆盖的窗口。这样，就可以得到一个图。在16个格子里面没有出现过的窗口我们可以不考虑。得到有向图后，发现，如果存在一个有向环，那么就一定是不合理的，因为这表明，一种窗口A覆盖了另一种窗口B，同时B又覆盖了A，这是不可能的。所以这个矩阵就是不合法的。反之，如果不存在有向环，就是合法的。这样，就转化为用拓扑排序判断环的问题了。先建图，再判断环。 写了两遍，其中出现各种BUG…… 第一遍：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; string cover[4][4]; int a[10][10];bool g[10][10];int id[10]; map&amp;lt;int, bool&amp;gt;mymap; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;poj2585.</description>
    </item>
    
    <item>
      <title>poj2478 ——欧拉函数入门题</title>
      <link>http://liuxueyang.github.io/posts/poj2478-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 22 Apr 2013 12:58:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2478-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=2478 题目大意： 给你一个数列f(N)，这个数列是由一系列不能约分的分数 a / b (0 &amp;lt; a &amp;lt; b &amp;lt;= n 且 (a,b) = 1)按照递增的顺序排列而成的。输入一个N，求这个数列中元素的个数。 题目思路： 因为题目只需要求出元素的个数，所以，把分母相同的放在一起，然后就发现规律了，其实就是求从2到 n 的欧拉函数的和。范围只有10^6，可以打表预处理。思路很清晰。因为要反复用欧拉函数，所以比较快的方法是用递推的方法求。 for (i = 1; i &amp;lt;= maxn; ++i) f[i] = i; for (i = 2; i &amp;lt;= maxn; i+=2) f[i] /= 2; for (i = 3; i &amp;lt;= maxn; i+=2){ if (f[i] == i){ for (j = i; j &amp;lt;= maxn; j+=i){ f[j] = f[j] / i * (i - 1); } } }  　这个方法和筛法求素数比较类似，貌似就是那个思想。模拟一下什么就懂了。这里也用到了欧拉函数的性质：φ(n) = n * (1 - 1/p1) * (1 - 1/p2) * …… * (1 - 1/pk)。</description>
    </item>
    
    <item>
      <title>poj2407 Relatives ——欧拉函数入门题</title>
      <link>http://liuxueyang.github.io/posts/poj2407-relatives-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 22 Apr 2013 08:36:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2407-relatives-%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=2407 题目大意： 这个题目就是欧拉函数的定义，求一个数字的欧拉函数。 题目思路： 用公式：φ(n) = n * (1-1/p1) * (1-1/p2) * …… * (1-1/pk)。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;poj2407.</description>
    </item>
    
    <item>
      <title>poj2480 Longge&#39;s problem ——积性函数入门题</title>
      <link>http://liuxueyang.github.io/posts/poj2480-longges-problem-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 21 Apr 2013 23:45:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2480-longges-problem-%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=2480 题目大意： 给定一个数字N，求∑gcd(i, N) 1&amp;lt;=i &amp;lt;=N 的值。 题目思路： x是一个数字，m与n互素，则gcd(x,m*n) = gcd(x, m) * gcd(x, n) 令g(y) = gcd(x, y) 那么g(y)是一个积性函数。令f(N) = ∑gcd(i, N) 满足gcd(x, n) = 1 的个数是欧拉函数φ(n)，那么可以知道，满足gcd(x, n) = p 的个数可以这么求：x 和 n 同时除以 p ，那么gcd(x/p, n/p) = 1 ，那么个数就是φ(n/p)。 分解N = p1^a1 * p2^a2 * …… *pn^an ，则f(N) = f(p1^a1 * p2^a2 * …… *pn^an) = f(p1^a1) * f(p2^a2) * …… * f(pn^an)； 可以枚举pi^ai的因数，对于f(pi^ai) = 1 * φ(pi^ai) + pi * φ(pi^(ai-1)) + pi^2 * φ(pi^(ai-2)) + …… + pi^(ai-1) * φ(pi) + pi^ai * φ(1)； 根据φ(pi^ai) = pi^ai - pi^(ai-1)，那么可以化简上面的式子：f(pi^ai) = ai * pi^ai + ai * pi^(ai-1) + pi^ai = pi^ai * (ai + ai/pi + 1)； 所以，f(N) = N * (a1 + a1/p1 + 1) * (a2 + a2/p2 + 1) * …… * (an + an/pn + 1)。 这题当然不是自己想出来的，但是学习了一下积性函数，看的神牛的解题代码：http://hi.</description>
    </item>
    
    <item>
      <title>poj2001 Shortest Prefixes ——字典树复习</title>
      <link>http://liuxueyang.github.io/posts/poj2001-shortest-prefixes-%E5%AD%97%E5%85%B8%E6%A0%91%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Fri, 19 Apr 2013 15:46:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2001-shortest-prefixes-%E5%AD%97%E5%85%B8%E6%A0%91%E5%A4%8D%E4%B9%A0/</guid>
      <description>题目链接：http://poj.org/problem?id=2001 这道题目以前写过，复习一下字典树，再写一遍……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; char a[1000+10][30], base = &#39;a&#39;; const int lo = 26; typedef struct trie{ int num; bool terminal; struct trie *son[lo]; }trie; trie *newtrie(){ trie *pnt = new trie; pnt-&amp;gt;num = 1; pnt-&amp;gt;terminal = false; for (int i = 0; i &amp;lt; lo; ++i) pnt-&amp;gt;son[i] = NULL; return pnt; } void insert(char str[], trie *pnt, int len){ trie *tem = pnt; for (int i= 0; i &amp;lt; len; ++i){ if (tem-&amp;gt;son[str[i]-base] !</description>
    </item>
    
    <item>
      <title>poj1298 The Hardest Problem Ever ——水题</title>
      <link>http://liuxueyang.github.io/posts/poj1298-the-hardest-problem-ever-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Fri, 19 Apr 2013 14:18:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1298-the-hardest-problem-ever-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1298 题目大意： 字母映射。太简单了。不说了。感脚都不好意思在博客里面写……水题一次最多切3道，再多就没意思了……也没有意义…… 题目思路： 为了学习ＳＴＬ，用的ｍａｐ。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; map&amp;lt;char, char&amp;gt; mymap; string a, b, c; char aa[10000]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;1298.</description>
    </item>
    
    <item>
      <title>poj3087 Shuffle&#39;m Up ——水题</title>
      <link>http://liuxueyang.github.io/posts/poj3087-shufflem-up-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Fri, 19 Apr 2013 13:53:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj3087-shufflem-up-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=3087 题目大意： 给定长度都为Ｃ两个字符串，Ｓ１，Ｓ2，和一个要求的结果字符串ＳＳ。先把Ｓ２的最下面一张牌放在最下面，然后Ｓ１，Ｓ２交错的叠放，得到Ｓ，再把Ｓ最下面的Ｃ个字符赋值给Ｓ１，把剩下的赋值给Ｓ２，再次重复上面的过程。最后求出要得到ＳＳ，需要几步这样的过程。 题目思路： 开始以为是用ＳＴＬ的栈，后来才发现根本用不到，直接用字符串模拟就可以了。为了学习一下ＳＴＬ，用的是ｓｔｒｉｎｇ类。只要比较当前得到的字符串和要得到的字符串是不是相等就可以了。如果永远也得不到要得到的字符串，那么就一定存在Ｓ１和Ｓ２和原来的Ｓ１和Ｓ２都对应相等，其实这道题目的难点就在这里。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;3087.</description>
    </item>
    
    <item>
      <title>poj1002 487-3279 ——水题</title>
      <link>http://liuxueyang.github.io/posts/poj1002-487-3279-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Fri, 19 Apr 2013 11:22:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1002-487-3279-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1002 题目大意： 给定一组电话号码，如果是包括字母，那么就映射到数字，统计相同的电话号码个数大于1的号码，按照从小到大的顺序输出，并且输出相应的个数。 题目思路： 因为电话号码最多又7位数字，在整数范围内，把每个读入的电话号码转化成整数，用一个ｍａｐ记录是不是出现过，如果出现过，就把相应的ｍａｐ记录加1,如果没有出现过，就把这个数字放进一个数组ａｒｒ里面，这样ａｒｒ里面的数字是不重复的。最后把ａｒｒ排序，对于每一个数组元素，输出相应的ｍａｐ记录，也就是它出现过的次数。 输出的时候，按照整数输出，但是要注意，开始要输出3位，如果前面有0的话，按照整数输出就不行，所以要控制格式，用ｐｒｉｎｔｆ（“%03ｄ”）；这样的格式，表示前面要补齐0；卡住了，看得以前的代码才想到这种情况，还是思维不严谨 啊～
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MINN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int arr[100000+10]; map&amp;lt;char, int&amp;gt; ma; char pri[10]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;poj1002.</description>
    </item>
    
    <item>
      <title>poj1006 Biorhythms ——中国剩余定理入门题</title>
      <link>http://liuxueyang.github.io/posts/poj1006-biorhythms-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Wed, 17 Apr 2013 02:20:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1006-biorhythms-%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1006 题目大意： 人体有三个周期，23，28，33. 对于每个周期分别给出从第0天开始，这三个周期的高潮出现的一个日期，不一定是第一次，p , e , i 。给出一个天数 d 表示今年已经过去了多少天，计算在这 d 天之后，三个高潮同时出现的那一天距离现在还有多少天。 思路： 23， 28， 33 是两两互素的，题目意思就是求一个数字 x ，使得这个数字 x 和 p 对23同余，同时 x 和 e 对28同余，同时 x 和 i 对33同余。所以可以用中国剩余定理解。 这是一个同余方程组。 x = p(mod 23); x = e (mod 28); x = i(mod 33); 这里的&amp;rsquo;=&amp;lsquo;代表同余符号。 因为求的是大于d的，所以，当求得的解小于等于d的时候，要加上模 23*28*33；直到解大于d为止。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int d, p, e, i, m[4], a[4]; LL M, Mi; void exgcd(int a, int b, int &amp;amp;d, int &amp;amp;x, int &amp;amp;y){ if (!</description>
    </item>
    
    <item>
      <title>poj 1995 Raising Modulo Numbers ——快速幂</title>
      <link>http://liuxueyang.github.io/posts/poj-1995-raising-modulo-numbers-%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Tue, 02 Apr 2013 17:47:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-1995-raising-modulo-numbers-%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; int m; LL power(LL a, LL k){ LL ans = 1; while (k){ if (k&amp;amp;1){ ans = (ans * a) % m; k--; } k &amp;gt;&amp;gt;= 1; a = (a*a)%m; } return ans; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;1995.</description>
    </item>
    
    <item>
      <title>poj 3233 Matrix Power Series ——矩阵快速幂&#43;二分求解</title>
      <link>http://liuxueyang.github.io/posts/poj-3233-matrix-power-series-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82&#43;%E4%BA%8C%E5%88%86%E6%B1%82%E8%A7%A3/</link>
      <pubDate>Tue, 02 Apr 2013 17:06:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-3233-matrix-power-series-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82&#43;%E4%BA%8C%E5%88%86%E6%B1%82%E8%A7%A3/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define LL long long #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 typedef struct matrix{ int a[33][33]; }matrix; matrix A, B, per; int m, k, n; void init(){ scanf(&amp;quot;%d%d%d&amp;quot;, &amp;amp;n, &amp;amp;k, &amp;amp;m); for (int i = 0; i &amp;lt; n; ++i){ for (int j = 0; j &amp;lt; n; ++j){ scanf(&amp;quot;%d&amp;quot;, &amp;amp;A.</description>
    </item>
    
    <item>
      <title>poj 1014 Dividing 多重背包</title>
      <link>http://liuxueyang.github.io/posts/poj-1014-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 28 Mar 2013 20:59:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-1014-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; int f[120000+10], V; const int MAX = 0x3f3f3f3f; void zeropack(int c, int w){ for (int v = V; v &amp;gt;= c; --v){ f[v] = max(f[v], f[v-c] + w); } } void completepack(int c, int w){ for (int v = c; v &amp;lt;= V; ++v){ f[v] = max(f[v], f[v-c] + w); } } int main(void){ int a[7], cnt = 1; #ifndef ONLINE_JUDGE freopen(&amp;quot;1014.</description>
    </item>
    
    <item>
      <title>poj 1061 青蛙的约会  ——扩展欧几里得</title>
      <link>http://liuxueyang.github.io/posts/poj-1061-%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A--%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</link>
      <pubDate>Mon, 18 Mar 2013 16:13:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-1061-%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A--%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstring&amp;gt; #define LL long long int LL exgcd(LL a, LL b, LL &amp;amp;x, LL &amp;amp;y){ if (b == 0){ x = 1; y = 0; return a; } LL r = exgcd(b, a%b, x, y); LL t = x; x = y; y = t - a / b * y; return r; } LL gcd(LL a, LL b){ return b ==0?a:gcd(b,a%b); } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;poj1061.</description>
    </item>
    
    <item>
      <title>poj 1659 Frogs&#39; Neighborhood</title>
      <link>http://liuxueyang.github.io/posts/poj-1659-frogs-neighborhood/</link>
      <pubDate>Wed, 13 Mar 2013 21:37:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-1659-frogs-neighborhood/</guid>
      <description>Frogs&amp;rsquo; Neighborhood Time Limit: 5000MS Memory Limit: 10000K Total Submissions: 5599 Accepted: 2419 Special Judge
Description
未名湖附近共有N个大小湖泊L1, L2, &amp;hellip;, Ln(其中包括未名湖)，每个湖泊Li里住着一只青蛙Fi(1 ≤ i ≤ N)。如果湖泊Li和Lj之间有水路相连，则青蛙Fi和Fj互称为邻居。现在已知每只青蛙的邻居数目x1, x2, &amp;hellip;, xn，请你给出每两个湖泊之间的相连关系。
Input
第一行是测试数据的组数T(0 ≤ T ≤ 20)。每组数据包括两行，第一行是整数N(2 &amp;lt; N &amp;lt; 10)，第二行是N个整数，x1, x2,&amp;hellip;, xn(0 ≤ xi ≤ N)。
Output
对输入的每组测试数据，如果不存在可能的相连关系，输出&amp;rdquo;NO&amp;rdquo;。否则输出&amp;rdquo;YES&amp;rdquo;，并用N×N的矩阵表示湖泊间的相邻关系，即如果湖泊i与湖泊j之间有水路相连，则第i行的第j个数字为1，否则为0。每两个数字之间输出一个空格。如果存在多种可能，只需给出一种符合条件的情形。相邻两组测试数据之间输出一个空行。
Sample Input
3 7 4 3 1 5 4 2 1 6 4 3 1 4 2 0 6 2 3 1 1 2 1</description>
    </item>
    
    <item>
      <title>poj 3225 Help with Intervals</title>
      <link>http://liuxueyang.github.io/posts/poj-3225-help-with-intervals/</link>
      <pubDate>Wed, 13 Mar 2013 21:35:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-3225-help-with-intervals/</guid>
      <description>Description Input Output Sample Input Sample Output #include &amp;lt;cstdio&amp;gt; using namespace std; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 const int maxn = 65535*2+10; int cover[maxn&amp;lt;&amp;lt;2],xorm[maxn&amp;lt;&amp;lt;2]; bool hash[maxn+10]; void fxor(int rt){ if (cover[rt] != -1) cover[rt] ^= 1; else xorm[rt] ^= 1; } void PushDown(int rt){ if (cover[rt] != -1){ cover[rt&amp;lt;&amp;lt;1] = cover[rt&amp;lt;&amp;lt;1|1] = cover[rt]; xorm[rt&amp;lt;&amp;lt;1] = xorm[rt&amp;lt;&amp;lt;1|1] = 0; cover[rt] = -1; // there has been a BUG.</description>
    </item>
    
    <item>
      <title>poj1579 Function Run Fun</title>
      <link>http://liuxueyang.github.io/posts/poj1579-function-run-fun/</link>
      <pubDate>Fri, 08 Mar 2013 13:38:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1579-function-run-fun/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int ww[22][22][22]; int w(int a, int b, int c){ if (a &amp;lt;= 0 || b &amp;lt;= 0 || c &amp;lt;= 0) return 1; if (a &amp;gt; 20 || b &amp;gt; 20 || c &amp;gt; 20) return w(20, 20, 20); if (ww[a][b][c] &amp;gt; 0) return ww[a][b][c]; if (a &amp;lt; b &amp;amp;&amp;amp; b &amp;lt; c) return ww[a][b][c] = w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c); else return ww[a][b][c] = w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1); } int main(void){ int a, b, c; #ifndef ONLINE_JUDGE freopen(&amp;quot;poj1759.</description>
    </item>
    
    <item>
      <title>poj 2528 Mayor&#39;s posters</title>
      <link>http://liuxueyang.github.io/posts/poj-2528-mayors-posters/</link>
      <pubDate>Tue, 05 Mar 2013 15:40:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-2528-mayors-posters/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 const int maxn = 111111; int li[maxn], ri[maxn], x[maxn*3], col[maxn&amp;lt;&amp;lt;4], cnt; bool hash[maxn]; void PushDown(int rt){ if (col[rt] != -1){ col[rt&amp;lt;&amp;lt;1] = col[rt&amp;lt;&amp;lt;1|1] = col[rt]; col[rt] = -1; } } void update(int L,int R, int c, int l, int r, int rt){ if (L &amp;lt;= l &amp;amp;&amp;amp; R &amp;gt;= r){col[rt] = c; return;} PushDown(rt); int m = (l + r) &amp;gt;&amp;gt; 1; if (L &amp;lt;= m) update(L, R, c, lson); if (R &amp;gt; m) update(L, R, c, rson); } void query(int l, int r, int rt){ if (col[rt] !</description>
    </item>
    
    <item>
      <title>poj 3468 A Simple Problem with Integers</title>
      <link>http://liuxueyang.github.io/posts/poj-3468-a-simple-problem-with-integers/</link>
      <pubDate>Mon, 04 Mar 2013 19:14:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-3468-a-simple-problem-with-integers/</guid>
      <description>A Simple Problem with Integers Time Limit: 5000MS Memory Limit: 131072K Total Submissions:40260 Accepted: 11693 Case Time Limit: 2000MS
Description
You have N integers, A1, A2, &amp;hellip; , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval.
Input</description>
    </item>
    
    <item>
      <title>poj 2828 Buy Tickets</title>
      <link>http://liuxueyang.github.io/posts/poj-2828-buy-tickets/</link>
      <pubDate>Sat, 02 Mar 2013 21:01:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-2828-buy-tickets/</guid>
      <description>Description Input Output Sample Input Sample Output 这道题目想法很重要，先建树，每个节点表示这个区间内的空的位置的数量，然后，从后往前读，Pos的值表示这个人前面有多少个空位，之所以从后往前读，是因为这样每个人的位置是确定的，以后就不用移动了，以后直接在树里面查找空位就可以了。 具体实现见代码：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 const int maxn = 222222; int tree[maxn&amp;lt;&amp;lt;2], val[maxn], pos[maxn], ans[maxn]; int id; void build(int l, int r, int rt){ tree[rt] = r - l + 1; if (l == r) {return;} int m = (l + r) &amp;gt;&amp;gt; 1; build(lson); build(rson); } void update(int p, int l, int r, int rt){ tree[rt]--; if (l == r){id = l-1; return;} int m = (l + r) &amp;gt;&amp;gt; 1; if (tree[rt&amp;lt;&amp;lt;1] &amp;gt;= p) update(p, lson); else {p -= tree[rt&amp;lt;&amp;lt;1]; update(p, rson);} } int main(void){ int n; #ifndef ONLINE_JUDGE freopen(&amp;quot;poj2828.</description>
    </item>
    
    <item>
      <title>poj 2945 Find the Clones</title>
      <link>http://liuxueyang.github.io/posts/poj-2945-find-the-clones/</link>
      <pubDate>Wed, 27 Feb 2013 23:50:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-2945-find-the-clones/</guid>
      <description>Find the Clones Time Limit: 5000MS Memory Limit: 65536K Total Submissions: 6265 Accepted: 2328
Description Doubleville, a small town in Texas, was attacked by the aliens. They have abducted some of the residents and taken them to the a spaceship orbiting around earth. After some (quite unpleasant) human experiments, the aliens cloned the victims, and released multiple copies of them back in Doubleville. So now it might happen that there are 6 identical person named Hugh F.</description>
    </item>
    
    <item>
      <title>poj 1056 IMMEDIATE DECODABILITY</title>
      <link>http://liuxueyang.github.io/posts/poj-1056-immediate-decodability/</link>
      <pubDate>Wed, 27 Feb 2013 19:05:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-1056-immediate-decodability/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; const int sonnum = 2, base = &#39;0&#39;; struct Trie { int num; bool terminal; Trie *son[sonnum]; }; Trie *NewTrie() { Trie *temp = new Trie; temp-&amp;gt;num = 1; temp-&amp;gt;terminal = false; for (int i = 0; i &amp;lt; sonnum; ++i) temp-&amp;gt;son[i] = NULL; return temp; } bool Insert(Trie *pnt, char *s, int len) { Trie *temp = pnt; bool mrk = true; for (int i = 0; i &amp;lt; len; ++i) { if (temp-&amp;gt;son[s[i]-base] == NULL) temp-&amp;gt;son[s[i]-base] = NewTrie(); else { temp-&amp;gt;son[s[i]-base]-&amp;gt;num++; if (temp-&amp;gt;son[s[i]-base]-&amp;gt;terminal == true) mrk = false; } temp = temp-&amp;gt;son[s[i]-base]; } temp-&amp;gt;terminal = true; return mrk; } int main(void) { Trie *tree; char a[20]; int cnt = 1; #ifndef ONLINE_JUDGE freopen(&amp;quot;poj2056.</description>
    </item>
    
    <item>
      <title>poj 2503 Babelfish</title>
      <link>http://liuxueyang.github.io/posts/poj-2503-babelfish/</link>
      <pubDate>Wed, 27 Feb 2013 00:28:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-2503-babelfish/</guid>
      <description>Babelfish Time Limit: 3000MS Memory Limit: 65536K Total Submissions: 26498 Accepted: 11378
Description You have just moved from Waterloo to a big city. The people here speak an incomprehensible dialect of a foreign language. Fortunately, you have a dictionary to help you understand them.
Input Input consists of up to 100,000 dictionary entries, followed by a blank line, followed by a message of up to 100,000 words. Each dictionary entry is a line containing an English word, followed by a space and a foreign language word.</description>
    </item>
    
    <item>
      <title>poj 2001 Shortest Prefixes ——字典树入门</title>
      <link>http://liuxueyang.github.io/posts/poj-2001-shortest-prefixes-%E5%AD%97%E5%85%B8%E6%A0%91%E5%85%A5%E9%97%A8/</link>
      <pubDate>Tue, 26 Feb 2013 23:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-2001-shortest-prefixes-%E5%AD%97%E5%85%B8%E6%A0%91%E5%85%A5%E9%97%A8/</guid>
      <description>#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; char a[1000+10][25]; const int sonnum = 26, base = &#39;a&#39;; struct Trie { int num; bool terminal; struct Trie *son[sonnum]; }; Trie *NewTrie() { Trie *temp = new Trie; temp-&amp;gt;num = 1; temp-&amp;gt;terminal = false; for (int i = 0; i &amp;lt; sonnum; ++i) temp-&amp;gt;son[i] = NULL; return temp; } void Insert(Trie *pnt, char *s, int len) { Trie *temp = pnt; for (int i = 0; i &amp;lt; len; ++i) { if (temp-&amp;gt;son[s[i]-base] == NULL) temp-&amp;gt;son[s[i]-base] = NewTrie(); else temp-&amp;gt;son[s[i]-base]-&amp;gt;num++; temp = temp-&amp;gt;son[s[i]-base]; } temp-&amp;gt;terminal = true; } Trie *Find(Trie *pnt, char *s, int len) { Trie *temp = pnt; for (int i = 0; i &amp;lt; len; ++i) { if (temp-&amp;gt;son[s[i]-base]-&amp;gt;num == 1) { printf(&amp;quot;%c&amp;quot;, s[i]); return temp; } printf(&amp;quot;%c&amp;quot;, s[i]); temp = temp-&amp;gt;son[s[i]-base]; } return temp; } int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;poj2001.</description>
    </item>
    
    <item>
      <title>poj 2752</title>
      <link>http://liuxueyang.github.io/posts/poj-2752/</link>
      <pubDate>Wed, 30 Jan 2013 20:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-2752/</guid>
      <description>题目链接：http://poj.org/problem?id=2752 #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #define N 400000 using namespace std; char s[N]; int next[N], a[N]; void getnext(char *p, int *next) { int i = 0, j = -1, len = strlen(p); next[0] = -1; while (i &amp;lt; len) { if (j == -1 || p[j] == p[i]) { i++; j++; next[i] = j; } else j = next[j]; } } int main(void) { freopen(&amp;quot;poj2752.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); while (~scanf(&amp;quot;%s&amp;quot;, s)) { getnext(s, next); int len = strlen(s), i, k = 0; i = len; a[0] = len; while (next[i] &amp;gt; 0) { i = next[i]; a[++k] = i; } for (int j = k; j &amp;gt;= 0; --j) { printf(&amp;quot;%d&amp;quot;, a[j]); if (j) printf(&amp;quot; &amp;quot;); } printf(&amp;quot;\n&amp;quot;); } return 0; }  这道题目要求既是前缀字符串又是后缀字符串的所有可能的长度，正好运用了KMP算法里面next数组的意义，要保证结果是针对整个字符串的，所以在next数组中从后往前扫描即可，因为，next数组中，越往后，数字就越大，并且表示的是后缀和前缀相同的最大长度，所以所得到的结果顺序是反的，要求从小到大输出，逆序输出就可以了。</description>
    </item>
    
  </channel>
</rss>