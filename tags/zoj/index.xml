<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zoj on LXY Site</title>
    <link>http://liuxueyang.github.io/tags/zoj/</link>
    <description>Recent content in Zoj on LXY Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright &amp;copy; 2018 (LXY). All Rights Reserved.</copyright>
    <lastBuildDate>Thu, 15 Aug 2013 17:43:00 +0000</lastBuildDate>
    
	<atom:link href="http://liuxueyang.github.io/tags/zoj/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>zoj3623 Battle Ships ——完全背包？简单DP！|| 泛化背包</title>
      <link>http://liuxueyang.github.io/posts/zoj3623-battle-ships-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%AE%80%E5%8D%95dp-%E6%B3%9B%E5%8C%96%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:43:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj3623-battle-ships-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%AE%80%E5%8D%95dp-%E6%B3%9B%E5%8C%96%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3623 看起来像完全背包，但是物品价值是变化的，所以很多人搞的很复杂。 晚上的代码要么很复杂，有一个代码虽然很简洁在zoj可以过，但是是错误的。求教lyl神犇，果然思想很深刻，抓住乐问题的本质，想法比网上搜到的所有博客里面的做法都简洁。 事实上，就是简单的DP，抓住一个技巧：让时间倒流，也就是说，把时间反过来考虑，先在将来把船造好，然后在过去用船攻击，哈哈，太巧秒了，说起来很别扭，很有意思，dp[j+time[i]]=max(dp[j]+j*time[i])；dp[j]表示在j这个时间，所造成的最大伤害。这样就可以枚举时间，在每个特定的时间内，枚举船的种类，找到最大值。最终在dp[]数组里面找到符合条件的并且时间最少的解。 只能说，ORZ…… 后来好不容易想明白了。茶具从哪里来……
/* ID: zypz4571 LANG: C++ TASK: battle.</description>
    </item>
    
    <item>
      <title>zoj2136 &amp;&amp; poj2533 Longest Ordered Subsequence ——最长上升子序列经典DP</title>
      <link>http://liuxueyang.github.io/posts/zoj2136--poj2533-longest-ordered-subsequence-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E7%BB%8F%E5%85%B8dp/</link>
      <pubDate>Thu, 16 May 2013 12:44:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj2136--poj2533-longest-ordered-subsequence-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E7%BB%8F%E5%85%B8dp/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1136  http://poj.org/problem?id=2533 题目大意：RT 题目思路： maxlen[j]表示，到j位置，最长的上升子序列的长度。时间复杂度O（N^2），数据范围是1000 参考解题报告：http://www.slyar.com/blog/longest-ordered-subsequence.html zoj:
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int str[1000], maxlen[1001], p[1001]; int main(void){ #ifdef LOCAL freopen(&amp;quot;lis.</description>
    </item>
    
    <item>
      <title>2013年5月11日zoj比赛残留题 zoj5000 Density of Power Network &amp;&amp; zoj5002 Friends</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8811%E6%97%A5zoj%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98-zoj5000-density-of-power-network--zoj5002-friends/</link>
      <pubDate>Sat, 11 May 2013 20:21:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8811%E6%97%A5zoj%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98-zoj5000-density-of-power-network--zoj5002-friends/</guid>
      <description>两道水题。直接暴力。数据范围都不大，还没有过，等哪天zoj把题目挂出来了再交。 Density of Power Network 题目链接：http://acm.zju.edu.cn/onlinejudge/showContestProblem.do?problemId=5000
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int edge[502][502], a[502], b[502]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;zoj5000.</description>
    </item>
    
    <item>
      <title>2013年5月11日 zoj比赛三道水题：zoj4998 Break Standard Weight &amp;&amp; zoj5004 Hard to Play &amp;&amp; zoj5006 Java Beans</title>
      <link>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8811%E6%97%A5-zoj%E6%AF%94%E8%B5%9B%E4%B8%89%E9%81%93%E6%B0%B4%E9%A2%98zoj4998-break-standard-weight--zoj5004-hard-to-play--zoj5006-java-beans/</link>
      <pubDate>Sat, 11 May 2013 18:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/2013%E5%B9%B45%E6%9C%8811%E6%97%A5-zoj%E6%AF%94%E8%B5%9B%E4%B8%89%E9%81%93%E6%B0%B4%E9%A2%98zoj4998-break-standard-weight--zoj5004-hard-to-play--zoj5006-java-beans/</guid>
      <description>都是水题，特别水的内种，题目意思、思路神马滴就不说了…… Break Standard Weight 题目链接：http://acm.zju.edu.cn/onlinejudge/showContestProblem.do?problemId=4998 范围只有100，并且只有3个数字，直接枚举，代码好挫……o(╯□╰)o 只有一个需要注意的地方，就是绝对值为0的时候要考虑到！因为如果绝对值为0，那么根本就称不出什么重量来。。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; map&amp;lt;int, bool&amp;gt;mymap; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;zoj4998.</description>
    </item>
    
    <item>
      <title>zoj3702 Gibonacci number ——找规律</title>
      <link>http://liuxueyang.github.io/posts/zoj3702-gibonacci-number-%E6%89%BE%E8%A7%84%E5%BE%8B/</link>
      <pubDate>Tue, 07 May 2013 23:31:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj3702-gibonacci-number-%E6%89%BE%E8%A7%84%E5%BE%8B/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3702 题目大意： 给一个数列，第一项是1，给第 i 项，这个数列满足斐波那契数列的那种性质。问是不是存在，如果存在输出第 j 项，否则输出 -1 题目思路： 找规律，这个数列每一项和原来的斐波那契数列的差值是原来的斐波那契数列的倍数。</description>
    </item>
    
    <item>
      <title>zoj3696  Alien&#39;s Organ ——概率题</title>
      <link>http://liuxueyang.github.io/posts/zoj3696--aliens-organ-%E6%A6%82%E7%8E%87%E9%A2%98/</link>
      <pubDate>Tue, 07 May 2013 23:27:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj3696--aliens-organ-%E6%A6%82%E7%8E%87%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3696 题目大意： 就是一个东西，随机产生器官，一天产生的数量的期望是x,求一天内产生个数小于等于N的概率 题目思路： 泊松分布。概率论得好好学。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;math.</description>
    </item>
    
    <item>
      <title>zoj2750 Idiomatic Phrases Game ——最短路入门题_Dijkstra算法</title>
      <link>http://liuxueyang.github.io/posts/zoj2750-idiomatic-phrases-game-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sun, 05 May 2013 22:43:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj2750-idiomatic-phrases-game-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%85%A5%E9%97%A8%E9%A2%98_dijkstra%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1750 题目大意： 成语接龙游戏。给定n个单词，每个单词前面先给一个权值，表示由这个单词找到下一个单词所需要花费的时间。问从第一个单词至少要花多少时间才能找到最后一个单词。如果不能找到，输出-1 题目思路： 如果一个单词的最后一个字和另一个成语的第一个字一样的话。那么就可以连一个有向边。就是求一个最短路。注意：题目中说成语至少三个字，别想当然地以为成语就是4个字的……开始没注意到，后来才改的。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MINN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 1000+10; int dist[MAX], S[MAX], n, wei[MAX], edge[MAX][MAX]; char start[MAX][10], end[MAX][10], ch[50]; void Dijkstra(int u0) { int i, j; for (i = 1; i &amp;lt;= n; ++i) { S[i] = 0; dist[i] = edge[u0][i]; } S[u0] = 1; dist[u0] = 0; int u; for (i = 1; i &amp;lt; n; ++i) { int Min = MAXN; u = 1; for (j = 1; j &amp;lt;= n; ++j) { if (S[j] == 0 &amp;amp;&amp;amp; dist[j] &amp;lt; Min) { Min = dist[j]; u = j; } } S[u] = 1; for (j = 1; j &amp;lt;= n; ++j) { if (S[j] == 0 &amp;amp;&amp;amp; edge[u][j] !</description>
    </item>
    
    <item>
      <title>zoj1586 QS Network ——最小生成树入门题_Prim算法</title>
      <link>http://liuxueyang.github.io/posts/zoj1586-qs-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 03 May 2013 01:59:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj1586-qs-network-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_prim%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=586 题目大意： 题目意思比较难懂。看书上的翻译竟然没有看懂，还是打开OJ，看英文的原题。看了两遍的样子，终于差不多懂了。 QS是一种生物，要完成通信，需要设备，每个QS需要的设备的价格不同，并且，这种设备只能在两个QS之间用一次，也就是说，如果一个QS需要和3个QS通信的话，它就必须得买3个设备，同时，对方三个也必须买对应的适合自己的设备。同时，每两个QS之间是有距离的，要完成通信还需要网线，给出每两个QS之间的网线的价值。求一棵生成树，使得所需要的费用最少。数据范围：所有数据都在1000以内。 题目思路： 根据这种设备的特性，每个设备只能和另外一个QS通信，所以呢，建图的时候，每条边的权值就是网线的费用，加上这条边的两个端点的QS所需设备的费用的和。这样，就转化成了常规的最小生成树的问题。因为只需要求出最小费用，所以，可以不必记录prim过程中要选的边的顶点编号，也就是说，可以省略nearvex数组，用lowcost数组就可以实现。如果lowcost[i]的值是-1，则代表已经选择了这个点，否则，lowcost[i]依然表示集合T1内的顶点 i 距离集合T内个顶点权值最小的边的权值。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 1000+10; int edge[MAX][MAX], lowcost[MAX]; int t, n, pri[MAX]; void prim(int u0) { int sum = 0, i, j, v; for (i = 1; i &amp;lt;= n; ++i) lowcost[i] = edge[u0][i]; lowcost[u0] = -1; for (i = 1; i &amp;lt; n; ++i) { int min = MAXN; v = -1; for (j = 1; j &amp;lt;= n; ++j) { if (min &amp;gt; lowcost[j] &amp;amp;&amp;amp; lowcost[j] !</description>
    </item>
    
    <item>
      <title>zoj1203 Swordfish ——最小生成树入门题_Kruscal算法</title>
      <link>http://liuxueyang.github.io/posts/zoj1203-swordfish-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 01 May 2013 13:36:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj1203-swordfish-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98_kruscal%E7%AE%97%E6%B3%95/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=203 题目大意： 给定N个点的坐标，求经过这N个点的路线长度总和的最小值。 题目思路： 求出任意两点之间的距离，然后就是最小生成树。 写的过程中还是遇到了三个问题，有一个局部变量没有初始化；没有把边按照权值排序；另外就是没有看输出，每两个case之间有一个空行。这里有一个十分常见的问题，就是最后一个case后面没有空行。否则会PE。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; typedef struct Edge { int u, v; double w; bool operator &amp;lt; (const Edge &amp;amp;other) const { return w &amp;lt; other.</description>
    </item>
    
    <item>
      <title>poj2585&amp;&amp;zoj2193 Window Pains ——拓扑排序入门题</title>
      <link>http://liuxueyang.github.io/posts/poj2585zoj2193-window-pains-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Tue, 30 Apr 2013 19:15:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj2585zoj2193-window-pains-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=2585 http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2193 题目大意： 有9个窗口，每个窗口占4个格子，并且每个窗口的位置是固定的。如果重叠的话，在前面的窗口会覆盖另一种窗口，这9个窗口在4*4的矩阵里面，给出一种矩阵的格局。问这中格局是不是合法的。 题目思路： 还是看的书上的。刚开始一点也没有思路。方法就是：16个格子，每个格子可能会存在哪几种窗口，这是可以枚举出来的。针对输入的矩阵，那么可以判断，每一个格子会覆盖哪几种窗口，如果这种窗口在16个格子里面出现过，那么就可以判断当前这个格子一定覆盖了它，那么就可以用一条有向边连接当前窗口和被覆盖的窗口。这样，就可以得到一个图。在16个格子里面没有出现过的窗口我们可以不考虑。得到有向图后，发现，如果存在一个有向环，那么就一定是不合理的，因为这表明，一种窗口A覆盖了另一种窗口B，同时B又覆盖了A，这是不可能的。所以这个矩阵就是不合法的。反之，如果不存在有向环，就是合法的。这样，就转化为用拓扑排序判断环的问题了。先建图，再判断环。 写了两遍，其中出现各种BUG…… 第一遍：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; string cover[4][4]; int a[10][10];bool g[10][10];int id[10]; map&amp;lt;int, bool&amp;gt;mymap; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;poj2585.</description>
    </item>
    
    <item>
      <title>zoj2913 Bus Pass ——BFS入门题</title>
      <link>http://liuxueyang.github.io/posts/zoj2913-bus-pass-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sat, 13 Apr 2013 01:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj2913-bus-pass-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1912 题目大意： 有很多个地区，有几条公交线经过一些地区，求出一个地区，满足，使这个地区到这些公交线上的所有公交站的距离中的最大值，最小。（这里的距离指的是两点之间的边数） 思路： 对于这些公交站中的每一个点，BFS，求出出当前点外，其他所有点到这个点的最小距离，然后对于公交站上的其他点，也进行同样地操作，不断更新所有点到公交站上的当前点的最小距离的较大值，然后遍历所有点，求出距离最小的一个点。用res1数组存储。res数组的作用是对于公交线上的每个点，BFS其他点的时候，临时存放其他点到这个公交站的最小距离，然后在与res1数组进行比较，用来更新res1数组。 注意： visited数组，标记这个是不是被访问过，并且标记的顺序要想清楚！把这个点入队的时候就要标记它被访问了，而不是它出队的时候再标记！这是因为，如果两天点同时和一个点相邻，如果等点出队的时候在标记的话，就会产生这个点被访问两次的情况，这个问题让我纠结了一个星期……我去……
比如这种情况，Ｃ和Ａ，Ｂ同时相邻，假如：先访问Ａ，ｒｅｓ［Ｂ］　＝　ｒｅｓ［Ｃ］　＝　２，把Ａ标记，然后出队；再访问Ｂ，ｒｅｓ［Ｃ］　＝　３，Ｃ的值显然是不对的，所以，当把Ｂ，Ｃ两个点入队的时候，就把他们标记为已经访问，就可以了…… 做这个题目感触挺大的，首先，写代码要全神贯注，不能有一点儿疏忽，否则很容易犯那种超级难找出来的隐蔽的错误，一定要考虑明白再写；然后就是数组的下标什么的，养成好习惯，到底什么时候该从０开始，什么时候该从１开始，我觉得从１开始比较保险，因为有的时候会用到编号，比如这道题目，点的标号从１开始；最后就是思考这种题目应该如何存储题目给的信息，这个东西是看的书上的思想； 自己写代码比看着人家的代码写感觉和收获是完全不一样的。</description>
    </item>
    
    <item>
      <title>zoj 1649 Rescue ——BFS入门题</title>
      <link>http://liuxueyang.github.io/posts/zoj-1649-rescue-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 08 Apr 2013 20:21:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-1649-rescue-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=649 题意： 给一个字符矩阵，‘#’代表墙壁，&amp;rsquo;.&amp;lsquo;代表空格，‘x’代表有警察的空格，&amp;rsquo;r&amp;rsquo;和&amp;rsquo;a&amp;rsquo;分别代表一屌丝，并且&amp;rsquo;r&amp;rsquo;要到&amp;rsquo;a&amp;rsquo;那里去串门儿，r走一个空格花费单位时间1，走一个有警察的空格需要先干掉警察，话费单位时间1，然后再走过去，也就是共花费时间2，请问屌丝r到屌丝a那里去最少花费的时间。 思路： 首先要搞明白一个问题：就是路径最短的路不一定花费时间最少。这是可以理解的，比如，一条很短但是有很多警察，另一条路很长，但是没有警察，很有可能是第二条路花费时间少。用深搜？貌似不太合适，因为你一条路径访问过一个点后，另一条路径很可能也会访问这个点，并且时间较少。关键是深搜找到的接不一定是最优的。所以，考虑用广搜解。这道题最朴素的广搜显然不行，也就是说，仅仅求步数最少的不可行，需要加上访问时间这个附加条件。 用一个结构体数组存储每个点的信息，包括坐标，到达这个点所需要的最短时间，从起点开始搜，先访问起点，然后把起点出队，如果从一个点A到达下一个点B的当前所需时间比这个点现在标记的时间少，则把这个点入队，然后判断点A的另一个方向上的下一个点。这样，总有一天队列会为空，这是因为，某个点不可能被访问无数次，也就是说，某个点不可能无数次入队，因为到达某个点所需要的时间一定是有个最小值的，所以BFS一定可以结束，并且最后找到的点‘a’的信息一定是最优解。输出就可以了，如果无解，因为初始化到达所有点所需时间都是MAXN，所以，如果点‘a’的时间信息如果等于MAXN，那么说明无解。 第一次做深搜，这道题开始不知道怎么做，看了书上的思路，坚持没看代码，自己又想了想，就试着开始写，好神奇，竟然1A了！！！
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MINN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; typedef struct point{ int a, b, t; }point; point p[220][220], st, en; char s[220][220]; int n, m, T, si, sj, di, dj; queue&amp;lt;point&amp;gt; qt; void bfs(){ qt.</description>
    </item>
    
    <item>
      <title>zoj 2165 Red and Black ——BFS入门题</title>
      <link>http://liuxueyang.github.io/posts/zoj-2165-red-and-black-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 07 Apr 2013 19:06:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-2165-red-and-black-bfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1165 题意： 给一个字符矩阵，“.”代表黑色格子，“#”代表红色格子，有一个起点“@”，它属于黑色格子，一个人从起点出发，只能走黑色格子，并且只能上下左右走，不能对角线走，问这个人能走到的黑色格子有多少个。输出个数。输入W，H，代表有W列，H行，然后输入一个字符矩阵，输出能走到的最多的黑色格子的个数，包括起点。 思路： 这个题目很简单，和zoj 2110 类似，但是这道题目比那道简单多了，不用剪枝，不用恢复现场，直接深搜就可以。首先找到起点，然后从起点出发，判断这个点是不是被访问过，如果被访问过，就return；否则判断这个格子是不是黑色格子或者是起点，如果是，就cnt++，然后标记这个格子已经被访问过，如果不是，return; 如果没有return，就在这个点的四个方向继续深搜。思路很清晰。1A。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; int w, h, cnt = 0; char s[22][22]; bool flag[22][22]; int dir[4][2] = {{0,1},{1,0},{-1,0},{0,-1}}; void dfs(int i, int j){ if (i &amp;lt;= 0 || j &amp;lt;= 0 || i &amp;gt; h || j &amp;gt; w) return; if (flag[i][j]) return; if (s[i][j] == &#39;.</description>
    </item>
    
    <item>
      <title>zoj 2412 Farm Irrigation ——DFS入门题</title>
      <link>http://liuxueyang.github.io/posts/zoj-2412-farm-irrigation-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 07 Apr 2013 12:48:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-2412-farm-irrigation-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1412 题意： 有11种正方形，每种正方形里面对应一种形状的水管，不同的的正方形一用A到K表示，给一个矩阵，问至少需要多少个水源可以使矩形中所有的地方都可以被灌溉，如果两个相邻的正方形的水管正好对口，那么这两个正方形可以共用一个水源。 思路： 开始感觉很复杂，明显可以DFS做，但是感觉比较麻烦，关键是怎么处理题目中的条件。 首先，处理11种不同的水管，分4个方向，1表示有接口，0表示没有接口。用一个二维数组存所有种类的水管。 然后，把输入的字符转化成数字，可以再输入的时候边输入边处理，用字符减去字符“A”就可以了，对应的上面给11中不同水管中的一种。以上这两个处理方法要注意，学习一下，稍微看了一下别人的代码才想到的。这种看似比较简单的处理，往往给解题带来比较大的方便。 最后，就是如何深搜了。这个要考虑清楚。用一个flag二维数组表示是否访问过这个方格。深搜的时候，如果访问到它时，先判断它是否被访问过，然后立刻标记为已访问。然后就是判断当前方格的四个方向是不是有接口，如果某个方向有接口的话，就判断这个方向上的下一个方格中，和当前方格相邻的边是不是有接口，如果有接口，则继续深搜这个相邻的点。这里有个处理：（k+2）%4，意味着，比如：当前方格如果右边有接口，则判断右边的方格的左边的边是不是有接口，其它情况一样。然后就是主函数里面的dfs外面的for循环，思想和以前做过的zoj 1709是一样的，就是搜到某个点的时候，用一个mrk标记一下，把和它有关系的点都搜完，如果有符合条件的，mrk会改变，然后就cnt++用来计数，这种题目是相似的，都是要求符合条件的点相邻。 有一个细节，就是矩阵的数组还是从1开始吧，数组稍微开大一点儿，这样在深搜下一个方向的时候，就不会因为数组越界出错了。这个问题以前没有注意到。</description>
    </item>
    
    <item>
      <title>zoj 1709 Oil Deposits ——DFS入门题</title>
      <link>http://liuxueyang.github.io/posts/zoj-1709-oil-deposits-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 07 Apr 2013 00:23:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-1709-oil-deposits-dfs%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=709 题目大意： 给一个矩阵，*代表空地，@代表油田，并且@如果水平，竖直，对角线相邻的话就认为是一块油田，问有多少块油田。 思路就是DFS，从第一个字符开始搜，找到一个@就标记一下，cnt++，然后看它的八个方向上是不是有@，如果有，全部标记为*，不需要恢复现场。然后输出cnt的值就行了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; char s[110][110]; bool flag; int cnt, n, m; int dir[8][2] = {{0,1},{0,-1},{-1,0},{1,0},{1,1},{-1,1},{1,-1},{-1,-1}}; void dfs(int i, int j){ if (i &amp;lt; 0 || j &amp;lt; 0 || i &amp;gt; m || j &amp;gt; n) return; if (s[i][j] == &#39;*&#39;) return; if (s[i][j] == &#39;@&#39;) flag = true; s[i][j] = &#39;*&#39;; for (int k = 0; k &amp;lt; 8; ++k){ if (s[i+dir[k][0]][j+dir[k][1]] == &#39;@&#39;){ dfs(i+dir[k][0], j+dir[k][1]); } } } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;zoj1709.</description>
    </item>
    
    <item>
      <title>zoj 2110 Tempter of the Bone ——DFS&#43;剪枝</title>
      <link>http://liuxueyang.github.io/posts/zoj-2110-tempter-of-the-bone-dfs&#43;%E5%89%AA%E6%9E%9D/</link>
      <pubDate>Sat, 06 Apr 2013 23:20:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-2110-tempter-of-the-bone-dfs&#43;%E5%89%AA%E6%9E%9D/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1110 题意： 给一个矩阵，‘X’代表墙壁，‘.’代表空格，‘S’代表起始位置，‘D’代表终点。从起点开始，每个空格只许经过一次，求在规定的时间t的时候，能否正好到达终点。每走一个花费1个单位时间。输入n,m,t，分别代表矩阵的行，列，规定的时间。 思路： 深度优先搜索，从起点开始，按照四个方向搜索，判断某个方向的下一个方格如果不是墙壁的话，就把它标为墙壁，然后从这个点继续往下搜索，如果从这个点往下搜索失败后，就要把这个点标记回原来的空格符号：‘.’。然后尝试下一个方向。直到i == di, j == dj, t == T的时候，表示搜索成功，flag = true; return; 其中si sj 是起点位置，di dj是终点位置，T是当前所花费的时间。 然后还有几处剪枝：如果这个矩阵的空格的数目小于等于时间t，那么不可能成功。这在主函数里面可以剪枝。在dfs的过程中，如果发现剩余的时间小于当前位置到终点的最小距离，可以直接判断搜索失败；如果剩余的时间和当前位置到终点的最小时间的差值是奇数的话，可以判断搜索一定失败，可以剪枝，如果是偶数的话，则可能成功。 今天突然发现，以前写的解题报告太搓了……向kedebug的博客学习，O(∩_∩)O哈哈~加油</description>
    </item>
    
    <item>
      <title>zoj 3693 Happy Great BG</title>
      <link>http://liuxueyang.github.io/posts/zoj-3693-happy-great-bg/</link>
      <pubDate>Sun, 31 Mar 2013 22:26:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-3693-happy-great-bg/</guid>
      <description>The summer training of ZJU ICPC in July is about to end.</description>
    </item>
    
    <item>
      <title>zoj 3410 Layton&#39;s Escape</title>
      <link>http://liuxueyang.github.io/posts/zoj-3410-laytons-escape/</link>
      <pubDate>Thu, 21 Mar 2013 10:59:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-3410-laytons-escape/</guid>
      <description>Professor Layton is a renowned archaeologist from London&amp;rsquo;s Gressenheller University. He and his apprentice Luke has solved various mysteries in different places.</description>
    </item>
    
    <item>
      <title>zoj 3409 KKV</title>
      <link>http://liuxueyang.github.io/posts/zoj-3409-kkv/</link>
      <pubDate>Wed, 20 Mar 2013 21:43:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-3409-kkv/</guid>
      <description>KKV (short for Kinetic Kill Vehicle), a new kind of projectile, is a powerful weapon and has a great ability to move in the space.</description>
    </item>
    
    <item>
      <title>zoj 3406 Another Very Easy Task</title>
      <link>http://liuxueyang.github.io/posts/zoj-3406-another-very-easy-task/</link>
      <pubDate>Tue, 19 Mar 2013 21:46:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-3406-another-very-easy-task/</guid>
      <description>This task is so easy that the description is omitted.</description>
    </item>
    
    <item>
      <title>zoj 3407 Doraemon&#39;s Cake Machine</title>
      <link>http://liuxueyang.github.io/posts/zoj-3407-doraemons-cake-machine/</link>
      <pubDate>Tue, 19 Mar 2013 21:42:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-3407-doraemons-cake-machine/</guid>
      <description>One day, N kids got one cake (a cylinder in shape).</description>
    </item>
    
    <item>
      <title>zoj 2110 Tempter of the Bone</title>
      <link>http://liuxueyang.github.io/posts/zoj-2110-tempter-of-the-bone/</link>
      <pubDate>Thu, 29 Nov 2012 14:10:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj-2110-tempter-of-the-bone/</guid>
      <description>The doggie found a bone in an ancient maze, which fascinated him a lot.</description>
    </item>
    
  </channel>
</rss>