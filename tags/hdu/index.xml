<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hdu on LXY Site</title>
    <link>http://liuxueyang.github.io/tags/hdu/</link>
    <description>Recent content in Hdu on LXY Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <managingEditor>your@email.com (Aos Dabbagh)</managingEditor>
    <webMaster>your@email.com (Aos Dabbagh)</webMaster>
    <copyright>(c) 2008 - 2014</copyright>
    <lastBuildDate>Tue, 20 Aug 2013 20:17:00 +0000</lastBuildDate>
    
	<atom:link href="http://liuxueyang.github.io/tags/hdu/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>hdu4690 EBCDIC ——水题，考耐心</title>
      <link>http://liuxueyang.github.io/posts/hdu4690-ebcdic-%E6%B0%B4%E9%A2%98%E8%80%83%E8%80%90%E5%BF%83/</link>
      <pubDate>Tue, 20 Aug 2013 20:17:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4690-ebcdic-%E6%B0%B4%E9%A2%98%E8%80%83%E8%80%90%E5%BF%83/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4690
考的是耐心何细心啊，用map把两个表格映射一下就行~
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; string A[16][16] = { &amp;quot;NUL&amp;quot;,&amp;quot;SOH&amp;quot;,&amp;quot;STX&amp;quot;,&amp;quot;ETX&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;HT&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;DEL&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;VT&amp;quot;,&amp;quot;FF&amp;quot;,&amp;quot;CR&amp;quot;,&amp;quot;SO&amp;quot;,&amp;quot;SI&amp;quot;, &amp;quot;DLE&amp;quot;,&amp;quot;DC1&amp;quot;,&amp;quot;DC2&amp;quot;,&amp;quot;DC3&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;BS&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;CAN&amp;quot;,&amp;quot;EM&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;IFS&amp;quot;,&amp;quot;IGS&amp;quot;,&amp;quot;IRS&amp;quot;,&amp;quot;IUS ITB&amp;quot;, &amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;LF&amp;quot;,&amp;quot;ETB&amp;quot;,&amp;quot;ESC&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;ENQ&amp;quot;,&amp;quot;ACK&amp;quot;,&amp;quot;BEL&amp;quot;, &amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;SYN&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;EOT&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;DC4&amp;quot;,&amp;quot;NAK&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;SUB&amp;quot;, &amp;quot;SP&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;&amp;quot;,&amp;quot;.</description>
    </item>
    
    <item>
      <title>hdu4671 Backup Plan ——构造题</title>
      <link>http://liuxueyang.github.io/posts/hdu4671-backup-plan-%E6%9E%84%E9%80%A0%E9%A2%98/</link>
      <pubDate>Thu, 15 Aug 2013 18:31:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4671-backup-plan-%E6%9E%84%E9%80%A0%E9%A2%98/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4671 其实是不难的那种构造题，先排第一列，第二列从后往前选。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int sad[111], fun[111][111]; int main(void) { int n, m; while (~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m)) { for(int i=1;i&amp;lt;=n;++i) { sad[i]=m/n; if(i&amp;lt;=m%n) sad[i]++; } int row=1; for(int i=1;i&amp;lt;=n;++i) { int k=n; for(int j=1;j&amp;lt;=sad[i];++j) { while (i==k||k==0) {if(i==k) k--; if(k==0) k=n;} fun[row][0]=i; fun[row][1]=k; k--; row++; } } for(int i=1;i&amp;lt;=m;++i) { printf(&amp;quot;%d %d&amp;quot;,fun[i][0],fun[i][1]); for(int j=1;j&amp;lt;=n;++j) { if(j!</description>
    </item>
    
    <item>
      <title>hdu4666 Hyperspace ——曼哈顿距离</title>
      <link>http://liuxueyang.github.io/posts/hdu4666-hyperspace-%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Thu, 15 Aug 2013 18:26:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4666-hyperspace-%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4666 这题学会了怎么处理曼哈顿距离。 比如维数是k，那么每个点有2^k个状态，求出在每个状态下，所有点的最大值，最小值，求他们的差，从中找到最大值就行。 开始觉得不好处理的是，删除的时候怎么办。比如要删除一个点，我可以在2^k个中的每个状态里面先找到这个点在这个状态下的值，删除这个值就行了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; multiset&amp;lt;int&amp;gt; a[44]; int sad[66666][10],will[66666][44]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu2191 悼念512汶川大地震     ——多重背包</title>
      <link>http://liuxueyang.github.io/posts/hdu2191-%E6%82%BC%E5%BF%B5512%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%87-----%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:54:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu2191-%E6%82%BC%E5%BF%B5512%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%87-----%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=2191 最简单的那种
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int n, V, t, f[111], c[111], w[111], m[111]; void zeropack(int c, int w) { for (int v=V; v&amp;gt;=c; --v) { f[v]=max(f[v],f[v-c]+w); } return; } void completepack(int c, int w) { for (int v=c;v&amp;lt;=V;++v) f[v]=max(f[v],f[v-c]+w); return; } void multipack(int c, int w, int m) { if (c*m &amp;gt;= V) { completepack(c,w); return; } int k=1; while (k&amp;lt;m) { zeropack(c*k,w*k); m-=k; k*=2; } zeropack(c*m,w*m); return; } int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu1059 Dividing ——多重背包</title>
      <link>http://liuxueyang.github.io/posts/hdu1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=1059 最简单的那种
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int V,m[6],c[6],w[6],f[66666]; void zeropack(int c, int w) { for (int v=V;v&amp;gt;=c;--v) f[v]=max(f[v],f[v-c]+w); return; } void completepack(int c,int w) { for(int v=c;v&amp;lt;=V;++v) f[v]=max(f[v],f[v-c]+w); return; } void multipack(int c,int w,int m) { if(c*m&amp;gt;=V) { completepack(c,w); return; } int k=1; while (k&amp;lt;m) { zeropack(k*c,k*w); m-=k; k*=2; } zeropack(c*m,w*m); return; } int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu1114 Piggy-Bank ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/hdu1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:47:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=1114 只不过求得是最小值。没什么可说的，连我都会做……o(╯□╰)o
/* ID: zypz4571 LANG: C++ TASK: pig.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int f[11111],c[555],w[555], V, n; void completepack(int c,int w) { for(int v=c;v&amp;lt;=V;++v) f[v]=min(f[v],f[v-c]+w); } int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu3033 I love sneakers!        分组背包变形</title>
      <link>http://liuxueyang.github.io/posts/hdu3033-i-love-sneakers--------%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E5%8F%98%E5%BD%A2/</link>
      <pubDate>Sun, 11 Aug 2013 18:24:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu3033-i-love-sneakers--------%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E5%8F%98%E5%BD%A2/</guid>
      <description>分组背包要求每一组里面只能选一个，这个题目要求每一组里面至少选一个物品。 dp[i, j] 表示前 i 组里面在每组至少放进一个物品的情况下，当花费 j 的时候，所得到的的最大价值。这个状态可以由三个状态转移过来： a[i, j].b表示第 i 组第 j 个物品的花费，v表示背包容量。 初始化： 如果一种物品都不放，那么对应的所有的背包容量都是0，也就是：dp[0, 0~M] = 0； 其他的情况，都初始化成-INF。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; typedef struct node { int b,v; }node; vector&amp;lt;node&amp;gt; a[11]; int dp[11][10009]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu1712 ACboy needs your help    分组背包</title>
      <link>http://liuxueyang.github.io/posts/hdu1712-acboy-needs-your-help----%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</link>
      <pubDate>Sun, 11 Aug 2013 16:20:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1712-acboy-needs-your-help----%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</guid>
      <description>最基础的分组背包~
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int dp[102], a[102][102]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin ); #endif // ONLINE_JUDGE int n,m; while (~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m)&amp;amp;&amp;amp;(n||m)) { for (int i=1;i&amp;lt;=n;++i) { for (int j=1;j&amp;lt;=m;++j) scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i][j]); } memset(dp,0,sizeof(dp)); for (int i=1;i&amp;lt;=n;++i) { for (int v=m;v&amp;gt;=0;--v) { for (int j=1;j&amp;lt;=v;++j) { dp[v]=max(dp[v],dp[v-j]+a[i][j]); } } } printf(&amp;quot;%d\n&amp;quot;,dp[m]); } return 0; }  没什么可说的。1Y</description>
    </item>
    
    <item>
      <title>hdu2955 Robberies 　０１背包＋概率</title>
      <link>http://liuxueyang.github.io/posts/hdu2955-robberies-%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85%E6%A6%82%E7%8E%87/</link>
      <pubDate>Tue, 06 Aug 2013 11:06:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu2955-robberies-%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85%E6%A6%82%E7%8E%87/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=2955 首先，这个题目的背包容量不能是概率．１．精度不清楚．２．把概率相加有什么意义呢？所以，转换一下，把所有银行的珠宝和当作背包容量，把小偷安全的概率当作物品价值．可以先求出背包尽可能满的情况下，安全概率最大的解．然后在这些解里面，找出安全概率满足大于１－Ｐ的并且价值最大的就行． 题目读清楚．人给的是被抓住的概率和每个银行被抓住的概率．这个是不能直接用的．比如连续偷几个银行，就要分别算出安全的概率，这样概率就可以直接相乘了． 只要要偷的几个银行的安全概率的积大于１－P就行．
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int V, n, c[11111]; double w[11111], f[11111]; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu2546　饭卡　　　　０１背包</title>
      <link>http://liuxueyang.github.io/posts/hdu2546%E9%A5%AD%E5%8D%A1%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85/</link>
      <pubDate>Tue, 06 Aug 2013 10:31:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu2546%E9%A5%AD%E5%8D%A1%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=2546 也算一个贪心的想法吧． 先把总钱数减去５，再把价值最大的挑出来．然后用０１背包．最终买下挑出来的那个价值最大的商品．这样的话，我就实现了最终用最少的钱数买了价值最多的商品，剩下钱数当然也是最少了．
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int main(void) { ios::sync_with_stdio(false); int n, V; int c[1111], f[1111]; #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu4632 Palindrome subsequence     ——区间动态规划</title>
      <link>http://liuxueyang.github.io/posts/hdu4632-palindrome-subsequence-----%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Sat, 03 Aug 2013 16:19:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4632-palindrome-subsequence-----%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4632 refer to: o(╯□╰)o……明明百度找的题解，然后后来就找不到我看的那份了，这位哥们对不住了……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; char a[1111]; int dp[1111][1111]; const int MOD = 10007; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu4642 Fliping game        ——博弈</title>
      <link>http://liuxueyang.github.io/posts/hdu4642-fliping-game--------%E5%8D%9A%E5%BC%88/</link>
      <pubDate>Sat, 03 Aug 2013 10:52:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4642-fliping-game--------%E5%8D%9A%E5%BC%88/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4642 refer to: http://www.cnblogs.com/jackge/archive/2013/08/01/3231573.html 这道题目很有意思。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif int t, n, m, tmp; ios::sync_with_stdio(false); cin&amp;gt;&amp;gt;t; for (int i = 0; i &amp;lt; t; ++i) { cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; for (int j = 0; j &amp;lt; n; ++j) for (int k = 0; k &amp;lt; m; ++k) cin&amp;gt;&amp;gt;tmp; if (tmp) cout&amp;lt;&amp;lt;&amp;quot;Alice&amp;quot;&amp;lt;&amp;lt;endl; else cout&amp;lt;&amp;lt;&amp;quot;Bob&amp;quot;&amp;lt;&amp;lt;endl; } return 0; }  o(╯□╰)o</description>
    </item>
    
    <item>
      <title>hdu4639 hehe      ——斐波纳契数列，找规律</title>
      <link>http://liuxueyang.github.io/posts/hdu4639-hehe------%E6%96%90%E6%B3%A2%E7%BA%B3%E5%A5%91%E6%95%B0%E5%88%97%E6%89%BE%E8%A7%84%E5%BE%8B/</link>
      <pubDate>Sat, 03 Aug 2013 10:29:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4639-hehe------%E6%96%90%E6%B3%A2%E7%BA%B3%E5%A5%91%E6%95%B0%E5%88%97%E6%89%BE%E8%A7%84%E5%BE%8B/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4639 refer to: http://blog.csdn.net/dongdongzhang_/article/details/9706259 http://www.cnblogs.com/wuhenqs/archive/2013/08/01/3230987.html
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; const int MOD = 10007; char a[11111]; long long fi[11111]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu3308  线段树——区间合并</title>
      <link>http://liuxueyang.github.io/posts/hdu3308--%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</link>
      <pubDate>Wed, 03 Jul 2013 14:10:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu3308--%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</guid>
      <description>更新一个点； 求某个区间的最长连续上升序列； 链接：http://acm.hdu.edu.cn/showproblem.php?pid=3308
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; #define maxn 100009 #define mid int m=(l+r)&amp;gt;&amp;gt;1 int num[maxn], lsum[maxn&amp;lt;&amp;lt;2], rsum[maxn&amp;lt;&amp;lt;2], msum[maxn&amp;lt;&amp;lt;2], n, m, p, v, a, b; void pushup(int o, int l, int r) { mid; if (num[m] &amp;lt; num[m+1]) { lsum[o] = (lsum[o&amp;lt;&amp;lt;1] == m+1-l) ? (m+1-l+lsum[o&amp;lt;&amp;lt;1|1]) : lsum[o&amp;lt;&amp;lt;1]; rsum[o] = (rsum[o&amp;lt;&amp;lt;1|1] == r-m) ? (r-m+rsum[o&amp;lt;&amp;lt;1]) : rsum[o&amp;lt;&amp;lt;1|1]; msum[o] = max(max(msum[o&amp;lt;&amp;lt;1], msum[o&amp;lt;&amp;lt;1|1]), lsum[o&amp;lt;&amp;lt;1|1] + rsum[o&amp;lt;&amp;lt;1]); } else lsum[o] = lsum[o&amp;lt;&amp;lt;1], rsum[o] = rsum[o&amp;lt;&amp;lt;1|1], msum[o] = max(msum[o&amp;lt;&amp;lt;1], msum[o&amp;lt;&amp;lt;1|1]); } void build(int o, int l, int r) { if (l == r) {lsum[o]= rsum[o] = msum[o] = 1; return;} mid; build(o&amp;lt;&amp;lt;1, l, m), build(o&amp;lt;&amp;lt;1|1, m+1, r), pushup(o, l, r); } void update(int o, int l, int r) { if (l == r) {num[p] = v; return;} mid; if (p &amp;lt;= m) update(o&amp;lt;&amp;lt;1, l, m); else update(o&amp;lt;&amp;lt;1|1, m+1, r); pushup(o, l, r); } int query(int o, int l, int r) { if (a &amp;lt;= l &amp;amp;&amp;amp; b &amp;gt;= r) return msum[o]; mid; int ret = 0; if (a &amp;lt;= m) ret = max(ret, query(o&amp;lt;&amp;lt;1, l, m)); if (b &amp;gt; m) ret = max(ret, query(o&amp;lt;&amp;lt;1|1, m+1, r)); if (num[m] &amp;lt; num[m+1]) ret = max(ret, min(m-a+1, rsum[o&amp;lt;&amp;lt;1])+min(b-m, lsum[o&amp;lt;&amp;lt;1|1])); return ret; } int main(void) { int t, n, m; char ch[5]; scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); while (t--) { scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;n, &amp;amp;m); for (int i = 1; i &amp;lt;= n; scanf(&amp;quot;%d&amp;quot;, num+i++)); build(1, 1, n); while (m--) { scanf(&amp;quot;%s%d%d&amp;quot;, ch, &amp;amp;a, &amp;amp;b); a++, b++; if (ch[0] == &#39;Q&#39;) printf(&amp;quot;%d\n&amp;quot;, query(1, 1, n)); else p = a, v = b-1, update(1, 1, n); } } return 0; }  。。</description>
    </item>
    
    <item>
      <title>hdu1420 Prepared for New Acmer ——快速幂</title>
      <link>http://liuxueyang.github.io/posts/hdu1420-prepared-for-new-acmer-%E5%BF%AB%E9%80%9F%E5%B9%82/</link>
      <pubDate>Sat, 01 Jun 2013 19:33:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1420-prepared-for-new-acmer-%E5%BF%AB%E9%80%9F%E5%B9%82/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1420 题目大意： 中文题。 题目思路： 赤裸裸的快速幂。呵呵
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; #define LL long long LL m; LL Po(LL a, LL b) { LL ans = 1; while (b) { if (b&amp;amp;1) { ans = (ans * a) % m; b--; } b /= 2; a = a * a % m; } return ans; } int main(void) { LL n, a, b; #ifndef ONLINE_JUDGE freopen(&amp;quot;1420.</description>
    </item>
    
    <item>
      <title>hdu1257 最少拦截系统 ——DP么？</title>
      <link>http://liuxueyang.github.io/posts/hdu1257-%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F-dp%E4%B9%88/</link>
      <pubDate>Sat, 01 Jun 2013 18:43:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1257-%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F-dp%E4%B9%88/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1257 题目大意： 中文的…… 题目思路： 人家说是DP，求最长不升子序列的个数。好吧……我不是那么做的。 我的思路是，从前往后扫一遍，访问过的标记为true，记录一下个数就ＯＫ了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int b[1000]; bool a[1000]; int main(void) { int n; #ifndef ONLINE_JUDGE freopen(&amp;quot;1257.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { int i, j, cnt = 0; for (i = 0; i &amp;lt; n; ++i) scanf(&amp;quot;%d&amp;quot;, b+i); memset(a, false, sizeof(a)); for (i = 0; i &amp;lt; n; ++i) { while (a[i]) ++i; if (i == n) break; if (!</description>
    </item>
    
    <item>
      <title>hdu1176 免费馅饼 ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu1176-%E5%85%8D%E8%B4%B9%E9%A6%85%E9%A5%BC-dp/</link>
      <pubDate>Sat, 25 May 2013 17:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1176-%E5%85%8D%E8%B4%B9%E9%A6%85%E9%A5%BC-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1176 题目大意： 中文题…… 题目思路： 类似于 Triangle 。d[i][j] 表示 i 时间在 j 位置的所得到的价值。然后就像 Triangle 一样从下往上递推。最终求在0秒的时候，在5位置上的值。 ＷＡ了两次，当初求的是0秒的时候，所有位置上的最大值，，这显然是不对的。因为起始位置是5啊。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; const int MAX = 100000+10; int a[MAX][11], d[MAX][11]; void init() { int m, i, j, x, t, tMax = -1; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;m) &amp;amp;&amp;amp; m) { memset(a, 0, sizeof(a)); memset(d, 0, sizeof(d)); for (i = 0; i &amp;lt; m; ++i) { scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;x, &amp;amp;t); if (tMax &amp;lt; t) tMax = t; a[t][x]++; } for (i = 0; i &amp;lt;= 10; ++i) d[tMax][i] = a[tMax][i]; for (i = tMax-1; i&amp;gt;= 0; --i) { for (j = 0; j &amp;lt;= 10; ++j) { if (j == 0) { d[i][j] = max(d[i+1][j], d[i+1][j+1]) + a[i][j]; continue; } else if (j == 10) { d[i][j] = max(d[i+1][j], d[i+1][j-1]) + a[i][j]; continue; } d[i][j]=max(d[i+1][j], max(d[i+1][j+1], d[i+1][j-1]))+a[i][j]; } } printf(&amp;quot;%d\n&amp;quot;, d[0][5]); } } int main(void) { init(); return 0; }  很多题目都是相通的</description>
    </item>
    
    <item>
      <title>hdu2069 Coin Change ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu2069-coin-change-dp/</link>
      <pubDate>Fri, 24 May 2013 11:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu2069-coin-change-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2069 题目大意： 给一个数字，用1, 5, 10， 25, 50 这五种硬币，最多用100枚，有多少种组合方式。 题目思路： 这道题和之前的题目不同，有了硬币个数的限制，所以需要加上一维表示硬币的个数就可以了。d[i][j]表示价值为 i 的最多用 j 枚硬币有多少中组合方式。很多人用母函数做，感觉DP做简单多了…… 参考博客：http://www.cnblogs.com/qiufeihai/archive/2012/09/11/2680840.html
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; const int MAX = 250+10; int d[MAX][MAX], n, a[5] = {1, 5, 10, 25, 50}; void solve() { while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { int i, j, k; memset(d, 0, sizeof(d)); d[0][0] = 1; for (k = 0; k &amp;lt; 5; ++k) { for (j = 1; j &amp;lt;= 100; ++j) { for (i = a[k]; i &amp;lt;= n; ++i) { d[i][j] += d[i-a[k]][j-1]; } } } int sum(0); for (i = 0; i &amp;lt;= n; ++i) { sum += d[n][i]; } printf(&amp;quot;%d\n&amp;quot;, sum); } } int main(void) { solve(); return 0; }  　还有要注意一点，初始化要d[0][0] = 1 因为题目中说：Note that we count that there is one way of making change for zero cent.</description>
    </item>
    
    <item>
      <title>hdu1398 Square Coins ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu1398-square-coins-dp/</link>
      <pubDate>Thu, 23 May 2013 23:20:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1398-square-coins-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1398 题目大意： 给一个数字，不大于300，求有多少种用完全平方数表示这个数字的方法 题目思路： 方法跟hdu1283一样一样的……只需要把那道题目的代码稍微改一下就可以过了 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n) &amp;amp;&amp;amp; n) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &amp;lt;= floor(sqrt(n)); ++i) { for (j = i*i; j &amp;lt;= n; ++j) { d[j] += d[j-i*i]; } } printf(&amp;quot;%lld\n&amp;quot;, d[n]); } } int main(void) { solve(); return 0; }   因为题目的范围很小嘛，只有300。 </description>
    </item>
    
    <item>
      <title>hdu1284 钱币兑换问题 ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu1284-%E9%92%B1%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-dp/</link>
      <pubDate>Thu, 23 May 2013 20:39:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1284-%E9%92%B1%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1284 题目大意： 中文题…… 题目思路： 只有3个硬币，范围是32768，可以一个一个枚举硬币，如果只放价值为1的硬币，从d[1]递推到d[n]；如果再加上价值为2的硬币，那么就从d[2]递推到d[n]；在加上价值为3的硬币，就从d[3]递推到d[n].递推公式是d[j] = d[j] + d[j-i]； d[j]表示j有几种只用1，2, 3这三个数字的拆分方法，i 就是硬币的价值。 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &amp;lt;= 3; ++i) { for (j = i; j &amp;lt;= n; ++j) { d[j] += d[j-i]; } } printf(&amp;quot;%lld\n&amp;quot;, d[n]); } } int main(void) { solve(); return 0; }   参考博客：http://www.</description>
    </item>
    
    <item>
      <title>hdu1028 Ignatius and the Princess III ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu1028-ignatius-and-the-princess-iii-dp/</link>
      <pubDate>Thu, 23 May 2013 19:48:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1028-ignatius-and-the-princess-iii-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1028 题目大意：　整数拆分，给一个整数n,求它有多少种拆分方法。 题目思路： 做法一： d[i][j]表示把整数 i 拆成最多 j 个数字所具有的方法数。那么 if (i &amp;gt;ｊ)　d[i][j] = d[i-j][j] + d[i][j-1]; 意思就是如果i&amp;gt;j，那么有两种方式：一种是先把i里面分理处j个1，然后再把i-j拆成最多i-j个数字；另一种是把i拆分成最多j-1个数字。 if (i &amp;lt; j) d[i][j] = d[i][i]; 意思就是如果i&amp;lt;j，那么这种情况和把数字i最多拆成i个数字的是一样的。 if (i == j) d[i][j] = d[i][j-1] + 1; 意思就是如果i==j，那么可以把数字i拆分成j-1个数字，也可以把数字i拆分成i个1（这个就是那个1的意义） #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; #define LL long long int d[140][140], n; void init() { while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { int i, j; memset(d, 0, sizeof(d)); for (i = 0; i &amp;lt;= n; ++i) d[i][1] = d[1][i] = 1; for (i = 2; i &amp;lt;= n; ++i) { for (j = 1; j &amp;lt;= n; ++j) { if (i &amp;gt; j) d[i][j] = d[i-j][j] + d[i][j-1]; else if (i == j) d[i][j] = 1 + d[i][j-1]; else d[i][j] = d[i][i]; } } cout &amp;lt;&amp;lt; d[n][n] &amp;lt;&amp;lt; endl; } } int main(void) { init(); return 0 ; }   剩下的就是考虑一下边界，比如当 i 或者 j 等于1的时候，显然都是只有一种拆分情况。 做法二： 借用hdu1284这道题的方法，也可以做这道题目，因为n的范围是120嘛,两个算法的复杂度都是O(n^2)的，当然可以了。只需要把hdu1284的代码里面把3改成n，这题就过了…… #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &amp;lt;= n; ++i) { for (j = i; j &amp;lt;= n; ++j) { d[j] += d[j-i]; } } printf(&amp;quot;%lld\n&amp;quot;, d[n]); } } int main(void) { solve(); return 0; }   优化到了一维数组，这个方法碉堡了…… 参考博客：http://www.</description>
    </item>
    
    <item>
      <title>hdu1394 Minimum Inversion Number ——线段树</title>
      <link>http://liuxueyang.github.io/posts/hdu1394-minimum-inversion-number-%E7%BA%BF%E6%AE%B5%E6%A0%91/</link>
      <pubDate>Thu, 23 May 2013 18:25:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1394-minimum-inversion-number-%E7%BA%BF%E6%AE%B5%E6%A0%91/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1394 题目大意： 给定一个0到ｎ-1的数字组成的序列，它的逆序数，然后把第一个数字放到末尾，得到一个新的序列，再求逆序数，再把新序列的第一个数字放到末尾，一直这样做，求所有这些序列的逆序数的最小值。 题目思路： 可以先求出起初的序列的逆序数。然后根据逆序数的定义，把一个数字从开头移动到末尾，逆序数的改变量是什么？求出这个改变量，然后剩下的所有序列的逆序数就都求出来了。 这样考虑：一个数字 ｂ[i] 在开头，比它大的数字有 ｂ[i] 个，也就是说和这个数字组成了 ｂ[i] 个逆序，把它放到最后，这个数字可以组成 n-1-ｂ[i] 个逆序，所以逆序数的增量是 n - 1 - ｂ[i] - ｂ[i] ，这样就可以根据原来的序列的逆序数求出剩下的所有序列的逆序数了～
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; const int MAX = 5000+10; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 int a[MAX&amp;lt;&amp;lt;2], b[MAX], n; void pushup(int rt) { a[rt] = a[rt&amp;lt;&amp;lt;1] + a[rt&amp;lt;&amp;lt;1|1]; } void build(int l, int r, int rt) { if (l == r) {a[rt] = 0; return;} int m = (l + r) &amp;gt;&amp;gt; 1; build(lson); build(rson); pushup(rt); } void update(int p, int l, int r, int rt) { if (l == r) {a[rt]++; return;} int m = (l + r) &amp;gt;&amp;gt; 1; if (p &amp;lt;= m) update(p, lson); else update(p, rson); pushup(rt); } int query(int L, int R,int l, int r, int rt) { if (L &amp;lt;= l &amp;amp;&amp;amp; R &amp;gt;= r) {return a[rt];} int m = (l + r) &amp;gt;&amp;gt; 1, ret = 0; if (L &amp;lt;= m) ret += query(L, R, lson); if (R &amp;gt; m) ret += query(L, R, rson); return ret; } void init() { while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { int i, sum = 0, ans; build(0, n - 1, 1); for (i = 0; i &amp;lt; n; ++i) { scanf(&amp;quot;%d&amp;quot;, b+i); sum += query(b[i]+1, n-1, 0, n-1, 1); update(b[i], 0, n-1, 1); } ans = sum; for (i = 0; i &amp;lt; n; ++i) { sum += (n-1-2*b[i]); if (sum &amp;lt; ans) ans = sum; } printf(&amp;quot;%d\n&amp;quot;, ans); } } int main(void) { init(); return 0; }  这题是线段树的单点更新</description>
    </item>
    
    <item>
      <title>hdu1272 小希的迷宫 ——并查集无向图判环</title>
      <link>http://liuxueyang.github.io/posts/hdu1272-%E5%B0%8F%E5%B8%8C%E7%9A%84%E8%BF%B7%E5%AE%AB-%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%97%A0%E5%90%91%E5%9B%BE%E5%88%A4%E7%8E%AF/</link>
      <pubDate>Sun, 12 May 2013 23:44:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1272-%E5%B0%8F%E5%B8%8C%E7%9A%84%E8%BF%B7%E5%AE%AB-%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%97%A0%E5%90%91%E5%9B%BE%E5%88%A4%E7%8E%AF/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1272 题目大意： 给一个无向图，判断是不是有环，有就输出No，否则输出Yes 题目思路： 用并查集，开始还天真地以为要用拓扑排序，好吧……虽然那个也可以做，可是为什么不用简单的方法呢？
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 100000+10; int parent[MAX]; bool flag; void init() { for (int i = 1; i&amp;lt;=MAX; ++i) parent[i] = -1; } int find(int x) { int s; for (s = x; parent[s] !</description>
    </item>
    
    <item>
      <title>hdu1028 Ignatius and the Princess III &amp;&amp; hdu2082 找单词 &amp;&amp; poj1664 放苹果 &amp;&amp; noj1046 正整数划分问题——整数划分</title>
      <link>http://liuxueyang.github.io/posts/hdu1028-ignatius-and-the-princess-iii--hdu2082-%E6%89%BE%E5%8D%95%E8%AF%8D--poj1664-%E6%94%BE%E8%8B%B9%E6%9E%9C--noj1046-%E6%AD%A3%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86/</link>
      <pubDate>Sun, 12 May 2013 20:37:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1028-ignatius-and-the-princess-iii--hdu2082-%E6%89%BE%E5%8D%95%E8%AF%8D--poj1664-%E6%94%BE%E8%8B%B9%E6%9E%9C--noj1046-%E6%AD%A3%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86/</guid>
      <description>这种问题有两种做法，DP和母函数。 hdu1028 Ignatius and the Princess III 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1028 DP做法：
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu1028.</description>
    </item>
    
    <item>
      <title>hdu2577 How to Type ——DP入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu2577-how-to-type-dp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Fri, 10 May 2013 20:49:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu2577-how-to-type-dp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2577 题目大意： 一个人打字，有小写字母，有大写字母，并且要求打完字以后要把CapsLock键关掉。求最少的按键次数。 题目思路： dp[i][0]表示打到第 i 个字母的时候，CapsLock键是关着的；　dp[i][1]表示打到第 i 个字母的时候，CapsLock键是开着的； 然后就是判断下一个字母是大写字母还是小写字母，如果是小写字母，dp[i+1][0] = min(dp[i][0] + 1, dp[i][1] + 2); 表示，要求下一个状态CapsLock关着，那么前一个状态如果是关着的，直接打字母就可以了，所以只需要加1，如果是开着的，就要先把CapsLock关掉，然后再打字母，所以需要加2. 其他的情况类似。参考的是这个人的代码：http://www.cnblogs.com/mengxm-lincf/archive/2011/06/07/2074489.html #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int dp[110][2]; char ch[110]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu2577.</description>
    </item>
    
    <item>
      <title>hdu2795 Billboard ——线段树入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu2795-billboard-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Wed, 24 Apr 2013 09:30:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu2795-billboard-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2795 题目大意： 高度为h,长度为w的板子，贴n个海报，每个海报的高度都为1，长度由n个整数给出。贴海报的原则是，从高到低，优先选高的，从左到右，优先选右边的位置。起初每个海报在板子上所在的行数。 题目思路： 建立一棵叶子节点有h个的线段树，每个节点代表这个区间内的最大值，最开始，叶子节点都是w。然后每插入一个值就插入到叶子节点，输出叶子节点的值，然后更新父节点。 这道题目的难点是，要想到建立线段树，把模型抽象出来。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 200000+10; int a[MAX&amp;lt;&amp;lt;2], n, h, w, b[MAX]; void pushup(int rt) { a[rt] = max(a[rt&amp;lt;&amp;lt;1], a[rt&amp;lt;&amp;lt;1|1]); } void build(int l, int r, int rt) { if (l == r) { a[rt] = w; return; } int m = (l + r) &amp;gt;&amp;gt; 1; build(lson); build(rson); pushup(rt); } void update(int p, int k, int l, int r, int rt) { if (l == r) { a[rt] -= k; return; } int m = (l + r) &amp;gt;&amp;gt; 1; if (p &amp;lt;= m) update(p, k, lson); else update(p, k, rson); pushup(rt); } int query(int k, int l, int r, int rt) { if (l == r) { return l; } int m = (l + r) &amp;gt;&amp;gt; 1, ret = 0; /* if (a[rt&amp;lt;&amp;lt;1] &amp;gt;= k) ret = query(k, lson); else ret = query(k, rson); */ if (a[rt] &amp;gt;= k) { if (a[rt&amp;lt;&amp;lt;1] &amp;gt;= k) ret = query(k, lson); else ret = query(k, rson); } else return 0; return ret; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu2795.</description>
    </item>
    
    <item>
      <title>hdu1394 Minimum Inversion Number ——线段树入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu1394-minimum-inversion-number-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Tue, 23 Apr 2013 23:23:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1394-minimum-inversion-number-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1394 题目大意： 给一个数字由0~n-1这n个数字组成的数列，不断地把第一个数字移动到最后，一共得到n个数列。求这n个数列中，逆序数最小是多少。 题目思路： 首先，建一棵线段树，每个节点表示这个区间内已经插入的数字的个数，开始初始化为0.然后没读入一个数字，把这个数字插入得到线段树的叶子节点，然后向上更新父节点。这样，在建树的过程中，就可以统计出每个逆序数，也就是说，可以再插入每个数字的时候，查找已经插入的数字当中，比这个数字大的数字有多少个，直到最后就可以求出这个数列的逆序数。 然后，利用数列的性质。因为每次都是把第一个数字移动到最后，比如这个数字是a，那么显然，比这个数字小的有a个，比这个数字大的有n-1-a个；因为这个数字在最前面，所以当前这个数字的逆序数是a，把这个数字移动到最后之后，这个数字的逆序数是n-1-a，逆序数增加量：n-1-a-a。这样就可以由原来的数列的逆序数求出所有数列的逆序数。好神奇~
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 5000+10; int a[MAX&amp;lt;&amp;lt;2], n, b[MAX]; void pushup(int rt) { a[rt] = a[rt&amp;lt;&amp;lt;1] + a[rt&amp;lt;&amp;lt;1|1]; } void build(int l, int r, int rt) { if (l == r) { a[rt] = 0; return; } int m = (l + r) &amp;gt;&amp;gt; 1; build(lson); build(rson); pushup(rt); } void update(int p, int l, int r, int rt) { if (l == r) { a[rt]++; return; } int m = (l + r) &amp;gt;&amp;gt; 1; if (p &amp;lt;= m) update(p, lson); else update(p, rson); pushup(rt); } int query(int L, int R, int l, int r, int rt) { if (L &amp;lt;= l &amp;amp;&amp;amp; R &amp;gt;= r) { return a[rt]; } int m = (l + r) &amp;gt;&amp;gt; 1, ret = 0; if (L &amp;lt;= m) ret += query(L, R, lson); if (R &amp;gt; m) ret += query(L, R, rson); return ret; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu1394.</description>
    </item>
    
    <item>
      <title>hdu1754 I Hate It &amp;&amp; hdu1166 敌兵布阵 ——线段树复习</title>
      <link>http://liuxueyang.github.io/posts/hdu1754-i-hate-it--hdu1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Tue, 23 Apr 2013 14:54:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1754-i-hate-it--hdu1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5-%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A4%8D%E4%B9%A0/</guid>
      <description>题目链接： http://acm.hdu.edu.cn/showproblem.php?pid=1754　 http://acm.hdu.edu.cn/showproblem.php?pid=1166 都是最基础的线段树，考的知识点就是点更新，区间求和，区间求最大值。再次学线段树，感觉理解加深了一些。 但是写的时候还是会出现各种奇葩的错误。唉。 hdu1754
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; const int MAX = 200000+10; int gra[MAX&amp;lt;&amp;lt;2], m , n; void pushup(int rt) { gra[rt] = max(gra[rt&amp;lt;&amp;lt;1], gra[rt&amp;lt;&amp;lt;1|1]); } void build(int l, int r, int rt) { if (l == r) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;gra[rt]); return; } int m = (l + r) &amp;gt;&amp;gt; 1; build(lson); build(rson); pushup(rt); } void update(int p, int k, int l, int r, int rt) { if (l == r) { gra[rt] = k; return; } int m = (l + r) &amp;gt;&amp;gt; 1; if (p &amp;lt;= m) update(p, k, lson); else update(p, k, rson); pushup(rt); } int query(int L, int R, int l, int r, int rt) { if (L &amp;lt;= l &amp;amp;&amp;amp; R &amp;gt;= r) { return gra[rt]; } int m = (l + r) &amp;gt;&amp;gt; 1, ret = 0; if (L &amp;lt;= m) ret = max(ret, query(L, R, lson)); if (R &amp;gt; m) ret = max(ret, query(L, R, rson)); return ret; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu1754.</description>
    </item>
    
    <item>
      <title>hdu2098 不要62 ——数位DP入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu2098-%E4%B8%8D%E8%A6%8162-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 15 Apr 2013 21:24:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu2098-%E4%B8%8D%E8%A6%8162-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2089 题目大意： 含有4或者62的数字是不吉利数字，给一个区间，[m, n]，求这个区间内的除了不吉利数字以外的数字的数目。 思路： 由于数据范围只有1~1000000，可以暴力，水题，但是为了练习一下数位DP，没有把它当水题做…… 看的是这个人的代码：http://blog.csdn.net/acm_cxlove/article/details/7819907# 和hdu3555那道题目相似，但是多了一个条件，多了一个不含有4的条件，讨论一下。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; LL dp[8][3]; int a[8], b[8]; bool flag; int solve(int k){ int len = 0; LL temp = k; while (k){ a[++len] = k % 10; k /= 10; } LL ans = 0; int last = 0; flag = false; a[len+1] = 0; for (int i = len; i &amp;gt;= 1; --i){ ans += dp[i-1][2] * a[i]; if (flag){ans += dp[i-1][0] * a[i];} //高位位填4，低位的不管 if (!</description>
    </item>
    
    <item>
      <title>hdu1202 The calculation of GPA ——水题</title>
      <link>http://liuxueyang.github.io/posts/hdu1202-the-calculation-of-gpa-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Mon, 15 Apr 2013 20:39:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1202-the-calculation-of-gpa-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1202 题目大意：先计算出学分和点数的乘积的和，然后在除以学分之和。 思路： 很简单。只能说这道题目比较坑……不说什么了 本来是早上起来想写道水题，练练手，结果碰见这种题目，刚才我还无聊的测试了很多次，交了N遍，发现这么个坑的问题，感觉这种题目很没有意思……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu1202.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif int t; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;t)){ double cnt = 0, cnt1 = 0; double s, p; for (int i = 0; i &amp;lt; t; ++i){ cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; p; cnt += s; if (p&amp;gt;=90 &amp;amp;&amp;amp; p &amp;lt;= 100) cnt1 += 4.</description>
    </item>
    
    <item>
      <title>hdu3555 Bomb ——数位DP入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu3555-bomb-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 14 Apr 2013 11:23:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu3555-bomb-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=3555 题目大意： 给一个数字n,范围在1~2^63-1，求1~n之间含有49的数字有多少个。 思路： 经典的数位DP，学习了一下，看的别人的代码：http://www.cnblogs.com/luyi0619/archive/2011/04/29/2033117.html 状态转移： dp[i][0]代表长度为 i 并且不含有49的数字的个数； dp[i][1]代表长度为 i 并且不含有49，但是最高位是9的数字的个数； dp[i][2]代表长度为 i 并且含有49的数字的个数。 数组 a[i] 从低位到高位存储 n 的每一位数字。 则：dp[i][0] = dp[i-1][0] * a[i] - dp[i-1][1]; 表示长度为 i 的不含有49的数字的个数等于长度为 i - 1 的不含有49的数字的个数*当前的数字，因为这个位置可以填0~a[i] - 1，然后再减去长度为 i - 1 的最高位是9的数字的个数，因为如果长度为 i - 1 的最高位是9的话，那么高一位就不能填4了，否则就组成了49。 dp[i][1] = dp[i-1][0]; 表示长度为 i 的并且不含有49同时最高位是9的数字的个数等于，长度为 i - 1 的不含有49的数字的个数，因为只要在它的高一位加上一个9就可以了。 dp[i][2] = dp[i-1][2] * a[i] + dp[i-1][1]; 表示长度为 i 的含有49的数字的个数等于，长度为 i - 1 的数字的个数*当前的数字，再加上长度为 i - 1 的并且不含有49同时最高位是9的数字的个数，因为这个时候，只要在高一位加上一个4就可以了，这样在最高的两位就组成了一个49。 做法是从数字的高位向低位扫描，对于第 i 位， 其实这个题目还有一个地方不懂，就是为什么要在输入 n 后，要把 n 加1。想了一下特例，比如输入49，按照上面的做法，在第3步，并不会把符合条件的数字加上，因为4不是严格大于4，最后的执行结果就是0，但是如果加上1之后，n就变成了50，这样第3步恰好可以执行，结果就是正确的了。但是对于一般的情况，还是不知道为什么要把n加1……o(╯□╰)o 这题还是卡了很久，照着别人的代码敲的，死活过不了，然后又找了一份代码：http://blog.</description>
    </item>
    
    <item>
      <title>hdu 1059 Dividing ——多重背包复习</title>
      <link>http://liuxueyang.github.io/posts/hdu-1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Fri, 05 Apr 2013 12:29:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E5%A4%8D%E4%B9%A0/</guid>
      <description>Dividing
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 11367 Accepted Submission(s): 3168
Problem Description Marsha and Bill own a collection of marbles. They want to split the collection among themselves so that both receive an equal share of the marbles. This would be easy if all the marbles had the same value, because then they could just split the collection in half. But unfortunately, some of the marbles are larger, or more beautiful than others.</description>
    </item>
    
    <item>
      <title>hdu 2035 人见人爱A^B ——同余的简单性质</title>
      <link>http://liuxueyang.github.io/posts/hdu-2035-%E4%BA%BA%E8%A7%81%E4%BA%BA%E7%88%B1ab-%E5%90%8C%E4%BD%99%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%A7%E8%B4%A8/</link>
      <pubDate>Sun, 31 Mar 2013 22:19:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-2035-%E4%BA%BA%E8%A7%81%E4%BA%BA%E7%88%B1ab-%E5%90%8C%E4%BD%99%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%A7%E8%B4%A8/</guid>
      <description>Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others)Total Submission(s): 15572 Accepted Submission(s): 11012 </description>
    </item>
    
    <item>
      <title>hdu 1021 Fibonacci Again   ——同余的简单性质</title>
      <link>http://liuxueyang.github.io/posts/hdu-1021-fibonacci-again---%E5%90%8C%E4%BD%99%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%A7%E8%B4%A8/</link>
      <pubDate>Sun, 31 Mar 2013 22:12:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1021-fibonacci-again---%E5%90%8C%E4%BD%99%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%A7%E8%B4%A8/</guid>
      <description>Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others)Total Submission(s): 26755 Accepted Submission(s): 12950 </description>
    </item>
    
    <item>
      <title>hdu 1712 ACboy needs your help 分组背包</title>
      <link>http://liuxueyang.github.io/posts/hdu-1712-acboy-needs-your-help-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</link>
      <pubDate>Fri, 29 Mar 2013 15:08:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1712-acboy-needs-your-help-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</guid>
      <description>ACboy needs your help
Time Limit: 1000&amp;frasl;1000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 2403 Accepted Submission(s): 1223
Problem Description ACboy has N courses this term, and he plans to spend at most M days on study.Of course,the profit he will gain from different course depending on the days he spend on it.How to arrange the M days for the N courses to maximize the profit?
Input The input consists of multiple data sets.</description>
    </item>
    
    <item>
      <title>hdu 2159 FATE 二维背包</title>
      <link>http://liuxueyang.github.io/posts/hdu-2159-fate-%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85/</link>
      <pubDate>Fri, 29 Mar 2013 13:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-2159-fate-%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85/</guid>
      <description>FATE
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 4682 Accepted Submission(s): 2105
Problem Description 最近xhd正在玩一款叫做FATE的游戏，为了得到极品装备，xhd在不停的杀怪做任务。久而久之xhd开始对杀怪产生的厌恶感，但又不得不通过杀怪来升完这最后一级。现在的问题是，xhd升掉最后一级还需n的经验值，xhd还留有m的忍耐度，每杀一个怪xhd会得到相应的经验，并减掉相应的忍耐度。当忍耐度降到0或者0以下时，xhd就不会玩这游戏。xhd还说了他最多只杀s只怪。请问他能升掉这最后一级吗？
Input 输入数据有多组，对于每组数据第一行输入n，m，k，s(0 &amp;lt; n,m,k,s &amp;lt; 100)四个正整数。分别表示还需的经验值，保留的忍耐度，怪的种数和最多的杀怪数。接下来输入k行数据。每行数据输入两个正整数a，b(0 &amp;lt; a,b &amp;lt; 20)；分别表示杀掉一只这种怪xhd会得到的经验值和会减掉的忍耐度。(每种怪都有无数个)
Output 输出升完这级还能保留的最大忍耐度，如果无法升完这级输出-1。
Sample Input 10 10 1 10 1 1 10 10 1 9 1 1 9 10 2 10 1 1 2 2
Sample Output 0 -1 1
二维背包。这道题目开始的思路是错误的，我把经验值看成了一个背包容量，实际上，这是不恰当的。因为，这个背包容量必须至少要装满，还有，可以超过这个容量，如果超过了，这样做是不可解的。 后来也没有认真想，就看了一下别人的代码，惭愧……又在翻别人的代码。。 明白了，把忍耐值看成一个背包，怪物个数看成另一个背包，这样就有2个背包容量，求出最大的经验值，然后再遍历一次，求出比要求的经验值大的，并且忍耐度最小的，就ＯＫ了。 明白了之后，然后我就把原来的代码开始修改，悲剧的是，后面的改了，但是输入的地方没有改，死活也Ａ不了……明明就40行代码，搞得这么纠结……次嗷……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; const int MAX = 0x3f3f3f3f; int f[120][120]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;2159.</description>
    </item>
    
    <item>
      <title>hdu 1114 Piggy-Bank 完全背包</title>
      <link>http://liuxueyang.github.io/posts/hdu-1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 28 Mar 2013 12:14:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>Piggy-Bank
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 6841 Accepted Submission(s): 3375
Problem Description Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank.</description>
    </item>
    
    <item>
      <title>hdu 2602 Bone Collector 01背包</title>
      <link>http://liuxueyang.github.io/posts/hdu-2602-bone-collector-01%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 28 Mar 2013 10:34:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-2602-bone-collector-01%E8%83%8C%E5%8C%85/</guid>
      <description>Bone Collector
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 17590 Accepted Submission(s): 6954
Problem Description Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave … The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get ?</description>
    </item>
    
    <item>
      <title>hdu 1065 I Think I Need a Houseboat</title>
      <link>http://liuxueyang.github.io/posts/hdu-1065-i-think-i-need-a-houseboat/</link>
      <pubDate>Fri, 15 Mar 2013 19:24:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1065-i-think-i-need-a-houseboat/</guid>
      <description>I Think I Need a Houseboat
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 5929 Accepted Submission(s): 1761
Problem Description
Fred Mapper is considering purchasing some land in Louisiana to build his house on. In the process of investigating the land, he learned that the state of Louisiana is actually shrinking by 50 square miles each year, due to erosion caused by the Mississippi River. Since Fred is hoping to live in this house the rest of his life, he needs to know if his land is going to be lost to erosion.</description>
    </item>
    
    <item>
      <title>hdu 1056 HangOver</title>
      <link>http://liuxueyang.github.io/posts/hdu-1056-hangover/</link>
      <pubDate>Fri, 15 Mar 2013 11:01:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1056-hangover/</guid>
      <description>HangOver
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 7186 Accepted Submission(s): 2884
Problem Description How far can you make a stack of cards overhang a table? If you have one card, you can create a maximum overhang of half a card length. (We&amp;rsquo;re assuming that the cards must be perpendicular to the table.) With two cards you can make the top card overhang the bottom one by half a card length, and the bottom one overhang the table by a third of a card length, for a total maximum overhang of 1&amp;frasl;2 + 1&amp;frasl;3 = 5&amp;frasl;6 card lengths.</description>
    </item>
    
    <item>
      <title>hdu 1040 As Easy As A&#43;B</title>
      <link>http://liuxueyang.github.io/posts/hdu-1040-as-easy-as-a&#43;b/</link>
      <pubDate>Wed, 13 Mar 2013 21:23:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1040-as-easy-as-a&#43;b/</guid>
      <description>As Easy As A+B
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 26401 Accepted Submission(s): 11218
Problem Description These days, I am thinking about a question, how can I get a problem as easy as A+B? It is fairly difficulty to do such a thing. Of course, I got it after many waking nights. Give you some integers, your task is to sort these number ascending (升序).</description>
    </item>
    
    <item>
      <title>hdu 1018 Big Number</title>
      <link>http://liuxueyang.github.io/posts/hdu-1018-big-number/</link>
      <pubDate>Wed, 13 Mar 2013 21:12:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1018-big-number/</guid>
      <description>Big Number
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 18525 Accepted Submission(s): 8292
Problem Description In many applications very large integers numbers are required. Some of these applications are using keys for secure transmission of data, encryption, etc. In this problem you are given a number, you have to determine the number of digits in the factorial of the number.
Input Input consists of several lines of integer numbers.</description>
    </item>
    
    <item>
      <title>hdu 1028 Ignatius and the Princess III</title>
      <link>http://liuxueyang.github.io/posts/hdu-1028-ignatius-and-the-princess-iii/</link>
      <pubDate>Wed, 13 Mar 2013 21:09:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1028-ignatius-and-the-princess-iii/</guid>
      <description>Ignatius and the Princess III
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 8447 Accepted Submission(s): 6009
Problem Description &amp;ldquo;Well, it seems the first problem is too easy. I will let you know how foolish you are later.&amp;rdquo; feng5166 says.
&amp;ldquo;The second problem is, given an positive integer N, we define an equation like this: N=a[1]+a[2]+a[3]+&amp;hellip;+a[m]; a[i]&amp;gt;0,1&amp;lt;=m&amp;lt;=N; My question is how many different equations you can find for a given N.</description>
    </item>
    
    <item>
      <title>hdu 1019 Least Common Multiple</title>
      <link>http://liuxueyang.github.io/posts/hdu-1019-least-common-multiple/</link>
      <pubDate>Wed, 13 Mar 2013 09:18:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1019-least-common-multiple/</guid>
      <description>Least Common Multiple
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 21158 Accepted Submission(s): 7899
Problem Description The least common multiple (LCM) of a set of positive integers is the smallest positive integer which is divisible by all the numbers in the set. For example, the LCM of 5, 7 and 15 is 105.
Input Input will consist of multiple problem instances. The first line of the input will contain a single integer indicating the number of problem instances.</description>
    </item>
    
    <item>
      <title>hdu 1061 Rightmost Digit</title>
      <link>http://liuxueyang.github.io/posts/hdu-1061-rightmost-digit/</link>
      <pubDate>Wed, 13 Mar 2013 08:40:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1061-rightmost-digit/</guid>
      <description>Rightmost Digit
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 22887 Accepted Submission(s): 8739
Problem Description Given a positive integer N, you should output the most right digit of N^N.
Input The input contains several test cases. The first line of the input is a single integer T which is the number of test cases. T test cases follow. Each test case contains a single positive integer N(1&amp;lt;=N&amp;lt;=1,000,000,000).</description>
    </item>
    
    <item>
      <title>hdu 1212 Big Number</title>
      <link>http://liuxueyang.github.io/posts/hdu-1212-big-number/</link>
      <pubDate>Tue, 12 Mar 2013 22:01:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1212-big-number/</guid>
      <description>Big Number
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 3386 Accepted Submission(s): 2305
Problem Description As we know, Big Number is always troublesome. But it&amp;rsquo;s really important in our ACM. And today, your task is to write a program to calculate A mod B.
To make the problem easier, I promise that B will be smaller than 100000.
Is it too hard? No, I work it out in 10 minutes, and my program contains less than 25 lines.</description>
    </item>
    
    <item>
      <title>hdu 1164 Eddy&#39;s research I</title>
      <link>http://liuxueyang.github.io/posts/hdu-1164-eddys-research-i/</link>
      <pubDate>Tue, 12 Mar 2013 21:21:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1164-eddys-research-i/</guid>
      <description>Eddy&amp;rsquo;s research I
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 4452 Accepted Submission(s): 2680
Problem Description Eddy&amp;rsquo;s interest is very extensive, recently he is interested in prime number. Eddy discover the all number owned can be divided into the multiply of prime number, but he can&amp;rsquo;t write program, so Eddy has to ask intelligent you to help him, he asks you to write a program which can do the number to divided into the multiply of prime number factor .</description>
    </item>
    
    <item>
      <title>hdu 1097 A hard puzzle</title>
      <link>http://liuxueyang.github.io/posts/hdu-1097-a-hard-puzzle/</link>
      <pubDate>Tue, 12 Mar 2013 16:19:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1097-a-hard-puzzle/</guid>
      <description>A hard puzzle
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 21925 Accepted Submission(s): 7696
Problem Description lcy gives a hard puzzle to feng5166,lwg,JGShining and Ignatius: gave a and b,how to know the a^b.everybody objects to this BT problem,so lcy makes the problem easier than begin. this puzzle describes that: gave a and b,how to know the a^b&amp;rsquo;s the last digit number.But everybody is too lazy to slove this problem,so they remit to you who is wise.</description>
    </item>
    
    <item>
      <title>hdu 1108 最小公倍数</title>
      <link>http://liuxueyang.github.io/posts/hdu-1108-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</link>
      <pubDate>Tue, 12 Mar 2013 14:35:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1108-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</guid>
      <description>最小公倍数
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 24145 Accepted Submission(s): 13180
Problem Description 给定两个正整数，计算这两个数的最小公倍数。
Input 输入包含多组测试数据，每组只有一行，包括两个不大于1000的正整数.
Output 对于每个测试用例，给出这两个数的最小公倍数，每个实例输出一行。
Sample Input 10 14
Sample Output 70
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; int gcd(int a, int b){ return b == 0 ? a : gcd(b, a%b); } int main(void){ int a, b; #ifndef ONLINE_JUDGE freopen(&amp;quot;1108.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif while (~scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b)){ printf(&amp;quot;%d\n&amp;quot;, a * b / gcd(a, b)); } return 0; }  基础的数学题……</description>
    </item>
    
    <item>
      <title>hdu 1039 Easier Done Than Said?</title>
      <link>http://liuxueyang.github.io/posts/hdu-1039-easier-done-than-said/</link>
      <pubDate>Tue, 12 Mar 2013 14:32:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1039-easier-done-than-said/</guid>
      <description>Easier Done Than Said?
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 5021 Accepted Submission(s): 2535
Problem Description Password security is a tricky thing. Users prefer simple passwords that are easy to remember (like buddy), but such passwords are often insecure. Some sites use random computer-generated passwords (like xvtpzyo), but users have a hard time remembering them and sometimes leave them written on notes stuck to their computer.</description>
    </item>
    
    <item>
      <title>hdu 1113 Word Amalgamation</title>
      <link>http://liuxueyang.github.io/posts/hdu-1113-word-amalgamation/</link>
      <pubDate>Tue, 12 Mar 2013 14:29:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1113-word-amalgamation/</guid>
      <description>Word Amalgamation
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 1834 Accepted Submission(s): 854
Problem Description In millions of newspapers across the United States there is a word game called Jumble. The object of this game is to solve a riddle, but in order to find the letters that appear in the answer it is necessary to unscramble four words. Your task is to write a program that can unscramble words.</description>
    </item>
    
    <item>
      <title>hdu4484 Hailstone HOTPO ——水题</title>
      <link>http://liuxueyang.github.io/posts/hdu4484-hailstone-hotpo-%E6%B0%B4%E9%A2%98/</link>
      <pubDate>Sun, 10 Mar 2013 16:21:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu4484-hailstone-hotpo-%E6%B0%B4%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=4484 题目思路： 直接模拟即可
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int cal(int n) { int Max = n; while (n!=1) { if ((n&amp;amp;1) == 0) { n /= 2; } else { n = n * 3 + 1; } if (n &amp;gt; Max) Max = n; } return Max; } void solve() { int n; scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); int i, t, ca; for (i = 0; i &amp;lt; n; ++i) { scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;t, &amp;amp;ca); int ans = cal(ca); printf(&amp;quot;%d %d\n&amp;quot;, t, ans); } } int main(void) { //freopen(&amp;quot;4484.</description>
    </item>
    
    <item>
      <title>hdu 1698 Just a Hook</title>
      <link>http://liuxueyang.github.io/posts/hdu-1698-just-a-hook/</link>
      <pubDate>Mon, 04 Mar 2013 01:36:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1698-just-a-hook/</guid>
      <description>Just a Hook
Time Limit: 4000&amp;frasl;2000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 10792 Accepted Submission(s): 5328
Problem Description In the game of DotA, Pudge’s meat hook is actually the most horrible thing for most of the heroes. The hook is made up of several consecutive metallic sticks which are of the same length.
Now Pudge wants to do some operations on the hook.
Let us number the consecutive metallic sticks of the hook from 1 to N.</description>
    </item>
    
    <item>
      <title>hdu 2795 Billboard</title>
      <link>http://liuxueyang.github.io/posts/hdu-2795-billboard/</link>
      <pubDate>Sat, 02 Mar 2013 19:25:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-2795-billboard/</guid>
      <description>Billboard
Time Limit: 20000&amp;frasl;8000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 5912 Accepted Submission(s): 2682
Problem Description At the entrance to the university, there is a huge rectangular billboard of size h*w (h is its height and w is its width). The board is the place where all possible announcements are posted: nearest programming competitions, changes in the dining room menu, and other important information.
On September 1, the billboard was empty.</description>
    </item>
    
    <item>
      <title>hdu 1394 Minimum Inversion Number</title>
      <link>http://liuxueyang.github.io/posts/hdu-1394-minimum-inversion-number/</link>
      <pubDate>Sat, 02 Mar 2013 18:00:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1394-minimum-inversion-number/</guid>
      <description>Minimum Inversion Number
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 5892 Accepted Submission(s): 3587
Problem Description The inversion number of a given number sequence a1, a2, &amp;hellip;, an is the number of pairs (ai, aj) that satisfy i &amp;lt; j and ai &amp;gt; aj.
For a given sequence of numbers a1, a2, &amp;hellip;, an, if we move the first m &amp;gt;= 0 numbers to the end of the seqence, we will obtain another sequence.</description>
    </item>
    
    <item>
      <title>hdu 1046</title>
      <link>http://liuxueyang.github.io/posts/hdu-1046/</link>
      <pubDate>Tue, 22 Jan 2013 09:30:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1046/</guid>
      <description>Gridland
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 2455 Accepted Submission(s): 1168
Problem Description For years, computer scientists have been trying to find efficient solutions to different computing problems. For some of them efficient algorithms are already available, these are the “easy” problems like sorting, evaluating a polynomial or finding the shortest path in a graph. For the “hard” ones only exponential-time algorithms are known. The traveling-salesman problem belongs to this latter group.</description>
    </item>
    
    <item>
      <title>hdu 1048</title>
      <link>http://liuxueyang.github.io/posts/hdu-1048/</link>
      <pubDate>Tue, 22 Jan 2013 09:29:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1048/</guid>
      <description>The Hardest Problem Ever
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 11459 Accepted Submission(s): 5165
Problem Description Julius Caesar lived in a time of danger and intrigue. The hardest situation Caesar ever faced was keeping himself alive. In order for him to survive, he decided to create one of the first ciphers. This cipher was so incredibly sound, that no one could figure it out without knowing how it worked.</description>
    </item>
    
    <item>
      <title>hdu 1049</title>
      <link>http://liuxueyang.github.io/posts/hdu-1049/</link>
      <pubDate>Tue, 22 Jan 2013 09:28:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1049/</guid>
      <description>Climbing Worm
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 8745 Accepted Submission(s): 5659
Problem Description An inch worm is at the bottom of a well n inches deep. It has enough energy to climb u inches every minute, but then has to rest a minute before climbing again. During the rest, it slips down d inches. The process of climbing and resting then repeats. How long before the worm climbs out of the well?</description>
    </item>
    
    <item>
      <title>hdu 1064</title>
      <link>http://liuxueyang.github.io/posts/hdu-1064/</link>
      <pubDate>Tue, 22 Jan 2013 09:27:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1064/</guid>
      <description>Financial Management
Time Limit: 400&amp;frasl;200 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 6666 Accepted Submission(s): 4157
Problem Description Larry graduated this year and finally has a job. He’s making a lot of money, but somehow never seems to have enough. Larry has decided that he needs to grab hold of his financial portfolio and solve his financing problems. The first step is to figure out what’s been going on with his money.</description>
    </item>
    
    <item>
      <title>hdu 1144</title>
      <link>http://liuxueyang.github.io/posts/hdu-1144/</link>
      <pubDate>Tue, 22 Jan 2013 09:26:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1144/</guid>
      <description>Prerequisites?
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 634 Accepted Submission(s): 401
Problem Description Freddie the frosh has chosen to take k courses. To meet the degree requirements, he must take courses from each of several categories. Can you assure Freddie that he will graduate, based on his course selection?
Input Input consists of several test cases. For each case, the first line of input contains 1 ≤ k ≤ 100, the number of courses Freddie has chosen, and 0 ≤ m ≤ 100, the number of categories.</description>
    </item>
    
    <item>
      <title>hdu 1076</title>
      <link>http://liuxueyang.github.io/posts/hdu-1076/</link>
      <pubDate>Tue, 22 Jan 2013 09:24:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1076/</guid>
      <description>An Easy Task
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 10133 Accepted Submission(s): 6291
Problem Description Ignatius was born in a leap year, so he want to know when he could hold his birthday party. Can you tell him?
Given a positive integers Y which indicate the start year, and a positive integer N, your task is to tell the Nth leap year from year Y.</description>
    </item>
    
    <item>
      <title>hdu 1196</title>
      <link>http://liuxueyang.github.io/posts/hdu-1196/</link>
      <pubDate>Tue, 22 Jan 2013 09:23:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1196/</guid>
      <description>Lowest Bit
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 5440 Accepted Submission(s): 3963
Problem Description Given an positive integer A (1 &amp;lt;= A &amp;lt;= 100), output the lowest bit of A.
For example, given A = 26, we can write A in binary form as 11010, so the lowest bit of A is 10, so the output should be 2.
Another example goes like this: given A = 88, we can write A in binary form as 1011000, so the lowest bit of A is 1000, so the output should be 8.</description>
    </item>
    
    <item>
      <title>hdu 1201</title>
      <link>http://liuxueyang.github.io/posts/hdu-1201/</link>
      <pubDate>Tue, 22 Jan 2013 09:22:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1201/</guid>
      <description>18岁生日
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 12363 Accepted Submission(s): 3885
Problem Description Gardon的18岁生日就要到了，他当然很开心，可是他突然想到一个问题，是不是每个人从出生开始，到达18岁生日时所经过的天数都是一样的呢？似乎并不全都是这样，所以他想请你帮忙计算一下他和他的几个朋友从出生到达18岁生日所经过的总天数，让他好来比较一下。
Input 一个数T，后面T行每行有一个日期，格式是YYYY-MM-DD。如我的生日是1988-03-07。
Output T行，每行一个数，表示此人从出生到18岁生日所经过的天数。如果这个人没有18岁生日，就输出-1。
Sample Input 1 1988-03-07
Sample Output 6574
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; bool leap(int n) { if (n%400==0 || (n%4==0 &amp;amp;&amp;amp; n%100!=0)) return true; else return false; } int main(void) { int t, y, m, d; #ifndef ONLINE_JUDGE freopen(&amp;quot;18.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); #endif scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); while (t--) { scanf(&amp;quot;%d-%d-%d&amp;quot;, &amp;amp;y, &amp;amp;m, &amp;amp;d); if (leap(y)&amp;amp;&amp;amp;(m==2)&amp;amp;&amp;amp;(d==29)) { printf(&amp;quot;-1\n&amp;quot;); continue; } int sum = 0; for (int i = 1; i &amp;lt;= 17; ++i) if (leap(i+y)) sum += 366; else sum += 365; sum += 365; if (leap(y) &amp;amp;&amp;amp; (m&amp;lt;2 || (m==2&amp;amp;&amp;amp;d&amp;lt;=29))) sum++; if (leap(y+18) &amp;amp;&amp;amp; (m&amp;gt;2 || (m==2&amp;amp;&amp;amp;d==29))) sum++; printf(&amp;quot;%d\n&amp;quot;, sum); } return 0; }  看的人家的代码才搞定……简洁，准确，代码要多练，才能精简</description>
    </item>
    
    <item>
      <title>hdu 1062 Text Reverse</title>
      <link>http://liuxueyang.github.io/posts/hdu-1062-text-reverse/</link>
      <pubDate>Fri, 18 Jan 2013 02:12:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1062-text-reverse/</guid>
      <description>Text Reverse
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 10835 Accepted Submission(s): 4104
Problem Description Ignatius likes to write words in reverse way. Given a single line of text which is written by Ignatius, you should reverse all the words and then output them.
Input The input contains several test cases. The first line of the input is a single integer T which is the number of test cases.</description>
    </item>
    
    <item>
      <title>hdu 1999 不可摸数</title>
      <link>http://liuxueyang.github.io/posts/hdu-1999-%E4%B8%8D%E5%8F%AF%E6%91%B8%E6%95%B0/</link>
      <pubDate>Fri, 11 Jan 2013 11:15:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1999-%E4%B8%8D%E5%8F%AF%E6%91%B8%E6%95%B0/</guid>
      <description>Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others)Total Submission(s): 5821 Accepted Submission(s): 1524 数学题，输入n，判断n是不是不可摸数。 设t = n - 1。 如果t是素数的话，那么要使得S(m) = n，只要m = t * t即可，此时m的真因子有：1, t。则S(m) = t + 1 = n，也就是说n可摸 如果t不是素数，但是t可以表示成两个素数的和的话，设 i 是素数，并且t = i + (t-i)，其中 t-i 也是素数。那么要使得S(m) = n，只要m = i * (t - i) 即可，此时，m 的真因子有：1, i , t - i 。则S(m) = 1 + i + t - i = t + 1 = n，也就是说 n 可摸 （这里注意：t - i !</description>
    </item>
    
    <item>
      <title>hdu 1161 Eddy&#39;s mistakes</title>
      <link>http://liuxueyang.github.io/posts/hdu-1161-eddys-mistakes/</link>
      <pubDate>Fri, 23 Nov 2012 18:51:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1161-eddys-mistakes/</guid>
      <description>Eddy&amp;rsquo;s mistakes
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 5189 Accepted Submission(s): 2956
Problem Description Eddy usually writes articles ,but he likes mixing the English letter uses, for example &amp;ldquo;computer science&amp;rdquo; is written frequently &amp;ldquo;coMpUtEr scIeNce&amp;rdquo; by him, this mistakes lets Eddy&amp;rsquo;s English teacher be extremely discontentment.Now please you to write a procedure to be able in the Bob article English letter to turn completely the small letter.</description>
    </item>
    
    <item>
      <title>hdu 1166 敌兵布阵</title>
      <link>http://liuxueyang.github.io/posts/hdu-1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5/</link>
      <pubDate>Fri, 23 Nov 2012 18:46:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu-1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5/</guid>
      <description>敌兵布阵
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 22041 Accepted Submission(s): 9654
Problem Description C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。 中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:&amp;ldquo;你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：&amp;rdquo;我知错了。。。&amp;rdquo;但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的.
Input 第一行一个整数T，表示有T组数据。 每组数据第一行一个正整数N（N&amp;lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&amp;lt;=ai&amp;lt;=50）。 接下来每行有一条命令，命令有4种形式： (1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30） (2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）; (3)Query i j ,i和j为正整数,i&amp;lt;=j，表示询问第i到第j个营地的总人数; (4)End 表示结束，这条命令在每组数据最后出现; 每组数据最多有40000条命令
Output 对第i组数据,首先输出“Case i:”和回车, 对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。
Sample Input 1 10 1 2 3 4 5 6 7 8 9 10 Query 1 3 Add 3 6 Query 2 7 Sub 10 2 Add 6 3 Query 3 10 End</description>
    </item>
    
    <item>
      <title>hdu1754 I Hate It ——线段数入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu1754-i-hate-it-%E7%BA%BF%E6%AE%B5%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Fri, 23 Nov 2012 18:42:00 +0000</pubDate>
      <author>your@email.com (Aos Dabbagh)</author>
      <guid>http://liuxueyang.github.io/posts/hdu1754-i-hate-it-%E7%BA%BF%E6%AE%B5%E6%95%B0%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1754
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #define maxn 200000&amp;lt;&amp;lt;2 //#define max(a,b) ((a)&amp;gt;(b)?(a):(b)) #define lson l,m,rt&amp;lt;&amp;lt;1 #define rson m+1,r,rt&amp;lt;&amp;lt;1|1 int Max[maxn]; using namespace std; void pushup(int rt) { Max[rt] = max(Max[rt&amp;lt;&amp;lt;1],Max[rt&amp;lt;&amp;lt;1|1]); } void build(int l, int r, int rt) { if(l==r) {scanf(&amp;quot;%d&amp;quot;, &amp;amp;Max[rt]); return;} int m=l+((r-l)&amp;gt;&amp;gt;1); build(lson);build(rson); pushup(rt); } void update(int p, int ck, int l, int r, int rt) { if (l==r) {Max[rt] = ck; return;} int m=l+((r-l)&amp;gt;&amp;gt;1); if (p &amp;lt;= m) update(p, ck, lson); else update(p, ck, rson); pushup(rt); } int query(int L, int R, int l, int r, int rt) { if (L &amp;lt;= l &amp;amp;&amp;amp; R &amp;gt;= r) {return Max[rt];} int m=l+((r-l)&amp;gt;&amp;gt;1); int ret = 0; if (L&amp;lt;=m) ret = max(query(L,R,lson),ret); if (R&amp;gt;m) ret = max(query(L,R,rson),ret); return ret; } int main(void) { int N, M; #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
  </channel>
</rss>