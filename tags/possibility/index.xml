<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Possibility on LXY Site</title>
    <link>http://liuxueyang.github.io/tags/possibility/</link>
    <description>Recent content in Possibility on LXY Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 06 Aug 2013 11:06:00 +0000</lastBuildDate>
    
	<atom:link href="http://liuxueyang.github.io/tags/possibility/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>hdu2955 Robberies 　０１背包＋概率</title>
      <link>http://liuxueyang.github.io/posts/hdu2955-robberies-%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85%E6%A6%82%E7%8E%87/</link>
      <pubDate>Tue, 06 Aug 2013 11:06:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu2955-robberies-%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85%E6%A6%82%E7%8E%87/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=2955 首先，这个题目的背包容量不能是概率．１．精度不清楚．２．把概率相加有什么意义呢？所以，转换一下，把所有银行的珠宝和当作背包容量，把小偷安全的概率当作物品价值．可以先求出背包尽可能满的情况下，安全概率最大的解．然后在这些解里面，找出安全概率满足大于１－Ｐ的并且价值最大的就行． 题目读清楚．人给的是被抓住的概率和每个银行被抓住的概率．这个是不能直接用的．比如连续偷几个银行，就要分别算出安全的概率，这样概率就可以直接相乘了． 只要要偷的几个银行的安全概率的积大于１－P就行．
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int V, n, c[11111]; double w[11111], f[11111]; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>zoj3696  Alien&#39;s Organ ——概率题</title>
      <link>http://liuxueyang.github.io/posts/zoj3696--aliens-organ-%E6%A6%82%E7%8E%87%E9%A2%98/</link>
      <pubDate>Tue, 07 May 2013 23:27:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj3696--aliens-organ-%E6%A6%82%E7%8E%87%E9%A2%98/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3696 题目大意： 就是一个东西，随机产生器官，一天产生的数量的期望是x,求一天内产生个数小于等于N的概率 题目思路： 泊松分布。概率论得好好学。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;math.h&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; double la; double cal(double k) { double l = 1; for (int i = 1; i &amp;lt;= k; ++i) { l = l * i; } double re = pow(la, k) / l * exp(-la); return re; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;a.</description>
    </item>
    
  </channel>
</rss>