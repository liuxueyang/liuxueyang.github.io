<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dp on LXY Site</title>
    <link>http://liuxueyang.github.io/tags/dp/</link>
    <description>Recent content in Dp on LXY Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright &amp;copy; 2018 (LXY). All Rights Reserved.</copyright>
    <lastBuildDate>Sat, 22 Mar 2014 23:44:49 +0000</lastBuildDate>
    
	<atom:link href="http://liuxueyang.github.io/tags/dp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Longest Increasing Subsequence</title>
      <link>http://liuxueyang.github.io/posts/longest-increasing-subsequence/</link>
      <pubDate>Sat, 22 Mar 2014 23:44:49 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/longest-increasing-subsequence/</guid>
      <description>很久不写算法了== 写个东西练练手
最长上升子序列
输入n，然后是数组a[ ]的n个元素
输出最长上升子序列的长度
一、最简单的方法复杂度O(n * n)
DP[ i ] 是以a[ i ] 为结尾的最长上升子序列的长度。 DP[ i ] = max{DP[ j ] + 1 | j &amp;lt; i &amp;amp;&amp;amp; a[ j ] &amp;lt; a[ i ]}  代码：</description>
    </item>
    
    <item>
      <title>Candy Store</title>
      <link>http://liuxueyang.github.io/posts/candy-store/</link>
      <pubDate>Wed, 18 Sep 2013 00:55:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/candy-store/</guid>
      <description>Candy Store Time Limit: 30000ms, Special Time Limit:75000ms, Memory Limit:65536KB Total submit users: 6, Accepted users: 6 Problem 12624 : No special judgement Problem description You are walking with a friend, when you pass a candy store.</description>
    </item>
    
    <item>
      <title>ural 1057Amount of Degrees ——数位DP</title>
      <link>http://liuxueyang.github.io/posts/ural-1057amount-of-degrees-%E6%95%B0%E4%BD%8Ddp/</link>
      <pubDate>Tue, 20 Aug 2013 09:26:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/ural-1057amount-of-degrees-%E6%95%B0%E4%BD%8Ddp/</guid>
      <description>link:http://acm.timus.ru/problem.aspx?space=1&amp;amp;num=1057
论文： 浅谈数位类统计问题 刘聪
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int a[33][33]; int bto2(int x, int b) { int tm[33], cnt = 0, ans = 0; while (x) { tm[cnt++] = x % b; x /= b; } for (int i = cnt - 1; i &amp;gt;= 0; --i) { if (tm[i] &amp;amp;&amp;amp; (tm[i] !</description>
    </item>
    
    <item>
      <title>codeforces mysterious present 最长上升子序列&#43;倒序打印路径</title>
      <link>http://liuxueyang.github.io/posts/codeforces-mysterious-present-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-%E5%80%92%E5%BA%8F%E6%89%93%E5%8D%B0%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Mon, 19 Aug 2013 15:22:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-mysterious-present-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-%E5%80%92%E5%BA%8F%E6%89%93%E5%8D%B0%E8%B7%AF%E5%BE%84/</guid>
      <description>link:http://codeforces.com/problemset/problem/4/D
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int n,w,h,cnt,ans,d[5009],path[5009],End; bool flag; typedef struct node { int W,H,In; bool operator &amp;lt; (const node &amp;amp;other) const { if(W!</description>
    </item>
    
    <item>
      <title>zoj3551 Bloodsucker ——概率DP</title>
      <link>http://liuxueyang.github.io/posts/zoj3551-bloodsucker-%E6%A6%82%E7%8E%87dp/</link>
      <pubDate>Sun, 18 Aug 2013 10:19:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj3551-bloodsucker-%E6%A6%82%E7%8E%87dp/</guid>
      <description>Link: http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=4530
A[i]数组表示当吸血鬼有 I 个的时候，还需要的天数。可以列出方程：
A[i] = p1(a[i+1]+1) + (1-p1)(a[i]+1) p1=(i*(n-i))p / (n(n-1)/2)</description>
    </item>
    
    <item>
      <title>poj1458 Common Subsequence ——最长公共子序列</title>
      <link>http://liuxueyang.github.io/posts/poj1458-common-subsequence-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sat, 17 Aug 2013 10:38:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1458-common-subsequence-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>link:http://poj.org/problem?id=1458 最基础的那种
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int sad[1111][1111];char apple[1111],pear[1111]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>poj3181 Dollar Dayz ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/poj3181-dollar-dayz-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 18:14:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj3181-dollar-dayz-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://poj.org/problem?id=3181 本来很常规的一道完全背包，比较有意思的一点是，结果会超int，更有意思的解决方法是，不用高精度，用两个整型的拼接起来就行了。ORZ
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; typedef unsigned long long ULL; ULL dp[1111], dp1[1111]; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>uva147 Dollars      ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/uva147-dollars------%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 18:03:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva147-dollars------%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=83 和完全背包一样的思想。 有两个trick： 没了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; long long d[33333]; int a[11]={5,10,20,50,100,200,500,1000,2000,5000,10000}; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>uva674 Coin Change ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/uva674-coin-change-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:59:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva674-coin-change-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=615 和完全背包一样的思想。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int a[5]={1,5,10,25,50}; int f[7777]; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu2191 悼念512汶川大地震     ——多重背包</title>
      <link>http://liuxueyang.github.io/posts/hdu2191-%E6%82%BC%E5%BF%B5512%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%87-----%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:54:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu2191-%E6%82%BC%E5%BF%B5512%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%87-----%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=2191 最简单的那种
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int n, V, t, f[111], c[111], w[111], m[111]; void zeropack(int c, int w) { for (int v=V; v&amp;gt;=c; --v) { f[v]=max(f[v],f[v-c]+w); } return; } void completepack(int c, int w) { for (int v=c;v&amp;lt;=V;++v) f[v]=max(f[v],f[v-c]+w); return; } void multipack(int c, int w, int m) { if (c*m &amp;gt;= V) { completepack(c,w); return; } int k=1; while (k&amp;lt;m) { zeropack(c*k,w*k); m-=k; k*=2; } zeropack(c*m,w*m); return; } int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu1059 Dividing ——多重背包</title>
      <link>http://liuxueyang.github.io/posts/hdu1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=1059 最简单的那种
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int V,m[6],c[6],w[6],f[66666]; void zeropack(int c, int w) { for (int v=V;v&amp;gt;=c;--v) f[v]=max(f[v],f[v-c]+w); return; } void completepack(int c,int w) { for(int v=c;v&amp;lt;=V;++v) f[v]=max(f[v],f[v-c]+w); return; } void multipack(int c,int w,int m) { if(c*m&amp;gt;=V) { completepack(c,w); return; } int k=1; while (k&amp;lt;m) { zeropack(k*c,k*w); m-=k; k*=2; } zeropack(c*m,w*m); return; } int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu1114 Piggy-Bank ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/hdu1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:47:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=1114 只不过求得是最小值。没什么可说的，连我都会做……o(╯□╰)o
/* ID: zypz4571 LANG: C++ TASK: pig.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int f[11111],c[555],w[555], V, n; void completepack(int c,int w) { for(int v=c;v&amp;lt;=V;++v) f[v]=min(f[v],f[v-c]+w); } int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>zoj3623 Battle Ships ——完全背包？简单DP！|| 泛化背包</title>
      <link>http://liuxueyang.github.io/posts/zoj3623-battle-ships-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%AE%80%E5%8D%95dp-%E6%B3%9B%E5%8C%96%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:43:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj3623-battle-ships-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%AE%80%E5%8D%95dp-%E6%B3%9B%E5%8C%96%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3623 看起来像完全背包，但是物品价值是变化的，所以很多人搞的很复杂。 晚上的代码要么很复杂，有一个代码虽然很简洁在zoj可以过，但是是错误的。求教lyl神犇，果然思想很深刻，抓住乐问题的本质，想法比网上搜到的所有博客里面的做法都简洁。 事实上，就是简单的DP，抓住一个技巧：让时间倒流，也就是说，把时间反过来考虑，先在将来把船造好，然后在过去用船攻击，哈哈，太巧秒了，说起来很别扭，很有意思，dp[j+time[i]]=max(dp[j]+j*time[i])；dp[j]表示在j这个时间，所造成的最大伤害。这样就可以枚举时间，在每个特定的时间内，枚举船的种类，找到最大值。最终在dp[]数组里面找到符合条件的并且时间最少的解。 只能说，ORZ…… 后来好不容易想明白了。茶具从哪里来……
/* ID: zypz4571 LANG: C++ TASK: battle.</description>
    </item>
    
    <item>
      <title>poj3249 Test for Job  ——拓扑&#43;DP</title>
      <link>http://liuxueyang.github.io/posts/poj3249-test-for-job--%E6%8B%93%E6%89%91&#43;dp/</link>
      <pubDate>Thu, 15 Aug 2013 17:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj3249-test-for-job--%E6%8B%93%E6%89%91&#43;dp/</guid>
      <description>link:http://poj.org/problem?id=3249 在拓扑排序的过程中进行状态转移，dp[i]表示从起点到 i 这个点所得到的的最大值。比如从u点到v点，dp[v]=max(dp[v], dp[u]+a[v]) a[]数组是点的价值，最终的dp[]数组里面的最大值就是所求的。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; #define N 111111 using namespace std; int WO[N],NI[N],dp[N],TA[N]; vector&amp;lt;int&amp;gt; V[N]; queue&amp;lt;int&amp;gt; QU; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu3033 I love sneakers!        分组背包变形</title>
      <link>http://liuxueyang.github.io/posts/hdu3033-i-love-sneakers--------%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E5%8F%98%E5%BD%A2/</link>
      <pubDate>Sun, 11 Aug 2013 18:24:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu3033-i-love-sneakers--------%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E5%8F%98%E5%BD%A2/</guid>
      <description>分组背包要求每一组里面只能选一个，这个题目要求每一组里面至少选一个物品。 dp[i, j] 表示前 i 组里面在每组至少放进一个物品的情况下，当花费 j 的时候，所得到的的最大价值。这个状态可以由三个状态转移过来： a[i, j].b表示第 i 组第 j 个物品的花费，v表示背包容量。 初始化： 如果一种物品都不放，那么对应的所有的背包容量都是0，也就是：dp[0, 0~M] = 0； 其他的情况，都初始化成-INF。</description>
    </item>
    
    <item>
      <title>hdu1712 ACboy needs your help    分组背包</title>
      <link>http://liuxueyang.github.io/posts/hdu1712-acboy-needs-your-help----%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</link>
      <pubDate>Sun, 11 Aug 2013 16:20:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1712-acboy-needs-your-help----%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</guid>
      <description>最基础的分组背包~
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int dp[102], a[102][102]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu2955 Robberies 　０１背包＋概率</title>
      <link>http://liuxueyang.github.io/posts/hdu2955-robberies-%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85%E6%A6%82%E7%8E%87/</link>
      <pubDate>Tue, 06 Aug 2013 11:06:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu2955-robberies-%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85%E6%A6%82%E7%8E%87/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=2955 首先，这个题目的背包容量不能是概率．１．精度不清楚．２．把概率相加有什么意义呢？所以，转换一下，把所有银行的珠宝和当作背包容量，把小偷安全的概率当作物品价值．可以先求出背包尽可能满的情况下，安全概率最大的解．然后在这些解里面，找出安全概率满足大于１－Ｐ的并且价值最大的就行． 题目读清楚．人给的是被抓住的概率和每个银行被抓住的概率．这个是不能直接用的．比如连续偷几个银行，就要分别算出安全的概率，这样概率就可以直接相乘了． 只要要偷的几个银行的安全概率的积大于１－P就行．
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int V, n, c[11111]; double w[11111], f[11111]; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>uva562 Dividing coins   01背包</title>
      <link>http://liuxueyang.github.io/posts/uva562-dividing-coins---01%E8%83%8C%E5%8C%85/</link>
      <pubDate>Tue, 06 Aug 2013 10:45:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva562-dividing-coins---01%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=503 分成２半，并且两半的差距最小，背包的体积变成V/2
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int V, c[111], w[111], f[55555], n; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>uva624 CD　　　０１背包&#43;输出最优解</title>
      <link>http://liuxueyang.github.io/posts/uva624-cd%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85&#43;%E8%BE%93%E5%87%BA%E6%9C%80%E4%BC%98%E8%A7%A3/</link>
      <pubDate>Tue, 06 Aug 2013 10:41:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uva624-cd%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85&#43;%E8%BE%93%E5%87%BA%E6%9C%80%E4%BC%98%E8%A7%A3/</guid>
      <description>link:http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=565 用一个二维数组g[i][v]表示：当状态转移到v的时候，第i个物品是不是用到，如果用到标记１，否则标记０． 输出路径的时候，注意，从物品编号０一直到n-1.如果某个物品被用到了，g[i][v]里面的v，就要减去这个物品的体积，然后继续往下找．
/* * ===================================================================================== * Filename: cd.cpp * Created: 04/08/2013 15:21:34 * Author: liuxueyang (lxy), 1459917536@qq.</description>
    </item>
    
    <item>
      <title>hdu2546　饭卡　　　　０１背包</title>
      <link>http://liuxueyang.github.io/posts/hdu2546%E9%A5%AD%E5%8D%A1%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85/</link>
      <pubDate>Tue, 06 Aug 2013 10:31:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu2546%E9%A5%AD%E5%8D%A1%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=2546 也算一个贪心的想法吧． 先把总钱数减去５，再把价值最大的挑出来．然后用０１背包．最终买下挑出来的那个价值最大的商品．这样的话，我就实现了最终用最少的钱数买了价值最多的商品，剩下钱数当然也是最少了．
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int main(void) { ios::sync_with_stdio(false); int n, V; int c[1111], f[1111]; #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu4632 Palindrome subsequence     ——区间动态规划</title>
      <link>http://liuxueyang.github.io/posts/hdu4632-palindrome-subsequence-----%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Sat, 03 Aug 2013 16:19:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu4632-palindrome-subsequence-----%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4632 refer to: o(╯□╰)o……明明百度找的题解，然后后来就找不到我看的那份了，这位哥们对不住了……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; char a[1111]; int dp[1111][1111]; const int MOD = 10007; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>Codeforces Flipping game 动态规划基础</title>
      <link>http://liuxueyang.github.io/posts/codeforces-flipping-game-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 19 Jul 2013 01:05:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/codeforces-flipping-game-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/</guid>
      <description>题目链接：http://codeforces.com/problemset/problem/327/A 这道题目有O(N^3)的做法，这里转化为动态规划求解，复杂度是O(N)
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; using namespace std; #define INF 0x3f3f3f3f int a[102], b[102], c[102]; int main ( void ) { int n, n1=0, cnt=0; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { n1 = cnt = 0; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); for (int i=1; i&amp;lt;=n; ++i){ scanf(&amp;quot;%d&amp;quot;,a+i); if(a[i]) n1++; if (a[i]) b[i]=-1; else b[i]=1; } c[0] = 0; for (int i = 1; i &amp;lt;= n; ++i) { c[i] = c[i-1] + b[i]; } int Max = -INF, Min = c[0]; for (int i = 1; i &amp;lt;= n; ++i) { if (c[i] - Min &amp;gt; Max) Max = c[i]-Min; if (c[i] &amp;lt; Min) Min = c[i]; } printf(&amp;quot;%d\n&amp;quot;,n1+Max); } return 0; }  转化为子序列的最大连续和</description>
    </item>
    
    <item>
      <title>tyvj1023 - 奶牛的锻炼 ——DP</title>
      <link>http://liuxueyang.github.io/posts/tyvj1023---%E5%A5%B6%E7%89%9B%E7%9A%84%E9%94%BB%E7%82%BC-dp/</link>
      <pubDate>Mon, 08 Jul 2013 23:31:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/tyvj1023---%E5%A5%B6%E7%89%9B%E7%9A%84%E9%94%BB%E7%82%BC-dp/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1023
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; int a[2002],f[2002][502]; int main(void) { //freopen(&amp;quot;in1.</description>
    </item>
    
    <item>
      <title>tyvj1015 - 公路乘车  ——完全背包</title>
      <link>http://liuxueyang.github.io/posts/tyvj1015---%E5%85%AC%E8%B7%AF%E4%B9%98%E8%BD%A6--%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Sun, 07 Jul 2013 21:14:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/tyvj1015---%E5%85%AC%E8%B7%AF%E4%B9%98%E8%BD%A6--%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1015 完全背包
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int c[11],f[101]; int main(void) { freopen(&amp;quot;in1.</description>
    </item>
    
    <item>
      <title>tyvj1014 - 乘法游戏  ——记忆化搜索DP</title>
      <link>http://liuxueyang.github.io/posts/tyvj1014---%E4%B9%98%E6%B3%95%E6%B8%B8%E6%88%8F--%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2dp/</link>
      <pubDate>Sun, 07 Jul 2013 17:28:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/tyvj1014---%E4%B9%98%E6%B3%95%E6%B8%B8%E6%88%8F--%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2dp/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1014 f[i][j]表示区间［i，j］所得到的最小值。 不断地划分区间，把结果保存起来。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; long long int f[101][101];int a[101], i, j, n, INF=0x7f7f7f7f; void dfs(int l, int r) { if(r-l&amp;lt;=1) {f[l][r]=0; return;} if(f[l][r]!</description>
    </item>
    
    <item>
      <title>tyvj1013 - 找啊找啊找GF  ——二维背包变种</title>
      <link>http://liuxueyang.github.io/posts/tyvj1013---%E6%89%BE%E5%95%8A%E6%89%BE%E5%95%8A%E6%89%BEgf--%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85%E5%8F%98%E7%A7%8D/</link>
      <pubDate>Sun, 07 Jul 2013 16:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/tyvj1013---%E6%89%BE%E5%95%8A%E6%89%BE%E5%95%8A%E6%89%BEgf--%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85%E5%8F%98%E7%A7%8D/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1013 好吧，这题没节操=_= 状态f[u,v,i]表示：消费u的人民币和v的人品同时泡到i个mm所需要的最少时间。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; int f[101][101][101], r[101], rp[101], t[101], rmb, RP, n, INF=0x7f7f7f7f; int main(void) { freopen(&amp;quot;in1.</description>
    </item>
    
    <item>
      <title>tyvj1011 - 传纸条  ——DP</title>
      <link>http://liuxueyang.github.io/posts/tyvj1011---%E4%BC%A0%E7%BA%B8%E6%9D%A1--dp/</link>
      <pubDate>Sun, 07 Jul 2013 11:32:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/tyvj1011---%E4%BC%A0%E7%BA%B8%E6%9D%A1--dp/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1011 状态转移方程： f[k,x1,x2] = max(f[k-1,x1,x2],f[k-1,x1-1,x2],f[k-1,x1-1,x2-1],f[k-1,x1,x2-1]) + a[y1,x1] + a[y2,x2]; f[k,x1,x2]表示，第K步的时候，一条路的横坐标是x1,另一条路的横坐标是x2的时候所得到的最优解。另外，还要考虑一下，当x1==x2的时候的情况，这个时候，只能允许一条路走到那个位置。</description>
    </item>
    
    <item>
      <title>hdu1176 免费馅饼 ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu1176-%E5%85%8D%E8%B4%B9%E9%A6%85%E9%A5%BC-dp/</link>
      <pubDate>Sat, 25 May 2013 17:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1176-%E5%85%8D%E8%B4%B9%E9%A6%85%E9%A5%BC-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1176 题目大意： 中文题…… 题目思路： 类似于 Triangle 。d[i][j] 表示 i 时间在 j 位置的所得到的价值。然后就像 Triangle 一样从下往上递推。最终求在0秒的时候，在5位置上的值。 ＷＡ了两次，当初求的是0秒的时候，所有位置上的最大值，，这显然是不对的。因为起始位置是5啊。</description>
    </item>
    
    <item>
      <title>hdu2069 Coin Change ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu2069-coin-change-dp/</link>
      <pubDate>Fri, 24 May 2013 11:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu2069-coin-change-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2069 题目大意： 给一个数字，用1, 5, 10， 25, 50 这五种硬币，最多用100枚，有多少种组合方式。 题目思路： 这道题和之前的题目不同，有了硬币个数的限制，所以需要加上一维表示硬币的个数就可以了。d[i][j]表示价值为 i 的最多用 j 枚硬币有多少中组合方式。很多人用母函数做，感觉DP做简单多了…… 参考博客：http://www.</description>
    </item>
    
    <item>
      <title>hdu1398 Square Coins ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu1398-square-coins-dp/</link>
      <pubDate>Thu, 23 May 2013 23:20:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1398-square-coins-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1398 题目大意： 给一个数字，不大于300，求有多少种用完全平方数表示这个数字的方法 题目思路： 方法跟hdu1283一样一样的……只需要把那道题目的代码稍微改一下就可以过了 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n) &amp;amp;&amp;amp; n) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &amp;lt;= floor(sqrt(n)); ++i) { for (j = i*i; j &amp;lt;= n; ++j) { d[j] += d[j-i*i]; } } printf(&amp;quot;%lld\n&amp;quot;, d[n]); } } int main(void) { solve(); return 0; }   因为题目的范围很小嘛，只有300。 </description>
    </item>
    
    <item>
      <title>hdu1284 钱币兑换问题 ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu1284-%E9%92%B1%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-dp/</link>
      <pubDate>Thu, 23 May 2013 20:39:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1284-%E9%92%B1%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1284 题目大意： 中文题…… 题目思路： 只有3个硬币，范围是32768，可以一个一个枚举硬币，如果只放价值为1的硬币，从d[1]递推到d[n]；如果再加上价值为2的硬币，那么就从d[2]递推到d[n]；在加上价值为3的硬币，就从d[3]递推到d[n].递推公式是d[j] = d[j] + d[j-i]； d[j]表示j有几种只用1，2, 3这三个数字的拆分方法，i 就是硬币的价值。 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &amp;lt;= 3; ++i) { for (j = i; j &amp;lt;= n; ++j) { d[j] += d[j-i]; } } printf(&amp;quot;%lld\n&amp;quot;, d[n]); } } int main(void) { solve(); return 0; }   参考博客：http://www.</description>
    </item>
    
    <item>
      <title>hdu1028 Ignatius and the Princess III ——DP</title>
      <link>http://liuxueyang.github.io/posts/hdu1028-ignatius-and-the-princess-iii-dp/</link>
      <pubDate>Thu, 23 May 2013 19:48:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu1028-ignatius-and-the-princess-iii-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1028 题目大意：　整数拆分，给一个整数n,求它有多少种拆分方法。 题目思路： 做法一： d[i][j]表示把整数 i 拆成最多 j 个数字所具有的方法数。那么 if (i &amp;gt;ｊ)　d[i][j] = d[i-j][j] + d[i][j-1]; 意思就是如果i&amp;gt;j，那么有两种方式：一种是先把i里面分理处j个1，然后再把i-j拆成最多i-j个数字；另一种是把i拆分成最多j-1个数字。 if (i &amp;lt; j) d[i][j] = d[i][i]; 意思就是如果i&amp;lt;j，那么这种情况和把数字i最多拆成i个数字的是一样的。 if (i == j) d[i][j] = d[i][j-1] + 1; 意思就是如果i==j，那么可以把数字i拆分成j-1个数字，也可以把数字i拆分成i个1（这个就是那个1的意义） #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; #define LL long long int d[140][140], n; void init() { while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { int i, j; memset(d, 0, sizeof(d)); for (i = 0; i &amp;lt;= n; ++i) d[i][1] = d[1][i] = 1; for (i = 2; i &amp;lt;= n; ++i) { for (j = 1; j &amp;lt;= n; ++j) { if (i &amp;gt; j) d[i][j] = d[i-j][j] + d[i][j-1]; else if (i == j) d[i][j] = 1 + d[i][j-1]; else d[i][j] = d[i][i]; } } cout &amp;lt;&amp;lt; d[n][n] &amp;lt;&amp;lt; endl; } } int main(void) { init(); return 0 ; }   剩下的就是考虑一下边界，比如当 i 或者 j 等于1的时候，显然都是只有一种拆分情况。 做法二： 借用hdu1284这道题的方法，也可以做这道题目，因为n的范围是120嘛,两个算法的复杂度都是O(n^2)的，当然可以了。只需要把hdu1284的代码里面把3改成n，这题就过了…… #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &amp;lt;= n; ++i) { for (j = i; j &amp;lt;= n; ++j) { d[j] += d[j-i]; } } printf(&amp;quot;%lld\n&amp;quot;, d[n]); } } int main(void) { solve(); return 0; }   优化到了一维数组，这个方法碉堡了…… 参考博客：http://www.</description>
    </item>
    
    <item>
      <title>NYOJ16 矩形嵌套 ——DP入门题</title>
      <link>http://liuxueyang.github.io/posts/nyoj16-%E7%9F%A9%E5%BD%A2%E5%B5%8C%E5%A5%97-dp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 20 May 2013 21:34:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/nyoj16-%E7%9F%A9%E5%BD%A2%E5%B5%8C%E5%A5%97-dp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.nyist.net/JudgeOnline/problem.php?pid=16 题目大意： 中文题…… 题目思路： 方法一： 先按照长和宽进行二级排序，然后转化成最长上升子序列求解。时间复杂度O(N^2)，数据范围1000.
#include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; const int MAX = 1000+10; typedef struct node { int x, y; bool operator &amp;lt; (const node &amp;amp;other) const { if (x !</description>
    </item>
    
    <item>
      <title>poj1163 The Triangle ——DP入门题</title>
      <link>http://liuxueyang.github.io/posts/poj1163-the-triangle-dp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 20 May 2013 16:42:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj1163-the-triangle-dp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1163 题目思路： 从三角形的底部开始考虑
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; const int MAX = 100; int a[MAX][MAX], dp[MAX][MAX]; int main(void) { //freopen(&amp;quot;1163.</description>
    </item>
    
    <item>
      <title>csu1290 Random Integers ——DP入门题&amp;&amp;比赛残留题</title>
      <link>http://liuxueyang.github.io/posts/csu1290-random-integers-dp%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/</link>
      <pubDate>Sun, 19 May 2013 17:07:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/csu1290-random-integers-dp%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/</guid>
      <description>题目链接：http://122.207.68.93/OnlineJudge/problem.php?id=1290 题目大意： 从K个不同的数字里面有放回地随机选N次，求选到的不同的数字的种类的期望。 题目思路： 这题不能用概率公式推导。因为有很多项的阶乘，应该会超double范围。应该用DP做。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; const int MAX=1000+10; double dp[MAX][MAX]; int main(void) { int i, j, k, t; double N, K; scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); while (t--) { scanf(&amp;quot;%lf%lf&amp;quot;, &amp;amp;K, &amp;amp;N); double sum = 0.</description>
    </item>
    
    <item>
      <title>zoj2136 &amp;&amp; poj2533 Longest Ordered Subsequence ——最长上升子序列经典DP</title>
      <link>http://liuxueyang.github.io/posts/zoj2136--poj2533-longest-ordered-subsequence-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E7%BB%8F%E5%85%B8dp/</link>
      <pubDate>Thu, 16 May 2013 12:44:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/zoj2136--poj2533-longest-ordered-subsequence-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E7%BB%8F%E5%85%B8dp/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1136  http://poj.org/problem?id=2533 题目大意：RT 题目思路： maxlen[j]表示，到j位置，最长的上升子序列的长度。时间复杂度O（N^2），数据范围是1000 参考解题报告：http://www.slyar.com/blog/longest-ordered-subsequence.html zoj:
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int str[1000], maxlen[1001], p[1001]; int main(void){ #ifdef LOCAL freopen(&amp;quot;lis.</description>
    </item>
    
    <item>
      <title>ural1057 Amount of Degrees ——数位DP</title>
      <link>http://liuxueyang.github.io/posts/ural1057-amount-of-degrees-%E6%95%B0%E4%BD%8Ddp/</link>
      <pubDate>Wed, 15 May 2013 16:30:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/ural1057-amount-of-degrees-%E6%95%B0%E4%BD%8Ddp/</guid>
      <description>题目链接：http://acm.timus.ru/problem.aspx?space=1&amp;amp;num=1057 题目大意： 意思就是给一个区间[x, y]，求这个区间内有多少个恰好可以被k个b的不同次幂的数之和表示出来的数字的个数。 题目思路： 只需要求区间[0, m]内的恰好可以被k个b的不同次幂的数之和表示出来的数字的个数，定义这个函数是solve(m, k, b)。题目要求的就是：solve(y, k, b) - solve(x - 1, k, b)。 思路就是，转化成二进制考虑。把这个区间内的某个数字表示成b进制，要求的数字是转化成b进制之后，每一位的数字均为0或者1，这样的数字。 画一棵完全二叉树，根节点是0，左子节点是0，右子节点是1，高度从0开始记起，整棵树的根节点不用。则f[i][j]表示，高度为i的二叉树里面恰好含有j个1的数字的个数。那么就有： f[i][j] = f[i-1][j-1] + f[i-1][j] 意思就是高度为i的树包含的数字里面，符合条件的数字的数目等于左右两棵子树的和。 当然数组f[i&amp;hellip;n][0]都要初始化为1，因为长度为i&amp;hellip;n的并且含有0个1的数字的个数总为1.</description>
    </item>
    
    <item>
      <title>hdu2577 How to Type ——DP入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu2577-how-to-type-dp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Fri, 10 May 2013 20:49:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu2577-how-to-type-dp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2577 题目大意： 一个人打字，有小写字母，有大写字母，并且要求打完字以后要把CapsLock键关掉。求最少的按键次数。 题目思路： dp[i][0]表示打到第 i 个字母的时候，CapsLock键是关着的；　dp[i][1]表示打到第 i 个字母的时候，CapsLock键是开着的； 然后就是判断下一个字母是大写字母还是小写字母，如果是小写字母，dp[i+1][0] = min(dp[i][0] + 1, dp[i][1] + 2); 表示，要求下一个状态CapsLock关着，那么前一个状态如果是关着的，直接打字母就可以了，所以只需要加1，如果是开着的，就要先把CapsLock关掉，然后再打字母，所以需要加2.</description>
    </item>
    
    <item>
      <title>hdu2098 不要62 ——数位DP入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu2098-%E4%B8%8D%E8%A6%8162-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 15 Apr 2013 21:24:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu2098-%E4%B8%8D%E8%A6%8162-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2089 题目大意： 含有4或者62的数字是不吉利数字，给一个区间，[m, n]，求这个区间内的除了不吉利数字以外的数字的数目。 思路： 由于数据范围只有1~1000000，可以暴力，水题，但是为了练习一下数位DP，没有把它当水题做…… 看的是这个人的代码：http://blog.csdn.net/acm_cxlove/article/details/7819907# 和hdu3555那道题目相似，但是多了一个条件，多了一个不含有4的条件，讨论一下。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; LL dp[8][3]; int a[8], b[8]; bool flag; int solve(int k){ int len = 0; LL temp = k; while (k){ a[++len] = k % 10; k /= 10; } LL ans = 0; int last = 0; flag = false; a[len+1] = 0; for (int i = len; i &amp;gt;= 1; --i){ ans += dp[i-1][2] * a[i]; if (flag){ans += dp[i-1][0] * a[i];} //高位位填4，低位的不管 if (!</description>
    </item>
    
    <item>
      <title>uestc1307 windy数 ——数位DP入门题</title>
      <link>http://liuxueyang.github.io/posts/uestc1307-windy%E6%95%B0-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 15 Apr 2013 19:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/uestc1307-windy%E6%95%B0-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.uestc.edu.cn/problem.php?pid=1307  题目大意： 不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。windy想知道，在A和B之间，包括A和B，总共有多少个windy数？ 思路： 具体解释代码中有。看的这个人的代码：http://blog.csdn.net/acm_cxlove/article/details/7819907# 然后自己又分析了一下，终于明白了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int dp[15][10], a[15]; // 这个函数求的是区间（0，n）内的个数 LL solve(int n){ int len = 0; LL ans = 0; while (n){ a[++len] = n % 10; n /= 10; }int i, j; a[len+1] = 0; // 长度为1~len-1 for (i = 1; i &amp;lt;= len-1; ++i) for (j = 1; j &amp;lt;= 9; ++j) // 注意j从1开始，因为最高位不能是0！ ans += dp[i][j]; // debug了好久！！！ // 长度为len，但是最高位是a[len] - 1 for (i = 1; i &amp;lt;= a[len] - 1; ++i) ans += dp[len][i]; // 长度为len，但是最高位是a[len] for (i = len - 1; i &amp;gt;= 1; --i){ for (j = 0; j &amp;lt; a[i]; ++j) if (abs(a[i+1] - j) &amp;gt;= 2) ans += dp[i][j]; if (abs(a[i] - a[i+1]) &amp;lt; 2) break; } return ans; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;uestcoj1307.</description>
    </item>
    
    <item>
      <title>hdu3555 Bomb ——数位DP入门题</title>
      <link>http://liuxueyang.github.io/posts/hdu3555-bomb-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 14 Apr 2013 11:23:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu3555-bomb-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=3555 题目大意： 给一个数字n,范围在1~2^63-1，求1~n之间含有49的数字有多少个。 思路： 经典的数位DP，学习了一下，看的别人的代码：http://www.cnblogs.com/luyi0619/archive/2011/04/29/2033117.html 状态转移： dp[i][0]代表长度为 i 并且不含有49的数字的个数； dp[i][1]代表长度为 i 并且不含有49，但是最高位是9的数字的个数； dp[i][2]代表长度为 i 并且含有49的数字的个数。 数组 a[i] 从低位到高位存储 n 的每一位数字。 则：dp[i][0] = dp[i-1][0] * a[i] - dp[i-1][1]; 表示长度为 i 的不含有49的数字的个数等于长度为 i - 1 的不含有49的数字的个数*当前的数字，因为这个位置可以填0~a[i] - 1，然后再减去长度为 i - 1 的最高位是9的数字的个数，因为如果长度为 i - 1 的最高位是9的话，那么高一位就不能填4了，否则就组成了49。 dp[i][1] = dp[i-1][0]; 表示长度为 i 的并且不含有49同时最高位是9的数字的个数等于，长度为 i - 1 的不含有49的数字的个数，因为只要在它的高一位加上一个9就可以了。 dp[i][2] = dp[i-1][2] * a[i] + dp[i-1][1]; 表示长度为 i 的含有49的数字的个数等于，长度为 i - 1 的数字的个数*当前的数字，再加上长度为 i - 1 的并且不含有49同时最高位是9的数字的个数，因为这个时候，只要在高一位加上一个4就可以了，这样在最高的两位就组成了一个49。 做法是从数字的高位向低位扫描，对于第 i 位， 其实这个题目还有一个地方不懂，就是为什么要在输入 n 后，要把 n 加1。想了一下特例，比如输入49，按照上面的做法，在第3步，并不会把符合条件的数字加上，因为4不是严格大于4，最后的执行结果就是0，但是如果加上1之后，n就变成了50，这样第3步恰好可以执行，结果就是正确的了。但是对于一般的情况，还是不知道为什么要把n加1……o(╯□╰)o 这题还是卡了很久，照着别人的代码敲的，死活过不了，然后又找了一份代码：http://blog.</description>
    </item>
    
    <item>
      <title>hdu 1059 Dividing ——多重背包复习</title>
      <link>http://liuxueyang.github.io/posts/hdu-1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Fri, 05 Apr 2013 12:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E5%A4%8D%E4%B9%A0/</guid>
      <description>Dividing
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 11367 Accepted Submission(s): 3168</description>
    </item>
    
    <item>
      <title>hdu 1712 ACboy needs your help 分组背包</title>
      <link>http://liuxueyang.github.io/posts/hdu-1712-acboy-needs-your-help-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</link>
      <pubDate>Fri, 29 Mar 2013 15:08:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1712-acboy-needs-your-help-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</guid>
      <description>ACboy needs your help
Time Limit: 1000&amp;frasl;1000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 2403 Accepted Submission(s): 1223</description>
    </item>
    
    <item>
      <title>hdu 2159 FATE 二维背包</title>
      <link>http://liuxueyang.github.io/posts/hdu-2159-fate-%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85/</link>
      <pubDate>Fri, 29 Mar 2013 13:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-2159-fate-%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85/</guid>
      <description>FATE
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 4682 Accepted Submission(s): 2105</description>
    </item>
    
    <item>
      <title>poj 1014 Dividing 多重背包</title>
      <link>http://liuxueyang.github.io/posts/poj-1014-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 28 Mar 2013 20:59:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/poj-1014-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; int f[120000+10], V; const int MAX = 0x3f3f3f3f; void zeropack(int c, int w){ for (int v = V; v &amp;gt;= c; --v){ f[v] = max(f[v], f[v-c] + w); } } void completepack(int c, int w){ for (int v = c; v &amp;lt;= V; ++v){ f[v] = max(f[v], f[v-c] + w); } } int main(void){ int a[7], cnt = 1; #ifndef ONLINE_JUDGE freopen(&amp;quot;1014.</description>
    </item>
    
    <item>
      <title>hdu 1114 Piggy-Bank 完全背包</title>
      <link>http://liuxueyang.github.io/posts/hdu-1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 28 Mar 2013 12:14:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>Piggy-Bank
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 6841 Accepted Submission(s): 3375</description>
    </item>
    
    <item>
      <title>hdu 2602 Bone Collector 01背包</title>
      <link>http://liuxueyang.github.io/posts/hdu-2602-bone-collector-01%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 28 Mar 2013 10:34:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-2602-bone-collector-01%E8%83%8C%E5%8C%85/</guid>
      <description>Bone Collector
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 17590 Accepted Submission(s): 6954</description>
    </item>
    
    <item>
      <title>hdu 1028 Ignatius and the Princess III</title>
      <link>http://liuxueyang.github.io/posts/hdu-1028-ignatius-and-the-princess-iii/</link>
      <pubDate>Wed, 13 Mar 2013 21:09:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/hdu-1028-ignatius-and-the-princess-iii/</guid>
      <description>Ignatius and the Princess III
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 8447 Accepted Submission(s): 6009</description>
    </item>
    
  </channel>
</rss>