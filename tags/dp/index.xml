<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dp on 黑历史</title>
    <link>http://liuxueyang.github.io/tags/dp/</link>
    <description>Recent content in Dp on 黑历史</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 22 Mar 2014 23:44:49 +0000</lastBuildDate>
    
	<atom:link href="http://liuxueyang.github.io/tags/dp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Longest Increasing Subsequence</title>
      <link>http://liuxueyang.github.io/blog/2014/03/22/longest-increasing-subsequence/</link>
      <pubDate>Sat, 22 Mar 2014 23:44:49 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2014/03/22/longest-increasing-subsequence/</guid>
      <description>很久不写算法了== 写个东西练练手
最长上升子序列
输入n，然后是数组a[ ]的n个元素
输出最长上升子序列的长度
一、最简单的方法复杂度O(n * n)
DP[ i ] 是以a[ i ] 为结尾的最长上升子序列的长度。 DP[ i ] = max{DP[ j ] + 1 | j &amp;lt; i &amp;amp;&amp;amp; a[ j ] &amp;lt; a[ i ]}  代码：
/* * ===================================================================================== * Filename : LongestIncrSub1.cpp * Description : O(n^2) * Version : a better Algorithm of O(n^2) * Created : 03/22/14 22:03 * Author : Liu Xue Yang (LXY), liuxueyang457@163.</description>
    </item>
    
    <item>
      <title>Candy Store</title>
      <link>http://liuxueyang.github.io/blog/2013/09/18/candy-store/</link>
      <pubDate>Wed, 18 Sep 2013 00:55:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/09/18/candy-store/</guid>
      <description>Candy Store Time Limit: 30000ms, Special Time Limit:75000ms, Memory Limit:65536KB Total submit users: 6, Accepted users: 6 Problem 12624 : No special judgement Problem description You are walking with a friend, when you pass a candy store. You make a comment about how unhealthy their wares are. Your friend issues an interesting challenge: who can be the unhealthiest? Both of you will go into the store with the same amount of money.</description>
    </item>
    
    <item>
      <title>ural 1057Amount of Degrees ——数位DP</title>
      <link>http://liuxueyang.github.io/blog/2013/08/20/ural-1057amount-of-degrees-%E6%95%B0%E4%BD%8Ddp/</link>
      <pubDate>Tue, 20 Aug 2013 09:26:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/20/ural-1057amount-of-degrees-%E6%95%B0%E4%BD%8Ddp/</guid>
      <description>link:http://acm.timus.ru/problem.aspx?space=1&amp;amp;num=1057
论文： 浅谈数位类统计问题 刘聪
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int a[33][33]; int bto2(int x, int b) { int tm[33], cnt = 0, ans = 0; while (x) { tm[cnt++] = x % b; x /= b; } for (int i = cnt - 1; i &amp;gt;= 0; --i) { if (tm[i] &amp;amp;&amp;amp; (tm[i] !</description>
    </item>
    
    <item>
      <title>codeforces mysterious present 最长上升子序列&#43;倒序打印路径</title>
      <link>http://liuxueyang.github.io/blog/2013/08/19/codeforces-mysterious-present-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-%E5%80%92%E5%BA%8F%E6%89%93%E5%8D%B0%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Mon, 19 Aug 2013 15:22:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/19/codeforces-mysterious-present-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-%E5%80%92%E5%BA%8F%E6%89%93%E5%8D%B0%E8%B7%AF%E5%BE%84/</guid>
      <description>link:http://codeforces.com/problemset/problem/4/D
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int n,w,h,cnt,ans,d[5009],path[5009],End; bool flag; typedef struct node { int W,H,In; bool operator &amp;lt; (const node &amp;amp;other) const { if(W!</description>
    </item>
    
    <item>
      <title>zoj3551 Bloodsucker ——概率DP</title>
      <link>http://liuxueyang.github.io/blog/2013/08/18/zoj3551-bloodsucker-%E6%A6%82%E7%8E%87dp/</link>
      <pubDate>Sun, 18 Aug 2013 10:19:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/18/zoj3551-bloodsucker-%E6%A6%82%E7%8E%87dp/</guid>
      <description>Link: http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=4530
A[i]数组表示当吸血鬼有 I 个的时候，还需要的天数。可以列出方程：
A[i] = p1(a[i+1]+1) + (1-p1)(a[i]+1) p1=(i*(n-i))p / (n(n-1)/2)
这道题目错了很多次，原因就是强制类型转换的时候，有一个细节，
(double)(n(n-1))/2.0 是错的，应该写成：(double)n(n-1)/2.0。这个小细节以后注意吧
# include&amp;lt;stdio.h&amp;gt; # include&amp;lt;string.h&amp;gt; # include&amp;lt;stdlib.h&amp;gt; int main(void) { // freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;,stdin ); int t; scanf(&amp;quot;%d&amp;quot;,&amp;amp;t); while (t--) { int n; double p; scanf(&amp;quot;%d%lf&amp;quot;,&amp;amp;n,&amp;amp;p); double sad=0.0,dw=(double)n*(n-1)/2.0; for(int i=n-1;i&amp;gt;=1;--i) { double lxy=i; lxy*=(n-i); lxy*=p; lxy=lxy/dw; sad+=1.0/lxy; } printf(&amp;quot;%.3f\n&amp;quot;,sad); } return 0; }  O(╯□╰)o</description>
    </item>
    
    <item>
      <title>poj1458 Common Subsequence ——最长公共子序列</title>
      <link>http://liuxueyang.github.io/blog/2013/08/17/poj1458-common-subsequence-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Sat, 17 Aug 2013 10:38:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/17/poj1458-common-subsequence-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>link:http://poj.org/problem?id=1458 最基础的那种
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int sad[1111][1111];char apple[1111],pear[1111]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin ); #endif // ONLINE_JUDGE // while (gets(apple)!</description>
    </item>
    
    <item>
      <title>poj3181 Dollar Dayz ——完全背包</title>
      <link>http://liuxueyang.github.io/blog/2013/08/15/poj3181-dollar-dayz-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 18:14:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/15/poj3181-dollar-dayz-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://poj.org/problem?id=3181 本来很常规的一道完全背包，比较有意思的一点是，结果会超int，更有意思的解决方法是，不用高精度，用两个整型的拼接起来就行了。ORZ
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; typedef unsigned long long ULL; ULL dp[1111], dp1[1111]; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>uva147 Dollars      ——完全背包</title>
      <link>http://liuxueyang.github.io/blog/2013/08/15/uva147-dollars------%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 18:03:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/15/uva147-dollars------%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=83 和完全背包一样的思想。 有两个trick： 没了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; long long d[33333]; int a[11]={5,10,20,50,100,200,500,1000,2000,5000,10000}; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>uva674 Coin Change ——完全背包</title>
      <link>http://liuxueyang.github.io/blog/2013/08/15/uva674-coin-change-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:59:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/15/uva674-coin-change-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=615 和完全背包一样的思想。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int a[5]={1,5,10,25,50}; int f[7777]; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu2191 悼念512汶川大地震     ——多重背包</title>
      <link>http://liuxueyang.github.io/blog/2013/08/15/hdu2191-%E6%82%BC%E5%BF%B5512%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%87-----%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:54:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/15/hdu2191-%E6%82%BC%E5%BF%B5512%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%87-----%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=2191 最简单的那种
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int n, V, t, f[111], c[111], w[111], m[111]; void zeropack(int c, int w) { for (int v=V; v&amp;gt;=c; --v) { f[v]=max(f[v],f[v-c]+w); } return; } void completepack(int c, int w) { for (int v=c;v&amp;lt;=V;++v) f[v]=max(f[v],f[v-c]+w); return; } void multipack(int c, int w, int m) { if (c*m &amp;gt;= V) { completepack(c,w); return; } int k=1; while (k&amp;lt;m) { zeropack(c*k,w*k); m-=k; k*=2; } zeropack(c*m,w*m); return; } int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu1059 Dividing ——多重背包</title>
      <link>http://liuxueyang.github.io/blog/2013/08/15/hdu1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/15/hdu1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=1059 最简单的那种
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int V,m[6],c[6],w[6],f[66666]; void zeropack(int c, int w) { for (int v=V;v&amp;gt;=c;--v) f[v]=max(f[v],f[v-c]+w); return; } void completepack(int c,int w) { for(int v=c;v&amp;lt;=V;++v) f[v]=max(f[v],f[v-c]+w); return; } void multipack(int c,int w,int m) { if(c*m&amp;gt;=V) { completepack(c,w); return; } int k=1; while (k&amp;lt;m) { zeropack(k*c,k*w); m-=k; k*=2; } zeropack(c*m,w*m); return; } int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu1114 Piggy-Bank ——完全背包</title>
      <link>http://liuxueyang.github.io/blog/2013/08/15/hdu1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:47:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/15/hdu1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=1114 只不过求得是最小值。没什么可说的，连我都会做……o(╯□╰)o
/* ID: zypz4571 LANG: C++ TASK: pig.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int f[11111],c[555],w[555], V, n; void completepack(int c,int w) { for(int v=c;v&amp;lt;=V;++v) f[v]=min(f[v],f[v-c]+w); } int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>zoj3623 Battle Ships ——完全背包？简单DP！|| 泛化背包</title>
      <link>http://liuxueyang.github.io/blog/2013/08/15/zoj3623-battle-ships-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%AE%80%E5%8D%95dp-%E6%B3%9B%E5%8C%96%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 15 Aug 2013 17:43:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/15/zoj3623-battle-ships-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%AE%80%E5%8D%95dp-%E6%B3%9B%E5%8C%96%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3623 看起来像完全背包，但是物品价值是变化的，所以很多人搞的很复杂。 晚上的代码要么很复杂，有一个代码虽然很简洁在zoj可以过，但是是错误的。求教lyl神犇，果然思想很深刻，抓住乐问题的本质，想法比网上搜到的所有博客里面的做法都简洁。 事实上，就是简单的DP，抓住一个技巧：让时间倒流，也就是说，把时间反过来考虑，先在将来把船造好，然后在过去用船攻击，哈哈，太巧秒了，说起来很别扭，很有意思，dp[j+time[i]]=max(dp[j]+j*time[i])；dp[j]表示在j这个时间，所造成的最大伤害。这样就可以枚举时间，在每个特定的时间内，枚举船的种类，找到最大值。最终在dp[]数组里面找到符合条件的并且时间最少的解。 只能说，ORZ…… 后来好不容易想明白了。茶具从哪里来……
/* ID: zypz4571 LANG: C++ TASK: battle.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int Time[33],dam[33], f[444]; int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>poj3249 Test for Job  ——拓扑&#43;DP</title>
      <link>http://liuxueyang.github.io/blog/2013/08/15/poj3249-test-for-job--%E6%8B%93%E6%89%91-dp/</link>
      <pubDate>Thu, 15 Aug 2013 17:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/15/poj3249-test-for-job--%E6%8B%93%E6%89%91-dp/</guid>
      <description>link:http://poj.org/problem?id=3249 在拓扑排序的过程中进行状态转移，dp[i]表示从起点到 i 这个点所得到的的最大值。比如从u点到v点，dp[v]=max(dp[v], dp[u]+a[v]) a[]数组是点的价值，最终的dp[]数组里面的最大值就是所求的。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; #define N 111111 using namespace std; int WO[N],NI[N],dp[N],TA[N]; vector&amp;lt;int&amp;gt; V[N]; queue&amp;lt;int&amp;gt; QU; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu3033 I love sneakers!        分组背包变形</title>
      <link>http://liuxueyang.github.io/blog/2013/08/11/hdu3033-i-love-sneakers--------%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E5%8F%98%E5%BD%A2/</link>
      <pubDate>Sun, 11 Aug 2013 18:24:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/11/hdu3033-i-love-sneakers--------%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%E5%8F%98%E5%BD%A2/</guid>
      <description>分组背包要求每一组里面只能选一个，这个题目要求每一组里面至少选一个物品。 dp[i, j] 表示前 i 组里面在每组至少放进一个物品的情况下，当花费 j 的时候，所得到的的最大价值。这个状态可以由三个状态转移过来： a[i, j].b表示第 i 组第 j 个物品的花费，v表示背包容量。 初始化： 如果一种物品都不放，那么对应的所有的背包容量都是0，也就是：dp[0, 0~M] = 0； 其他的情况，都初始化成-INF。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; typedef struct node { int b,v; }node; vector&amp;lt;node&amp;gt; a[11]; int dp[11][10009]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu1712 ACboy needs your help    分组背包</title>
      <link>http://liuxueyang.github.io/blog/2013/08/11/hdu1712-acboy-needs-your-help----%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</link>
      <pubDate>Sun, 11 Aug 2013 16:20:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/11/hdu1712-acboy-needs-your-help----%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</guid>
      <description>最基础的分组背包~
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int dp[102], a[102][102]; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.txt&amp;quot;, &amp;quot;r&amp;quot;, stdin ); #endif // ONLINE_JUDGE int n,m; while (~scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m)&amp;amp;&amp;amp;(n||m)) { for (int i=1;i&amp;lt;=n;++i) { for (int j=1;j&amp;lt;=m;++j) scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i][j]); } memset(dp,0,sizeof(dp)); for (int i=1;i&amp;lt;=n;++i) { for (int v=m;v&amp;gt;=0;--v) { for (int j=1;j&amp;lt;=v;++j) { dp[v]=max(dp[v],dp[v-j]+a[i][j]); } } } printf(&amp;quot;%d\n&amp;quot;,dp[m]); } return 0; }  没什么可说的。1Y</description>
    </item>
    
    <item>
      <title>hdu2955 Robberies 　０１背包＋概率</title>
      <link>http://liuxueyang.github.io/blog/2013/08/06/hdu2955-robberies-%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85%E6%A6%82%E7%8E%87/</link>
      <pubDate>Tue, 06 Aug 2013 11:06:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/06/hdu2955-robberies-%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85%E6%A6%82%E7%8E%87/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=2955 首先，这个题目的背包容量不能是概率．１．精度不清楚．２．把概率相加有什么意义呢？所以，转换一下，把所有银行的珠宝和当作背包容量，把小偷安全的概率当作物品价值．可以先求出背包尽可能满的情况下，安全概率最大的解．然后在这些解里面，找出安全概率满足大于１－Ｐ的并且价值最大的就行． 题目读清楚．人给的是被抓住的概率和每个银行被抓住的概率．这个是不能直接用的．比如连续偷几个银行，就要分别算出安全的概率，这样概率就可以直接相乘了． 只要要偷的几个银行的安全概率的积大于１－P就行．
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int V, n, c[11111]; double w[11111], f[11111]; int main(void) { ios::sync_with_stdio(false); #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>uva562 Dividing coins   01背包</title>
      <link>http://liuxueyang.github.io/blog/2013/08/06/uva562-dividing-coins---01%E8%83%8C%E5%8C%85/</link>
      <pubDate>Tue, 06 Aug 2013 10:45:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/06/uva562-dividing-coins---01%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=503 分成２半，并且两半的差距最小，背包的体积变成V/2
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int V, c[111], w[111], f[55555], n; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>uva624 CD　　　０１背包&#43;输出最优解</title>
      <link>http://liuxueyang.github.io/blog/2013/08/06/uva624-cd%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85-%E8%BE%93%E5%87%BA%E6%9C%80%E4%BC%98%E8%A7%A3/</link>
      <pubDate>Tue, 06 Aug 2013 10:41:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/06/uva624-cd%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85-%E8%BE%93%E5%87%BA%E6%9C%80%E4%BC%98%E8%A7%A3/</guid>
      <description>link:http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=565 用一个二维数组g[i][v]表示：当状态转移到v的时候，第i个物品是不是用到，如果用到标记１，否则标记０． 输出路径的时候，注意，从物品编号０一直到n-1.如果某个物品被用到了，g[i][v]里面的v，就要减去这个物品的体积，然后继续往下找．
/* * ===================================================================================== * Filename: cd.cpp * Created: 04/08/2013 15:21:34 * Author: liuxueyang (lxy), 1459917536@qq.com * Organization: Hunan University * * ===================================================================================== */ /* ID: zypz4571 LANG: C++ TASK: cd.cpp */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;list&amp;gt; #define INF 0x3f3f3f3f #define MOD 1000000007 #define LL long long const double eps=1e-9; using namespace std; int V, n, c[22], f[22222], g[22][22222]; int main ( int argc, char *argv[] ) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu2546　饭卡　　　　０１背包</title>
      <link>http://liuxueyang.github.io/blog/2013/08/06/hdu2546%E9%A5%AD%E5%8D%A1%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85/</link>
      <pubDate>Tue, 06 Aug 2013 10:31:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/06/hdu2546%E9%A5%AD%E5%8D%A1%EF%BC%90%EF%BC%91%E8%83%8C%E5%8C%85/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=2546 也算一个贪心的想法吧． 先把总钱数减去５，再把价值最大的挑出来．然后用０１背包．最终买下挑出来的那个价值最大的商品．这样的话，我就实现了最终用最少的钱数买了价值最多的商品，剩下钱数当然也是最少了．
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; int main(void) { ios::sync_with_stdio(false); int n, V; int c[1111], f[1111]; #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>hdu4632 Palindrome subsequence     ——区间动态规划</title>
      <link>http://liuxueyang.github.io/blog/2013/08/03/hdu4632-palindrome-subsequence-----%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Sat, 03 Aug 2013 16:19:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/08/03/hdu4632-palindrome-subsequence-----%E5%8C%BA%E9%97%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>link:http://acm.hdu.edu.cn/showproblem.php?pid=4632 refer to: o(╯□╰)o……明明百度找的题解，然后后来就找不到我看的那份了，这位哥们对不住了……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; #include &amp;lt;functional&amp;gt; #include &amp;lt;fstream&amp;gt; #include &amp;lt;iomanip&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;numeric&amp;gt; #include &amp;lt;cassert&amp;gt; #include &amp;lt;ctime&amp;gt; #include &amp;lt;iterator&amp;gt; const int INF = 0x3f3f3f3f; const int dir[8][2] = {{-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1}}; using namespace std; char a[1111]; int dp[1111][1111]; const int MOD = 10007; int main(void) { #ifndef ONLINE_JUDGE freopen(&amp;quot;in.</description>
    </item>
    
    <item>
      <title>Codeforces Flipping game 动态规划基础</title>
      <link>http://liuxueyang.github.io/blog/2013/07/19/codeforces-flipping-game-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Fri, 19 Jul 2013 01:05:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/07/19/codeforces-flipping-game-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/</guid>
      <description>题目链接：http://codeforces.com/problemset/problem/327/A 这道题目有O(N^3)的做法，这里转化为动态规划求解，复杂度是O(N)
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;list&amp;gt; #include &amp;lt;map&amp;gt; using namespace std; #define INF 0x3f3f3f3f int a[102], b[102], c[102]; int main ( void ) { int n, n1=0, cnt=0; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { n1 = cnt = 0; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); for (int i=1; i&amp;lt;=n; ++i){ scanf(&amp;quot;%d&amp;quot;,a+i); if(a[i]) n1++; if (a[i]) b[i]=-1; else b[i]=1; } c[0] = 0; for (int i = 1; i &amp;lt;= n; ++i) { c[i] = c[i-1] + b[i]; } int Max = -INF, Min = c[0]; for (int i = 1; i &amp;lt;= n; ++i) { if (c[i] - Min &amp;gt; Max) Max = c[i]-Min; if (c[i] &amp;lt; Min) Min = c[i]; } printf(&amp;quot;%d\n&amp;quot;,n1+Max); } return 0; }  转化为子序列的最大连续和</description>
    </item>
    
    <item>
      <title>tyvj1023 - 奶牛的锻炼 ——DP</title>
      <link>http://liuxueyang.github.io/blog/2013/07/08/tyvj1023---%E5%A5%B6%E7%89%9B%E7%9A%84%E9%94%BB%E7%82%BC-dp/</link>
      <pubDate>Mon, 08 Jul 2013 23:31:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/07/08/tyvj1023---%E5%A5%B6%E7%89%9B%E7%9A%84%E9%94%BB%E7%82%BC-dp/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1023
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; int a[2002],f[2002][502]; int main(void) { //freopen(&amp;quot;in1.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin); int n, m; scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;n,&amp;amp;m); for(int i=1;i&amp;lt;=n;scanf(&amp;quot;%d&amp;quot;,a+i++)); f[0][0]=0,f[1][1]=a[1]; for(int i=1;i&amp;lt;=n;++i) for(int j=0;j&amp;lt;=m;++j) { if(!j) for(int k=1;k&amp;lt;=i;++k) f[i][0]=max(max(f[i-1][0],f[i-k][k]),f[i][0]); else f[i][j]=f[i-1][j-1]+a[i]; //printf(&amp;quot;%d &amp;quot;,f[i][j]); } printf(&amp;quot;\n%d\n&amp;quot;,f[n][0]); return 0; }  =_=</description>
    </item>
    
    <item>
      <title>tyvj1015 - 公路乘车  ——完全背包</title>
      <link>http://liuxueyang.github.io/blog/2013/07/07/tyvj1015---%E5%85%AC%E8%B7%AF%E4%B9%98%E8%BD%A6--%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Sun, 07 Jul 2013 21:14:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/07/07/tyvj1015---%E5%85%AC%E8%B7%AF%E4%B9%98%E8%BD%A6--%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1015 完全背包
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int c[11],f[101]; int main(void) { freopen(&amp;quot;in1.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin); int n,i,j;for(i=1;i&amp;lt;=10;scanf(&amp;quot;%d&amp;quot;,c+i++)) ;scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); for(i=1;i&amp;lt;=n;f[i++]=100000) ; for(i=1;i&amp;lt;=10;++i)for(j=i;j&amp;lt;=n;++j)f[j]=min(f[j],f[j-i]+c[i]); printf(&amp;quot;%d\n&amp;quot;,f[n]); return 0; }  0x3f3f3f3f可以memset-_-#</description>
    </item>
    
    <item>
      <title>tyvj1014 - 乘法游戏  ——记忆化搜索DP</title>
      <link>http://liuxueyang.github.io/blog/2013/07/07/tyvj1014---%E4%B9%98%E6%B3%95%E6%B8%B8%E6%88%8F--%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2dp/</link>
      <pubDate>Sun, 07 Jul 2013 17:28:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/07/07/tyvj1014---%E4%B9%98%E6%B3%95%E6%B8%B8%E6%88%8F--%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2dp/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1014 f[i][j]表示区间［i，j］所得到的最小值。 不断地划分区间，把结果保存起来。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; long long int f[101][101];int a[101], i, j, n, INF=0x7f7f7f7f; void dfs(int l, int r) { if(r-l&amp;lt;=1) {f[l][r]=0; return;} if(f[l][r]!=INF) return; for(int i=l+1;i&amp;lt;=r-1;++i) dfs(1,i),dfs(i,r),f[l][r]=min(f[l][r],f[l][i]+f[i][r]+a[i]*a[l]*a[r]); } int main(void) { freopen(&amp;quot;in1.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin); scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);for(i=1;i&amp;lt;=n;scanf(&amp;quot;%d&amp;quot;,a+i++)) ;for(i=0;i&amp;lt;=n;++i)for(j=0;j&amp;lt;=n;++j)f[i][j]=INF;dfs(1,n);printf(&amp;quot;%lld\n&amp;quot;,f[1][n]); return 0; }  =_=</description>
    </item>
    
    <item>
      <title>tyvj1013 - 找啊找啊找GF  ——二维背包变种</title>
      <link>http://liuxueyang.github.io/blog/2013/07/07/tyvj1013---%E6%89%BE%E5%95%8A%E6%89%BE%E5%95%8A%E6%89%BEgf--%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85%E5%8F%98%E7%A7%8D/</link>
      <pubDate>Sun, 07 Jul 2013 16:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/07/07/tyvj1013---%E6%89%BE%E5%95%8A%E6%89%BE%E5%95%8A%E6%89%BEgf--%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85%E5%8F%98%E7%A7%8D/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1013 好吧，这题没节操=_= 状态f[u,v,i]表示：消费u的人民币和v的人品同时泡到i个mm所需要的最少时间。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; int f[101][101][101], r[101], rp[101], t[101], rmb, RP, n, INF=0x7f7f7f7f; int main(void) { freopen(&amp;quot;in1.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin); scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);for(int i=1;i&amp;lt;=n;scanf(&amp;quot;%d%d%d&amp;quot;,r+i,rp+i,t+i),++i) ;scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;rmb,&amp;amp;RP); for(int i=0;i&amp;lt;=rmb;++i)for(int j=0;j&amp;lt;=RP;++j)for(int k=1;k&amp;lt;=n;++k)f[i][j][k]=INF; for(int i=1;i&amp;lt;=n;++i)for(int u=rmb;u&amp;gt;=r[i];--u)for(int v=RP;v&amp;gt;=rp[i];--v)for(int j=1;j&amp;lt;=i;++j) if(f[u][v][j-1]!=INF) f[u][v][j]=min(f[u][v][j],f[u-r[i]][v-rp[i]][j-1]+t[i]); for(int i=n;i&amp;gt;=0;--i)if(f[rmb][RP][i]!=INF){printf(&amp;quot;%d\n&amp;quot;,f[rmb][RP][i]);break;} return 0; }  为了使泡到的mm尽量多，所以要从后往前找合法的解，只要找到就输出，然后break; =_=</description>
    </item>
    
    <item>
      <title>tyvj1011 - 传纸条  ——DP</title>
      <link>http://liuxueyang.github.io/blog/2013/07/07/tyvj1011---%E4%BC%A0%E7%BA%B8%E6%9D%A1--dp/</link>
      <pubDate>Sun, 07 Jul 2013 11:32:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/07/07/tyvj1011---%E4%BC%A0%E7%BA%B8%E6%9D%A1--dp/</guid>
      <description>题目链接：https://www.tyvj.cn/Problem_Show.aspx?id=1011 状态转移方程： f[k,x1,x2] = max(f[k-1,x1,x2],f[k-1,x1-1,x2],f[k-1,x1-1,x2-1],f[k-1,x1,x2-1]) + a[y1,x1] + a[y2,x2]; f[k,x1,x2]表示，第K步的时候，一条路的横坐标是x1,另一条路的横坐标是x2的时候所得到的最优解。另外，还要考虑一下，当x1==x2的时候的情况，这个时候，只能允许一条路走到那个位置。
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; int a[51][51],f[100][51][51]; int main(void) { freopen(&amp;quot;in1.txt&amp;quot;,&amp;quot;r&amp;quot;,stdin); int N,M; scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;M, &amp;amp;N);for(int i=1;i&amp;lt;=M;++i)for(int j=1;j&amp;lt;=N;++j)scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i][j]); for(int k=1;k&amp;lt;=M+N-3;++k)for(int x1=1;x1&amp;lt;=min(N,k+1);++x1)for(int x2=1;x2&amp;lt;=min(N,k+1);++x2) { f[k][x1][x2]=max(max(f[k-1][x1][x2],f[k-1][x1-1][x2]),max(f[k-1][x1][x2-1],f[k-1][x1-1][x2-1])); if (x1==x2)f[k][x1][x2]+=a[k-x1+2][x1]; else f[k][x1][x2]+=(a[k-x1+2][x1]+a[k-x2+2][x2]); } printf(&amp;quot;%d\n&amp;quot;,f[M+N-3][N][N-1]); return 0; }  昨天看了一篇文章，才发现，其实，题解是写给自己看的-_-#</description>
    </item>
    
    <item>
      <title>hdu1176 免费馅饼 ——DP</title>
      <link>http://liuxueyang.github.io/blog/2013/05/25/hdu1176-%E5%85%8D%E8%B4%B9%E9%A6%85%E9%A5%BC-dp/</link>
      <pubDate>Sat, 25 May 2013 17:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/05/25/hdu1176-%E5%85%8D%E8%B4%B9%E9%A6%85%E9%A5%BC-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1176 题目大意： 中文题…… 题目思路： 类似于 Triangle 。d[i][j] 表示 i 时间在 j 位置的所得到的价值。然后就像 Triangle 一样从下往上递推。最终求在0秒的时候，在5位置上的值。 ＷＡ了两次，当初求的是0秒的时候，所有位置上的最大值，，这显然是不对的。因为起始位置是5啊。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; const int MAX = 100000+10; int a[MAX][11], d[MAX][11]; void init() { int m, i, j, x, t, tMax = -1; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;m) &amp;amp;&amp;amp; m) { memset(a, 0, sizeof(a)); memset(d, 0, sizeof(d)); for (i = 0; i &amp;lt; m; ++i) { scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;x, &amp;amp;t); if (tMax &amp;lt; t) tMax = t; a[t][x]++; } for (i = 0; i &amp;lt;= 10; ++i) d[tMax][i] = a[tMax][i]; for (i = tMax-1; i&amp;gt;= 0; --i) { for (j = 0; j &amp;lt;= 10; ++j) { if (j == 0) { d[i][j] = max(d[i+1][j], d[i+1][j+1]) + a[i][j]; continue; } else if (j == 10) { d[i][j] = max(d[i+1][j], d[i+1][j-1]) + a[i][j]; continue; } d[i][j]=max(d[i+1][j], max(d[i+1][j+1], d[i+1][j-1]))+a[i][j]; } } printf(&amp;quot;%d\n&amp;quot;, d[0][5]); } } int main(void) { init(); return 0; }  很多题目都是相通的</description>
    </item>
    
    <item>
      <title>hdu2069 Coin Change ——DP</title>
      <link>http://liuxueyang.github.io/blog/2013/05/24/hdu2069-coin-change-dp/</link>
      <pubDate>Fri, 24 May 2013 11:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/05/24/hdu2069-coin-change-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2069 题目大意： 给一个数字，用1, 5, 10， 25, 50 这五种硬币，最多用100枚，有多少种组合方式。 题目思路： 这道题和之前的题目不同，有了硬币个数的限制，所以需要加上一维表示硬币的个数就可以了。d[i][j]表示价值为 i 的最多用 j 枚硬币有多少中组合方式。很多人用母函数做，感觉DP做简单多了…… 参考博客：http://www.cnblogs.com/qiufeihai/archive/2012/09/11/2680840.html
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; const int MAX = 250+10; int d[MAX][MAX], n, a[5] = {1, 5, 10, 25, 50}; void solve() { while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { int i, j, k; memset(d, 0, sizeof(d)); d[0][0] = 1; for (k = 0; k &amp;lt; 5; ++k) { for (j = 1; j &amp;lt;= 100; ++j) { for (i = a[k]; i &amp;lt;= n; ++i) { d[i][j] += d[i-a[k]][j-1]; } } } int sum(0); for (i = 0; i &amp;lt;= n; ++i) { sum += d[n][i]; } printf(&amp;quot;%d\n&amp;quot;, sum); } } int main(void) { solve(); return 0; }  　还有要注意一点，初始化要d[0][0] = 1 因为题目中说：Note that we count that there is one way of making change for zero cent.</description>
    </item>
    
    <item>
      <title>hdu1398 Square Coins ——DP</title>
      <link>http://liuxueyang.github.io/blog/2013/05/23/hdu1398-square-coins-dp/</link>
      <pubDate>Thu, 23 May 2013 23:20:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/05/23/hdu1398-square-coins-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1398 题目大意： 给一个数字，不大于300，求有多少种用完全平方数表示这个数字的方法 题目思路： 方法跟hdu1283一样一样的……只需要把那道题目的代码稍微改一下就可以过了 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n) &amp;amp;&amp;amp; n) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &amp;lt;= floor(sqrt(n)); ++i) { for (j = i*i; j &amp;lt;= n; ++j) { d[j] += d[j-i*i]; } } printf(&amp;quot;%lld\n&amp;quot;, d[n]); } } int main(void) { solve(); return 0; }   因为题目的范围很小嘛，只有300。 </description>
    </item>
    
    <item>
      <title>hdu1284 钱币兑换问题 ——DP</title>
      <link>http://liuxueyang.github.io/blog/2013/05/23/hdu1284-%E9%92%B1%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-dp/</link>
      <pubDate>Thu, 23 May 2013 20:39:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/05/23/hdu1284-%E9%92%B1%E5%B8%81%E5%85%91%E6%8D%A2%E9%97%AE%E9%A2%98-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1284 题目大意： 中文题…… 题目思路： 只有3个硬币，范围是32768，可以一个一个枚举硬币，如果只放价值为1的硬币，从d[1]递推到d[n]；如果再加上价值为2的硬币，那么就从d[2]递推到d[n]；在加上价值为3的硬币，就从d[3]递推到d[n].递推公式是d[j] = d[j] + d[j-i]； d[j]表示j有几种只用1，2, 3这三个数字的拆分方法，i 就是硬币的价值。 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &amp;lt;= 3; ++i) { for (j = i; j &amp;lt;= n; ++j) { d[j] += d[j-i]; } } printf(&amp;quot;%lld\n&amp;quot;, d[n]); } } int main(void) { solve(); return 0; }   参考博客：http://www.</description>
    </item>
    
    <item>
      <title>hdu1028 Ignatius and the Princess III ——DP</title>
      <link>http://liuxueyang.github.io/blog/2013/05/23/hdu1028-ignatius-and-the-princess-iii-dp/</link>
      <pubDate>Thu, 23 May 2013 19:48:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/05/23/hdu1028-ignatius-and-the-princess-iii-dp/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1028 题目大意：　整数拆分，给一个整数n,求它有多少种拆分方法。 题目思路： 做法一： d[i][j]表示把整数 i 拆成最多 j 个数字所具有的方法数。那么 if (i &amp;gt;ｊ)　d[i][j] = d[i-j][j] + d[i][j-1]; 意思就是如果i&amp;gt;j，那么有两种方式：一种是先把i里面分理处j个1，然后再把i-j拆成最多i-j个数字；另一种是把i拆分成最多j-1个数字。 if (i &amp;lt; j) d[i][j] = d[i][i]; 意思就是如果i&amp;lt;j，那么这种情况和把数字i最多拆成i个数字的是一样的。 if (i == j) d[i][j] = d[i][j-1] + 1; 意思就是如果i==j，那么可以把数字i拆分成j-1个数字，也可以把数字i拆分成i个1（这个就是那个1的意义） #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; #define LL long long int d[140][140], n; void init() { while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { int i, j; memset(d, 0, sizeof(d)); for (i = 0; i &amp;lt;= n; ++i) d[i][1] = d[1][i] = 1; for (i = 2; i &amp;lt;= n; ++i) { for (j = 1; j &amp;lt;= n; ++j) { if (i &amp;gt; j) d[i][j] = d[i-j][j] + d[i][j-1]; else if (i == j) d[i][j] = 1 + d[i][j-1]; else d[i][j] = d[i][i]; } } cout &amp;lt;&amp;lt; d[n][n] &amp;lt;&amp;lt; endl; } } int main(void) { init(); return 0 ; }   剩下的就是考虑一下边界，比如当 i 或者 j 等于1的时候，显然都是只有一种拆分情况。 做法二： 借用hdu1284这道题的方法，也可以做这道题目，因为n的范围是120嘛,两个算法的复杂度都是O(n^2)的，当然可以了。只需要把hdu1284的代码里面把3改成n，这题就过了…… #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; const int MAX = 32768+10; long long d[MAX]; void solve() { int n, i, j; while (~scanf(&amp;quot;%d&amp;quot;, &amp;amp;n)) { memset(d, 0, sizeof(d)); d[0] = 1; for (i = 1; i &amp;lt;= n; ++i) { for (j = i; j &amp;lt;= n; ++j) { d[j] += d[j-i]; } } printf(&amp;quot;%lld\n&amp;quot;, d[n]); } } int main(void) { solve(); return 0; }   优化到了一维数组，这个方法碉堡了…… 参考博客：http://www.</description>
    </item>
    
    <item>
      <title>NYOJ16 矩形嵌套 ——DP入门题</title>
      <link>http://liuxueyang.github.io/blog/2013/05/20/nyoj16-%E7%9F%A9%E5%BD%A2%E5%B5%8C%E5%A5%97-dp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 20 May 2013 21:34:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/05/20/nyoj16-%E7%9F%A9%E5%BD%A2%E5%B5%8C%E5%A5%97-dp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.nyist.net/JudgeOnline/problem.php?pid=16 题目大意： 中文题…… 题目思路： 方法一： 先按照长和宽进行二级排序，然后转化成最长上升子序列求解。时间复杂度O(N^2)，数据范围1000.
#include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; const int MAX = 1000+10; typedef struct node { int x, y; bool operator &amp;lt; (const node &amp;amp;other) const { if (x != other.x) { return x &amp;lt; other.x; } else return y &amp;lt; other.y; } }node; node ma[MAX]; int n, maxlen[MAX]; void init() { int i, a, b; scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); for (i = 0; i &amp;lt; n; ++i) { scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b); if (a &amp;gt; b) swap(a,b); ma[i].</description>
    </item>
    
    <item>
      <title>poj1163 The Triangle ——DP入门题</title>
      <link>http://liuxueyang.github.io/blog/2013/05/20/poj1163-the-triangle-dp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 20 May 2013 16:42:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/05/20/poj1163-the-triangle-dp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://poj.org/problem?id=1163 题目思路： 从三角形的底部开始考虑
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; const int MAX = 100; int a[MAX][MAX], dp[MAX][MAX]; int main(void) { //freopen(&amp;quot;1163.in&amp;quot;, &amp;quot;r&amp;quot;, stdin); int n,i,j; scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); for (i = 0; i &amp;lt; n; ++i) { for (j = 0; j &amp;lt; i+1; ++j) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;a[i][j]); } } memset(dp, 0, sizeof(dp)); for (i = 0; i &amp;lt; n; ++i) dp[n-1][i] = a[n-1][i]; for (i = n - 2; i &amp;gt;= 0; --i) { for (j = 0; j &amp;lt; n - 1; ++j) { dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + a[i][j]; } } printf(&amp;quot;%d\n&amp;quot;, dp[0][0]); return 0; }  还是从最简单的开始做起吧 另外一种写法： #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdio&amp;gt; using namespace std; const int MAX = 100; int a[MAX][MAX], dp[MAX][MAX], n; int f(int i, int j) { if (dp[i][j] &amp;gt;= 0) return dp[i][j]; else { if (i == n-1) dp[i][j] = a[i][j]; else dp[i][j] = a[i][j] + max(dp[i+1][j], dp[i+1][j+1]); return dp[i][j]; } } int main(void) { int i,j; scanf(&amp;quot;%d&amp;quot;,&amp;amp;n); for (i = 0; i &amp;lt; n; ++i) { for (j = 0; j &amp;lt; i+1; ++j) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;a[i][j]); } } memset(dp, -1, sizeof(dp)); for (i = 0; i &amp;lt; n; ++i) dp[n-1][i] = a[n-1][i]; for (i = n-1; i &amp;gt;= 0; --i) for (j = 0; j &amp;lt; i+1; ++j) f(i, j); printf(&amp;quot;%d\n&amp;quot;, dp[0][0]); return 0; }   这就是所谓的记忆化搜索 </description>
    </item>
    
    <item>
      <title>csu1290 Random Integers ——DP入门题&amp;&amp;比赛残留题</title>
      <link>http://liuxueyang.github.io/blog/2013/05/19/csu1290-random-integers-dp%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/</link>
      <pubDate>Sun, 19 May 2013 17:07:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/05/19/csu1290-random-integers-dp%E5%85%A5%E9%97%A8%E9%A2%98%E6%AF%94%E8%B5%9B%E6%AE%8B%E7%95%99%E9%A2%98/</guid>
      <description>题目链接：http://122.207.68.93/OnlineJudge/problem.php?id=1290 题目大意： 从K个不同的数字里面有放回地随机选N次，求选到的不同的数字的种类的期望。 题目思路： 这题不能用概率公式推导。因为有很多项的阶乘，应该会超double范围。应该用DP做。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; using namespace std; const int MAX=1000+10; double dp[MAX][MAX]; int main(void) { int i, j, k, t; double N, K; scanf(&amp;quot;%d&amp;quot;, &amp;amp;t); while (t--) { scanf(&amp;quot;%lf%lf&amp;quot;, &amp;amp;K, &amp;amp;N); double sum = 0.0; for (i = 0; i &amp;lt;= N; ++i) for (j = 0; j &amp;lt;= K; ++j) dp[i][j] = 0.0; dp[0][0] = 1.0; for (i = 1; i &amp;lt;= N; ++i){ for (j = 1; j &amp;lt;= K; ++j){ dp[i][j]=dp[i-1][j-1]*(K-j+1)/K + dp[i-1][j]*(j/K); //sum += (j*dp[i][j]); } } for (i = 1; i &amp;lt;= K; ++i) { sum += (i * dp[(int)N][i]); } printf(&amp;quot;%.</description>
    </item>
    
    <item>
      <title>zoj2136 &amp;&amp; poj2533 Longest Ordered Subsequence ——最长上升子序列经典DP</title>
      <link>http://liuxueyang.github.io/blog/2013/05/16/zoj2136--poj2533-longest-ordered-subsequence-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E7%BB%8F%E5%85%B8dp/</link>
      <pubDate>Thu, 16 May 2013 12:44:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/05/16/zoj2136--poj2533-longest-ordered-subsequence-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E7%BB%8F%E5%85%B8dp/</guid>
      <description>题目链接：http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1136  http://poj.org/problem?id=2533 题目大意：RT 题目思路： maxlen[j]表示，到j位置，最长的上升子序列的长度。时间复杂度O（N^2），数据范围是1000 参考解题报告：http://www.slyar.com/blog/longest-ordered-subsequence.html zoj:
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int str[1000], maxlen[1001], p[1001]; int main(void){ #ifdef LOCAL freopen(&amp;quot;lis.</description>
    </item>
    
    <item>
      <title>ural1057 Amount of Degrees ——数位DP</title>
      <link>http://liuxueyang.github.io/blog/2013/05/15/ural1057-amount-of-degrees-%E6%95%B0%E4%BD%8Ddp/</link>
      <pubDate>Wed, 15 May 2013 16:30:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/05/15/ural1057-amount-of-degrees-%E6%95%B0%E4%BD%8Ddp/</guid>
      <description>题目链接：http://acm.timus.ru/problem.aspx?space=1&amp;amp;num=1057 题目大意： 意思就是给一个区间[x, y]，求这个区间内有多少个恰好可以被k个b的不同次幂的数之和表示出来的数字的个数。 题目思路： 只需要求区间[0, m]内的恰好可以被k个b的不同次幂的数之和表示出来的数字的个数，定义这个函数是solve(m, k, b)。题目要求的就是：solve(y, k, b) - solve(x - 1, k, b)。 思路就是，转化成二进制考虑。把这个区间内的某个数字表示成b进制，要求的数字是转化成b进制之后，每一位的数字均为0或者1，这样的数字。 画一棵完全二叉树，根节点是0，左子节点是0，右子节点是1，高度从0开始记起，整棵树的根节点不用。则f[i][j]表示，高度为i的二叉树里面恰好含有j个1的数字的个数。那么就有： f[i][j] = f[i-1][j-1] + f[i-1][j] 意思就是高度为i的树包含的数字里面，符合条件的数字的数目等于左右两棵子树的和。 当然数组f[i&amp;hellip;n][0]都要初始化为1，因为长度为i&amp;hellip;n的并且含有0个1的数字的个数总为1. 参考解题报告：http://hi.baidu.com/zyz913614263/item/a0215c20efefa01f42634a12
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;deque&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int f[32][32]; int solve(int n, int k, int b) { int a[32], sum, cnt, i, j; sum = 0; cnt = 0; i = 0; while (n) { a[++i] = n%b; n /= b; } for (j = i; j &amp;gt;= 1 &amp;amp;&amp;amp; cnt &amp;lt;= k; --j) { if (a[j] &amp;gt; 1) { sum += f[j][k-cnt]; break; } else if (a[j] == 1) { sum += f[j-1][k-cnt]; cnt++; } if (j == 1 &amp;amp;&amp;amp; cnt == k) sum++; } return sum; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;ural1057.</description>
    </item>
    
    <item>
      <title>hdu2577 How to Type ——DP入门题</title>
      <link>http://liuxueyang.github.io/blog/2013/05/10/hdu2577-how-to-type-dp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Fri, 10 May 2013 20:49:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/05/10/hdu2577-how-to-type-dp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2577 题目大意： 一个人打字，有小写字母，有大写字母，并且要求打完字以后要把CapsLock键关掉。求最少的按键次数。 题目思路： dp[i][0]表示打到第 i 个字母的时候，CapsLock键是关着的；　dp[i][1]表示打到第 i 个字母的时候，CapsLock键是开着的； 然后就是判断下一个字母是大写字母还是小写字母，如果是小写字母，dp[i+1][0] = min(dp[i][0] + 1, dp[i][1] + 2); 表示，要求下一个状态CapsLock关着，那么前一个状态如果是关着的，直接打字母就可以了，所以只需要加1，如果是开着的，就要先把CapsLock关掉，然后再打字母，所以需要加2. 其他的情况类似。参考的是这个人的代码：http://www.cnblogs.com/mengxm-lincf/archive/2011/06/07/2074489.html #include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;set&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x7fffffff; const int MINN = -0x7fffffff; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int dp[110][2]; char ch[110]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;hdu2577.</description>
    </item>
    
    <item>
      <title>hdu2098 不要62 ——数位DP入门题</title>
      <link>http://liuxueyang.github.io/blog/2013/04/15/hdu2098-%E4%B8%8D%E8%A6%8162-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 15 Apr 2013 21:24:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/04/15/hdu2098-%E4%B8%8D%E8%A6%8162-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=2089 题目大意： 含有4或者62的数字是不吉利数字，给一个区间，[m, n]，求这个区间内的除了不吉利数字以外的数字的数目。 思路： 由于数据范围只有1~1000000，可以暴力，水题，但是为了练习一下数位DP，没有把它当水题做…… 看的是这个人的代码：http://blog.csdn.net/acm_cxlove/article/details/7819907# 和hdu3555那道题目相似，但是多了一个条件，多了一个不含有4的条件，讨论一下。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; LL dp[8][3]; int a[8], b[8]; bool flag; int solve(int k){ int len = 0; LL temp = k; while (k){ a[++len] = k % 10; k /= 10; } LL ans = 0; int last = 0; flag = false; a[len+1] = 0; for (int i = len; i &amp;gt;= 1; --i){ ans += dp[i-1][2] * a[i]; if (flag){ans += dp[i-1][0] * a[i];} //高位位填4，低位的不管 if (!</description>
    </item>
    
    <item>
      <title>uestc1307 windy数 ——数位DP入门题</title>
      <link>http://liuxueyang.github.io/blog/2013/04/15/uestc1307-windy%E6%95%B0-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Mon, 15 Apr 2013 19:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/04/15/uestc1307-windy%E6%95%B0-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.uestc.edu.cn/problem.php?pid=1307  题目大意： 不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。windy想知道，在A和B之间，包括A和B，总共有多少个windy数？ 思路： 具体解释代码中有。看的这个人的代码：http://blog.csdn.net/acm_cxlove/article/details/7819907# 然后自己又分析了一下，终于明白了。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cctype&amp;gt; #include &amp;lt;stack&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;cmath&amp;gt; #include &amp;lt;algorithm&amp;gt; #define lson l, m, rt&amp;lt;&amp;lt;1 #define rson m+1, r, rt&amp;lt;&amp;lt;1|1 using namespace std; typedef long long int LL; const int MAXN = 0x3f3f3f3f; const int MIN = -0x3f3f3f3f; const double eps = 1e-9; const int dir[8][2] = {{0,1},{1,0},{0,-1},{-1,0},{-1,1}, {1,1},{1,-1},{-1,-1}}; int dp[15][10], a[15]; // 这个函数求的是区间（0，n）内的个数 LL solve(int n){ int len = 0; LL ans = 0; while (n){ a[++len] = n % 10; n /= 10; }int i, j; a[len+1] = 0; // 长度为1~len-1 for (i = 1; i &amp;lt;= len-1; ++i) for (j = 1; j &amp;lt;= 9; ++j) // 注意j从1开始，因为最高位不能是0！ ans += dp[i][j]; // debug了好久！！！ // 长度为len，但是最高位是a[len] - 1 for (i = 1; i &amp;lt;= a[len] - 1; ++i) ans += dp[len][i]; // 长度为len，但是最高位是a[len] for (i = len - 1; i &amp;gt;= 1; --i){ for (j = 0; j &amp;lt; a[i]; ++j) if (abs(a[i+1] - j) &amp;gt;= 2) ans += dp[i][j]; if (abs(a[i] - a[i+1]) &amp;lt; 2) break; } return ans; } int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;uestcoj1307.</description>
    </item>
    
    <item>
      <title>hdu3555 Bomb ——数位DP入门题</title>
      <link>http://liuxueyang.github.io/blog/2013/04/14/hdu3555-bomb-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</link>
      <pubDate>Sun, 14 Apr 2013 11:23:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/04/14/hdu3555-bomb-%E6%95%B0%E4%BD%8Ddp%E5%85%A5%E9%97%A8%E9%A2%98/</guid>
      <description>题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=3555 题目大意： 给一个数字n,范围在1~2^63-1，求1~n之间含有49的数字有多少个。 思路： 经典的数位DP，学习了一下，看的别人的代码：http://www.cnblogs.com/luyi0619/archive/2011/04/29/2033117.html 状态转移： dp[i][0]代表长度为 i 并且不含有49的数字的个数； dp[i][1]代表长度为 i 并且不含有49，但是最高位是9的数字的个数； dp[i][2]代表长度为 i 并且含有49的数字的个数。 数组 a[i] 从低位到高位存储 n 的每一位数字。 则：dp[i][0] = dp[i-1][0] * a[i] - dp[i-1][1]; 表示长度为 i 的不含有49的数字的个数等于长度为 i - 1 的不含有49的数字的个数*当前的数字，因为这个位置可以填0~a[i] - 1，然后再减去长度为 i - 1 的最高位是9的数字的个数，因为如果长度为 i - 1 的最高位是9的话，那么高一位就不能填4了，否则就组成了49。 dp[i][1] = dp[i-1][0]; 表示长度为 i 的并且不含有49同时最高位是9的数字的个数等于，长度为 i - 1 的不含有49的数字的个数，因为只要在它的高一位加上一个9就可以了。 dp[i][2] = dp[i-1][2] * a[i] + dp[i-1][1]; 表示长度为 i 的含有49的数字的个数等于，长度为 i - 1 的数字的个数*当前的数字，再加上长度为 i - 1 的并且不含有49同时最高位是9的数字的个数，因为这个时候，只要在高一位加上一个4就可以了，这样在最高的两位就组成了一个49。 做法是从数字的高位向低位扫描，对于第 i 位， 其实这个题目还有一个地方不懂，就是为什么要在输入 n 后，要把 n 加1。想了一下特例，比如输入49，按照上面的做法，在第3步，并不会把符合条件的数字加上，因为4不是严格大于4，最后的执行结果就是0，但是如果加上1之后，n就变成了50，这样第3步恰好可以执行，结果就是正确的了。但是对于一般的情况，还是不知道为什么要把n加1……o(╯□╰)o 这题还是卡了很久，照着别人的代码敲的，死活过不了，然后又找了一份代码：http://blog.</description>
    </item>
    
    <item>
      <title>hdu 1059 Dividing ——多重背包复习</title>
      <link>http://liuxueyang.github.io/blog/2013/04/05/hdu-1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Fri, 05 Apr 2013 12:29:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/04/05/hdu-1059-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E5%A4%8D%E4%B9%A0/</guid>
      <description>Dividing
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 11367 Accepted Submission(s): 3168
Problem Description Marsha and Bill own a collection of marbles. They want to split the collection among themselves so that both receive an equal share of the marbles. This would be easy if all the marbles had the same value, because then they could just split the collection in half. But unfortunately, some of the marbles are larger, or more beautiful than others.</description>
    </item>
    
    <item>
      <title>hdu 1712 ACboy needs your help 分组背包</title>
      <link>http://liuxueyang.github.io/blog/2013/03/29/hdu-1712-acboy-needs-your-help-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</link>
      <pubDate>Fri, 29 Mar 2013 15:08:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/03/29/hdu-1712-acboy-needs-your-help-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85/</guid>
      <description>ACboy needs your help
Time Limit: 1000&amp;frasl;1000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 2403 Accepted Submission(s): 1223
Problem Description ACboy has N courses this term, and he plans to spend at most M days on study.Of course,the profit he will gain from different course depending on the days he spend on it.How to arrange the M days for the N courses to maximize the profit?
Input The input consists of multiple data sets.</description>
    </item>
    
    <item>
      <title>hdu 2159 FATE 二维背包</title>
      <link>http://liuxueyang.github.io/blog/2013/03/29/hdu-2159-fate-%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85/</link>
      <pubDate>Fri, 29 Mar 2013 13:51:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/03/29/hdu-2159-fate-%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85/</guid>
      <description>FATE
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 4682 Accepted Submission(s): 2105
Problem Description 最近xhd正在玩一款叫做FATE的游戏，为了得到极品装备，xhd在不停的杀怪做任务。久而久之xhd开始对杀怪产生的厌恶感，但又不得不通过杀怪来升完这最后一级。现在的问题是，xhd升掉最后一级还需n的经验值，xhd还留有m的忍耐度，每杀一个怪xhd会得到相应的经验，并减掉相应的忍耐度。当忍耐度降到0或者0以下时，xhd就不会玩这游戏。xhd还说了他最多只杀s只怪。请问他能升掉这最后一级吗？
Input 输入数据有多组，对于每组数据第一行输入n，m，k，s(0 &amp;lt; n,m,k,s &amp;lt; 100)四个正整数。分别表示还需的经验值，保留的忍耐度，怪的种数和最多的杀怪数。接下来输入k行数据。每行数据输入两个正整数a，b(0 &amp;lt; a,b &amp;lt; 20)；分别表示杀掉一只这种怪xhd会得到的经验值和会减掉的忍耐度。(每种怪都有无数个)
Output 输出升完这级还能保留的最大忍耐度，如果无法升完这级输出-1。
Sample Input 10 10 1 10 1 1 10 10 1 9 1 1 9 10 2 10 1 1 2 2
Sample Output 0 -1 1
二维背包。这道题目开始的思路是错误的，我把经验值看成了一个背包容量，实际上，这是不恰当的。因为，这个背包容量必须至少要装满，还有，可以超过这个容量，如果超过了，这样做是不可解的。 后来也没有认真想，就看了一下别人的代码，惭愧……又在翻别人的代码。。 明白了，把忍耐值看成一个背包，怪物个数看成另一个背包，这样就有2个背包容量，求出最大的经验值，然后再遍历一次，求出比要求的经验值大的，并且忍耐度最小的，就ＯＫ了。 明白了之后，然后我就把原来的代码开始修改，悲剧的是，后面的改了，但是输入的地方没有改，死活也Ａ不了……明明就40行代码，搞得这么纠结……次嗷……
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;algorithm&amp;gt; using namespace std; const int MAX = 0x3f3f3f3f; int f[120][120]; int main(void){ #ifndef ONLINE_JUDGE freopen(&amp;quot;2159.</description>
    </item>
    
    <item>
      <title>poj 1014 Dividing 多重背包</title>
      <link>http://liuxueyang.github.io/blog/2013/03/28/poj-1014-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 28 Mar 2013 20:59:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/03/28/poj-1014-dividing-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</guid>
      <description>Description Input Output Sample Input Sample Output
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cstring&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;cstdlib&amp;gt; using namespace std; int f[120000+10], V; const int MAX = 0x3f3f3f3f; void zeropack(int c, int w){ for (int v = V; v &amp;gt;= c; --v){ f[v] = max(f[v], f[v-c] + w); } } void completepack(int c, int w){ for (int v = c; v &amp;lt;= V; ++v){ f[v] = max(f[v], f[v-c] + w); } } int main(void){ int a[7], cnt = 1; #ifndef ONLINE_JUDGE freopen(&amp;quot;1014.</description>
    </item>
    
    <item>
      <title>hdu 1114 Piggy-Bank 完全背包</title>
      <link>http://liuxueyang.github.io/blog/2013/03/28/hdu-1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 28 Mar 2013 12:14:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/03/28/hdu-1114-piggy-bank-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/</guid>
      <description>Piggy-Bank
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 6841 Accepted Submission(s): 3375
Problem Description Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank.</description>
    </item>
    
    <item>
      <title>hdu 2602 Bone Collector 01背包</title>
      <link>http://liuxueyang.github.io/blog/2013/03/28/hdu-2602-bone-collector-01%E8%83%8C%E5%8C%85/</link>
      <pubDate>Thu, 28 Mar 2013 10:34:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/03/28/hdu-2602-bone-collector-01%E8%83%8C%E5%8C%85/</guid>
      <description>Bone Collector
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 32768&amp;frasl;32768 K (Java/Others) Total Submission(s): 17590 Accepted Submission(s): 6954
Problem Description Many years ago , in Teddy’s hometown there was a man who was called “Bone Collector”. This man like to collect varies of bones , such as dog’s , cow’s , also he went to the grave … The bone collector had a big bag with a volume of V ,and along his trip of collecting there are a lot of bones , obviously , different bone has different value and different volume, now given the each bone’s value along his trip , can you calculate out the maximum of the total value the bone collector can get ?</description>
    </item>
    
    <item>
      <title>hdu 1028 Ignatius and the Princess III</title>
      <link>http://liuxueyang.github.io/blog/2013/03/13/hdu-1028-ignatius-and-the-princess-iii/</link>
      <pubDate>Wed, 13 Mar 2013 21:09:00 +0000</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2013/03/13/hdu-1028-ignatius-and-the-princess-iii/</guid>
      <description>Ignatius and the Princess III
Time Limit: 2000&amp;frasl;1000 MS (Java/Others) Memory Limit: 65536&amp;frasl;32768 K (Java/Others) Total Submission(s): 8447 Accepted Submission(s): 6009
Problem Description &amp;ldquo;Well, it seems the first problem is too easy. I will let you know how foolish you are later.&amp;rdquo; feng5166 says.
&amp;ldquo;The second problem is, given an positive integer N, we define an equation like this: N=a[1]+a[2]+a[3]+&amp;hellip;+a[m]; a[i]&amp;gt;0,1&amp;lt;=m&amp;lt;=N; My question is how many different equations you can find for a given N.</description>
    </item>
    
  </channel>
</rss>