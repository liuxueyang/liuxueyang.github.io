<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on LXY Site</title>
    <link>http://liuxueyang.github.io/categories/algorithm/</link>
    <description>Recent content in Algorithm on LXY Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 17 May 2017 15:33:49 +0800</lastBuildDate>
    
	<atom:link href="http://liuxueyang.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Clustering</title>
      <link>http://liuxueyang.github.io/posts/clustering/</link>
      <pubDate>Wed, 17 May 2017 15:33:49 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/clustering/</guid>
      <description>题目链接：pdf
题目给出一个些点的坐标，要求把这些点分成k组，求这k组中，组和组之间的点 的最小距离d。
这道题，好像可以用Kruskal？比如：按照边长度从小到大扫描， 同时记录当前有多少个连通分量（比如：每次Union之后连通分量 的个数减一），一直到只剩k个连通分量的时候，找到下一个可用 边（这个边的两个点在不同的连通分量中）的时候退出循环。这个 可用边就是答案。
因为要求最小的d嘛，所以就是贪心吧。
所以相对难实现的就是这些了：
 处理输入数据 带路径压缩的并查集  这些也挺好写的。
// Tue May 16 21:01:58 2017 // Tue May 16 22:06:44 2017 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; struct edge { int from, to; double cost; }; inline double p_distance(int x1, int y1, int x2, int y2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); } int p_find(int x, vector&amp;lt;int&amp;gt; &amp;amp;parent) { int p = x; while (p !</description>
    </item>
    
    <item>
      <title>Building Roads to Connect Cities</title>
      <link>http://liuxueyang.github.io/posts/building-roads-to-connect-cities/</link>
      <pubDate>Wed, 17 May 2017 15:24:43 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/building-roads-to-connect-cities/</guid>
      <description>题目链接：pdf
给出平面上的一些点，任意两点之间可以相连，求最小生成树的总权值。
用Kruskal：把所有边按照边长度升序排序，循环所有边，每次加入一个边之前要判断这个边的两个点是不是在一个集合中，如果是那么跳过，如果不是那么把这个边的两个点合并到一个集合中。集合操作用带路径压缩的并查集。循环边的过程中累加边的权值。
// Tue May 16 17:02:04 2017 // Tue May 16 20:42:10 2017 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; struct edge { int from, to; double cost; }; inline double p_distance(int x1, int y1, int x2, int y2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); } int p_find(int x, vector&amp;lt;int&amp;gt; &amp;amp;parent) { int p = x; while (p != parent[p]) { p = parent[p]; } return parent[x] = p; } void p_union(int x, int y, vector&amp;lt;int&amp;gt; &amp;amp;parent, vector&amp;lt;int&amp;gt; &amp;amp;p_size) { int p_x = p_find(x, parent), p_y = p_find(y, parent), ps_x = p_size[p_x], ps_y = p_size[p_y]; if (ps_x &amp;gt; ps_y) { parent[p_y] = p_x; p_size[p_x] += ps_y; } else { parent[p_x] = p_y; p_size[p_y] += ps_x; } }	double minimum_distance(vector&amp;lt;int&amp;gt; x, vector&amp;lt;int&amp;gt; y) { double result = 0.</description>
    </item>
    
    <item>
      <title>Detecting Anomalies in Currency Exchange Rates</title>
      <link>http://liuxueyang.github.io/posts/detecting-anomalies-in-currency-exchange-rates/</link>
      <pubDate>Wed, 17 May 2017 15:01:28 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/detecting-anomalies-in-currency-exchange-rates/</guid>
      <description>题目链接：pdf
题目给一个有向图，判定这个有向图是不是存在负环。
思路：
对这个图进行Bellman-Ford算法：不断对所有边进行松弛操作，循环进行V次，如果第V次仍然有边被松弛，那么说明存在负环。
相反，如果第V次没有边被松弛，那么说明没有负环。
在讨论Dijkstra算法的时候，最开始的V*E的算法其实就是Bellman-Ford算法。
初始化的时候把dist数组初始化为0。为什么呢？因为我们找的是负环，所以我们可以假设所有点到对源点的距离都是0。如果有负环，那么一定有负边，在第V次松弛所有边的时候，这个环中一定有一个点的最短路为负值。
// Mon May 15 14:13:09 CST 2017 // Mon May 15 15:09:41 CST 2017 // 一个有向图是不是存在负环 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; using namespace std; typedef pair&amp;lt;int, int&amp;gt; PII;	// from, to struct edge { int from; int to; int w; }; int negative_cycle(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;cost) { vector&amp;lt;int&amp;gt; dist(adj.size(), 0); vector&amp;lt;edge&amp;gt; edges; for (size_t i = 0; i &amp;lt; adj.size(); ++i) { for (size_t j = 0; j &amp;lt; adj[i].</description>
    </item>
    
    <item>
      <title>Computing the Minimum Cost of a Flight</title>
      <link>http://liuxueyang.github.io/posts/computing-minimum-cost-of-a-flight/</link>
      <pubDate>Wed, 17 May 2017 08:37:01 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/computing-minimum-cost-of-a-flight/</guid>
      <description>题目链接：pdf
题目给出一个有向图，边的权值非负，求起点到终点的最短路。
用Dijkstra，基本思想是这样的：如果一个有向图权值非负，那么两点之间的最 短路有最优子结构的性质。两点之间的最短路上的任意两点之间的路径也是最优 的。
设S -&amp;gt; ... -&amp;gt; u -&amp;gt; ... -&amp;gt; v -&amp;gt; ... -&amp;gt; t是从S到t的一条最短路，那么这条路径 上从u到v的部分也是u到v的最短路。反证：假设从u到v存在一条更短的路径L， 那么用L替换S到t中从u到v的部分，就可以得到一条从S到v的更短的路径，由于 我们假设原来的路径是从S对v的最短路，得出矛盾。
这样，设d(S, t)是S -&amp;gt; ... -&amp;gt; u -&amp;gt; t是S到t的最短路。则：
d(S, t) = d(S, u) + w(u, t)  所以我们可以不断地对所有边的进行松弛操作，直到没有边可以松弛。这个时候就可以得到单源最短路。这样的循环最多进行V次，每次最多进行E次松弛操作，因此复杂度是V*E。
显然我们不必每次都对所有边进行松弛。我们可以记录下以后不需要松弛的点，也就是最短路已经确定的点，所以我们可以把所有点分成两个集合，一个集合表示这些点到源点的最短路已经确定，另一个集合表示最短路还不确定。
也就是说每次松弛的循环中，我们可以把松弛过的点放到一个优先队列中，然后从中选择到源点距离最小的出队，它就是最短距离已经确定的点。继续从这个开始松弛操作，一直循环到队列为空。每个点入队一次，出队一次。总共循环V次，每次循环中要出队最小元素（VlogV），对这个点相连的所有边进行松弛并且入队(ElogV)。总共是(E+V)logV。
// Mon May 15 10:45:45 CST 2017 // Mon May 15 11:29:58 CST 2017 /* 最简单的Dijkstra */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;climits&amp;gt; using namespace std; typedef pair&amp;lt;int, int&amp;gt; PII; class Comp { public: bool operator() (const PII &amp;amp;a, const PII &amp;amp;b) { return a.</description>
    </item>
    
    <item>
      <title>Checking whether a Graph is Bipartite</title>
      <link>http://liuxueyang.github.io/posts/checking-whether-a-graph-is-bipartite/</link>
      <pubDate>Wed, 17 May 2017 00:06:00 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/checking-whether-a-graph-is-bipartite/</guid>
      <description>题目链接：pdf
题目给一个无向图，判定这个图是否是二分图。
所谓二分图就是，用可以两种颜色给这个图的所有节点染色，并且满足相邻两个点颜色不同。
思路：
模拟染色过程，遍历所有点，如果这个点没有被染色，那么用BFS从这个点开始染色，当出现两个点颜色相同，说明这个图不是二分图。如果这个点已经被染色过，那么判断一下和这个点直接相连的点和它的颜色是否相同。
// Sun May 14 21:24:26 CST 2017 // Sun May 14 21:43:44 CST 2017 /* 二分图判定 */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; using std::vector; using std::queue; int bipartite(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj) { int result = 1; vector&amp;lt;int&amp;gt; color(adj.size(), -1); queue&amp;lt;int&amp;gt; que; for (size_t i = 0; i &amp;lt; adj.size(); ++i) { if (-1 == color[i]) { color[i] =1; que.push(i); while (!que.empty()) { int cur = que.</description>
    </item>
    
    <item>
      <title>Computing the Minimum Number of Flight Segments</title>
      <link>http://liuxueyang.github.io/posts/computing-minimum-number-of-flight-segments/</link>
      <pubDate>Tue, 16 May 2017 23:57:39 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/computing-minimum-number-of-flight-segments/</guid>
      <description>题目链接：pdf
给一个无向图，一个起点，一个终点，求从起点到终点的路径的边数的最小值。
就是一遍BFS。
// Sun May 14 21:01:40 CST 2017 // Sun May 14 21:20:34 CST 2017 /* 最简单的BFS */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; using std::vector; using std::queue; int distance(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, int s, int t) { vector&amp;lt;int&amp;gt; dist(adj.size(), -1); queue&amp;lt;int&amp;gt; que; dist[s] = 0; que.push(s); while (!que.empty()) { int cur = que.front(); que.pop(); for (auto v : adj[cur]) { if (-1 == dist[v]) { dist[v] = dist[cur] + 1; que.</description>
    </item>
    
    <item>
      <title>Checking Whether Any Intersection in a City is Reachable from Any Other</title>
      <link>http://liuxueyang.github.io/posts/checking-whether-any-intersection-in-a-city-is-reachable-any-other/</link>
      <pubDate>Tue, 16 May 2017 23:24:52 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/checking-whether-any-intersection-in-a-city-is-reachable-any-other/</guid>
      <description>题目链接：pdf
题目给出一个有向图，要求输出图中强连通分量的个数。
我把这样的强连通分量叫做一个sink：不存在一个边从这个强连通分量中的任意 一个点连接到其它连通分量。也就是说如果把这个强连通分量缩成一个点的话， 它的出度为0。
我把和一个图的所有边都反向的图叫做反向图。貌似没有这样的术语。不知道 reverse graph应该怎么翻译。
思路大概是这样的：
 如果我们知道一个有向图的sink中的一个点，那么我们就可以求出这个强连 通分量的所有点，因为强连通分量中的任意两个点都相互可达。 如何求有相同的sink？我们知道反向图的强连通分量的个数和原图的强连通 分量一定是一样的，只是方向不同。并且，原图的sink对应于反向图的 source strong connected component，所以我们可以通过求反向图的source SCC，来求原图的sink。 求一个图的source SCC的思路和用DFS求拓扑排序的思路是一样的，我们可以 按照所有点的DFS回退的时刻降序排序，这样DFS最晚回退的点就是反向图的 source SCC，也就是原图的sink，我们可以第二次DFS得到这个sink中的所有 点并且从原图中去掉，继续求下一个sink，同时计数。  实现的过程中出现了非常难以发现的bug：一个vector，我在dfs里面加入元素， 然后在调用dfs的外层循环中循环这个vector。所以对于小数据并没有显现出错 误，对于10000的数据就出现段错误了。调试了很久，不过xhe也教了我好多调试 的方法，比如gdb，valgrind，libsigseg库，strace等。不过gdb调试的时候查 看STL数据结构里面的数据的时候还是有点小麻烦，这个时候IDE的调试工具就好 用很多了。
另外，gdb设置端点竟然支持条件表达式，这个功能非常有用。
// Sat May 13 09:28:34 CST 2017 // Sat May 13 10:46:30 CST 2017 // 求一个有向图的强连通分量的个数。。。 /* 1. 建reverse graph 2. 降序排序post 3. 在原图中依次求强连通分量，并且从图中去掉 */ #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; using namespace std; typedef vector&amp;lt;int&amp;gt; VI; typedef pair&amp;lt;int, int&amp;gt; PII; int cnt; vector&amp;lt;PII&amp;gt; post;	// index, post void dfs(vector&amp;lt;VI&amp;gt; &amp;amp;adj, vector&amp;lt;bool&amp;gt; &amp;amp;used, int x, bool get_post) { used[x] = true; for (auto &amp;amp;v1 : adj[x]) { if (!</description>
    </item>
    
    <item>
      <title>Determining an Order of Courses</title>
      <link>http://liuxueyang.github.io/posts/determining-an-order-of-courses/</link>
      <pubDate>Tue, 16 May 2017 23:11:46 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/determining-an-order-of-courses/</guid>
      <description>题目链接：pdf
题目给出一个有向图，保证没有环，求这个有向图所有点的拓扑排序之后的序列， 只输出一种即可。
同样用DFS，求拓扑排序的过程一般是先求所有出度为0的点，然后删除这些点， 如此循环。DFS的过程中，回退过程最早的那个点一定是出度为0，所以就可以记 录下DFS的过程中每个点回退的时刻，然后按照时刻大小逆序排序就是拓扑顺序 了。
// Sat May 13 00:14:15 CST 2017 // Sat May 13 09:27:41 CST 2017 // 拓扑排序 #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; using namespace std; typedef pair&amp;lt;int, int&amp;gt; PII; vector&amp;lt;PII &amp;gt; post;	// index, clock_cnt int clock_cnt; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, vector&amp;lt;int&amp;gt; &amp;amp;used, int x) { used[x] = true; for (auto v : adj[x]) { if (!used[v]) { dfs(adj, used, v); } } clock_cnt++; post.</description>
    </item>
    
    <item>
      <title>Checking Consistency of CS Curriculum</title>
      <link>http://liuxueyang.github.io/posts/checking-consistency-curriculum/</link>
      <pubDate>Tue, 16 May 2017 23:00:54 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/checking-consistency-curriculum/</guid>
      <description>题目链接：pdf
题目给一个有向图，判断是不是有环。我的方法是DFS，对于一个点，访问的过程中存在这三种情况：
 访问v的过程中，再次访问到了v这个点，说明存在环。 完成访问v后（DFS已经回退到v之后），以后再次访问到了v，这是没有问题 的，这种情况不能说明存在环。 v还没有访问过。  因此用三个不同的值来标记这三种情况就可以了。
// Fri May 12 22:50:22 CST 2017 // Fri May 12 23:50:02 CST 2017 // 判断一个有向图是不是有环。。。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; /* visit[i]的值有三种情况： 0:这个点没有访问过 1:这个点正在访问 2:这个点以及和它相连的点都已经访问过了 所以DFS的过程中，下一个点遇到了visit[e] == 1说明有环。 */ void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, vector&amp;lt;int&amp;gt; &amp;amp;visit, int x, bool &amp;amp;mark) { // cout &amp;lt;&amp;lt; &amp;quot;(&amp;quot; &amp;lt;&amp;lt; x + 1 &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;quot;)&amp;quot; &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;; visit[x] = 1; if (mark) return; for (auto e : adj[x]) { if (mark) return; else if (visit[e] == 1) { mark = true; return; } else if (!</description>
    </item>
    
    <item>
      <title>Adding Exits to a Maze</title>
      <link>http://liuxueyang.github.io/posts/adding-exits-to-maze/</link>
      <pubDate>Tue, 16 May 2017 22:52:55 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/adding-exits-to-maze/</guid>
      <description>题目链接：pdf
给出一个无向图，求连通分量的个数。对这个图做一遍DFS同时计数就好了。因 为我用邻接表表示图，所以还要记得孤点的情况，这个后来才发现。
// Begin: Fri May 12 19:52:46 CST 2017 // Finish: Fri May 12 20:16:44 CST 2017 // 求有几个连通块。。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, vector&amp;lt;bool&amp;gt; &amp;amp;visit, int x) { visit[x] = true; for (size_t i = 0; i &amp;lt; adj[x].size(); ++i) { if (!visit[adj[x][i]]) { dfs(adj, visit, adj[x][i]); } } } int number_of_components(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, int n) { int res = 0; vector&amp;lt;bool&amp;gt; visit(n, false); // 所以我忘了孤点。。。。T_T for (size_t i = 0; i &amp;lt; adj.</description>
    </item>
    
    <item>
      <title>Finding an Exit from a Maze</title>
      <link>http://liuxueyang.github.io/posts/finding-an-exit-from-maze/</link>
      <pubDate>Tue, 16 May 2017 22:28:46 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/posts/finding-an-exit-from-maze/</guid>
      <description>题目链接：pdf
这道题目给出一个无向图，一个起点，一个终点，判断从起点是否能够到达终点。 显然就是从起点开始做一次DFS就可以了。
// 2017/05/12 19:35:19 // 判断两个点是否连通。。。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, int x, int y, vector&amp;lt;bool&amp;gt; &amp;amp;visit) { visit[x] = true; if (visit[y]) return; for (size_t i = 0; i &amp;lt; adj[x].size(); ++i) { if (!visit[adj[x][i]]) { dfs(adj, adj[x][i], y, visit); } } } int reach(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, int x, int y, int n) { vector&amp;lt;bool&amp;gt; visit(n, false); dfs(adj, x, y, visit); return (visit[y] ?</description>
    </item>
    
  </channel>
</rss>