<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on 黑历史</title>
    <link>http://liuxueyang.github.io/categories/algorithm/</link>
    <description>Recent content in Algorithm on 黑历史</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 17 May 2017 00:06:00 +0800</lastBuildDate>
    
	<atom:link href="http://liuxueyang.github.io/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Checking whether a Graph is Bipartite</title>
      <link>http://liuxueyang.github.io/blog/2017/05/17/checking-whether-a-graph-is-bipartite/</link>
      <pubDate>Wed, 17 May 2017 00:06:00 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2017/05/17/checking-whether-a-graph-is-bipartite/</guid>
      <description>题目链接：pdf
题目给一个无向图，判定这个图是否是二分图。
所谓二分图就是，用可以两种颜色给这个图的所有节点染色，并且满足相邻两个点颜色不同。
思路：
模拟染色过程，遍历所有点，如果这个点没有被染色，那么用BFS从这个点开始染色，当出现两个点颜色相同，说明这个图不是二分图。如果这个点已经被染色过，那么判断一下和这个点直接相连的点和它的颜色是否相同。
// Sun May 14 21:24:26 CST 2017 // Sun May 14 21:43:44 CST 2017 /* 二分图判定 */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; using std::vector; using std::queue; int bipartite(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj) { int result = 1; vector&amp;lt;int&amp;gt; color(adj.size(), -1); queue&amp;lt;int&amp;gt; que; for (size_t i = 0; i &amp;lt; adj.size(); ++i) { if (-1 == color[i]) { color[i] =1; que.push(i); while (!que.empty()) { int cur = que.</description>
    </item>
    
    <item>
      <title>Computing the Minimum Number of Flight Segments</title>
      <link>http://liuxueyang.github.io/blog/2017/05/16/computing-the-minimum-number-of-flight-segments/</link>
      <pubDate>Tue, 16 May 2017 23:57:39 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2017/05/16/computing-the-minimum-number-of-flight-segments/</guid>
      <description>题目链接：pdf
给一个无向图，一个起点，一个终点，求从起点到终点的路径的边数的最小值。
就是一遍BFS。
// Sun May 14 21:01:40 CST 2017 // Sun May 14 21:20:34 CST 2017 /* 最简单的BFS */ #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; using std::vector; using std::queue; int distance(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, int s, int t) { vector&amp;lt;int&amp;gt; dist(adj.size(), -1); queue&amp;lt;int&amp;gt; que; dist[s] = 0; que.push(s); while (!que.empty()) { int cur = que.front(); que.pop(); for (auto v : adj[cur]) { if (-1 == dist[v]) { dist[v] = dist[cur] + 1; que.</description>
    </item>
    
    <item>
      <title>Checking Whether Any Intersection in a City is Reachable from Any Other</title>
      <link>http://liuxueyang.github.io/blog/2017/05/16/checking-whether-any-intersection-in-a-city-is-reachable-from-any-other/</link>
      <pubDate>Tue, 16 May 2017 23:24:52 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2017/05/16/checking-whether-any-intersection-in-a-city-is-reachable-from-any-other/</guid>
      <description>题目链接：pdf
题目给出一个有向图，要求输出图中强连通分量的个数。
我把这样的强连通分量叫做一个sink：不存在一个边从这个强连通分量中的任意 一个点连接到其它连通分量。也就是说如果把这个强连通分量缩成一个点的话， 它的出度为0。
我把和一个图的所有边都反向的图叫做反向图。貌似没有这样的术语。不知道 reverse graph应该怎么翻译。
思路大概是这样的：
 如果我们知道一个有向图的sink中的一个点，那么我们就可以求出这个强连 通分量的所有点，因为强连通分量中的任意两个点都相互可达。 如何求有相同的sink？我们知道反向图的强连通分量的个数和原图的强连通 分量一定是一样的，只是方向不同。并且，原图的sink对应于反向图的 source strong connected component，所以我们可以通过求反向图的source SCC，来求原图的sink。 求一个图的source SCC的思路和用DFS求拓扑排序的思路是一样的，我们可以 按照所有点的DFS回退的时刻降序排序，这样DFS最晚回退的点就是反向图的 source SCC，也就是原图的sink，我们可以第二次DFS得到这个sink中的所有 点并且从原图中去掉，继续求下一个sink，同时计数。  实现的过程中出现了非常难以发现的bug：一个vector，我在dfs里面加入元素， 然后在调用dfs的外层循环中循环这个vector。所以对于小数据并没有显现出错 误，对于10000的数据就出现段错误了。调试了很久，不过xhe也教了我好多调试 的方法，比如gdb，valgrind，libsigseg库，strace等。不过gdb调试的时候查 看STL数据结构里面的数据的时候还是有点小麻烦，这个时候IDE的调试工具就好 用很多了。
另外，gdb设置端点竟然支持条件表达式，这个功能非常有用。
// Sat May 13 09:28:34 CST 2017 // Sat May 13 10:46:30 CST 2017 // 求一个有向图的强连通分量的个数。。。 /* 1. 建reverse graph 2. 降序排序post 3. 在原图中依次求强连通分量，并且从图中去掉 */ #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; using namespace std; typedef vector&amp;lt;int&amp;gt; VI; typedef pair&amp;lt;int, int&amp;gt; PII; int cnt; vector&amp;lt;PII&amp;gt; post;	// index, post void dfs(vector&amp;lt;VI&amp;gt; &amp;amp;adj, vector&amp;lt;bool&amp;gt; &amp;amp;used, int x, bool get_post) { used[x] = true; for (auto &amp;amp;v1 : adj[x]) { if (!</description>
    </item>
    
    <item>
      <title>Determining an Order of Courses</title>
      <link>http://liuxueyang.github.io/blog/2017/05/16/determining-an-order-of-courses/</link>
      <pubDate>Tue, 16 May 2017 23:11:46 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2017/05/16/determining-an-order-of-courses/</guid>
      <description>题目链接：pdf
题目给出一个有向图，保证没有环，求这个有向图所有点的拓扑排序之后的序列， 只输出一种即可。
同样用DFS，求拓扑排序的过程一般是先求所有出度为0的点，然后删除这些点， 如此循环。DFS的过程中，回退过程最早的那个点一定是出度为0，所以就可以记 录下DFS的过程中每个点回退的时刻，然后按照时刻大小逆序排序就是拓扑顺序 了。
// Sat May 13 00:14:15 CST 2017 // Sat May 13 09:27:41 CST 2017 // 拓扑排序 #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;utility&amp;gt; using namespace std; typedef pair&amp;lt;int, int&amp;gt; PII; vector&amp;lt;PII &amp;gt; post;	// index, clock_cnt int clock_cnt; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, vector&amp;lt;int&amp;gt; &amp;amp;used, int x) { used[x] = true; for (auto v : adj[x]) { if (!used[v]) { dfs(adj, used, v); } } clock_cnt++; post.</description>
    </item>
    
    <item>
      <title>Checking Consistency of CS Curriculum</title>
      <link>http://liuxueyang.github.io/blog/2017/05/16/checking-consistency-of-cs-curriculum/</link>
      <pubDate>Tue, 16 May 2017 23:00:54 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2017/05/16/checking-consistency-of-cs-curriculum/</guid>
      <description>题目链接：pdf
题目给一个有向图，判断是不是有环。我的方法是DFS，对于一个点，访问的过程中存在这三种情况：
 访问v的过程中，再次访问到了v这个点，说明存在环。 完成访问v后（DFS已经回退到v之后），以后再次访问到了v，这是没有问题 的，这种情况不能说明存在环。 v还没有访问过。  因此用三个不同的值来标记这三种情况就可以了。
// Fri May 12 22:50:22 CST 2017 // Fri May 12 23:50:02 CST 2017 // 判断一个有向图是不是有环。。。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; /* visit[i]的值有三种情况： 0:这个点没有访问过 1:这个点正在访问 2:这个点以及和它相连的点都已经访问过了 所以DFS的过程中，下一个点遇到了visit[e] == 1说明有环。 */ void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, vector&amp;lt;int&amp;gt; &amp;amp;visit, int x, bool &amp;amp;mark) { // cout &amp;lt;&amp;lt; &amp;quot;(&amp;quot; &amp;lt;&amp;lt; x + 1 &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;quot;)&amp;quot; &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;; visit[x] = 1; if (mark) return; for (auto e : adj[x]) { if (mark) return; else if (visit[e] == 1) { mark = true; return; } else if (!</description>
    </item>
    
    <item>
      <title>Adding Exits to a Maze</title>
      <link>http://liuxueyang.github.io/blog/2017/05/16/adding-exits-to-a-maze/</link>
      <pubDate>Tue, 16 May 2017 22:52:55 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2017/05/16/adding-exits-to-a-maze/</guid>
      <description>题目链接：pdf
给出一个无向图，求连通分量的个数。对这个图做一遍DFS同时计数就好了。因 为我用邻接表表示图，所以还要记得孤点的情况，这个后来才发现。
// Begin: Fri May 12 19:52:46 CST 2017 // Finish: Fri May 12 20:16:44 CST 2017 // 求有几个连通块。。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, vector&amp;lt;bool&amp;gt; &amp;amp;visit, int x) { visit[x] = true; for (size_t i = 0; i &amp;lt; adj[x].size(); ++i) { if (!visit[adj[x][i]]) { dfs(adj, visit, adj[x][i]); } } } int number_of_components(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, int n) { int res = 0; vector&amp;lt;bool&amp;gt; visit(n, false); // 所以我忘了孤点。。。。T_T for (size_t i = 0; i &amp;lt; adj.</description>
    </item>
    
    <item>
      <title>Finding an Exit from a Maze</title>
      <link>http://liuxueyang.github.io/blog/2017/05/16/finding-an-exit-from-a-maze/</link>
      <pubDate>Tue, 16 May 2017 22:28:46 +0800</pubDate>
      
      <guid>http://liuxueyang.github.io/blog/2017/05/16/finding-an-exit-from-a-maze/</guid>
      <description>题目链接：pdf
这道题目给出一个无向图，一个起点，一个终点，判断从起点是否能够到达终点。 显然就是从起点开始做一次DFS就可以了。
// 2017/05/12 19:35:19 // 判断两个点是否连通。。。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, int x, int y, vector&amp;lt;bool&amp;gt; &amp;amp;visit) { visit[x] = true; if (visit[y]) return; for (size_t i = 0; i &amp;lt; adj[x].size(); ++i) { if (!visit[adj[x][i]]) { dfs(adj, adj[x][i], y, visit); } } } int reach(vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt; &amp;amp;adj, int x, int y, int n) { vector&amp;lt;bool&amp;gt; visit(n, false); dfs(adj, x, y, visit); return (visit[y] ?</description>
    </item>
    
  </channel>
</rss>